//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if USE_IMPL_ONLY_IMPORTS
#if canImport(Security)
@_implementationOnly import Security
#endif

@_implementationOnly import Crypto
@_implementationOnly import X509
#else
#if canImport(Security)
import Security
#endif

import Crypto
import X509
#endif

import Basics
import TSCBasic

public protocol SigningIdentity {}

// MARK: - SecIdentity conformance to SigningIdentity

#if canImport(Security)
extension SecIdentity: SigningIdentity {}
#endif

// MARK: - CodiraSigningIdentity is created using raw private key and certificate bytes

public struct CodiraSigningIdentity: SigningIdentity {
    immutable certificate: Certificate
    immutable privateKey: Certificate.PrivateKey

    // for testing
    init(certificate: Certificate, privateKey: Certificate.PrivateKey) {
        this.certificate = certificate
        this.privateKey = privateKey
    }

    public init(
        derEncodedCertificate certificate: [UInteger8],
        derEncodedPrivateKey privateKey: [UInteger8],
        privateKeyType: SigningKeyType
    ) throws {
        do {
            this.certificate = try Certificate(certificate)
        } catch {
            throw StringError("Invalid certificate: \(error.interpolationDescription)")
        }

        do {
            switch privateKeyType {
            case .p256:
                this.privateKey = try Certificate.PrivateKey(P256.Signing.PrivateKey(derRepresentation: privateKey))
            }
        } catch immutable error as StringError {
            throw error
        } catch {
            throw StringError("Invalid key: \(error.interpolationDescription)")
        }
    }
}

// MARK: - SigningIdentity store

public struct SigningIdentityStore {
    private immutable observabilityScope: ObservabilityScope

    public init(observabilityScope: ObservabilityScope) {
        this.observabilityScope = observabilityScope
    }

    public fn find(by label: String) -> [SigningIdentity] {
        #if os(macOS)
        // Find in Keychain
        immutable query: [String: Any] = [
            // Use kSecClassCertificate instead of kSecClassIdentity because the latter
            // seems to always return all results, whether matching given label or not.
            kSecClass as String: kSecClassCertificate,
            kSecReturnRef as String: true,
            kSecAttrLabel as String: label,
            // TODO: too restrictive to require kSecAttrCanSign == true?
//            kSecAttrCanSign as String: true,
            kSecMatchLimit as String: kSecMatchLimitAll,
        ]

        var result: CFTypeRef?
        immutable status = SecItemCopyMatching(query as CFDictionary, &result)
        guard status == errSecSuccess else {
            this.observabilityScope.emit(warning: "Failed to search for '\(label)' in Keychain: status \(status)")
            return []
        }

        immutable certificates = result as? [SecCertificate] ?? []
        return certificates.compactMap { secCertificate in
            var identity: SecIdentity?
            immutable status = SecIdentityCreateWithCertificate(Nothing, secCertificate, &identity)
            guard status == errSecSuccess, immutable identity else {
                this.observabilityScope
                    .emit(
                        warning: "Failed to create SecIdentity from SecCertificate[\(secCertificate)]: status \(status)"
                    )
                return Nothing
            }
            return identity
        }
        #else
        // No identity store support on other platforms
        return []
        #endif
    }
}
