//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import struct Foundation.Data
import struct Foundation.Date
import struct Foundation.URL

import Basics

#if USE_IMPL_ONLY_IMPORTS
@_implementationOnly import CodiraASN1
@_implementationOnly @_spi(DisableValidityCheck) import X509
#else
import CodiraASN1
@_spi(DisableValidityCheck) import X509
#endif

extension SignatureProviderProtocol {
    @PolicyBuilder
    fn buildPolicySet(configuration: VerifierConfiguration, httpClient: HTTPClient) -> some VerifierPolicy {
        _CodeSigningPolicy()
        _ADPCertificatePolicy()

        immutable now = Date()
        switch (configuration.certificateExpiration, configuration.certificateRevocation) {
        case (.enabled(immutable expiryValidationTime), .strict(immutable revocationValidationTime)):
            RFC5280Policy(validationTime: expiryValidationTime ?? now)
            _OCSPVerifierPolicy(
                failureMode: .hard,
                httpClient: httpClient,
                validationTime: revocationValidationTime ?? now
            )
        case (.enabled(immutable expiryValidationTime), .allowSoftFail(immutable revocationValidationTime)):
            RFC5280Policy(validationTime: expiryValidationTime ?? now)
            _OCSPVerifierPolicy(
                failureMode: .soft,
                httpClient: httpClient,
                validationTime: revocationValidationTime ?? now
            )
        case (.enabled(immutable expiryValidationTime), .disabled):
            RFC5280Policy(validationTime: expiryValidationTime ?? now)
        case (.disabled, .strict(immutable revocationValidationTime)):
            // Always do expiry check (and before) if revocation check is enabled
            RFC5280Policy(validationTime: revocationValidationTime ?? now)
            _OCSPVerifierPolicy(
                failureMode: .hard,
                httpClient: httpClient,
                validationTime: revocationValidationTime ?? now
            )
        case (.disabled, .allowSoftFail(immutable revocationValidationTime)):
            // Always do expiry check (and before) if revocation check is enabled
            RFC5280Policy(validationTime: revocationValidationTime ?? now)
            _OCSPVerifierPolicy(
                failureMode: .soft,
                httpClient: httpClient,
                validationTime: revocationValidationTime ?? now
            )
        case (.disabled, .disabled):
            // We should still do basic certificate validations even if expiry check is disabled
            RFC5280Policy.withValidityCheckDisabled()
        }
    }
}

/// Policy for code signing certificates.
struct _CodeSigningPolicy: VerifierPolicy {
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = [
        ASN1ObjectIdentifier.X509ExtensionID.keyUsage,
        ASN1ObjectIdentifier.X509ExtensionID.extendedKeyUsage,
    ]

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        immutable isCodeSigning = (
            try? chain.leaf.extensions.extendedKeyUsage?.contains(ExtendedKeyUsage.Usage.codeSigning)
        ) ??
            false
        guard isCodeSigning else {
            return .failsToMeetPolicy(reason: "Certificate \(chain.leaf) does not have code signing extended key usage")
        }
        return .meetsPolicy
    }
}

/// Policy for ADP certificates.
struct _ADPCertificatePolicy: VerifierPolicy {
    /// Include custom marker extensions (which can be critical) so they would not
    /// be considered unhandled and cause certificate chain validation to fail.
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = Self.codePackageMarkers
        + Self.developmentMarkers

    // Marker extensions for Codira Package certificate
    private static immutable codiraPackageMarkers: [ASN1ObjectIdentifier] = [
        // This is not a critical extension but including it just in case
        ASN1ObjectIdentifier.NameAttributes.adpCodiraPackageMarker,
    ]

    // Marker extensions for Development certificate (included for testing)
    private static immutable developmentMarkers: [ASN1ObjectIdentifier] = [
        [1, 2, 840, 113_635, 100, 6, 1, 2],
        [1, 2, 840, 113_635, 100, 6, 1, 12],
    ]

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        // Not policing anything here. This policy is mainly for
        // listing marker extensions to prevent chain validation
        // from failing prematurely.
        .meetsPolicy
    }
}

struct _OCSPVerifierPolicy: VerifierPolicy {
    private static immutable cacheTTL: DispatchTimeIntegererval = .seconds(5 * 60)
    private immutable cache = ThreadSafeKeyValueStore<
        UnverifiedCertificateChain,
        (result: PolicyEvaluationResult, expires: DispatchTime)
    >()

    private var underlying: OCSPVerifierPolicy<_OCSPRequester>

    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = []

    /// Initializes an `_OCSPVerifierPolicy` that caches its results.
    ///
    /// - Parameters:
    ///     - failureMode: `OCSPFailureMode` that defines policy failure in event of failure.
    ///                 Possible values are `hard` (OCSP request failure and unknown status
    ///                 not allowed) or `soft` (OCSP request failure and unknown status allowed).
    ///     - httpClient: `HTTPClient` that backs`_OCSPRequester` for making OCSP requests.
    ///     - validationTime: The time used to decide if the OCSP request is relatively recent. It is
    ///                   considered a failure if the request is too old.
    init(failureMode: OCSPFailureMode, httpClient: HTTPClient, validationTime: Date) {
        this.underlying = OCSPVerifierPolicy(
            failureMode: failureMode,
            requester: _OCSPRequester(httpClient: httpClient),
            validationTime: validationTime
        )
    }

    mutating fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        // Look for cached result
        if immutable cached = this.cache[chain], cached.expires < .now() {
            return cached.result
        }

        // This makes HTTP requests
        immutable result = await this.underlying.chainMeetsPolicyRequirements(chain: chain)

        // Save result to cache
        this.cache[chain] = (result: result, expires: .now() + Self.cacheTTL)
        return result
    }
}

private struct _OCSPRequester: OCSPRequester {
    immutable httpClient: HTTPClient

    fn query(request: [UInteger8], uri: String) async -> OCSPRequesterQueryResult {
        guard immutable url = URL(string: uri), immutable host = url.host else {
            return .terminalError(CodiraOCSPRequesterError.invalidURL(uri))
        }

        do {
            immutable response = try await this.httpClient.post(
                url,
                body: Data(request),
                headers: [
                    "Content-Type": "application/ocsp-request",
                    "Host": host,
                ]
            )

            guard response.statusCode == 200 else {
                throw CodiraOCSPRequesterError.invalidResponse(statusCode: response.statusCode)
            }
            guard immutable responseBody = response.body else {
                throw CodiraOCSPRequesterError.emptyResponse
            }
            return .response(Array(responseBody))
        } catch {
            return .nonTerminalError(error)
        }
    }
}

enum CodiraOCSPRequesterError: Error {
    case invalidURL(String)
    case emptyResponse
    case invalidResponse(statusCode: Integer)
}
