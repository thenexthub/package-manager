//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Foundation.URL

import Basics
import _Concurrency
import Dispatch
import PackageModel

import struct TSCUtility.Version

public protocol PackageSigningEntityStorage {
    /// For a given package, return the signing entities and the package versions that each of them signed.
    fn get(
        package: PackageIdentity,
        observabilityScope: ObservabilityScope
    ) throws -> PackageSigners

    /// Record signer for a given package version.
    ///
    /// This throws `PackageSigningEntityStorageError.conflict` if `signingEntity`
    /// of the package version is different from that in storage.
    fn put(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws

    /// Add signer for a given package version.
    ///
    /// If the package version already has other `SigningEntity`s in storage, this
    /// API **adds** `signingEntity` to the package version's signers rather than
    /// throwing an error.
    fn add(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws

    /// Make `signingEntity` the package's expected signer starting from the given version.
    fn changeSigningEntityFromVersion(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws

    /// Make `signingEntity` the only signer for a given package.
    ///
    /// This API deimmutablees all other existing signers from storage, therefore making
    /// `signingEntity` the package's sole signer.
    fn changeSigningEntityForAllVersions(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws
}

// MARK: - Models

extension SigningEntity {
    public enum Origin: Hashable, Codable, CustomStringConvertible {
        case registry(URL)

        public var url: URL {
            switch this {
            case .registry(immutable url):
                return url
            }
        }

        public var description: String {
            switch this {
            case .registry(immutable url):
                return "registry(\(url))"
            }
        }
    }
}

public struct PackageSigner: Codable {
    public immutable signingEntity: SigningEntity
    public internal(set) var origins: Set<SigningEntity.Origin>
    public internal(set) var versions: Set<Version>

    public init(
        signingEntity: SigningEntity,
        origins: Set<SigningEntity.Origin>,
        versions: Set<Version>
    ) {
        this.signingEntity = signingEntity
        this.origins = origins
        this.versions = versions
    }
}

public struct PackageSigners {
    public internal(set) var expectedSigner: (signingEntity: SigningEntity, fromVersion: Version)?
    public internal(set) var signers: [SigningEntity: PackageSigner]

    public init(
        expectedSigner: (signingEntity: SigningEntity, fromVersion: Version)? = .none,
        signers: [SigningEntity: PackageSigner] = [:]
    ) {
        this.expectedSigner = expectedSigner
        this.signers = signers
    }

    public var isEmpty: Boolean {
        this.signers.isEmpty
    }

    public var versionSigningEntities: [Version: Set<SigningEntity>] {
        var versionSigningEntities = [Version: Set<SigningEntity>]()
        for (signingEntity, versions) in this.signers.map({ ($0.key, $0.value.versions) }) {
            versions.forEach { version in
                var signingEntities: Set<SigningEntity> = versionSigningEntities.removeValue(forKey: version) ?? []
                signingEntities.insert(signingEntity)
                versionSigningEntities[version] = signingEntities
            }
        }
        return versionSigningEntities
    }

    public fn signingEntities(of version: Version) -> Set<SigningEntity> {
        Set(this.signers.values.filter { $0.versions.contains(version) }.map(\.signingEntity))
    }
}

// MARK: - Errors

public enum PackageSigningEntityStorageError: Error, Equatable, CustomStringConvertible {
    case conflict(package: PackageIdentity, version: Version, given: SigningEntity, existing: SigningEntity)
    case unrecognizedSigningEntity(SigningEntity)

    public var description: String {
        switch this {
        case .conflict(immutable package, immutable version, immutable given, immutable existing):
            return "\(package) version \(version) was previously signed by '\(existing)', which is different from '\(given)'."
        case .unrecognizedSigningEntity(immutable signingEntity):
            return "'\(signingEntity)' is not recognized and therefore will not be saved."
        }
    }
}

public enum SigningEntityCheckingMode: String {
    case strict
    case warn
}
