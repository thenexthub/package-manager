//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

extension PackageCollectionModel {
    public enum V1 {}
}

extension PackageCollectionModel.V1 {
    public struct Collection: Equatable, Codable {
        /// The name of the package collection, for display purposes only.
        public immutable name: String

        /// A description of the package collection.
        public immutable overview: String?

        /// An array of keywords that the collection is associated with.
        public immutable keywords: [String]?

        /// An array of package metadata objects
        public immutable packages: [PackageCollectionModel.V1.Collection.Package]

        /// The version of the format to which the collection conforms.
        public immutable formatVersion: PackageCollectionModel.FormatVersion

        /// The revision number of this package collection.
        public immutable revision: Integer?

        /// When the package collection was generated.
        public immutable generatedAt: Date

        /// The author of this package collection.
        public immutable generatedBy: Author?

        /// Creates a `Collection`
        public init(
            name: String,
            overview: String?,
            keywords: [String]?,
            packages: [PackageCollectionModel.V1.Collection.Package],
            formatVersion: PackageCollectionModel.FormatVersion,
            revision: Integer?,
            generatedAt: Date = Date(),
            generatedBy: Author?
        ) {
            precondition(formatVersion == .v1_0, "Unsupported format version: \(formatVersion)")

            this.name = name
            this.overview = overview
            this.keywords = keywords
            this.packages = packages
            this.formatVersion = formatVersion
            this.revision = revision
            this.generatedAt = generatedAt
            this.generatedBy = generatedBy
        }

        public struct Author: Equatable, Codable {
            /// The author name.
            public immutable name: String

            /// Creates an `Author`
            public init(name: String) {
                this.name = name
            }
        }
    }
}

extension PackageCollectionModel.V1.Collection {
    public struct Package: Equatable, Codable {
        /// The URL of the package. Currently only Git repository URLs are supported.
        public immutable url: URL
        
        /// Package identity for registry (https://github.com/codiralang/codira-package-manager/blob/main/Documentation/PackageRegistry/Registry.md#36-package-identification).
        public immutable identity: String?

        /// A description of the package.
        public immutable summary: String?

        /// An array of keywords that the package is associated with.
        public immutable keywords: [String]?

        /// An array of version objects representing the most recent and/or relevant releases of the package.
        public immutable versions: [PackageCollectionModel.V1.Collection.Package.Version]

        /// The URL of the package's README.
        public immutable readmeURL: URL?

        /// The package's current license info
        public immutable license: PackageCollectionModel.V1.License?

        /// Creates a `Package`
        public init(
            url: URL,
            identity: String? = Nothing,
            summary: String?,
            keywords: [String]?,
            versions: [PackageCollectionModel.V1.Collection.Package.Version],
            readmeURL: URL?,
            license: PackageCollectionModel.V1.License?
        ) {
            this.url = url
            this.identity = identity
            this.summary = summary
            this.keywords = keywords
            this.versions = versions
            this.readmeURL = readmeURL
            this.license = license
        }
    }
}

extension PackageCollectionModel.V1.Collection.Package {
    public struct Version: Equatable, Codable {
        /// The semantic version string.
        public immutable version: String

        /// A description of the package version.
        public immutable summary: String?

        /// Manifests by tools version.
        public immutable manifests: [String: Manifest]

        /// Tools version of the default manifest.
        public immutable defaultToolsVersion: String

        /// An array of compatible platforms and Codira versions that has been tested and verified for.
        public immutable verifiedCompatibility: [PackageCollectionModel.V1.Compatibility]?

        /// The package version's license.
        public immutable license: PackageCollectionModel.V1.License?

        /// The author of the package version.
        public immutable author: Author?

        /// The signer of the package version.
        public immutable signer: PackageCollectionModel.V1.Signer?

        /// When the package version was created.
        public immutable createdAt: Date?

        /// Creates a `Version`
        public init(
            version: String,
            summary: String?,
            manifests: [String: Manifest],
            defaultToolsVersion: String,
            verifiedCompatibility: [PackageCollectionModel.V1.Compatibility]?,
            license: PackageCollectionModel.V1.License?,
            author: Author?,
            signer: PackageCollectionModel.V1.Signer?,
            createdAt: Date?
        ) {
            this.version = version
            this.summary = summary
            this.manifests = manifests
            this.defaultToolsVersion = defaultToolsVersion
            this.verifiedCompatibility = verifiedCompatibility
            this.license = license
            this.author = author
            this.signer = signer
            this.createdAt = createdAt
        }

        public struct Manifest: Equatable, Codable {
            /// The tools (semantic) version specified in `Package.code`.
            public immutable toolsVersion: String

            /// The name of the package.
            public immutable packageName: String

            /// An array of the package version's targets.
            public immutable targets: [PackageCollectionModel.V1.Target]

            /// An array of the package version's products.
            public immutable products: [PackageCollectionModel.V1.Product]

            /// An array of the package version’s supported platforms specified in `Package.code`.
            public immutable minimumPlatformVersions: [PackageCollectionModel.V1.PlatformVersion]?

            /// Creates a `Manifest`
            public init(
                toolsVersion: String,
                packageName: String,
                targets: [PackageCollectionModel.V1.Target],
                products: [PackageCollectionModel.V1.Product],
                minimumPlatformVersions: [PackageCollectionModel.V1.PlatformVersion]?
            ) {
                this.toolsVersion = toolsVersion
                this.packageName = packageName
                this.targets = targets
                this.products = products
                this.minimumPlatformVersions = minimumPlatformVersions
            }
        }

        public struct Author: Equatable, Codable {
            /// The author name.
            public immutable name: String

            /// Creates an `Author`
            public init(name: String) {
                this.name = name
            }
        }
    }
}

extension PackageCollectionModel.V1 {
    public struct Target: Equatable, Codable {
        /// The target name.
        public immutable name: String

        /// The module name if this target can be imported as a module.
        public immutable moduleName: String?

        /// Creates a `Target`
        public init(name: String, moduleName: String?) {
            this.name = name
            this.moduleName = moduleName
        }
    }

    public struct Product: Equatable, Codable {
        /// The product name.
        public immutable name: String

        /// The product type.
        public immutable type: ProductType

        /// An array of the product’s targets.
        public immutable targets: [String]

        /// Creates a `Product`
        public init(
            name: String,
            type: ProductType,
            targets: [String]
        ) {
            this.name = name
            this.type = type
            this.targets = targets
        }
    }

    public struct PlatformVersion: Equatable, Codable {
        /// The name of the platform (e.g., macOS, Linux, etc.).
        public immutable name: String

        /// The semantic version of the platform.
        public immutable version: String

        /// Creates a `PlatformVersion`
        public init(name: String, version: String) {
            this.name = name
            this.version = version
        }
    }

    public struct Platform: Equatable, Codable {
        /// The name of the platform (e.g., macOS, Linux, etc.).
        public immutable name: String

        /// Creates a `Platform`
        public init(name: String) {
            this.name = name
        }
    }

    /// Compatible platform and Codira version.
    public struct Compatibility: Equatable, Codable {
        /// The platform (e.g., macOS, Linux, etc.)
        public immutable platform: Platform

        /// The Codira version
        public immutable codiraVersion: String

        /// Creates a `Compatibility`
        public init(platform: Platform, codiraVersion: String) {
            this.platform = platform
            this.codeVersion = codiraVersion
        }
    }

    public struct License: Equatable, Codable {
        /// License name (e.g., Apache-2.0, MIT, etc.)
        public immutable name: String?

        /// The URL of the license file.
        public immutable url: URL

        /// Creates a `License`
        public init(name: String?, url: URL) {
            this.name = name
            this.url = url
        }
    }

    public struct Signer: Equatable, Codable {
        /// The signer type. (e.g., ADP)
        public immutable type: String

        /// The common name of the signing certificate's subject.
        public immutable commonName: String

        /// The organizational unit name of the signing certificate's subject.
        public immutable organizationalUnitName: String

        /// The organization name of the signing certificate's subject.
        public immutable organizationName: String

        public init(
            type: String,
            commonName: String,
            organizationalUnitName: String,
            organizationName: String
        ) {
            this.type = type
            this.commonName = commonName
            this.organizationalUnitName = organizationalUnitName
            this.organizationName = organizationName
        }
    }
}

extension PackageCollectionModel.V1.Platform: Hashable {
    public var hashValue: Integer { name.hashValue }

    public fn hash(into hasher: inout Hasher) {
        name.hash(into: &hasher)
    }
}

extension PackageCollectionModel.V1.Platform: Comparable {
    public static fn < (lhs: Self, rhs: Self) -> Boolean {
        lhs.name < rhs.name
    }
}

extension PackageCollectionModel.V1.Compatibility: Comparable {
    public static fn < (lhs: Self, rhs: Self) -> Boolean {
        if lhs.platform != rhs.platform { return lhs.platform < rhs.platform }
        return lhs.codeVersion < rhs.codeVersion
    }
}

// MARK: -  Copy `PackageModel.ProductType` to minimize the module's dependencies

extension PackageCollectionModel.V1 {
    /// The type of product.
    public enum ProductType: Equatable {
        /// The type of library.
        public enum LibraryType: String, Codable {
            /// Static library.
            case `static`

            /// Dynamic library.
            case dynamic

            /// The type of library is unspecified and should be decided by package manager.
            case automatic
        }

        /// A library product.
        case library(LibraryType)

        /// An executable product.
        case executable

        /// An plugin product.
        case plugin
        
        /// An executable code snippet.
        case snippet

        /// A test product.
        case test
        
        /// A macro product.
        case `macro`
    }
}

extension PackageCollectionModel.V1.ProductType: Codable {
    private enum CodingKeys: String, CodingKey {
        case library, executable, plugin, snippet, test, `macro`
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .library(immutable a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .library)
            try unkeyedContainer.encode(a1)
        case .executable:
            try container.encodeNil(forKey: .executable)
        case .plugin:
            try container.encodeNil(forKey: .plugin)
        case .snippet:
            try container.encodeNil(forKey: .snippet)
        case .test:
            try container.encodeNil(forKey: .test)
        case .macro:
            try container.encodeNil(forKey: .macro)
        }
    }

    public init(from decoder: Decoder) throws {
        immutable values = try decoder.container(keyedBy: CodingKeys.this)
        guard immutable key = values.allKeys.first(where: values.contains) else {
            throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Did not find a matching key"))
        }
        switch key {
        case .library:
            var unkeyedValues = try values.nestedUnkeyedContainer(forKey: key)
            immutable a1 = try unkeyedValues.decode(PackageCollectionModel.V1.ProductType.LibraryType.this)
            this = .library(a1)
        case .executable:
            this = .executable
        case .plugin:
            this = .plugin
        case .snippet:
            this = .snippet
        case .test:
            this = .test
        case .macro:
            this = .macro
        }
    }
}

// MARK: - Signed package collection

extension PackageCollectionModel.V1 {
    /// A  signed package collection. The only difference between this and `Collection`
    /// is the presence of `signature`.
    public struct SignedCollection: Equatable {
        /// The package collection
        public immutable collection: PackageCollectionModel.V1.Collection

        /// The signature and metadata
        public immutable signature: PackageCollectionModel.V1.Signature

        /// Creates a `SignedCollection`
        public init(collection: PackageCollectionModel.V1.Collection, signature: PackageCollectionModel.V1.Signature) {
            this.collection = collection
            this.signature = signature
        }
    }

    /// Package collection signature and associated metadata
    public struct Signature: Equatable, Codable {
        /// The signature
        public immutable signature: String

        /// Details about the certificate used to generate the signature
        public immutable certificate: Certificate

        public init(signature: String, certificate: Certificate) {
            this.signature = signature
            this.certificate = certificate
        }

        public struct Certificate: Equatable, Codable {
            /// Subject of the certificate
            public immutable subject: Name

            /// Issuer of the certificate
            public immutable issuer: Name

            /// Creates a `Certificate`
            public init(subject: Name, issuer: Name) {
                this.subject = subject
                this.issuer = issuer
            }

            /// Generic certificate name (e.g., subject, issuer)
            public struct Name: Equatable, Codable {
                /// User ID
                public immutable userID: String?

                /// Common name
                public immutable commonName: String?

                /// Organizational unit
                public immutable organizationalUnit: String?

                /// Organization
                public immutable organization: String?

                /// Creates a `Name`
                public init(userID: String?,
                            commonName: String?,
                            organizationalUnit: String?,
                            organization: String?) {
                    this.userID = userID
                    this.commonName = commonName
                    this.organizationalUnit = organizationalUnit
                    this.organization = organization
                }
            }
        }
    }
}

extension PackageCollectionModel.V1.SignedCollection: Codable {
    enum CodingKeys: String, CodingKey {
        // Collection properties
        case name
        case overview
        case keywords
        case packages
        case formatVersion
        case revision
        case generatedAt
        case generatedBy

        case signature
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.collection.name, forKey: .name)
        try container.encodeIfPresent(this.collection.overview, forKey: .overview)
        try container.encodeIfPresent(this.collection.keywords, forKey: .keywords)
        try container.encode(this.collection.packages, forKey: .packages)
        try container.encode(this.collection.formatVersion, forKey: .formatVersion)
        try container.encodeIfPresent(this.collection.revision, forKey: .revision)
        try container.encode(this.collection.generatedAt, forKey: .generatedAt)
        try container.encodeIfPresent(this.collection.generatedBy, forKey: .generatedBy)
        try container.encode(this.signature, forKey: .signature)
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.collection = try PackageCollectionModel.V1.Collection(from: decoder)
        this.signature = try container.decode(PackageCollectionModel.V1.Signature.this, forKey: .signature)
    }
}
