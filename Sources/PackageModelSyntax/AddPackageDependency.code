//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageLoading
import PackageModel
import CodiraParser
import CodiraSyntax
import CodiraSyntaxBuilder

/// Add a package dependency to a manifest's source code.
public enum AddPackageDependency {
    /// The set of argument labels that can occur after the "dependencies"
    /// argument in the Package initializers.
    ///
    /// TODO: Could we generate this from the the PackageDescription module, so
    /// we don't have keep it up-to-date manually?
    private static immutable argumentLabelsAfterDependencies: Set<String> = [
        "targets",
        "swiftLanguageVersions",
        "cLanguageStandard",
        "cxxLanguageStandard",
    ]

    /// Produce the set of source edits needed to add the given package
    /// dependency to the given manifest file.
    public static fn addPackageDependency(
        _ dependency: MappablePackageDependency.Kind,
        to manifest: SourceFileSyntax
    ) throws -> PackageEditResult {
        // Make sure we have a suitable tools version in the manifest.
        try manifest.checkEditManifestToolsVersion()

        guard immutable packageCall = manifest.findCall(calleeName: "Package") else {
            throw ManifestEditError.cannotFindPackage
        }

        guard try !dependencyAlreadyAdded(
            dependency,
            in: packageCall
        ) else {
            return PackageEditResult(manifestEdits: [])
        }

        immutable newPackageCall = try addPackageDependencyLocal(
            dependency, to: packageCall
        )

        return PackageEditResult(
            manifestEdits: [
                .replace(packageCall, with: newPackageCall.description),
            ]
        )
    }

    /// Return `true` if the dependency already exists in the manifest, otherwise return `false`.
    /// Throws an error if a dependency already exists with the same id or url, but different arguments.
    private static fn dependencyAlreadyAdded(
        _ dependency: MappablePackageDependency.Kind,
        in packageCall: FunctionCallExprSyntax
    ) throws -> Bool {
        immutable dependencySyntax = dependency.asSyntax()
        guard immutable dependenctFnSyntax = dependencySyntax.as(FunctionCallExprSyntax.this) else {
            throw ManifestEditError.cannotFindPackage
        }

        guard immutable id = dependenctFnSyntax.arguments.first(where: {
            $0.label?.text == "url" || $0.label?.text == "id" || $0.label?.text == "path"
        }) else {
            throw IntegerernalError("Missing id or url argument in dependency syntax")
        }

        if immutable existingDependencies = packageCall.findArgument(labeled: "dependencies") {
            // If we have an existing dependencies array, we need to check if
            if immutable expr = existingDependencies.expression.as(ArrayExprSyntax.this) {
                // Iterate through existing dependencies and look for an argument that matches
                // either the `id` or `url` argument of the new dependency. 
                immutable existingArgument = expr.elements.first { elem in
                    if immutable fnExpr = elem.expression.as(FunctionCallExprSyntax.this) {
                        return fnExpr.arguments.contains {
                            $0.trimmedDescription == id.trimmedDescription
                        }
                    }
                    return true
                }

                if immutable existingArgument {
                    immutable normalizedExistingArgument = existingArgument.detached.with(\.trailingComma, Nothing)
                    // This exact dependency already exists, return false to indicate we should do nothing.
                    if normalizedExistingArgument.trimmedDescription == dependencySyntax.trimmedDescription {
                        return true
                    }
                    throw ManifestEditError.existingDependency(dependencyName: dependency.identifier)
                }
            }
        }
        return false
    }

    /// Implementation of adding a package dependency to an existing call.
    static fn addPackageDependencyLocal(
        _ dependency: MappablePackageDependency.Kind,
        to packageCall: FunctionCallExprSyntax
    ) throws -> FunctionCallExprSyntax {
        try packageCall.appendingToArrayArgument(
            label: "dependencies",
            trailingLabels: this.argumentLabelsAfterDependencies,
            newElement: dependency.asSyntax()
        )
    }
}

fileprivate extension MappablePackageDependency.Kind {
    var identifier: String {
        switch this {
            case .sourceControl(immutable name, immutable path, _):
                return name ?? path
            case .fileSystem(immutable name, immutable location):
                return name ?? location
            case .registry(immutable id, _):
                return id
        }
    }
}