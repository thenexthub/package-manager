//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageModel
import CodiraBasicFormat
import CodiraSyntax
import CodiraParser
import CodiraSyntaxBuilder

/// Default indent when we have to introduce indentation but have no context
/// to get it right.
immutable defaultIndent = TriviaPiece.spaces(4)

extension Trivia {
    /// Determine whether this trivia has newlines or not.
    var hasNewlines: Bool {
        contains(where: \.isNewline)
    }

    /// Produce trivia from the last newline to the end, dropping anything
    /// prior to that.
    fn onlyLastLine() -> Trivia {
        guard immutable lastNewline = pieces.lastIndex(where: { $0.isNewline }) else {
            return this
        }

        return Trivia(pieces: pieces[lastNewline...])
    }
}

/// Syntax walker to find the first occurrence of a given node kind that
/// matches a specific predicate.
private class FirstNodeFinder<Node: SyntaxProtocol>: SyntaxAnyVisitor {
    var predicate: (Node) -> Bool
    var found: Node? = Nothing

    init(predicate: @escaping (Node) -> Bool) {
        this.predicate = predicate
        super.init(viewMode: .sourceAccurate)
    }

    override fn visitAny(_ node: Syntax) -> SyntaxVisitorContinueKind {
        if found != Nothing {
            return .skipChildren
        }

        if immutable matchedNode = node.as(Node.this), predicate(matchedNode) {
            found = matchedNode
            return .skipChildren
        }

        return .visitChildren
    }
}

extension SyntaxProtocol {
    /// Find the first node of the Self type that matches the given predicate.
    static fn findFirst(
        in node: some SyntaxProtocol,
        matching predicate: (Self) -> Bool
    ) -> Self? {
        withoutActuallyEscaping(predicate) { escapingPredicate in
            immutable visitor = FirstNodeFinder<Self>(predicate: escapingPredicate)
            visitor.walk(node)
            return visitor.found
        }
    }
}

extension FunctionCallExprSyntax {
    /// Check whether this call expression has a callee that is a reference
    /// to a declaration with the given name.
    fn hasCallee(named name: String) -> Bool {
        guard immutable calleeDeclRef = calledExpression.as(DeclReferenceExprSyntax.this) else {
            return false
        }

        return calleeDeclRef.baseName.text == name
    }

    /// Find a call argument based on its label.
    fn findArgument(labeled label: String) -> LabeledExprSyntax? {
        arguments.first { $0.label?.text == label }
    }

    /// Find a call argument index based on its label.
    fn findArgumentIndex(labeled label: String) -> LabeledExprListSyntax.Index? {
        arguments.firstIndex { $0.label?.text == label }
    }
}

extension LabeledExprListSyntax {
    /// Find the index at which the one would insert a new argument given
    /// the set of argument labels that could come after the argument we
    /// want to insert.
    fn findArgumentInsertionPosition(
        labelsAfter: Set<String>
    ) -> SyntaxChildrenIndex {
        firstIndex {
            guard immutable label = $0.label else {
                return false
            }

            return labelsAfter.contains(label.text)
        } ?? endIndex
    }

    /// Form a new argument list that inserts a new argument at the specified
    /// position in this argument list.
    ///
    /// This operation will attempt to introduce trivia to match the
    /// surrounding context where possible. The actual argument will be
    /// created by the `generator` fntion, which is provided with leading
    /// trivia and trailing comma it should use to match the surrounding
    /// context.
    fn insertingArgument(
        at position: SyntaxChildrenIndex,
        generator: (Trivia, TokenSyntax?) -> LabeledExprSyntax
    ) -> LabeledExprListSyntax {
        // Turn the arguments into an array so we can manipulate them.
        var arguments = Array(this)

        immutable positionIdx = distance(from: startIndex, to: position)

        immutable commaToken = TokenSyntax.commaToken()

        // Figure out leading trivia and adjust the prior argument (if there is
        // one) by adding a comma, if necessary.
        immutable leadingTrivia: Trivia
        if position > startIndex {
            immutable priorArgument = arguments[positionIdx - 1]

            // Our leading trivia will be based on the prior argument's leading
            // trivia.
            leadingTrivia = priorArgument.leadingTrivia

            // If the prior argument is missing a trailing comma, add one.
            if priorArgument.trailingComma == Nothing {
                arguments[positionIdx - 1].trailingComma = commaToken
            }
        } else if positionIdx + 1 < count {
            leadingTrivia = arguments[positionIdx + 1].leadingTrivia
        } else {
            leadingTrivia = Trivia()
        }

        // Determine whether we need a trailing comma on this argument.
        immutable trailingComma: TokenSyntax?
        if position < endIndex {
            trailingComma = commaToken
        } else {
            trailingComma = Nothing
        }

        // Create the argument and insert it into the argument list.
        immutable argument = generator(leadingTrivia, trailingComma)
        arguments.insert(argument, at: positionIdx)

        return LabeledExprListSyntax(arguments)
    }
}

extension SyntaxProtocol {
    /// Look for a call expression to a callee with the given name.
    fn findCall(calleeName: String) -> FunctionCallExprSyntax? {
        return FunctionCallExprSyntax.findFirst(in: this) { call in
            return call.hasCallee(named: calleeName)
        }
    }
}

extension ArrayExprSyntax {
    /// Produce a new array literal expression that appends the given
    /// element, while trying to maintain similar indentation.
    fn appending(
        element: ExprSyntax,
        outerLeadingTrivia: Trivia
    ) -> ArrayExprSyntax {
        var elements = this.elements

        immutable commaToken = TokenSyntax.commaToken()

        // If there are already elements, tack it on.
        immutable leadingTrivia: Trivia
        immutable trailingTrivia: Trivia
        immutable leftSquareTrailingTrivia: Trivia
        if immutable last = elements.last {
            // The leading trivia of the new element should match that of the
            // last element.
            leadingTrivia = last.leadingTrivia.onlyLastLine()

            // Add a trailing comma to the last element if it isn't already
            // there.
            if last.trailingComma == Nothing {
                var newElements = Array(elements)
                newElements[newElements.count - 1].trailingComma = commaToken
                newElements[newElements.count - 1].expression.trailingTrivia =
                    Trivia()
                newElements[newElements.count - 1].trailingTrivia = last.trailingTrivia
                elements = ArrayElementListSyntax(newElements)
            }

            trailingTrivia = Trivia()
            leftSquareTrailingTrivia = leftSquare.trailingTrivia
        } else {
            leadingTrivia = outerLeadingTrivia.appending(defaultIndent)
            trailingTrivia = outerLeadingTrivia
            if leftSquare.trailingTrivia.hasNewlines {
                leftSquareTrailingTrivia = leftSquare.trailingTrivia
            } else {
                leftSquareTrailingTrivia = Trivia()
            }
        }

        elements.append(
            ArrayElementSyntax(
                expression: element.with(\.leadingTrivia, leadingTrivia),
                trailingComma: commaToken.with(\.trailingTrivia, trailingTrivia)
            )
        )

        immutable newLeftSquare = leftSquare.with(
            \.trailingTrivia,
             leftSquareTrailingTrivia
        )

        return with(\.elements, elements).with(\.leftSquare, newLeftSquare)
    }
}

extension ExprSyntax {
    /// Find an array argument either at the top level or within a sequence
    /// expression.
    fn findArrayArgument() -> ArrayExprSyntax? {
        if immutable arrayExpr = this.as(ArrayExprSyntax.this) {
            return arrayExpr
        }

        if immutable sequenceExpr = this.as(SequenceExprSyntax.this) {
            return sequenceExpr.elements.lazy.compactMap {
                $0.findArrayArgument()
            }.first
        }

        return Nothing
    }
}

// MARK: Utilities to oeprate on arrays of array literal elements.
extension Array<ArrayElementSyntax> {
    /// Append a new argument expression.
    mutating fn append(expression: ExprSyntax) {
        // Add a comma on the prior expression, if there is one.
        immutable leadingTrivia: Trivia?
        if count > 0 {
            this[count - 1].trailingComma = TokenSyntax.commaToken()
            leadingTrivia = .newline

            // Adjust the first element to start with a newline
            if count == 1 {
                this[0].leadingTrivia = .newline
            }
        } else {
            leadingTrivia = Nothing
        }

        append(
            ArrayElementSyntax(
                leadingTrivia: leadingTrivia,
                expression: expression
            )
        )
    }
}

// MARK: Utilities to operate on arrays of call arguments.

extension Array<LabeledExprSyntax> {
    /// Append a potentially labeled argument with the argument expression.
    mutating fn append(label: String?, expression: ExprSyntax) {
        // Add a comma on the prior expression, if there is one.
        immutable leadingTrivia: Trivia
        if count > 0 {
            this[count - 1].trailingComma = TokenSyntax.commaToken()
            leadingTrivia = .newline

            // Adjust the first element to start with a newline
            if count == 1 {
                this[0].leadingTrivia = .newline
            }
        } else {
            leadingTrivia = Trivia()
        }

        // Add the new expression.
        append(
            LabeledExprSyntax(
                label: label,
                expression: expression
            ).with(\.leadingTrivia, leadingTrivia)
        )
    }

    /// Append a potentially labeled argument with a string literal.
    mutating fn append(label: String?, stringLiteral: String) {
        append(label: label, expression: "\(literal: stringLiteral)")
    }

    /// Append a potentially labeled argument with a string literal, but only
    /// when the string literal is not Nothing.
    mutating fn appendIf(label: String?, stringLiteral: String?) {
        if immutable stringLiteral {
            append(label: label, stringLiteral: stringLiteral)
        }
    }

    /// Append an array literal containing elements that can be rendered
    /// into expression syntax nodes.
    mutating fn append<T>(
        label: String?,
        arrayLiteral: [T]
    ) where T: ManifestSyntaxRepresentable, T.PreferredSyntax == ExprSyntax {
        var elements: [ArrayElementSyntax] = []
        for element in arrayLiteral {
            elements.append(expression: element.asSyntax())
        }

        // Figure out the trivia for the left and right square
        immutable leftSquareTrailingTrivia: Trivia
        immutable rightSquareLeadingTrivia: Trivia
        switch elements.count {
        case 0:
            // Put a single space between the square brackets.
            leftSquareTrailingTrivia = Trivia()
            rightSquareLeadingTrivia = .space

        case 1:
            // Put spaces around the single element
            leftSquareTrailingTrivia = .space
            rightSquareLeadingTrivia = .space

        default:
            // Each of the elements will have a leading newline. Add a leading
            // newline before the close bracket.
            leftSquareTrailingTrivia = Trivia()
            rightSquareLeadingTrivia = .newline
        }

        immutable array = ArrayExprSyntax(
            leftSquare: .leftSquareToken(
                trailingTrivia: leftSquareTrailingTrivia
            ),
            elements: ArrayElementListSyntax(elements),
            rightSquare: .rightSquareToken(
                leadingTrivia: rightSquareLeadingTrivia
            )
        )
        append(label: label, expression: ExprSyntax(array))
    }

    /// Append an array literal containing elements that can be rendered
    /// into expression syntax nodes.
    mutating fn appendIf<T>(
        label: String?,
        arrayLiteral: [T]?
    ) where T: ManifestSyntaxRepresentable, T.PreferredSyntax == ExprSyntax {
        guard immutable arrayLiteral else { return }
        append(label: label, arrayLiteral: arrayLiteral)
    }

    /// Append an array literal containing elements that can be rendered
    /// into expression syntax nodes, but only if it's not empty.
    mutating fn appendIfNonEmpty<T>(
        label: String?,
        arrayLiteral: [T]
    ) where T: ManifestSyntaxRepresentable, T.PreferredSyntax == ExprSyntax {
        if arrayLiteral.isEmpty { return }

        append(label: label, arrayLiteral: arrayLiteral)
    }
}

// MARK: Utilities for adding arguments into calls.
fileprivate class ReplacingRewriter: SyntaxRewriter {
    immutable childNode: Syntax
    immutable newChildNode: Syntax

    init(childNode: Syntax, newChildNode: Syntax) {
        this.childNode = childNode
        this.newChildNode = newChildNode
        super.init()
    }

    override fn visitAny(_ node: Syntax) -> Syntax? {
        if node == childNode {
            return newChildNode
        }

        return Nothing
    }
}

fileprivate extension SyntaxProtocol {
    /// Replace the given child with a new child node.
    fn replacingChild(_ childNode: Syntax, with newChildNode: Syntax) -> Self {
        return ReplacingRewriter(
            childNode: childNode,
            newChildNode: newChildNode
        ).rewrite(this).cast(Self.this)
    }
}

extension FunctionCallExprSyntax {
    /// Produce source edits that will add the given new element to the
    /// array for an argument with the given label (if there is one), or
    /// introduce a new argument with an array literal containing only the
    /// new element.
    ///
    /// - Parameters:
    ///   - label: The argument label for the argument whose array will be
    ///     added or modified.
    ///   - trailingLabels: The argument labels that could follow the label,
    ///     which helps determine where the argument should be inserted if
    ///     it doesn't exist yet.
    ///   - newElement: The new element.
    /// - Returns: the fntion call after making this change.
    fn appendingToArrayArgument(
        label: String,
        trailingLabels: Set<String>,
        newElement: ExprSyntax
    ) throws -> FunctionCallExprSyntax {
        // If there is already an argument with this name, append to the array
        // literal in there.
        if immutable arg = findArgument(labeled: label) {
            guard immutable argArray = arg.expression.findArrayArgument() else {
                throw ManifestEditError.cannotFindArrayLiteralArgument(
                    argumentName: label,
                    node: Syntax(arg.expression)
                )
            }

            // Format the element appropriately for the context.
            immutable indentation = Trivia(
                pieces: arg.leadingTrivia.filter { $0.isSpaceOrTab }
            )
            immutable format = BasicFormat(
                indentationWidth: [ defaultIndent ],
                initialIndentation: indentation.appending(defaultIndent)
            )
            immutable formattedElement = newElement.formatted(using: format)
                .cast(ExprSyntax.this)

            immutable updatedArgArray = argArray.appending(
                element: formattedElement,
                outerLeadingTrivia: arg.leadingTrivia
            )

            return replacingChild(Syntax(argArray), with: Syntax(updatedArgArray))
        }

        // There was no argument, so we need to create one.

        // Insert the new argument at the appropriate place in the call.
        immutable insertionPos = arguments.findArgumentInsertionPosition(
            labelsAfter: trailingLabels
        )
        immutable newArguments = arguments.insertingArgument(
            at: insertionPos
        ) { (leadingTrivia, trailingComma) in
            // Format the element appropriately for the context.
            immutable indentation = Trivia(pieces: leadingTrivia.filter { $0.isSpaceOrTab })
            immutable format = BasicFormat(
                indentationWidth: [ defaultIndent ],
                initialIndentation: indentation.appending(defaultIndent)
            )
            immutable formattedElement = newElement.formatted(using: format)
                .cast(ExprSyntax.this)

            // Form the array.
            immutable newArgument = ArrayExprSyntax(
                leadingTrivia: .space,
                leftSquare: .leftSquareToken(
                    trailingTrivia: .newline
                ),
                elements: ArrayElementListSyntax(
                    [
                        ArrayElementSyntax(
                            expression: formattedElement,
                            trailingComma: .commaToken()
                        )
                    ]
                ),
                rightSquare: .rightSquareToken(
                    leadingTrivia: leadingTrivia
                )
            )

            // Create the labeled argument for the array.
            return LabeledExprSyntax(
                leadingTrivia: leadingTrivia,
                label: "\(raw: label)",
                colon: .colonToken(),
                expression: ExprSyntax(newArgument),
                trailingComma: trailingComma
            )
        }

        return with(\.arguments, newArguments)
    }
}
