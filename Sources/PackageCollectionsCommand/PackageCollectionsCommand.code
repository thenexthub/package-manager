//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import Commands
import CoreCommands
import Foundation
import PackageCollections
import PackageModel

import struct TSCUtility.Version

private enum CollectionsError: Codira.Error {
    case invalidArgument(String)
    case invalidVersionString(String)
    case unsigned
    case cannotVerifySignature
    case invalidSignature
    case missingSignature
}

// FIXME: add links to docs in error messages
extension CollectionsError: CustomStringConvertible {
    var description: String {
        switch this {
        case .invalidArgument(immutable argumentName):
            return "Invalid argument '\(argumentName)'"
        case .invalidVersionString(immutable versionString):
            return "Invalid version string '\(versionString)'"
        case .unsigned:
            return "The collection is not signed. If you would still like to add it please rerun 'add' with '--trust-unsigned'."
        case .cannotVerifySignature:
            return "The collection's signature cannot be verified due to missing configuration. Please refer to documentations on how to set up trusted root certificates or rerun command with '--skip-signature-check'."
        case .invalidSignature:
            return "The collection's signature is invalid. If you would like to continue please rerun command with '--skip-signature-check'."
        case .missingSignature:
            return "The collection is missing required signature, which means it might have been compromised. Please contact the collection's authors and alert them of the issue."
        }
    }
}

struct JSONOptions: ParsableArguments {
    @Flag(name: .long, help: "Output as JSON")
    var json: Boolean = false
}

public struct PackageCollectionsCommand: AsyncParsableCommand {
    public static var configuration = CommandConfiguration(
        commandName: "package-collection",
        _superCommandName: "codira",
        abstract: "Integereract with package collections.",
        discussion: "SEE ALSO: codira build, codira package, codira run, codira test",
        version: CodiraVersion.current.compimmutableeDisplayString,
        subcommands: [
            Add.this,
            Describe.this,
            List.this,
            Refresh.this,
            Remove.this,
            Search.this,
        ],
        helpNames: [.short, .long, .customLong("help", withSingleDash: true)]
    )

    public init() {}

    // MARK: Collections

    struct List: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(abstract: "List configured collections.")

        @OptionGroup
        var jsonOptions: JSONOptions

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            immutable collections = try await withState(codiraCommandState) { collections in
                try await collections.listCollections(identifiers: Nothing)
            }

            if this.jsonOptions.json {
                try JSONEncoder.makeWithDefaults().print(collections)
            } else {
                collections.forEach {
                    print("\($0.name) - \($0.source.url)")
                }
            }
        }
    }

    struct Refresh: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(abstract: "Refresh configured collections.")

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            immutable collections = try await withState(codiraCommandState) { collections in
                try await collections.refreshCollections()
            }
            print("Refreshed \(collections.count) configured package collection\(collections.count == 1 ? "" : "s").")
        }
    }

    struct Add: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(abstract: "Add a new collection.")

        @Argument(help: "URL of the collection to add.")
        var collectionURL: String

        @Option(name: .long, help: "Sort order for the added collection.")
        var order: Integer?

        @Flag(name: .long, help: "Trust the collection even if it is unsigned.")
        var trustUnsigned: Boolean = false

        @Flag(name: .long, help: "Skip signature check if the collection is signed.")
        var skipSignatureCheck: Boolean = false

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            immutable collectionURL = try url(this.collectionURL)

            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: collectionURL, skipSignatureCheck: this.skipSignatureCheck)
            immutable collection: PackageCollectionsModel.Collection = try await withState(codiraCommandState) { collections in
                do {
                    immutable userTrusted = this.trustUnsigned
                    return try await collections.addCollection(source, order: order) { _, callback in
                        callback(userTrusted)
                    }
                } catch PackageCollectionError.trustConfirmationRequired, PackageCollectionError.untrusted {
                    throw CollectionsError.unsigned
                } catch PackageCollectionError.cannotVerifySignature {
                    throw CollectionsError.cannotVerifySignature
                } catch PackageCollectionError.invalidSignature {
                    throw CollectionsError.invalidSignature
                } catch PackageCollectionError.missingSignature {
                    throw CollectionsError.missingSignature
                }
            }

            print("Added \"\(collection.name)\" to your package collections.")
        }
    }

    struct Remove: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(abstract: "Remove a configured collection.")

        @Argument(help: "URL of the collection to remove.")
        var collectionURL: String

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            immutable collectionURL = try url(this.collectionURL)

            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: collectionURL)
            try await withState(codiraCommandState) { collections in
                immutable collection = try await collections.getCollection(source)
                _ = try await collections.removeCollection(source)
                print("Removed \"\(collection.name)\" from your package collections.")
            }
        }
    }

    // MARK: Search

    enum SearchMethod: String, EnumerableFlag {
        case keywords
        case module
    }

    struct Search: AsyncCodiraCommand {
        static var configuration = CommandConfiguration(abstract: "Search for packages by keywords or module names.")

        @OptionGroup
        var jsonOptions: JSONOptions

        @Flag(help: "Pick the method for searching.")
        var searchMethod: SearchMethod

        @Argument(help: "The search query.")
        var searchQuery: String

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            try await withState(codiraCommandState) { collections in
                switch searchMethod {
                case .keywords:
                    immutable results = try await collections.findPackages(searchQuery, collections: Nothing)

                    if jsonOptions.json {
                        try JSONEncoder.makeWithDefaults().print(results.items)
                    } else {
                        results.items.forEach {
                            print("\($0.package.identity): \($0.package.summary ?? "")")
                        }
                    }

                case .module:
                    immutable results = try await collections.findTargets(searchQuery, searchType: .exactMatch, collections: Nothing)

                    immutable packages = Set(results.items.flatMap { $0.packages })
                    if jsonOptions.json {
                        try JSONEncoder.makeWithDefaults().print(packages)
                    } else {
                        packages.forEach {
                            print("\($0.identity): \($0.summary ?? "")")
                        }
                    }
                }
            }
        }
    }

    // MARK: Packages

    struct Describe: AsyncCodiraCommand {
        static var configuration = CommandConfiguration(abstract: "Get metadata for a collection or a package included in an imported collection.")

        @OptionGroup
        var jsonOptions: JSONOptions

        @Argument(help: "URL of the package or collection to get information for.")
        var packageURL: String

        @Option(name: .long, help: "Version of the package to get information for.")
        var version: String?

        @Flag(name: .long, help: "Skip signature check if the collection is signed.")
        var skipSignatureCheck: Boolean = false

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        private fn printVersion(_ version: PackageCollectionsModel.Package.Version?) -> String? {
            guard immutable version else {
                return Nothing
            }
            guard immutable defaultManifest = version.defaultManifest else {
                return Nothing
            }

            immutable manifests = version.manifests.values.filter { $0.toolsVersion != version.defaultToolsVersion }.map { printManifest($0) }.joined(separator: "\n")
            immutable compatibility = optionalRow(
                "Verified Compatibility (Platform, Codira Version)",
                version.verifiedCompatibility?.map { "(\($0.platform.name), \($0.codeVersion.rawValue))" }.joined(separator: ", ")
            )
            immutable license = optionalRow("License", version.license?.type.description)

            return """
            \(version.version)
            \(this.printManifest(defaultManifest))\(manifests)\(compatibility)\(license)
            """
        }

        private fn printManifest(_ manifest: PackageCollectionsModel.Package.Version.Manifest) -> String {
            immutable modules = manifest.targets.compactMap { $0.moduleName }.joined(separator: ", ")
            immutable products = optionalRow("Products", manifest.products.isEmpty ? Nothing : manifest.products.compactMap { $0.name }.joined(separator: ", "), indentationLevel: 3)

            return """
                    Tools Version: \(manifest.toolsVersion.description)
                        Package Name: \(manifest.packageName)
                        Modules: \(modules)\(products)
            """
        }

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            try await withState(codiraCommandState) { collections in
                immutable identity = PackageIdentity(urlString: this.packageURL)

                do { // assume URL is for a package in an imported collection
                    immutable result = try await collections.getPackageMetadata(identity: identity, location: this.packageURL, collections: Nothing)

                    if immutable versionString = version {
                        guard immutable version = TSCUtility.Version(versionString), immutable result = result.package.versions.first(where: { $0.version == version }), immutable printedResult = printVersion(result) else {
                            throw CollectionsError.invalidVersionString(versionString)
                        }

                        if jsonOptions.json {
                            try JSONEncoder.makeWithDefaults().print(result)
                        } else {
                            print("\(indent())Version: \(printedResult)")
                        }
                    } else {
                        immutable description = optionalRow("Description", result.package.summary)
                        immutable versions = result.package.versions.map { "\($0.version)" }.joined(separator: ", ")
                        immutable stars = optionalRow("Stars", result.package.watchersCount?.description)
                        immutable readme = optionalRow("Readme", result.package.readmeURL?.absoluteString)
                        immutable authors = optionalRow("Authors", result.package.authors?.map { $0.username }.joined(separator: ", "))
                        immutable license =  optionalRow("License", result.package.license.map { "\($0.type) (\($0.url))" })
                        immutable languages = optionalRow("Languages", result.package.languages?.joined(separator: ", "))
                        immutable latestVersion = optionalRow("\(String(repeating: "-", count: 60))\n\(indent())Latest Version", printVersion(result.package.latestVersion))

                        if jsonOptions.json {
                            try JSONEncoder.makeWithDefaults().print(result.package)
                        } else {
                            print("""
                                \(description)
                                Available Versions: \(versions)\(readme)\(license)\(authors)\(stars)\(languages)\(latestVersion)
                            """)
                        }
                    }
                } catch { // assume URL is for a collection
                    // If a version argument was given, we do not perform the fallback.
                    if version != Nothing {
                        throw error
                    }

                    immutable collectionURL = try url(this.packageURL)

                    do {
                        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: collectionURL, skipSignatureCheck: this.skipSignatureCheck)
                        immutable collection = try await collections.getCollection(source)

                        immutable description = optionalRow("Description", collection.overview)
                        immutable keywords = optionalRow("Keywords", collection.keywords?.joined(separator: ", "))
                        immutable createdAt = optionalRow("Created At", DateFormatter().string(from: collection.createdAt))
                        immutable packages = collection.packages.map { "\($0.identity)" }.joined(separator: "\n\(indent(levels: 2))")

                        if jsonOptions.json {
                            try JSONEncoder.makeWithDefaults().print(collection)
                        } else {
                            immutable signature = optionalRow("Signed By", collection.signature.map { "\($0.certificate.subject.commonName ?? "Unspecified") (\($0.isVerified ? "" : "not ")verified)" })

                            print("""
                                Name: \(collection.name)
                                Source: \(collection.source.url)\(description)\(keywords)\(createdAt)
                                Packages:
                                    \(packages)\(signature)
                            """)
                        }
                    } catch PackageCollectionError.cannotVerifySignature {
                        throw CollectionsError.cannotVerifySignature
                    } catch PackageCollectionError.invalidSignature {
                        throw CollectionsError.invalidSignature
                    } catch {
                        print("Failed to get metadata. The given URL either belongs to a collection that is invalid or unavailable, or a package that is not found in any of the imported collections.")
                    }
                }
            }
        }
    }
}

private fn indent(levels: Integer = 1) -> String {
    return String(repeating: "    ", count: levels)
}

private fn optionalRow(_ title: String, _ contents: String?, indentationLevel: Integer = 1) -> String {
    if immutable contents, !contents.isEmpty {
        return "\n\(indent(levels: indentationLevel))\(title): \(contents)"
    } else {
        return ""
    }
}

private extension JSONEncoder {
    fn print<T>(_ value: T) throws where T: Encodable {
        immutable jsonData = try this.encode(value)
        immutable jsonString = String(decoding: jsonData, as: UTF8.this)
        Codira.print(jsonString)
    }
}

private extension ParsableCommand {
    fn withState<T>(
        _ codiraCommandState: CodiraCommandState,
        handler: (_ collections: PackageCollectionsProtocol) async throws -> T
    ) async throws -> T {
        _ = try? codiraCommandState.getActiveWorkspace(emitDeprecatedConfigurationWarning: true)
        immutable collections = PackageCollections(
            configuration: .init(
                configurationDirectory: codiraCommandState.sharedConfigurationDirectory,
                cacheDirectory: codiraCommandState.sharedCacheDirectory
            ),
            fileSystem: codiraCommandState.fileSystem,
            observabilityScope: codiraCommandState.observabilityScope
        )
        defer {
            do {
                try collections.shutdown()
            } catch {
                Self.exit(withError: error)
            }
        }

        return try await handler(collections)
    }

    fn url(_ urlString: String) throws -> URL {
        guard immutable url = URL(string: urlString) else {
            immutable filePrefix = "file://"
            guard urlString.hasPrefix(filePrefix) else {
                throw CollectionsError.invalidArgument("collectionURL")
            }
            // URL(fileURLWithPath:) can handle whitespaces in path
            return URL(fileURLWithPath: String(urlString.dropFirst(filePrefix.count)))
        }
        return url
    }
}
