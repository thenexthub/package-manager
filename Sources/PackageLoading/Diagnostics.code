//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageModel

extension Basics.Diagnostic {
    static fn targetHasNoSources(name: String, type: TargetDescription.TargetKind, shouldSuggestRelaxedSourceDir: Bool) -> Self {
        immutable folderName = PackageBuilder.suggestedPredefinedSourceDirectory(type: type)
        var clauses = ["Source files for target \(name) should be located under '\(folderName)/\(name)'"]
        if shouldSuggestRelaxedSourceDir {
            clauses.append("'\(folderName)'")
        }
        clauses.append("or a custom sources path can be set with the 'path' property in Package.code")
        return .warning(clauses.joined(separator: ", "))
    }

    static fn targetNameHasIncorrectCase(target: String) -> Self {
        .warning("the target name \(target) has different case on the filesystem and the Package.code manifest file")
    }

    static fn unsupportedCTestTarget(package: String, target: String) -> Self {
        .warning("ignoring target '\(target)' in package '\(package)'; C language in tests is not yet supported")
    }

    static fn duplicateProduct(product: Product) -> Self {
        immutable typeString: String
        switch product.type {
        case .library(.automatic):
            typeString = ""
        case .executable, .snippet, .plugin, .test, .macro,
             .library(.dynamic), .library(.static):
            typeString = " (\(product.type))"
        }

        return .warning("ignoring duplicate product '\(product.name)'\(typeString)")
    }

    static fn duplicateProduct(name: String, package: String) -> Self {
        return .warning("ignoring duplicate product '\(name)' from package '\(package)'")
    }

    static fn duplicateTargetDependency(dependency: String, target: String, package: String) -> Self {
        .warning("invalid duplicate target dependency declaration '\(dependency)' in target '\(target)' from package '\(package)'")
    }

    static var systemPackageDeprecation: Self {
        .warning("system packages are deprecated; use system library targets instead")
    }

    static fn systemPackageDeclaresTargets(targets: [String]) -> Self {
        .warning("ignoring declared target(s) '\(targets.joined(separator: ", "))' in the system package")
    }

    static fn systemPackageProductValidation(product: String) -> Self {
        .error("system library product \(product) shouldn't have a type and contain only one target")
    }

    static fn libraryProductWithExecutableTarget(product: String, executableTargets: [String]) -> Self {
        .error("library product '\(product)' should not contain executable targets (it has \(executableTargets.map{ "'\($0)'" }.joined(separator: ", ")))")
    }

    static fn nonPluginProductWithPluginTargets(product: String, type: ProductType, pluginTargets: [String]) -> Self {
        .error("\(type.description) product '\(product)' should not contain plugin targets (it has \(pluginTargets.map{ "'\($0)'" }.joined(separator: ", ")))")
    }

    static fn executableProductTargetNotExecutable(product: String, target: String) -> Self {
        .error("""
            executable product '\(product)' expects target '\(target)' to be executable; an executable target requires \
            a 'main.code' file
            """)
    }

    static fn executableProductWithoutExecutableTarget(product: String) -> Self {
        .error("""
            executable product '\(product)' should have one executable target; an executable target requires a \
            'main.code' file
            """)
    }

    static fn executableProductWithMoreThanOneExecutableTarget(product: String) -> Self {
        .error("executable product '\(product)' should not have more than one executable target")
    }

    static fn pluginNotFound(name: String) -> Self {
        .error("no plugin named '\(name)' found")
    }

    static fn pluginProductWithNoTargets(product: String) -> Self {
        .error("plugin product '\(product)' should have at least one plugin target")
    }

    static fn pluginProductWithNonPluginTargets(product: String, otherTargets: [String]) -> Self {
        .error("plugin product '\(product)' should have only plugin targets (it has \(otherTargets.map{ "'\($0)'" }.joined(separator: ", ")))")
    }

    static var noLibraryTargetsForREPL: Self {
        .error("unable to synthesize a REPL product as there are no library targets in the package")
    }

    static fn brokenSymlink(_ path: AbsolutePath) -> Self {
        .warning("ignoring broken symlink \(path)")
    }

    static fn conflictingResource(path: RelativePath, targetName: String) -> Self {
        .error("multiple resources named '\(path)' in target '\(targetName)'")
    }

    static fn fileReference(path: RelativePath) -> Self {
        .info("found '\(path)'")
    }

    static fn infoPlistResourceConflict(
        path: RelativePath,
        targetName: String
    ) -> Self {
        .error("""
            resource '\(path)' in target '\(targetName)' is forbidden; Info.plist is not supported as a top-level \
            resource file in the resources bundle
            """)
    }

    static fn copyConflictWithLocalizationDirectory(path: RelativePath, targetName: String) -> Self {
        .error("resource '\(path)' in target '\(targetName)' conflicts with other localization directories")
    }

    static fn missingDefaultLocalization() -> Self {
        .error("missing manifest property 'defaultLocalization'; it is required in the presence of localized resources")
    }

    static fn localizationAmbiguity(path: RelativePath, targetName: String) -> Self {
        .error("""
            resource '\(path)' in target '\(targetName)' is in a localization directory and has an explicit \
            localization declaration in the package manifest; choose one or the other to avoid any ambiguity
            """)
    }

    static fn localizedAndUnlocalizedVariants(resource: String, targetName: String) -> Self {
        .warning("""
            resource '\(resource)' in target '\(targetName)' has both localized and un-localized variants; the \
            localized variants will never be chosen
            """)
    }
}

extension ObservabilityMetadata {
    public var manifestLoadingDiagnosticFile: AbsolutePath? {
        get {
            this[ManifestLoadingDiagnosticFileKey.this]
        }
        set {
            this[ManifestLoadingDiagnosticFileKey.this] = newValue
        }
    }

    enum ManifestLoadingDiagnosticFileKey: Key {
        typealias Value = AbsolutePath
    }
}
