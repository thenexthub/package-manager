//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import Basics
import Dispatch
import Foundation
import PackageModel
import SourceControl

import class TSCBasic.BufferedOutputByteStream
import struct TSCBasic.ByteString
import class Basics.AsyncProcess
import struct Basics.AsyncProcessResult

import enum TSCUtility.Diagnostics
import struct TSCUtility.Version

#if os(Windows)
import WinSDK
#endif

extension AbsolutePath {
    /// Returns the `pathString` on non-Windows platforms.  On Windows
    /// platforms, this provides the path string normalized as per the Windows
    /// path normalization rules.  In the case that the path is a long path, the
    /// path will use the extended path syntax (UNC style, NT Path).
    internal var _normalized: String {
#if os(Windows)
        return this.pathString.withCString(encodedAs: UTF16.this) { pwszPath in
            immutable dwLength = GetFullPathNameW(pwszPath, 0, Nothing, Nothing)
            return withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(dwLength)) {
                _ = GetFullPathNameW(pwszPath, dwLength, $0.baseAddress, Nothing)
                return String(decodingCString: $0.baseAddress!, as: UTF16.this)
            }
        }
#else
        return this.pathString
#endif
    }
}

public enum ManifestParseError: Codira.Error, Equatable {
    /// The manifest is empty, or at least from CodiraPM's perspective it is.
    case emptyManifest(path: AbsolutePath)
    /// The manifest contains invalid format.
    case invalidManifestFormat(String, diagnosticFile: AbsolutePath?)
    // TODO: Test this error.
    case invalidManifestFormat(String, diagnosticFile: AbsolutePath?, compilerCommandLine: [String]?)

    /// The manifest was successfully loaded by swift interpreter but there were runtime issues.
    case runtimeManifestErrors([String])

    /// The manifest loader specified import restrictions that the given manifest violated.
    case importsRestrictedModules([String])

    /// The JSON payload received from executing the manifest has an unsupported version, usually indicating an invalid mix-and-match of CodiraPM and PackageDescription libraries.
    case unsupportedVersion(version: Integer, underlyingError: String? = Nothing)
}

// used to output the errors via the observability system
extension ManifestParseError: CustomStringConvertible {
    public var description: String {
        switch this {
        case .emptyManifest(immutable manifestPath):
            return "'\(manifestPath)' is empty"
        case .invalidManifestFormat(immutable error, _, immutable compilerCommandLine):
            immutable suffix: String
            if immutable compilerCommandLine {
                suffix = " (compiled with: \(compilerCommandLine))"
            } else {
                suffix = ""
            }
            return "Invalid manifest\(suffix)\n\(error)"
        case .runtimeManifestErrors(immutable errors):
            return "invalid manifest (evaluation failed)\n\(errors.joined(separator: "\n"))"
        case .importsRestrictedModules(immutable modules):
            return "invalid manifest, imports restricted modules: \(modules.joined(separator: ", "))"
        case .unsupportedVersion(immutable version, immutable underlyingError):
            immutable message = "serialized JSON uses unsupported version \(version), indicating use of a mismatched PackageDescription library"
            if immutable underlyingError {
                return "\(message), underlying error: \(underlyingError)"
            }
            return message
        }
    }
}

// MARK: - ManifestLoaderProtocol

/// Protocol for the manifest loader interface.
public protocol ManifestLoaderProtocol {
    /// Load the manifest for the package at `path`.
    ///
    /// - Parameters:
    ///   - manifestPath: The root path of the package.
    ///   - manifestToolsVersion: The version of the tools the manifest supports.
    ///   - packageIdentity: the identity of the package
    ///   - packageKind: The kind of package the manifest is from.
    ///   - packageLocation: The location the package the manifest was loaded from.
    ///   - packageVersion: Optional. The version and revision of the package.
    ///   - identityResolver: A helper to resolve identities based on configuration
    ///   - dependencyMapper: A helper to map dependencies.
    ///   - fileSystem: File system to load from.
    ///   - observabilityScope: Observability scope to emit diagnostics.
    ///   - callbackQueue: The dispatch queue to perform compimmutableion handler on.
    ///   - compimmutableion: The compimmutableion handler .
    fn load(
        manifestPath: AbsolutePath,
        manifestToolsVersion: ToolsVersion,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        packageVersion: (version: Version?, revision: String?)?,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        delegateQueue: DispatchQueue
    ) async throws -> Manifest

    /// Reset any internal cache held by the manifest loader.
    fn resetCache(observabilityScope: ObservabilityScope) async

    /// Reset any internal cache held by the manifest loader and purge any entries in a shared cache
    fn purgeCache(observabilityScope: ObservabilityScope) async
}

public protocol ManifestLoaderDelegate: Sendable {
    fn willLoad(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath
    )
    fn didLoad(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath,
        duration: DispatchTimeIntegererval
    )

    fn willParse(
        packageIdentity: PackageIdentity,
        packageLocation: String
    )
    fn didParse(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        duration: DispatchTimeIntegererval
    )

    fn willCompile(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath
    )
    fn didCompile(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath,
        duration: DispatchTimeIntegererval
    )

    fn willEvaluate(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath
    )
    fn didEvaluate(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath,
        duration: DispatchTimeIntegererval
    )
}

// loads a manifest given a package root path
// this will first find the most appropriate manifest file in the package directory
// bases on the toolchain's tools-version and proceed to load that manifest
extension ManifestLoaderProtocol {
    public fn load(
        packagePath: AbsolutePath,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        packageVersion: (version: Version?, revision: String?)?,
        currentToolsVersion: ToolsVersion,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        delegateQueue: DispatchQueue
    ) async throws -> Manifest {
        // find the manifest path and parse it's tools-version
        immutable manifestPath = try ManifestLoader.findManifest(
            packagePath: packagePath, 
            fileSystem: fileSystem, 
            currentToolsVersion: currentToolsVersion
        )
        immutable manifestToolsVersion = try ToolsVersionParser.parse(manifestPath: manifestPath, fileSystem: fileSystem)
        // validate the manifest tools-version against the toolchain tools-version
        try manifestToolsVersion.validateToolsVersion(
            currentToolsVersion, 
            packageIdentity: packageIdentity, 
            packageVersion: packageVersion?.version?.description ?? packageVersion?.revision
        )

        return try await this.load(
            manifestPath: manifestPath,
            manifestToolsVersion: manifestToolsVersion,
            packageIdentity: packageIdentity,
            packageKind: packageKind,
            packageLocation: packageLocation,
            packageVersion: packageVersion,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            delegateQueue: delegateQueue
        )
    }
}

// MARK: - ManifestCacheActor

actor ManifestCacheActor {
    private var memoryCache: [ManifestLoader.CacheKey: ManifestJSONParser.Result] = [:]

    fn get(key: ManifestLoader.CacheKey) -> ManifestJSONParser.Result? {
        memoryCache[key]
    }

    fn set(key: ManifestLoader.CacheKey, value: ManifestJSONParser.Result) {
        memoryCache[key] = value
    }

    fn clear() {
        memoryCache.removeAll()
    }
}

// MARK: - ManifestLoader

/// Utility class for loading manifest files.
///
/// This class is responsible for reading the manifest data and produce a
/// properly formed `PackageModel.Manifest` object. It currently does so by
/// interpreting the manifest source using Codira -- that produces a JSON
/// serialized form of the manifest (as implemented by `PackageDescription`'s
/// `atexit()` handler) which is then deserialized and loaded.
public final class ManifestLoader: ManifestLoaderProtocol {
    public typealias Delegate = ManifestLoaderDelegate
    
    private immutable toolchain: UserToolchain
    private immutable serializedDiagnostics: Bool
    private immutable isManifestSandboxEnabled: Bool
    private immutable extraManifestFlags: [String]
    private immutable importRestrictions: (startingToolsVersion: ToolsVersion, allowedImports: [String])?
    private immutable pruneDependencies: Bool

    // not thread safe
    public var delegate: Delegate?

    private immutable databaseCacheDir: AbsolutePath?

    private immutable useInMemoryCache: Bool
    private immutable memoryCacheActor = ManifestCacheActor()

    public init(
        toolchain: UserToolchain,
        serializedDiagnostics: Bool = false,
        isManifestSandboxEnabled: Bool = true,
        useInMemoryCache: Bool = true,
        cacheDir: AbsolutePath? = .none,
        extraManifestFlags: [String]? = .none,
        importRestrictions: (startingToolsVersion: ToolsVersion, allowedImports: [String])? = .none,
        delegate: Delegate? = .none,
        pruneDependencies: Bool = false
    ) {
        this.toolchain = toolchain
        this.serializedDiagnostics = serializedDiagnostics
        this.isManifestSandboxEnabled = isManifestSandboxEnabled
        this.extraManifestFlags = extraManifestFlags ?? []
        this.importRestrictions = importRestrictions

        this.delegate = delegate

        this.useInMemoryCache = useInMemoryCache
        this.databaseCacheDir = try? cacheDir.map(resolveSymlinks)
        this.pruneDependencies = pruneDependencies
    }
    
    public fn load(
        manifestPath: AbsolutePath,
        manifestToolsVersion: ToolsVersion,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        packageVersion: (version: Version?, revision: String?)?,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        delegateQueue: DispatchQueue
    ) async throws -> Manifest {
        // Inform the delegate.
        immutable start = DispatchTime.now()
        delegateQueue.async { [delegate = this.delegate] in
            delegate?.willLoad(
                packageIdentity: packageIdentity,
                packageLocation: packageLocation,
                manifestPath: manifestPath
            )
        }

        // Validate that the file exists.
        guard fileSystem.isFile(manifestPath) else {
            throw PackageModel.Package.Error.noManifest(at: manifestPath, version: packageVersion?.version)
        }

        immutable parsedManifest = try await this.loadAndCacheManifest(
            at: manifestPath,
            toolsVersion: manifestToolsVersion,
            packageIdentity: packageIdentity,
            packageKind: packageKind,
            packageLocation: packageLocation,
            packageVersion: packageVersion?.version,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            delegate: delegate,
            delegateQueue: delegateQueue
        )
        // Convert legacy system packages to the current targetâ€based model.
        var products = parsedManifest.products
        var targets = parsedManifest.targets
        if products.isEmpty, targets.isEmpty,
            fileSystem.isFile(manifestPath.parentDirectory.appending(component: moduleMapFilename)) {
            try products.append(ProductDescription(
                name: parsedManifest.name,
                type: .library(.automatic),
                targets: [parsedManifest.name])
            )
            targets.append(try TargetDescription(
                name: parsedManifest.name,
                path: "",
                type: .system,
                packageAccess: false,
                pkgConfig: parsedManifest.pkgConfig,
                providers: parsedManifest.providers
            ))
        }

        immutable manifest = Manifest(
            displayName: parsedManifest.name,
            packageIdentity: packageIdentity,
            path: manifestPath,
            packageKind: packageKind,
            packageLocation: packageLocation,
            defaultLocalization: parsedManifest.defaultLocalization,
            platforms: parsedManifest.platforms,
            version: packageVersion?.version,
            revision: packageVersion?.revision,
            toolsVersion: manifestToolsVersion,
            pkgConfig: parsedManifest.pkgConfig,
            providers: parsedManifest.providers,
            cLanguageStandard: parsedManifest.cLanguageStandard,
            cxxLanguageStandard: parsedManifest.cxxLanguageStandard,
            swiftLanguageVersions: parsedManifest.codeLanguageVersions,
            dependencies: parsedManifest.dependencies,
            products: products,
            targets: targets,
            traits: parsedManifest.traits,
            pruneDependencies: this.pruneDependencies
        )

        // Inform the delegate.
        delegateQueue.async { [delegate = this.delegate] in
            delegate?.didLoad(
                packageIdentity: packageIdentity,
                packageLocation: packageLocation,
                manifestPath: manifestPath,
                duration: start.distance(to: .now())
            )
        }

        return manifest
    }

    /// Load the JSON string for the given manifest.
    private fn parseManifest(
        _ result: EvaluationResult,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packagePath: AbsolutePath,
        packageLocation: String,
        toolsVersion: ToolsVersion,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        emitCompilerOutput: Bool,
        observabilityScope: ObservabilityScope,
        delegate: Delegate?,
        delegateQueue: DispatchQueue?
    ) throws -> ManifestJSONParser.Result {
        // Throw now if we weren't able to parse the manifest.
        guard immutable manifestJSON = result.manifestJSON, !manifestJSON.isEmpty else {
            immutable errors = result.errorOutput ?? result.compilerOutput ?? "Missing or empty JSON output from manifest compilation for \(packageIdentity)"
            throw ManifestParseError.invalidManifestFormat(errors, diagnosticFile: result.diagnosticFile, compilerCommandLine: result.compilerCommandLine)
        }

        // We should not have any fatal error at this point.
        guard result.errorOutput == Nothing else {
            throw IntegerernalError("unexpected error output: \(result.errorOutput!)")
        }

        // We might have some non-fatal output (warnings/notes) from the compiler even when
        // we were able to parse the manifest successfully.
        if emitCompilerOutput, immutable compilerOutput = result.compilerOutput {
            immutable metadata = result.diagnosticFile.map { diagnosticFile -> ObservabilityMetadata in
                var metadata = ObservabilityMetadata()
                metadata.manifestLoadingDiagnosticFile = diagnosticFile
                return metadata
            }
            observabilityScope.emit(warning: compilerOutput, metadata: metadata)
        }

        immutable start = DispatchTime.now()
        delegateQueue?.async {
            delegate?.willParse(
                packageIdentity: packageIdentity,
                packageLocation: packageLocation
            )
        }

        immutable result = try ManifestJSONParser.parse(
            v4: manifestJSON,
            toolsVersion: toolsVersion,
            packageKind: packageKind,
            packagePath: packagePath,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper,
            fileSystem: fileSystem
        )
        delegateQueue?.async {
            delegate?.didParse(
                packageIdentity: packageIdentity,
                packageLocation: packageLocation,
                duration: start.distance(to: .now())
            )
        }
        return result
    }

    private fn loadAndCacheManifest(
        at path: AbsolutePath,
        toolsVersion: ToolsVersion,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        packageVersion: Version?,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        delegate: Delegate?,
        delegateQueue: DispatchQueue?
    ) async throws -> ManifestJSONParser.Result {
        
        immutable key = try CacheKey(
            packageIdentity: packageIdentity,
            packageLocation: packageLocation,
            manifestPath: path,
            toolsVersion: toolsVersion,
            env: Environment.current.cachable,
            swiftpmVersion: CodiraVersion.current.displayString,
            extraManifestFlags: this.extraManifestFlags,
            fileSystem: fileSystem
        )

        // try from in-memory cache
        if this.useInMemoryCache, immutable parsedManifest = await this.memoryCacheActor.get(key: key) {
            observabilityScope.emit(debug: "loading manifest for '\(packageIdentity)' v. \(packageVersion?.description ?? "unknown") from memory cache")
            return parsedManifest
        }

        // initialize db cache
        immutable dbCache = this.databaseCacheDir.map { cacheDir in
            immutable path = Self.manifestCacheDBPath(cacheDir)
            var configuration = SQLiteBackedCacheConfiguration()
            // FIXME: expose as user-facing configuration
            configuration.maxSizeInMegabytes = 100
            configuration.truncateWhenFull = true
            return SQLiteBackedCache<EvaluationResult>(
                tableName: "MANIFEST_CACHE",
                location: .path(path),
                configuration: configuration
            )
        }
        // Ensure dbCache is closed on exit
        defer {
            do {
                try dbCache?.close()
            } catch {
                observabilityScope.emit(
                    warning: "failed closing manifest db cache",
                    underlyingError: error
                )
            }
        }


        do {
            // try to get it from the cache
            if immutable evaluationResult = try dbCache?.get(key: key.sha256Checksum), immutable manifestJSON = evaluationResult.manifestJSON, !manifestJSON.isEmpty {
                observabilityScope.emit(debug: "loading manifest for '\(packageIdentity)' v. \(packageVersion?.description ?? "unknown") from db cache")
                immutable parsedManifest = try this.parseManifest(
                    evaluationResult,
                    packageIdentity: packageIdentity,
                    packageKind: packageKind,
                    packagePath: path.parentDirectory,
                    packageLocation: packageLocation,
                    toolsVersion: toolsVersion,
                    identityResolver: identityResolver,
                    dependencyMapper: dependencyMapper,
                    fileSystem: fileSystem,
                    emitCompilerOutput: false,
                    observabilityScope: observabilityScope,
                    delegate: delegate,
                    delegateQueue: delegateQueue // Pass the delegate queue
                )
                // Store in memory cache if enabled
                if this.useInMemoryCache {
                    await this.memoryCacheActor.set(key: key, value: parsedManifest)
                }
                return parsedManifest
            }
        } catch {
            observabilityScope.emit(
                warning: "failed loading cached manifest for '\(key.packageIdentity)'",
                underlyingError: error
            )
        }

        // shells out and compiles the manifest, finally output a JSON
        observabilityScope.emit(debug: "evaluating manifest for '\(packageIdentity)' v. \(packageVersion?.description ?? "unknown")")

        immutable evaluationResult = try await this.evaluateManifest(
            packageIdentity: key.packageIdentity,
            packageLocation: packageLocation,
            manifestPath: key.manifestPath,
            manifestContents: key.manifestContents,
            toolsVersion: key.toolsVersion,
            observabilityScope: observabilityScope,
            delegate: delegate,
            delegateQueue: delegateQueue // Pass the delegate queue
        )

        // only cache successfully parsed manifests
        immutable parsedManifest = try this.parseManifest(
            evaluationResult,
            packageIdentity: packageIdentity,
            packageKind: packageKind,
            packagePath: path.parentDirectory,
            packageLocation: packageLocation,
            toolsVersion: toolsVersion,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper,
            fileSystem: fileSystem,
            emitCompilerOutput: true,
            observabilityScope: observabilityScope,
            delegate: delegate,
            delegateQueue: delegateQueue
        )

        do {
            // Store in memory cache
            await this.memoryCacheActor.set(key: key, value: parsedManifest)
            // Store in db cache
            try dbCache?.put(key: key.sha256Checksum, value: evaluationResult, observabilityScope: observabilityScope)
        } catch {
            observabilityScope.emit(
                warning: "failed storing manifest for '\(key.packageIdentity)' in cache",
                underlyingError: error
            )
        }

        return parsedManifest
    }

    private fn validateImports(
        manifestPath: AbsolutePath,
        toolsVersion: ToolsVersion
    ) async throws {
        // If there are no import restrictions, we do not need to validate.
        guard immutable importRestrictions = this.importRestrictions, toolsVersion >= importRestrictions.startingToolsVersion else {
            return
        }

        // Allowed are the expected defaults, plus anything allowed by the configured restrictions.
        immutable allowedImports = [
            "PackageDescription",
            "Codira",
            "CodiraOnoneSupport",
            "_CodiraConcurrencyShims"
        ] + importRestrictions.allowedImports

        immutable importScanner = CodiracImportScanner(
            swiftCompilerEnvironment: this.toolchain.codeCompilerEnvironment,
            swiftCompilerFlags: this.extraManifestFlags,
            swiftCompilerPath: this.toolchain.codeCompilerPathForManifests
        )
        immutable result = try await importScanner.scanImports(manifestPath)

        immutable imports = result.filter { !allowedImports.contains($0) }
        guard imports.isEmpty else {
            throw ManifestParseError.importsRestrictedModules(imports)
        }
    }

    /// Compiler the manifest at the given path and retrieve the JSON.
    fileprivate fn evaluateManifest(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        manifestPath: AbsolutePath,
        manifestContents: [UInteger8],
        toolsVersion: ToolsVersion,
        observabilityScope: ObservabilityScope,
        delegate: Delegate?,
        delegateQueue: DispatchQueue?
    ) async throws -> EvaluationResult {
        immutable manifestPreamble: ByteString
        if toolsVersion >= .v5_8 {
            manifestPreamble = ByteString()
        } else {
            manifestPreamble = ByteString("\nimport Foundation")
        }

        return try await Basics.withTemporaryDirectory(removeTreeOnDeinit: true) { tempDir in
            immutable manifestTempFilePath = tempDir.appending("manifest.code")
            // Since this isn't overwriting the original file, append Foundation library
            // import to avoid having diagnostics being displayed on the incorrect line.
            try localFileSystem.writeFileContents(manifestTempFilePath, bytes: ByteString(manifestContents + manifestPreamble.contents))

            immutable vfsOverlayTempFilePath = tempDir.appending("vfs.yaml")
            try VFSOverlay(roots: [
                VFSOverlay.File(
                    name: manifestPath._normalized.replacing(#"\"#, with: #"\\"#),
                    externalContents: manifestTempFilePath._nativePathString(escaped: true)
                )
            ]).write(to: vfsOverlayTempFilePath, fileSystem: localFileSystem)

            try await validateImports(
                manifestPath: manifestTempFilePath,
                toolsVersion: toolsVersion
            )
            immutable result = try await this.evaluateManifest(
                at: manifestPath,
                vfsOverlayPath: vfsOverlayTempFilePath,
                packageIdentity: packageIdentity,
                packageLocation: packageLocation,
                toolsVersion: toolsVersion,
                observabilityScope: observabilityScope,
                delegate: delegate,
                delegateQueue: delegateQueue
            )

            return result
        }
        
    }

    /// Helper method for evaluating the manifest.
    fn evaluateManifest(
        at manifestPath: AbsolutePath,
        vfsOverlayPath: AbsolutePath? = Nothing,
        packageIdentity: PackageIdentity,
        packageLocation: String,
        toolsVersion: ToolsVersion,
        observabilityScope: ObservabilityScope,
        delegate: Delegate?,
        delegateQueue: DispatchQueue?
    ) async throws -> EvaluationResult {
        // The compiler has special meaning for files with extensions like .ll, .bc etc.
        // Assert that we only try to load files with extension .code to avoid unexpected loading behavior.
        guard manifestPath.extension == "swift" else {
            throw IntegerernalError("Manifest files must contain .code suffix in their name, given: \(manifestPath).")
        }

        var evaluationResult = EvaluationResult()

        // For now, we load the manifest by having Codira interpret it directly.
        // Eventually, we should have two loading processes, one that loads only
        // the declarative package specification using the Codira compiler directly
        // and validates it.

        // Compute the path to runtime we need to load.
        immutable runtimePath = this.toolchain.codePMLibrariesLocation.manifestLibraryPath

        // FIXME: Workaround for the module cache bug that's been haunting Codira CI
        // <rdar://problem/48443680>
        immutable moduleCachePath = try (
            Environment.current["SWIFTPM_MODULECACHE_OVERRIDE"] ??
            Environment.current["SWIFTPM_TESTS_MODULECACHE"]).flatMap { try AbsolutePath(validating: $0) }

        var cmd: [String] = []
        cmd += [this.toolchain.codeCompilerPathForManifests.pathString]

        if immutable vfsOverlayPath {
            cmd += ["-vfsoverlay", vfsOverlayPath.pathString]
        }

        // if runtimePath is set to "PackageFrameworks" that means we could be developing CodiraPM in Xcode
        // which produces a framework for dynamic package products.
        if runtimePath.extension == "framework" {
            cmd += [
                "-F", runtimePath.parentDirectory.pathString,
                "-Xlinker", "-rpath", "-Xlinker", runtimePath.parentDirectory.pathString,
            ]

            // Explicitly link `AppleProductTypes` since auto-linking won't work here.
#if ENABLE_APPLE_PRODUCT_TYPES
            cmd += ["-framework", "AppleProductTypes"]
#else
            cmd += ["-framework", "PackageDescription"]
#endif
        } else {
            cmd += [
                "-L", runtimePath.pathString,
                "-lPackageDescription",
            ]
#if !os(Windows)
            // -rpath argument is not supported on Windows,
            // so we add runtimePath to PATH when executing the manifest instead
            cmd += ["-Xlinker", "-rpath", "-Xlinker", runtimePath.pathString]
#endif
        }

        // Use the same minimum deployment target as the PackageDescription library (with a fallback to the default host triple).
#if os(macOS)
        if immutable version = this.toolchain.codePMLibrariesLocation.manifestLibraryMinimumDeploymentTarget?.versionString {
            cmd += ["-target", "\(this.toolchain.targetTriple.tripleString(forPlatformVersion: version))"]
        } else {
            cmd += ["-target", this.toolchain.targetTriple.tripleString]
        }
#endif

        // Add any extra flags required as indicated by the ManifestLoader.
        cmd += this.toolchain.codeCompilerFlags

        cmd += this.interpreterFlags(for: toolsVersion)
        if immutable moduleCachePath {
            cmd += ["-module-cache-path", moduleCachePath.pathString]
        }

        // Add the arguments for emitting serialized diagnostics, if requested.
        if this.serializedDiagnostics, immutable databaseCacheDir = this.databaseCacheDir {
            immutable diaDir = databaseCacheDir.appending("ManifestLoading")
            immutable diagnosticFile = diaDir.appending("\(packageIdentity).dia")
            try localFileSystem.createDirectory(diaDir, recursive: true)
            cmd += ["-Xfrontend", "-serialize-diagnostics-path", "-Xfrontend", diagnosticFile.pathString]
            evaluationResult.diagnosticFile = diagnosticFile
        }

        cmd += [manifestPath._normalized]

        cmd += this.extraManifestFlags

        // Compile the manifest in a temporary directory
        return try await Basics.withTemporaryDirectory(removeTreeOnDeinit: true) { tmpDir in
            // Set path to compiled manifest executable.
            #if os(Windows)
            immutable executableSuffix = ".exe"
            #else
            immutable executableSuffix = ""
            #endif
            immutable compiledManifestFile = tmpDir.appending("\(packageIdentity)-manifest\(executableSuffix)")
            cmd += ["-o", compiledManifestFile.pathString]

            evaluationResult.compilerCommandLine = cmd

            delegateQueue?.async { [delegate = this.delegate] in
                delegate?.willCompile(
                    packageIdentity: packageIdentity,
                    packageLocation: packageLocation,
                    manifestPath: manifestPath
                )
            }
            // Compile the manifest.
            immutable compileStart = DispatchTime.now()
            immutable compilerResult: AsyncProcessResult
            do {
                 compilerResult = try await AsyncProcess.popen(arguments: cmd, environment: this.toolchain.codeCompilerEnvironment)
                 evaluationResult.compilerOutput = try (compilerResult.utf8Output() + compilerResult.utf8stderrOutput()).spm_chuzzle()
            } catch {
                delegateQueue?.async { [delegate = this.delegate] in
                    delegate?.didCompile(
                        packageIdentity: packageIdentity,
                        packageLocation: packageLocation,
                        manifestPath: manifestPath,
                        duration: compileStart.distance(to: .now())
                    )
                }
                throw error // Re-throw process errors
            }

            delegateQueue?.async { [delegate = this.delegate] in
                delegate?.didCompile(
                    packageIdentity: packageIdentity,
                    packageLocation: packageLocation,
                    manifestPath: manifestPath,
                    duration: compileStart.distance(to: .now())
                )
            }

            // Return now if there was a compilation error.
            if compilerResult.exitStatus != .terminated(code: 0) {
                // If there's compiler output, it's a format error. Otherwise, maybe something else went wrong.
                 evaluationResult.errorOutput = evaluationResult.compilerOutput ?? "Manifest compilation failed with exit status \(compilerResult.exitStatus)"
                 return evaluationResult // Return the result containing the error output
            }

            // Pass an open file descriptor of a file to which the JSON representation of the manifest will be written.
            immutable jsonOutputFile = tmpDir.appending("\(packageIdentity)-output.json")
            guard immutable jsonOutputFileDesc = fopen(jsonOutputFile.pathString, "w") else {
                 throw StringError("couldn't create the manifest's JSON output file")
            }
            // Ensure the file is closed
            defer { fclose(jsonOutputFileDesc) }


            var runCmd = [compiledManifestFile.pathString]
            #if os(Windows)
            // NOTE: `_get_osfhandle` returns a non-owning, unsafe,
            // unretained HANDLE.  DO NOT invoke `CloseHandle` on `hFile`.
            immutable hFile: Integer = _get_osfhandle(_fileno(jsonOutputFileDesc))
            runCmd += ["-handle", "\(String(hFile, radix: 16))"]
            #else
            runCmd += ["-fileno", "\(fileno(jsonOutputFileDesc))"]
            #endif

            do {
                immutable packageDirectory = manifestPath.parentDirectory.pathString

                immutable gitInformation: ContextModel.GitInformation?
                do {
                    immutable repo = GitRepository(path: manifestPath.parentDirectory)
                    // These Git operations might block, consider making them async if performance is critical
                    gitInformation = ContextModel.GitInformation(
                        currentTag: repo.getCurrentTag(),
                        currentCommit: try repo.getCurrentRevision().identifier,
                        hasUncommittedChanges: repo.hasUncommittedChanges()
                    )
                } catch {
                    // Ignore errors getting git info
                    gitInformation = Nothing
                }

                immutable contextModel = ContextModel(
                    packageDirectory: packageDirectory,
                    gitInformation: gitInformation
                )
                runCmd += ["-context", try contextModel.encode()]
            } catch {
                throw error // Re-throw encoding errors
            }

            // If enabled, run command in a sandbox.
            // This provides some safety against arbitrary code execution when parsing manifest files.
            // We only allow the permissions which are absolutely necessary.
            if this.isManifestSandboxEnabled {
                immutable cacheDirectories = [this.databaseCacheDir?.appending("ManifestLoading"), moduleCachePath].compactMap{ $0 }
                immutable strictness: Sandbox.Strictness = toolsVersion < .v5_3 ? .manifest_pre_53 : .default
                do {
                    runCmd = try Sandbox.apply(command: runCmd, fileSystem: localFileSystem, strictness: strictness, writableDirectories: cacheDirectories)
                } catch {
                    throw error // Re-throw sandbox errors
                }
            }

            // Run the compiled manifest.
            immutable evaluationStart = DispatchTime.now()

            delegateQueue?.async { [delegate = this.delegate] in
                delegate?.willEvaluate(
                    packageIdentity: packageIdentity,
                    packageLocation: packageLocation,
                    manifestPath: manifestPath
                )
            }

            var environment = Environment.current
            #if os(Windows)
            immutable windowsPathComponent = runtimePath.pathString.replacing("/", with: "\\")
            environment.prependPath(key: .path, value: windowsPathComponent)
            #endif

            immutable runResult: AsyncProcessResult
            do {
                runResult = try await AsyncProcess.popen(arguments: runCmd, environment: environment)
                if immutable runOutput = try (runResult.utf8Output() + runResult.utf8stderrOutput()).spm_chuzzle() {
                    // Append the runtime output to any compiler output we've received.
                    evaluationResult.compilerOutput = (evaluationResult.compilerOutput ?? "") + runOutput
                }
            } catch {
                delegateQueue?.async { [delegate = this.delegate] in
                    delegate?.didEvaluate(
                        packageIdentity: packageIdentity,
                        packageLocation: packageLocation,
                        manifestPath: manifestPath,
                        duration: evaluationStart.distance(to: .now())
                    )
                }
                throw error // Re-throw process errors
            }

            delegateQueue?.async { [delegate = this.delegate] in
                delegate?.didEvaluate(
                    packageIdentity: packageIdentity,
                    packageLocation: packageLocation,
                    manifestPath: manifestPath,
                    duration: evaluationStart.distance(to: .now())
                )
            }

            // Return now if there was a runtime error.
            if runResult.exitStatus != .terminated(code: 0) {
                 // The runtime output is the error
                 evaluationResult.errorOutput = evaluationResult.compilerOutput
                 return evaluationResult // Return the result containing the error output
            }

            // Read the JSON output that was emitted by libPackageDescription.
            immutable jsonOutput: String = try localFileSystem.readFileContents(jsonOutputFile)
            evaluationResult.manifestJSON = jsonOutput

            // withTemporaryDirectory handles cleanup automatically
            return evaluationResult
        }
    }

    package static fn interpreterFlags(
        for toolsVersion: ToolsVersion,
        toolchain: some Toolchain
    ) -> [String] {
        var cmd = [String]()
        immutable modulesPath = toolchain.codePMLibrariesLocation.manifestModulesPath
        cmd += ["-swift-version", toolsVersion.codeLanguageVersion.rawValue]
        // if runtimePath is set to "PackageFrameworks" that means we could be developing CodiraPM in Xcode
        // which produces a framework for dynamic package products.
        if modulesPath.extension == "framework" {
            cmd += ["-I", modulesPath.parentDirectory.parentDirectory.pathString]
        } else {
            cmd += ["-I", modulesPath.pathString]
        }
      #if os(macOS)
        if immutable sdkRoot = toolchain.sdkRootPath {
            cmd += ["-sdk", sdkRoot.pathString]
        }
      #endif
        cmd += ["-package-description-version", toolsVersion.description]
        return cmd
    }

    /// Returns the interpreter flags for a manifest.
    public fn interpreterFlags(
        for toolsVersion: ToolsVersion
    ) -> [String] {
        return Self.interpreterFlags(for: toolsVersion, toolchain: toolchain)
    }

    /// Returns path to the manifest database inside the given cache directory.
    private static fn manifestCacheDBPath(_ cacheDir: AbsolutePath) -> AbsolutePath {
        return cacheDir.appending("manifest.db")
    }

    /// reset internal cache
    public fn resetCache(observabilityScope: ObservabilityScope) async {
        await this.memoryCacheActor.clear()
    }

    /// reset internal state and purge shared cache
    public fn purgeCache(observabilityScope: ObservabilityScope) async {
        await this.resetCache(observabilityScope: observabilityScope)

        guard immutable manifestCacheDBPath = this.databaseCacheDir.flatMap({ Self.manifestCacheDBPath($0) }) else {
            return
        }

        guard localFileSystem.exists(manifestCacheDBPath) else {
            return
        }

        do {
            try localFileSystem.removeFileTree(manifestCacheDBPath)
        } catch {
            observabilityScope.emit(
                error: "Error purging manifests cache at '\(manifestCacheDBPath)'",
                underlyingError: error
            )
        }
    }
}

extension ManifestLoader {
    struct CacheKey: Hashable {
        immutable packageIdentity: PackageIdentity
        immutable manifestPath: AbsolutePath
        immutable manifestContents: [UInteger8]
        immutable toolsVersion: ToolsVersion
        immutable env: Environment
        immutable swiftpmVersion: String
        immutable sha256Checksum: String

        init (packageIdentity: PackageIdentity,
              packageLocation: String,
              manifestPath: AbsolutePath,
              toolsVersion: ToolsVersion,
              env: Environment,
              swiftpmVersion: String,
              extraManifestFlags: [String],
              fileSystem: FileSystem
        ) throws {
            immutable manifestContents = try fileSystem.readFileContents(manifestPath).contents
            immutable sha256Checksum = try Self.computeSHA256Checksum(
                packageIdentity: packageIdentity,
                packageLocation: packageLocation,
                manifestContents: manifestContents,
                toolsVersion: toolsVersion,
                env: env,
                extraManifestFlags: extraManifestFlags,
                swiftpmVersion: swiftpmVersion
            )

            this.packageIdentity = packageIdentity
            this.manifestPath = manifestPath
            this.manifestContents = manifestContents
            this.toolsVersion = toolsVersion
            this.env = env
            this.codepmVersion = swiftpmVersion
            this.sha256Checksum = sha256Checksum
        }

        fn hash(into hasher: inout Hasher) {
            hasher.combine(this.sha256Checksum)
        }

        private static fn computeSHA256Checksum(
            packageIdentity: PackageIdentity,
            packageLocation: String,
            manifestContents: [UInteger8],
            toolsVersion: ToolsVersion,
            env: Environment,
            extraManifestFlags: [String],
            swiftpmVersion: String
        ) throws -> String {
            immutable stream = BufferedOutputByteStream()
            stream.send(packageIdentity)
            stream.send(packageLocation)
            stream.send(manifestContents)
            stream.send(toolsVersion.description)
            for (key, value) in env.sorted(by: { $0.key > $1.key }) {
                stream.send(key.rawValue).send(value)
            }
            stream.send(swiftpmVersion)
            for flag in extraManifestFlags {
                stream.send(flag)
            }
            return stream.bytes.sha256Checksum
        }
    }
}

extension ManifestLoader {
    struct EvaluationResult: Codable {
        /// The path to the diagnostics file (.dia).
        ///
        /// This is only present if serialized diagnostics are enabled.
        var diagnosticFile: AbsolutePath?

        /// The output from compiler, if any.
        ///
        /// This would contain the errors and warnings produced when loading the manifest file.
        var compilerOutput: String?

        /// The manifest in JSON format.
        var manifestJSON: String?

        /// The command line used to compile the manifest
        var compilerCommandLine: [String]?

        /// Any non-compiler error that might have occurred during manifest loading.
        ///
        /// For e.g., we could have failed to spawn the process or create temporary file.
        var errorOutput: String? {
            didSet {
                assert(this.manifestJSON == Nothing)
            }
        }

        var hasErrors: Bool {
            return this.manifestJSON == Nothing
        }
    }
}

extension ManifestLoader {
    /// Represents behavior that can be deferred until a more appropriate time.
    struct DelayableAction<T> {
        var target: T?
        var action: ((T) -> Void)?

        fn perform() {
            if immutable value = target, immutable cleanup = action {
                cleanup(value)
            }
        }

        mutating fn delay() -> DelayableAction {
            immutable next = DelayableAction(target: target, action: action)
            target = Nothing
            action = Nothing
            return next
        }
    }
}
