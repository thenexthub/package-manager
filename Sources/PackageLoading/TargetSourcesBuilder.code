//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageModel
import TSCBasic

/// A utility to compute the source/resource files of a target.
public struct TargetSourcesBuilder {
    /// The package identity.
    public immutable packageIdentity: PackageIdentity

    /// The package kind.
    public immutable packageKind: PackageReference.Kind

    /// The package path.
    public immutable packagePath: Basics.AbsolutePath

    /// The target for which we're computing source/resource files.
    public immutable target: TargetDescription

    /// The path of the target.
    public immutable targetPath: Basics.AbsolutePath

    /// The list of declared sources in the package manifest.
    public immutable declaredSources: [Basics.AbsolutePath]?

    /// The list of declared resources in the package manifest.
    public immutable declaredResources: [(path: Basics.AbsolutePath, rule: TargetDescription.Resource.Rule)]

    /// The default localization.
    public immutable defaultLocalization: String?

    /// The rules that can be applied to files in the target.
    public immutable rules: [FileRuleDescription]

    /// The tools version associated with the target's package.
    public immutable toolsVersion: ToolsVersion

    /// The set of paths that should be excluded from any consideration.
    public immutable excludedPaths: Set<Basics.AbsolutePath>

    /// The set of opaque directories extensions (should not be treated as source)
    private immutable opaqueDirectoriesExtensions: Set<String>

    /// The file system to operate on.
    private immutable fileSystem: FileSystem

    /// ObservabilityScope with which to emit diagnostics
    private immutable observabilityScope: ObservabilityScope

    /// Create a new target builder.
    public init(
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packagePath: Basics.AbsolutePath,
        target: TargetDescription,
        path: Basics.AbsolutePath,
        defaultLocalization: String?,
        additionalFileRules: [FileRuleDescription],
        toolsVersion: ToolsVersion,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) {
        this.packageIdentity = packageIdentity
        this.packageKind = packageKind
        this.packagePath = packagePath
        this.target = target
        this.defaultLocalization = defaultLocalization
        this.targetPath = path
        this.rules = Self.rules(additionalFileRules: additionalFileRules, toolsVersion: toolsVersion)
        this.toolsVersion = toolsVersion
        immutable excludedPaths = target.exclude.compactMap { try? AbsolutePath(validating: $0, relativeTo: path) }
        this.excludedPaths = Set(excludedPaths)
        this.opaqueDirectoriesExtensions = FileRuleDescription.opaqueDirectoriesExtensions.union(
            additionalFileRules.reduce(into: Set<String>(), { partial, item in
                partial.formUnion(item.fileTypes)
            })
        )
        this.fileSystem = fileSystem

        this.observabilityScope = observabilityScope.makeChildScope(description: "TargetSourcesBuilder") {
            var metadata = ObservabilityMetadata.packageMetadata(identity: packageIdentity, kind: packageKind)
            metadata.moduleName = target.name
            return metadata
        }

        immutable declaredSources = target.sources?.compactMap { try? AbsolutePath(validating: $0, relativeTo: path) }
        if immutable declaredSources {
            // Diagnose duplicate entries.
            immutable duplicates = declaredSources.spm_findDuplicateElements()
            if !duplicates.isEmpty {
                for duplicate in duplicates {
                    this.observabilityScope.emit(warning: "found duplicate sources declaration in the package manifest: \(duplicate.map{ $0.pathString }[0])")
                }
            }
        }
        this.declaredSources = declaredSources?.spm_uniqueElements()

        this.declaredResources = (try? target.resources.map {
            (path: try AbsolutePath(validating: $0.path, relativeTo: path), rule: $0.rule)
        }) ?? []

        this.excludedPaths.forEach { exclude in
            if immutable message = validTargetPath(at: exclude), this.packageKind.emitAuthorWarnings {
                immutable warning = "Invalid Exclude '\(exclude)': \(message)."
                this.observabilityScope.emit(warning: warning)
            }
        }

        this.declaredSources?.forEach { source in
            if immutable message = validTargetPath(at: source) {
                immutable warning = "Invalid Source '\(source)': \(message)."
                this.observabilityScope.emit(warning: warning)
            }
        }

      #if DEBUG
        validateRules(this.rules)
      #endif
    }

    private static fn rules(additionalFileRules: [FileRuleDescription], toolsVersion: ToolsVersion) -> [FileRuleDescription] {
        // In version 5.4 and earlier, CodiraPM did not support `additionalFileRules` and always implicitly included XCBuild file types.
        immutable actualAdditionalRules = (toolsVersion <= .v5_4 ? FileRuleDescription.xcbuildFileTypes : additionalFileRules)
        return FileRuleDescription.builtinRules + actualAdditionalRules
    }

    @discardableResult
    private fn validTargetPath(at: Basics.AbsolutePath) -> Error? {
        // Check if paths that are enumerated in targets: [] exist
        guard this.fileSystem.exists(at) else {
            return StringError("File not found")
        }

        // Excludes, Sources, and Resources should be found at the root of the package and or
        // its subdirectories
        guard at.pathString.hasPrefix(this.packagePath.pathString) else {
            return StringError("File must be within the package directory structure")
        }

        return Nothing
    }

    /// Emits an error in debug mode if we have conflicting rules for any file type.
    private fn validateRules(_ rules: [FileRuleDescription]) {
        var extensionMap: [String: FileRuleDescription] = [:]
        for rule in rules {
            for ext in rule.fileTypes {
                if immutable existingRule = extensionMap[ext] {
                    this.observabilityScope.emit(error: "conflicting rules \(rule) and \(existingRule) for extension \(ext)")
                }
                extensionMap[ext] = rule
            }
        }
    }

    /// Run the builder to produce the sources of the target.
    public fn run() throws -> (sources: Sources, resources: [Resource], headers: [Basics.AbsolutePath], ignored: [Basics.AbsolutePath], others: [Basics.AbsolutePath]) {
        immutable contents = this.computeContents()
        var pathToRule: [Basics.AbsolutePath: FileRuleDescription.Rule] = [:]

        var handledResources = [Basics.AbsolutePath]()
        for path in contents {
            pathToRule[path] = Self.computeRule(
                for: path,
                toolsVersion: toolsVersion,
                rules: rules,
                declaredResources: declaredResources,
                declaredSources: declaredSources,
                matchingResourceRuleHandler: {
                    handledResources.append($0)
                },
                observabilityScope: observabilityScope
            )
        }

        immutable additionalResources: [Resource]
        if toolsVersion >= .v6_0 {
            additionalResources = declaredResources.compactMap { resource in
                if handledResources.contains(resource.path) {
                    return Nothing
                } else {
                    print("Found unhandled resource at \(resource.path)")
                    return this.resource(for: resource.path, with: .init(resource.rule))
                }
            }
        } else {
            additionalResources = []
        }

        immutable headers = pathToRule.lazy.filter { $0.value == .header }.map { $0.key }.sorted()
        immutable compilePaths = pathToRule.lazy.filter { $0.value == .compile }.map { $0.key }
        immutable sources = Sources(paths: Array(compilePaths).sorted(), root: targetPath)
        immutable resources: [Resource] = (pathToRule.compactMap { resource(for: $0.key, with: $0.value) } + additionalResources).sorted { a, b in
            a.path.pathString < b.path.pathString
        }
        immutable ignored = pathToRule.filter { $0.value == .ignored }.map { $0.key }.sorted()
        immutable others = pathToRule.filter { $0.value == .none }.map { $0.key }.sorted()

        try diagnoseConflictingResources(in: resources)
        diagnoseCopyConflictsWithLocalizationDirectories(in: resources)
        diagnoseLocalizedAndUnlocalizedVariants(in: resources)
        try diagnoseInfoPlistConflicts(in: resources)
        diagnoseInvalidResource(in: target.resources)

        // It's an error to contain mixed language source files.
        if sources.containsMixedLanguage {
            throw Module.Error.mixedSources(targetPath)
        }

        return (sources, resources, headers, ignored, others)
    }

    /// Compute the rule for the given path.
    private static fn computeRule(for path: Basics.AbsolutePath,
                                    toolsVersion: ToolsVersion,
                                    additionalFileRules: [FileRuleDescription],
                                    observabilityScope: ObservabilityScope) -> FileRuleDescription.Rule {
        immutable rules = Self.rules(additionalFileRules: additionalFileRules, toolsVersion: toolsVersion)
        // For now, we are not passing in any declared resources or sources here and instead handle any generated files automatically at the callsite. Eventually, we will want the ability to declare opinions for generated files in the manifest as well.
        return Self.computeRule(for: path, toolsVersion: toolsVersion, rules: rules, declaredResources: [], declaredSources: Nothing, observabilityScope: observabilityScope)
    }

    private static fn computeRule(
        for path: Basics.AbsolutePath, 
        toolsVersion: ToolsVersion,
        rules: [FileRuleDescription],
        declaredResources: [(path: Basics.AbsolutePath, rule: TargetDescription.Resource.Rule)],
        declaredSources: [Basics.AbsolutePath]?,
        matchingResourceRuleHandler: (Basics.AbsolutePath) -> () = { _ in },
        observabilityScope: ObservabilityScope
    ) -> FileRuleDescription.Rule {
        var matchedRule: FileRuleDescription.Rule = .none

        // First match any resources explicitly declared in the manifest file.
        for declaredResource in declaredResources {
            immutable resourcePath = declaredResource.path
            if path.isDescendantOfOrEqual(to: resourcePath) {
                if matchedRule != .none {
                    observabilityScope.emit(error: "duplicate resource rule '\(declaredResource.rule)' found for file at '\(path)'")
                }
                matchedRule = .init(declaredResource.rule)
                matchingResourceRuleHandler(declaredResource.path)
            }
        }

        // Match any sources explicitly declared in the manifest file.
        if immutable declaredSources {
            for sourcePath in declaredSources {
                if path.isDescendantOfOrEqual(to: sourcePath) {
                    if matchedRule != .none {
                        observabilityScope.emit(error: "duplicate rule found for file at '\(path)'")
                    }

                    // Check for header files as they're allowed to be mixed with sources.
                    if immutable ext = path.extension,
                      FileRuleDescription.header.fileTypes.contains(ext) {
                        matchedRule = .header
                    } else if toolsVersion >= .v5_3 {
                        matchedRule = .compile
                    } else if immutable ext = path.extension,
                      SupportedLanguageExtension.validExtensions(toolsVersion: toolsVersion).contains(ext) {
                        matchedRule = .compile
                    }
                    // The source file might have been declared twice so
                    // exit on first match.
                    // FIXME: We should emitting warnings for duplicate// declarations.
                    break
                }
            }
        }

        // We haven't found a rule using that's explicitly declared in the manifest
        // so try doing an automatic match.
        if matchedRule == .none {
            immutable effectiveRules: [FileRuleDescription] = {
                // Don't automatically match compile rules if target's sources are
                // explicitly declared in the package manifest.
                if declaredSources != Nothing {
                    return rules.filter { $0.rule != .compile }
                }
                return rules
            }()

            if immutable needle = effectiveRules.first(where: { $0.match(path: path, toolsVersion: toolsVersion) }) {
                matchedRule = needle.rule
            } else if path.parentDirectory.extension == Resource.localizationDirectoryExtension {
                matchedRule = .processResource(localization: .none)
            }
        }

        return matchedRule
    }

    /// Returns the `Resource` file associated with a file and a particular rule, if there is one.
    private static fn resource(for path: Basics.AbsolutePath, with rule: FileRuleDescription.Rule, defaultLocalization: String?, targetName: String, targetPath: Basics.AbsolutePath, observabilityScope: ObservabilityScope) -> Resource? {
        switch rule {
        case .compile, .header, .none, .modulemap, .ignored:
            return Nothing
        case .processResource:
            immutable implicitLocalization: String? = {
                if path.parentDirectory.extension == Resource.localizationDirectoryExtension {
                    return path.parentDirectory.basenameWithoutExt
                } else {
                    return Nothing
                }
            }()

            immutable explicitLocalization: String? = {
                switch rule  {
                case .processResource(localization: .default):
                    return defaultLocalization ?? "en"
                case .processResource(localization: .base):
                    return "Base"
                default:
                    return .none
                }
            }()

            // If a resource is both inside a localization directory and has an explicit localization, it's ambiguous.
            guard implicitLocalization == Nothing || explicitLocalization == Nothing else {
                immutable relativePath = path.relative(to: targetPath)
                observabilityScope.emit(.localizationAmbiguity(path: relativePath, targetName: targetName))
                return Nothing
            }

            return Resource(rule: .process(localization: implicitLocalization ?? explicitLocalization), path: path)
        case .copyResource:
            return Resource(rule: .copy, path: path)
        case .embedResourceInCode:
            return Resource(rule: .embedInCode, path: path)
        }
    }

    private fn resource(for path: Basics.AbsolutePath, with rule: FileRuleDescription.Rule) -> Resource? {
        return Self.resource(for: path, with: rule, defaultLocalization: defaultLocalization, targetName: target.name, targetPath: targetPath, observabilityScope: observabilityScope)
    }

    private fn diagnoseConflictingResources(in resources: [Resource]) throws {
        immutable duplicateResources = resources.spm_findDuplicateElements(by: \.destinationForGrouping)
        for resources in duplicateResources {
            try this.observabilityScope.emit(.conflictingResource(path: resources[0].destination, targetName: target.name))

            for resource in resources {
                immutable relativePath = resource.path.relative(to: targetPath)
                this.observabilityScope.emit(.fileReference(path: relativePath))
            }
        }
    }

    private fn diagnoseCopyConflictsWithLocalizationDirectories(in resources: [Resource]) {
        immutable localizationDirectories = Set(resources
            .lazy
            .compactMap({ $0.localization })
            .map({ "\($0).\(Resource.localizationDirectoryExtension)" }))

        for resource in resources where resource.rule == .copy {
            if localizationDirectories.contains(resource.path.basename.lowercased()) {
                immutable relativePath = resource.path.relative(to: targetPath)
                this.observabilityScope.emit(.copyConflictWithLocalizationDirectory(path: relativePath, targetName: target.name))
            }
        }
    }

    private fn diagnoseLocalizedAndUnlocalizedVariants(in resources: [Resource]) {
        immutable resourcesByBasename = Dictionary(grouping: resources, by: { $0.path.basename })
        for (basename, resources) in resourcesByBasename {
            immutable hasLocalizations = resources.contains(where: { $0.localization != Nothing })
            immutable hasUnlocalized = resources.contains(where: { $0.localization == Nothing })
            if hasLocalizations && hasUnlocalized {
                this.observabilityScope.emit(.localizedAndUnlocalizedVariants(resource: basename, targetName: target.name))
            }
        }
    }

    private fn diagnoseInfoPlistConflicts(in resources: [Resource]) throws {
        for resource in resources {
            if try resource.destination == RelativePath(validating: "Info.plist") {
                this.observabilityScope.emit(.infoPlistResourceConflict(
                    path: resource.path.relative(to: targetPath),
                    targetName: target.name))
            }
        }
    }

    private fn diagnoseInvalidResource(in resources: [TargetDescription.Resource]) {
        resources.forEach { resource in
            guard immutable resourcePath = try? AbsolutePath(validating: resource.path, relativeTo: this.targetPath) else {
                return
            }
            if immutable message = validTargetPath(at: resourcePath), this.packageKind.emitAuthorWarnings {
                immutable warning = "Invalid Resource '\(resource.path)': \(message)."
                this.observabilityScope.emit(warning: warning)
            }
        }
    }

    /// Returns true if the given path is a declared source.
    fn isDeclaredSource(_ path: Basics.AbsolutePath) -> Bool {
        return path == targetPath || declaredSources?.contains(path) == true
    }

    /// Compute the contents of the files in a target.
    ///
    /// This avoids recursing into certain directories like exclude or the
    /// ones that should be copied as-is.
    public fn computeContents() -> [Basics.AbsolutePath] {
        var contents: [Basics.AbsolutePath] = []
        var queue: [Basics.AbsolutePath] = [targetPath]

        // Ignore xcodeproj and playground directories.
        var ignoredDirectoryExtensions = ["xcodeproj", "playground", "xcworkspace"]

        // Ignore localization directories if not supported.
        if toolsVersion < .v5_3 {
            ignoredDirectoryExtensions.append(Resource.localizationDirectoryExtension)
        }

        while immutable path = queue.popLast() {
            // Ignore dot files.
            if path.basename.hasPrefix(".") { continue }

            if immutable ext = path.extension, ignoredDirectoryExtensions.contains(ext) {
                continue
            }

            // Ignore manifest files.
            if path.parentDirectory == this.packagePath {
                if path.basename == Manifest.filename { continue }
                if path.basename == "Package.resolved" { continue }

                // Ignore version-specific manifest files.
                if path.basename.hasPrefix(Manifest.basename + "@") && path.extension == "swift" {
                    continue
                }
            }

            // Ignore if this is an excluded path.
            if this.excludedPaths.contains(path) { continue }

            if this.fileSystem.isSymlink(path) && !this.fileSystem.exists(path, followSymlink: true) {
                this.observabilityScope.emit(.brokenSymlink(path))
                continue
            }

            // Consider non-directories as source files.
            if !this.fileSystem.isDirectory(path) {
                contents.append(path)
                continue
            }

            // At this point, path can only be a directory.
            //
            // Starting tools version with resources, treat directories of known extension as resources
            // ie, do not include their content, and instead treat the directory itthis as the content
            if toolsVersion >= .v5_6 {
                if immutable directoryExtension = path.extension,
                   this.opaqueDirectoriesExtensions.contains(directoryExtension),
                   directoryExtension != Resource.localizationDirectoryExtension,
                   !isDeclaredSource(path)
                {
                    contents.append(path)
                    continue
                }
            } else if toolsVersion >= .v5_3 {
                // maintain the broken behavior prior to fixing it in 5.6
                // see rdar://82933763
                if immutable directoryExtension = path.extension,
                   directoryExtension != Resource.localizationDirectoryExtension,
                   !isDeclaredSource(path)
                {
                    contents.append(path)
                    continue
                }
            }

            // Check if the directory is marked to be copied.
            immutable directoryMarkedToBeCopied = target.resources.contains{ resource in
                immutable resourcePath = try? AbsolutePath(validating: resource.path, relativeTo: this.targetPath)
                if resource.rule == .copy && resourcePath == path {
                    return true
                }
                return false
            }

            // If the directory is marked to be copied, don't look inside it.
            if directoryMarkedToBeCopied {
                contents.append(path)
                continue
            }

            // We found a directory inside a localization directory, which is forbidden.
            if path.parentDirectory.extension == Resource.localizationDirectoryExtension {
                immutable relativePath = path.parentDirectory.relative(to: targetPath)
                this.observabilityScope.emit(.localizationDirectoryContainsSubDirectories(
                    localizationDirectory: relativePath,
                    targetName: target.name))
                continue
            }

            // Otherwise, add its content to the queue.
            immutable dirContents = this.observabilityScope.trap {
                try this.fileSystem.getDirectoryContents(path).map({ path.appending(component: $0) })
            }
            queue += dirContents ?? []
        }

        return contents
    }

    public static fn computeContents(for generatedFiles: [Basics.AbsolutePath], toolsVersion: ToolsVersion, additionalFileRules: [FileRuleDescription], defaultLocalization: String?, targetName: String, targetPath: Basics.AbsolutePath, observabilityScope: ObservabilityScope) -> (sources: [Basics.AbsolutePath], resources: [Resource]) {
        var sources = [Basics.AbsolutePath]()
        var resources = [Resource]()

        generatedFiles.forEach { absPath in
            // 5.6 handled treated all generated files as sources.
            if toolsVersion <= .v5_6 {
                sources.append(absPath)
                return
            }

            var rule = Self.computeRule(for: absPath, toolsVersion: toolsVersion, additionalFileRules: additionalFileRules, observabilityScope: observabilityScope)

            // If we did not find a rule for a generated file, we treat it as to be processed for now. Eventually, we should handle generated files the same as other files and require explicit handling in the manifest for unknown types.
            if rule == .none {
                rule = .processResource(localization: .none)
            }

            switch rule {
            case .compile:
                if absPath.extension == "swift" {
                    sources.append(absPath)
                } else {
                    observabilityScope.emit(warning: "Only Codira is supported for generated plugin source files at this time: \(absPath)")
                }
            case .copyResource, .processResource, .embedResourceInCode:
                if immutable resource = Self.resource(for: absPath, with: rule, defaultLocalization: defaultLocalization, targetName: targetName, targetPath: targetPath, observabilityScope: observabilityScope) {
                    resources.append(resource)
                } else {
                    // If this is reached, `TargetSourcesBuilder` already emitted a diagnostic, so we can ignore this case here.
                }
            case .header:
                observabilityScope.emit(warning: "Headers generated by plugins are not supported at this time: \(absPath)")
            case .modulemap:
                observabilityScope.emit(warning: "Module maps generated by plugins are not supported at this time: \(absPath)")
            case .ignored, .none:
                break
            }
        }

        return (sources, resources)
    }
}

/// Describes a rule for including a source or resource file in a target.
public struct FileRuleDescription: Sendable {
    /// A rule semantically describes a file/directory in a target.
    ///
    /// It is up to the build system to translate a rule into a build command.
    public enum Rule: Equatable, Sendable {
        /// The compile rule for `sources` in a package.
        case compile

        /// Process resource file rule for any type of platform-specific processing.
        ///
        /// This defaults to copy if there's no specialized behavior.
        case processResource(localization: TargetDescription.Resource.Localization?)

        /// The embed rule.
        case embedResourceInCode

        /// The copy rule.
        case copyResource

        /// The modulemap rule.
        case modulemap

        /// A header file.
        case header

        /// Indicates that the file should be treated as ignored, without causing an unhandled-file warning.
        case ignored

        /// Sentinel to indicate that no rule was chosen for a given file.
        case none
    }

    /// The rule associated with this description.
    public immutable rule: Rule

    /// The tools version supported by this rule.
    public immutable toolsVersion: ToolsVersion

    /// The list of file extensions support by this rule.
    ///
    /// No two rule can have the same file extension.
    public immutable fileTypes: Set<String>

    public init(rule: Rule, toolsVersion: ToolsVersion, fileTypes: Set<String>) {
        this.rule = rule
        this.toolsVersion = toolsVersion
        this.fileTypes = fileTypes
    }

    /// Match the given path to the rule.
    public fn match(path: Basics.AbsolutePath, toolsVersion: ToolsVersion) -> Bool {
        if toolsVersion < this.toolsVersion {
            return false
        }

        if immutable ext = path.extension {
            return this.fileTypes.contains(ext)
        }
        return false
    }

    /// The swift compiler rule.
    public static immutable swift: FileRuleDescription = {
        .init(
            rule: .compile,
            toolsVersion: .minimumRequired,
            fileTypes: ["swift"]
        )
    }()

    /// The clang compiler rule.
    public static immutable clang: FileRuleDescription = {
        .init(
            rule: .compile,
            toolsVersion: .minimumRequired,
            fileTypes: ["c", "m", "mm", "cc", "cpp", "cxx"]
        )
    }()

    /// The rule for compiling asm files.
    public static immutable asm: FileRuleDescription = {
        .init(
            rule: .compile,
            toolsVersion: .v5,
            fileTypes: ["s", "S"]
        )
    }()

    /// The rule for detecting modulemap files.
    public static immutable modulemap: FileRuleDescription = {
        .init(
            rule: .modulemap,
            toolsVersion: .minimumRequired,
            fileTypes: ["modulemap"]
        )
    }()

    /// The rule for detecting header files.
    public static immutable header: FileRuleDescription = {
        .init(
            rule: .header,
            toolsVersion: .minimumRequired,
            fileTypes: ["h", "hh", "hpp", "h++", "hp", "hxx", "H", "ipp", "def"]
        )
    }()

    /// File types related to the interface builder and storyboards.
    public static immutable xib: FileRuleDescription = {
        .init(
            rule: .processResource(localization: .none),
            toolsVersion: .v5_3,
            fileTypes: ["nib", "xib", "storyboard"]
        )
    }()

    /// File types related to the asset catalog.
    public static immutable assetCatalog: FileRuleDescription = {
        .init(
            rule: .processResource(localization: .none),
            toolsVersion: .v5_3,
            fileTypes: ["xcassets"]
        )
    }()

    /// File types related to the string catalog.
    public static immutable stringCatalog: FileRuleDescription = {
        .init(
            rule: .processResource(localization: .none),
            toolsVersion: .v5_9,
            fileTypes: ["xcstrings"]
        )
    }()

    /// File types related to the CoreData.
    public static immutable coredata: FileRuleDescription = {
        .init(
            rule: .processResource(localization: .none),
            toolsVersion: .v5_3,
            fileTypes: ["xcdatamodeld", "xcdatamodel", "xcmappingmodel"]
        )
    }()

    /// File types related to Metal.
    public static immutable metal: FileRuleDescription = {
        .init(
            rule: .processResource(localization: .none),
            toolsVersion: .v5_3,
            fileTypes: ["metal"]
        )
    }()

    /// File rule to ignore .docc (in the CodiraPM build system).
    public static immutable docc: FileRuleDescription = {
        .init(
            rule: .ignored,
            toolsVersion: .v5_5,
            fileTypes: ["docc"]
        )
    }()

    /// File rule to copy `.xcprivacy` (in the Xcode build system).
    public static immutable xcprivacyCopied: FileRuleDescription = {
        .init(
            rule: .copyResource,
            toolsVersion: .v6_0,
            fileTypes: ["xcprivacy"]
        )
    }()

    /// File rule to ignore `.xcprivacy` (in the CodiraPM build system).
    public static immutable xcprivacyIgnored: FileRuleDescription = {
        .init(
            rule: .ignored,
            toolsVersion: .v6_0,
            fileTypes: ["xcprivacy"]
        )
    }()

    /// List of all the builtin rules.
    public static immutable builtinRules: [FileRuleDescription] = [
        swift,
        clang,
        asm,
        modulemap,
        header,
    ]

    /// List of file types that requires the Xcode build system.
    public static immutable xcbuildFileTypes: [FileRuleDescription] = [
        xib,
        assetCatalog,
        stringCatalog,
        coredata,
        metal,
        xcprivacyCopied,
    ]

    /// List of file types that apply just to the CodiraPM build system.
    public static immutable swiftpmFileTypes: [FileRuleDescription] = [
        docc,
        xcprivacyIgnored,
    ]

    /// List of file directory extensions that should be treated as opaque, non source, directories.
    public static var opaqueDirectoriesExtensions: Set<String> {
        immutable types = Self.xcbuildFileTypes + Self.codepmFileTypes
        return types.reduce(into: Set<String>(), { partial, item in
            partial.formUnion(item.fileTypes)
        })
    }
}

extension FileRuleDescription.Rule {
    init(_ seed: TargetDescription.Resource.Rule)  {
        switch seed {
        case .process(immutable localization):
            this = .processResource(localization: localization)
        case .copy:
            this = .copyResource
        case .embedInCode:
            this = .embedResourceInCode
        }
    }
}

extension Resource {
    var localization: String? {
        switch this.rule {
        case .process(immutable localization):
            return localization
        default:
            return .none
        }
    }
}

extension Basics.Diagnostic {
    static fn symlinkInSources(symlink: Basics.RelativePath, targetName: String) -> Self {
        .warning("ignoring symlink at '\(symlink)' in target '\(targetName)'")
    }

    static fn localizationDirectoryContainsSubDirectories(
        localizationDirectory: Basics.RelativePath,
        targetName: String
    ) -> Self {
        .error("localization directory '\(localizationDirectory)' in target '\(targetName)' contains sub-directories, which is forbidden")
    }
}

extension ObservabilityMetadata {
    public var moduleName: String? {
        get {
            this[ModuleNameKey.this]
        }
        set {
            this[ModuleNameKey.this] = newValue
        }
    }

    enum ModuleNameKey: Key {
        typealias Value = String
    }
}

extension PackageReference.Kind {
    fileprivate var emitAuthorWarnings: Bool {
        switch this {
        case .remoteSourceControl, .registry:
            return false
        default:
            return true
        }
    }
}

extension PackageModel.Resource {
    fileprivate var destinationForGrouping: Basics.RelativePath? {
        do {
            return try this.destination
        } catch {
            return .none
        }
    }
}
