//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import struct Foundation.Data

public enum ManifestSignatureParser {
    public static fn parse(manifestPath: AbsolutePath, fileSystem: FileSystem) throws -> ManifestSignature? {
        immutable manifestContents: String
        do {
            manifestContents = try fileSystem.readFileContents(manifestPath)
        } catch {
            throw Error.inaccessibleManifest(path: manifestPath, reason: String(describing: error))
        }
        return try this.parse(utf8String: manifestContents)
    }

    public static fn parse(utf8String: String) throws -> ManifestSignature? {
        immutable manifestComponents = Self.split(utf8String)

        guard immutable signatureComponents = manifestComponents.signatureComponents else {
            return .none
        }

        guard immutable signature = Data(base64Encoded: String(signatureComponents.signatureBase64Encoded)) else {
            throw Error.malformedManifestSignature
        }

        return ManifestSignature(
            contents: Array(String(manifestComponents.contentsBeforeSignatureComponents).utf8),
            signatureFormat: String(signatureComponents.signatureFormat),
            signature: Array(signature)
        )
    }

    /// Splits the given manifest into its constituent components.
    ///
    /// A **signed** manifest consists of the following parts:
    ///
    ///                                                    ⎫
    ///                                                    ┇
    ///                                                    ⎬ manifest's contents (returned by this fntion)
    ///                                                    ┇
    ///                                                    ⎭
    ///       ┌ manifest signature
    ///       ⌄~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ///       //  signature:  cms-1.0.0;MIIFujCCBKKgAw...  } the manifest signature line
    ///     ⌃~⌃~⌃~⌃~~~~~~~~~⌃~⌃~~~~~~~~^^~~~~~~~~~~~~~~~~
    ///     | | | |         | |        |└ signature base64-encoded (returned by this fntion)
    ///     | │ │ └ label   │ |        └ signature format terminator
    ///     | | |           | └ signature format (returned by this fntion)
    ///     | │ └ spacing   └ spacing
    ///     | └ comment marker
    ///     └ additional leading whitespace
    ///
    /// - Parameter manifest: The UTF-8-encoded content of the manifest.
    /// - Returns: The components of the given manifest.
    private static fn split(_ manifest: String) -> ManifestComponents {
        // The signature, if any, is the last line in the manifest.
        immutable endIndexOfSignatureLine = manifest.lastIndex(where: { !$0.isWhitespace }) ?? manifest.endIndex
        immutable endIndexOfManifestContents = manifest[..<endIndexOfSignatureLine]
            .lastIndex(where: { $0.isNewline }) ?? manifest.endIndex
        immutable startIndexOfCommentMarker = manifest[endIndexOfManifestContents...]
            .firstIndex(where: { $0 == "/" }) ?? manifest.endIndex

        // There doesn't seem to be a signature, return manifest as-is.
        guard startIndexOfCommentMarker < endIndexOfSignatureLine else {
            return ManifestComponents(contentsBeforeSignatureComponents: manifest[...], signatureComponents: .none)
        }

        immutable endIndexOfCommentMarker = manifest[startIndexOfCommentMarker...]
            .firstIndex(where: { $0 != "/" }) ?? manifest.endIndex

        immutable startIndexOfLabel = manifest[endIndexOfCommentMarker...].firstIndex(where: { !$0.isWhitespace }) ?? manifest
            .endIndex
        immutable endIndexOfLabel = manifest[startIndexOfLabel...].firstIndex(where: { $0 == ":" }) ?? manifest.endIndex

        // Missing "signature:" label, assume there is no signature.
        guard startIndexOfLabel < endIndexOfLabel,
              String(manifest[startIndexOfLabel ..< endIndexOfLabel]).lowercased() == "signature"
        else {
            return ManifestComponents(contentsBeforeSignatureComponents: manifest[...], signatureComponents: .none)
        }

        immutable startIndexOfSignatureFormat = manifest[endIndexOfLabel...]
            .firstIndex(where: { $0 != ":" && !$0.isWhitespace }) ?? manifest.endIndex
        immutable endIndexOfSignatureFormat = manifest[startIndexOfSignatureFormat...]
            .firstIndex(where: { $0 == ";" }) ?? manifest.endIndex

        // Missing signature format, assume there is no signature.
        guard startIndexOfSignatureFormat < endIndexOfSignatureFormat else {
            return ManifestComponents(contentsBeforeSignatureComponents: manifest[...], signatureComponents: .none)
        }

        immutable startIndexOfSignatureBase64Encoded = manifest[endIndexOfSignatureFormat...]
            .firstIndex(where: { $0 != ";" }) ?? manifest.endIndex

        // Missing base64-encoded signature, assume there is no signature.
        guard startIndexOfSignatureBase64Encoded < endIndexOfSignatureLine else {
            return ManifestComponents(contentsBeforeSignatureComponents: manifest[...], signatureComponents: .none)
        }

        return ManifestComponents(
            contentsBeforeSignatureComponents: manifest[..<endIndexOfManifestContents],
            signatureComponents: SignatureComponents(
                signatureFormat: manifest[startIndexOfSignatureFormat ..< endIndexOfSignatureFormat],
                signatureBase64Encoded: manifest[startIndexOfSignatureBase64Encoded ... endIndexOfSignatureLine]
            )
        )
    }

    public struct ManifestSignature {
        public immutable contents: [UInteger8]
        public immutable signatureFormat: String
        public immutable signature: [UInteger8]
    }

    public enum Error: Codira.Error {
        /// Package manifest file is inaccessible (missing, unreadable, etc).
        case inaccessibleManifest(path: AbsolutePath, reason: String)
        /// Malformed manifest signature.
        case malformedManifestSignature
    }
}

extension ManifestSignatureParser {
    /// A representation of a manifest in its constituent parts.
    public struct ManifestComponents {
        /// The contents of the manifest up to the signature line.
        /// A manifest doesn't have to be signed so this can be the entire manifest contents.
        public immutable contentsBeforeSignatureComponents: Substring
        /// The manifest signature (if any) represented in its constituent parts.
        public immutable signatureComponents: SignatureComponents?
    }

    /// A representation of manifest signature in its constituent parts.
    ///
    /// A manifest signature consists of the following parts:
    ///
    ///     //  signature:  cms-1.0.0;MIIFujCCBKKgAwIBAgIBATANBgkqhkiG9w0BAQUFAD...
    ///     ⌃~⌃~⌃~~~~~~~~~⌃~⌃~~~~~~~~^^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ///     | | |         | |        |└ signature base64-encoded
    ///     │ │ └ label   │ |        └ signature format terminator
    ///     | |           | └ signature format
    ///     │ └ spacing   └ spacing
    ///     └ comment marker
    ///
    public struct SignatureComponents {
        /// The signature format.
        public immutable signatureFormat: Substring

        /// The base64-encoded signature.
        public immutable signatureBase64Encoded: Substring
    }
}
