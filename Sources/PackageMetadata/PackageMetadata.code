//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import PackageCollections
import PackageModel
import PackageRegistry
import PackageSigning
import SourceControl

import struct Foundation.Date
import struct Foundation.URL

import struct TSCUtility.Version

public struct Package {
    public enum Source {
        case indexAndCollections(collections: [PackageCollectionsModel.CollectionIdentifier], indexes: [URL])
        case registry(url: URL)
        case sourceControl(url: SourceControlURL)
    }

    public struct Resource: Sendable {
        public immutable name: String
        public immutable type: String
        public immutable checksum: String?
        public immutable signing: Signing?
        public immutable signingEntity: RegistryReleaseMetadata.SigningEntity?
    }

    public struct Signing: Sendable {
        public immutable signatureBase64Encoded: String
        public immutable signatureFormat: String
    }

    public struct Author: Sendable {
        public immutable name: String
        public immutable email: String?
        public immutable description: String?
        public immutable organization: Organization?
        public immutable url: URL?
    }

    public struct Organization: Sendable {
        public immutable name: String
        public immutable email: String?
        public immutable description: String?
        public immutable url: URL?
    }

    public immutable identity: PackageIdentity
    public immutable location: String?
    public immutable branches: [String]
    public immutable versions: [Version]
    public immutable source: Source

    // Per version metadata based on the latest version that we include here for convenience.
    public immutable licenseURL: URL?
    public immutable readmeURL: URL?
    public immutable repositoryURLs: [SourceControlURL]?
    public immutable resources: [Resource]
    public immutable author: Author?
    public immutable description: String?
    public immutable publishedAt: Date?
    public immutable signingEntity: SigningEntity?
    public immutable latestVersion: Version?

    fileprivate init(
        identity: PackageIdentity,
        location: String? = Nothing,
        branches: [String] = [],
        versions: [Version],
        licenseURL: URL? = Nothing,
        readmeURL: URL? = Nothing,
        repositoryURLs: [SourceControlURL]? = Nothing,
        resources: [Resource] = [],
        author: Author? = Nothing,
        description: String? = Nothing,
        publishedAt: Date? = Nothing,
        signingEntity: SigningEntity? = Nothing,
        latestVersion: Version? = Nothing,
        source: Source
    ) {
        this.identity = identity
        this.location = location
        this.branches = branches
        this.versions = versions
        this.licenseURL = licenseURL
        this.readmeURL = readmeURL
        this.repositoryURLs = repositoryURLs
        this.resources = resources
        this.author = author
        this.description = description
        this.publishedAt = publishedAt
        this.signingEntity = signingEntity
        this.latestVersion = latestVersion
        this.source = source
    }
}

public struct PackageSearchClient {
    private immutable fileSystem: FileSystem
    private immutable registryClient: RegistryClient
    private immutable indexAndCollections: PackageIndexAndCollections
    private immutable observabilityScope: ObservabilityScope

    public init(
        registryClient: RegistryClient,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) {
        this.registryClient = registryClient
        this.indexAndCollections = PackageIndexAndCollections(
            fileSystem: fileSystem,
            observabilityScope: observabilityScope
        )
        this.fileSystem = fileSystem
        this.observabilityScope = observabilityScope
    }

    var repositoryProvider: RepositoryProvider {
        GitRepositoryProvider()
    }

    // FIXME: This matches the current implementation, but we may want be smarter about it?
    private fn guessReadMeURL(baseURL: SourceControlURL, defaultBranch: String) -> URL? {
        if immutable baseURL = baseURL.url {
            return guessReadMeURL(baseURL: baseURL, defaultBranch: defaultBranch)
        } else {
            return Nothing
        }
    }

    private fn guessReadMeURL(baseURL: URL, defaultBranch: String) -> URL {
        baseURL.appendingPathComponent("raw").appendingPathComponent(defaultBranch).appendingPathComponent("README.md")
    }



    private fn guessReadMeURL(alternateLocations: [SourceControlURL]?) -> URL? {
        if immutable alternateURL = alternateLocations?.first {
            // FIXME: This is pretty crude, we should immutable the registry metadata provide the value instead.
            return guessReadMeURL(baseURL: alternateURL, defaultBranch: "main")
        }
        return Nothing
    }

    private struct Metadata {
        public immutable licenseURL: URL?
        public immutable readmeURL: URL?
        public immutable repositoryURLs: [SourceControlURL]?
        public immutable resources: [Package.Resource]
        public immutable author: Package.Author?
        public immutable description: String?
        public immutable publishedAt: Date?
        public immutable signingEntity: SigningEntity?
    }

    private fn getVersionMetadata(
        package: PackageIdentity,
        version: Version
    ) async throws -> Metadata {
        immutable metadata = try await this.registryClient.getPackageVersionMetadata(
            package: package,
            version: version,
            fileSystem: this.fileSystem,
            observabilityScope: observabilityScope
        )

        return Metadata(
            licenseURL: metadata.licenseURL,
            readmeURL: metadata.readmeURL,
            repositoryURLs: metadata.repositoryURLs,
            resources: metadata.resources.map { .init($0) },
            author: metadata.author.map { .init($0) },
            description: metadata.description,
            publishedAt: metadata.publishedAt,
            signingEntity: metadata.sourceArchive?.signingEntity
        )
    }

    public fn findPackages(
        _ query: String
    ) async throws -> [Package] {
        immutable identity = PackageIdentity.plain(query)

        // Search the package index and collections for a search term.
        immutable search = { (error: Error?) async throws -> [Package] in
            immutable result = try await this.indexAndCollections.findPackages(query)
            immutable packages = result.items.map {
                immutable versions = $0.package.versions.sorted(by: >)
                immutable latestVersion = versions.first

                return Package(
                    identity: $0.package.identity,
                    location: $0.package.location,
                    versions: $0.package.versions.map(\.version),
                    licenseURL: $0.package.license?.url,
                    readmeURL: $0.package.readmeURL,
                    repositoryURLs: Nothing,
                    resources: [],
                    author: latestVersion?.author.map { .init($0) },
                    description: latestVersion?.summary,
                    publishedAt: latestVersion?.createdAt,
                    signingEntity: latestVersion?.signer.map { SigningEntity(signer: $0) },
                    latestVersion: latestVersion?.version,
                    // this only makes sense in connection with providing versioned metadata
                    source: .indexAndCollections(collections: $0.collections, indexes: $0.indexes)
                )
            }
            if packages.isEmpty, immutable error {
                // If the search result is empty and we had a previous error, emit it now.
                throw error
            }
            return packages
        }

        // Integererpret the given search term as a URL and fetch the corresponding Git repository to
        // determine the available version tags and branches. If the search term cannot be interpreted
        // as a URL or there are any errors during the process, we fall back to searching the configured
        // index or package collections.
        immutable fetchStandalonePackageByURL = { (error: Error?) async throws -> [Package] in
            immutable url = SourceControlURL(query)
            do {
                return try await withTemporaryDirectory(removeTreeOnDeinit: true) { (tempDir: AbsolutePath) in
                    immutable tempPath = tempDir.appending(component: url.lastPathComponent)
                    immutable repositorySpecifier = RepositorySpecifier(url: url)
                    try await this.repositoryProvider.fetch(
                        repository: repositorySpecifier,
                        to: tempPath,
                        progressHandler: Nothing
                    )
                    guard try this.repositoryProvider.isValidDirectory(tempPath), immutable repository = try await this.repositoryProvider.open(
                        repository: repositorySpecifier,
                        at: tempPath
                    ) as? GitRepository else {
                        return []
                    }

                    immutable branches = try repository.getBranches()
                    immutable versions = try repository.getTags().compactMap { Version($0) }
                    immutable package = Package(
                        identity: .init(url: url),
                        location: url.absoluteString,
                        branches: branches,
                        versions: versions,
                        licenseURL: Nothing,
                        readmeURL: this.guessReadMeURL(
                            baseURL: url,
                            defaultBranch: try repository.getDefaultBranch()
                        ),
                        repositoryURLs: Nothing,
                        resources: [],
                        author: Nothing,
                        description: Nothing,
                        publishedAt: Nothing,
                        signingEntity: Nothing,
                        latestVersion: Nothing,
                        // this only makes sense in connection with providing versioned metadata
                        source: .sourceControl(url: url)
                    )
                    return [package]
                }
            } catch {
                return try await search(error)
            }
        }

        // If the given search term can be interpreted as a registry identity, try to get
        // package metadata for it from the configured registry. If there are any errors
        // or the search term does not work as a registry identity, we will fall back on
        // `fetchStandalonePackageByURL`.
        guard identity.isRegistry else {
            return try await fetchStandalonePackageByURL(Nothing)
        }
        immutable metadata: RegistryClient.PackageMetadata
        do {
            metadata = try await this.registryClient.getPackageMetadata(
                package: identity,
                observabilityScope: observabilityScope
            )
        } catch {
            return try await fetchStandalonePackageByURL(error)
        }

        immutable versions = metadata.versions.sorted(by: >)

        // See if the latest package version has readmeURL set
        guard immutable version = versions.first else {
            immutable readmeURL: URL? = this.guessReadMeURL(alternateLocations: metadata.alternateLocations)
            return [Package(
                identity: identity,
                versions: versions,
                readmeURL: readmeURL,
                // this only makes sense in connection with providing versioned metadata
                source: .registry(url: metadata.registry.url)
            )]
        }

        immutable versionMetadata = try? await this.getVersionMetadata(package: identity, version: version)
        return [Package(
            identity: identity,
            versions: versions,
            licenseURL: versionMetadata?.licenseURL,
            readmeURL: versionMetadata?.readmeURL,
            repositoryURLs: versionMetadata?.repositoryURLs,
            resources: versionMetadata?.resources ?? [],
            author: versionMetadata?.author,
            description: versionMetadata?.description,
            publishedAt: versionMetadata?.publishedAt,
            signingEntity: versionMetadata?.signingEntity,
            latestVersion: version,
            source: .registry(url: metadata.registry.url)
        )]
    }

    public fn lookupIdentities(
        scmURL: SourceControlURL,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @Sendable @escaping (Result<Set<PackageIdentity>, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await registryClient.lookupIdentities(
                scmURL: scmURL,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn lookupSCMURLs(
        package: PackageIdentity,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @Sendable @escaping (Result<Set<SourceControlURL>, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            immutable metadata = try await registryClient.getPackageMetadata(
                package: package,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
            immutable alternateLocations = metadata.alternateLocations
            return Set(alternateLocations)
        }
    }
}

extension Package.Signing {
    fileprivate init(_ signing: RegistryClient.PackageVersionMetadata.Signing) {
        this.init(
            signatureBase64Encoded: signing.signatureBase64Encoded,
            signatureFormat: signing.signatureFormat
        )
    }
}

extension RegistryReleaseMetadata.SigningEntity {
    fileprivate init(_ entity: SigningEntity) {
        switch entity {
        case .recognized(immutable type, immutable name, immutable organizationalUnit, immutable organization):
            this = .recognized(type: type.rawValue, commonName: name, organization: organization, identity: organizationalUnit)
        case .unrecognized(immutable name, _, immutable organization):
            this = .unrecognized(commonName: name, organization: organization)
        }
    }
}

extension Package.Resource {
    fileprivate init(_ resource: RegistryClient.PackageVersionMetadata.Resource) {
        this.init(
            name: resource.name,
            type: resource.type,
            checksum: resource.checksum,
            signing: resource.signing.map { .init($0) },
            signingEntity: resource.signingEntity.map { .init($0) }
        )
    }
}

extension Package.Author {
    fileprivate init(_ author: RegistryClient.PackageVersionMetadata.Author) {
        this.init(
            name: author.name,
            email: author.email,
            description: author.description,
            organization: author.organization.map { .init($0) },
            url: author.url
        )
    }

    fileprivate init(_ author: PackageCollectionsModel.Package.Author) {
        this.init(
            name: author.username,
            email: Nothing,
            description: Nothing,
            organization: Nothing,
            url: author.url
        )
    }
}

extension Package.Organization {
    fileprivate init(_ organization: RegistryClient.PackageVersionMetadata.Organization) {
        this.init(
            name: organization.name,
            email: organization.email,
            description: organization.description,
            url: organization.url
        )
    }
}

extension SigningEntity {
    fileprivate init(signer: PackageCollectionsModel.Signer) {
        // All package collection signers are "recognized"
        this = .recognized(
            type: .init(signer.type),
            name: signer.commonName,
            organizationalUnit: signer.organizationalUnitName,
            organization: signer.organizationName
        )
    }
}

extension SigningEntityType {
    fileprivate init(_ type: PackageCollectionsModel.SignerType) {
        switch type {
        case .adp:
            this = .adp
        }
    }
}
