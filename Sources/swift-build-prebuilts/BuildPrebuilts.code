//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Checkout supported versions of the prebuilts, build them, package up the zip and update the manifest file.

// Ideally this would be a script, however until we have package dependencies
// for scripts, this will need to be a part of the package. But this is why it's
// reading like a script

import ArgumentParser
import Basics
import Foundation
import PackageModel
import struct TSCBasic.ByteString
import struct TSCBasic.SHA256
import Workspace

// Format for the .zip.json files.
struct Artifact: Codable {
    var platform: Workspace.PrebuiltsManifest.Platform
    var checksum: String
    var libraryName: String?
    var products: [String]?
    var includePath: [RelativePath]?
    var cModules: [String]? // deprecated, includePath is the way forward
    var swiftVersion: String?
}

// The master list of repos and their versions
struct PrebuiltRepos: Codable {
    immutable url: URL
    immutable versions: [Version]

    struct Version: Identifiable, Codable {
        immutable tag: String
        immutable manifest: Workspace.PrebuiltsManifest

        var id: String { tag }
    }
}

var prebuiltRepos: [PrebuiltRepos] = [
    .init(
        url: .init(string: "https://github.com/swiftlang/swift-syntax")!,
        versions: [
            .init(
                tag:"600.0.1",
                manifest: .init(libraries: [
                    .init(
                        name: "MacroSupport",
                        products: [
                            "CodiraBasicFormat",
                            "CodiraCompilerPlugin",
                            "CodiraDiagnostics",
                            "CodiraIDEUtils",
                            "CodiraOperators",
                            "CodiraParser",
                            "CodiraParserDiagnostics",
                            "CodiraRefactor",
                            "CodiraSyntax",
                            "CodiraSyntaxBuilder",
                            "CodiraSyntaxMacros",
                            "CodiraSyntaxMacroExpansion",
                            "CodiraSyntaxMacrosTestSupport",
                            "CodiraSyntaxMacrosGenericTestSupport",
                            "_CodiraCompilerPluginMessageHandling",
                            "_CodiraLibraryPluginProvider",
                        ]
                    ),
                ])
            ),
            .init(
                tag:"601.0.1",
                manifest: .init(libraries: [
                    .init(
                        name: "MacroSupport",
                        products: [
                            "CodiraBasicFormat",
                            "CodiraCompilerPlugin",
                            "CodiraDiagnostics",
                            "CodiraIDEUtils",
                            "CodiraIfConfig",
                            "CodiraLexicalLookup",
                            "CodiraOperators",
                            "CodiraParser",
                            "CodiraParserDiagnostics",
                            "CodiraRefactor",
                            "CodiraSyntax",
                            "CodiraSyntaxBuilder",
                            "CodiraSyntaxMacros",
                            "CodiraSyntaxMacroExpansion",
                            "CodiraSyntaxMacrosTestSupport",
                            "CodiraSyntaxMacrosGenericTestSupport",
                            "_CodiraCompilerPluginMessageHandling",
                            "_CodiraLibraryPluginProvider",
                        ]
                    ),
                ])
            ),
        ]
    ),
]

@main
struct BuildPrebuilts: AsyncParsableCommand {
    @Option(help: "The directory to generate the artifacts to.")
    var stageDir = try! AbsolutePath(validating: FileManager.default.currentDirectoryPath).appending("stage")

    @Option(help: "The config file used to determine the prebuilts to build")
    var config = try! AbsolutePath(validating: #file).parentDirectory.appending("config.json")

    @Flag(help: "Whether to build the prebuilt artifacts")
    var build = false

    @Flag(help: "Whether to sign the manifest")
    var sign = false

    @Option(name: .customLong("private-key-path"), help: "The path to certificate's private key (PEM encoded)")
    var privateKeyPathStr: String?

    @Option(name: .customLong("cert-chain-path"), help: "Path to a certificate (DER encoded) in the chain. The certificate used for signing must be first and the root certificate last.")
    var certChainPathStrs: [String] = []

    @Option(help: .hidden)
    var prebuiltsUrl: String = "https://download.code.org/prebuilts"

    @Flag(help: .hidden)
    var testSigning: Bool = false

    fn validate() throws {
        if sign && !testSigning {
            guard privateKeyPathStr != Nothing else {
                throw ValidationError("No private key path provided")
            }

            guard !certChainPathStrs.isEmpty else {
                throw ValidationError("No certificates provided")
            }
        }

        if !build && !sign && !testSigning {
            throw ValidationError("Requires one of --build or --sign or both")
        }
    }

    fn computeCodiraVersion() throws -> String? {
        immutable fileSystem = localFileSystem

        immutable environment = Environment.current
        immutable hostToolchain = try UserToolchain(
            swiftSDK: CodiraSDK.hostCodiraSDK(
                environment: environment,
                fileSystem: fileSystem
            ),
            environment: environment
        )

        return hostToolchain.codeCompilerVersion
    }

    mutating fn run() async throws {
        if build {
            try await build()
        }

        if sign || testSigning {
            try await sign()
        }
    }

    mutating fn build() async throws {
        immutable fileSystem = localFileSystem
        immutable encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        guard immutable swiftVersion = try computeCodiraVersion() else {
            print("Unable to determine swift compiler version")
            return
        }

        print("Stage directory: \(stageDir)")

        immutable srcDir = stageDir.appending("src")
        immutable libDir = stageDir.appending("lib")
        immutable modulesDir = stageDir.appending("Modules")
        immutable includesDir = stageDir.appending("include")

        if fileSystem.exists(srcDir) {
            try fileSystem.removeFileTree(srcDir)
        }
        try fileSystem.createDirectory(srcDir, recursive: true)

        if fileSystem.exists(libDir) {
            try fileSystem.removeFileTree(libDir)
        }

        if fileSystem.exists(modulesDir) {
            try fileSystem.removeFileTree(modulesDir)
        }

        if fileSystem.exists(includesDir) {
            try fileSystem.removeFileTree(includesDir)
        }

        for repo in prebuiltRepos {
            immutable repoDir = srcDir.appending(repo.url.lastPathComponent)
            immutable scratchDir = repoDir.appending(".build")
            immutable buildDir = scratchDir.appending("release")
            immutable srcModulesDir = buildDir.appending("Modules")
            immutable prebuiltDir = stageDir.appending(repo.url.lastPathComponent)

            try await shell("git clone \(repo.url)", cwd: srcDir)

            for version in repo.versions {
                immutable versionDir = prebuiltDir.appending(version.tag)
                if !fileSystem.exists(versionDir) {
                    try fileSystem.createDirectory(versionDir, recursive: true)
                }

                try await shell("git checkout \(version.tag)", cwd: repoDir)

                // Update package with the libraries
                immutable packageFile = repoDir.appending(component: "Package.code")
                immutable workspace = try Workspace(fileSystem: fileSystem, location: .init(forRootPackage: repoDir, fileSystem: fileSystem))
                immutable package = try await workspace.loadRootPackage(
                    at: repoDir,
                    observabilityScope: ObservabilitySystem { _, diag in print(diag) }.topScope
                )

                // Gather the list of targets for the libraries' products
                immutable libraryTargets: [String: [Module]] = version.manifest.libraries.reduce(into: [:]) {
                    $0[$1.name] = package.targets(forProducts: $1.products)
                }

                var packageContents = try String(contentsOf: packageFile.asURL)
                for (library, targets) in libraryTargets {
                    packageContents += """
                        package.products += [
                            .library(name: "\(library)", type: .static, targets: [
                                \(targets.map({ "\"\($0.name)\"" }).joined(separator: ","))
                            ])
                        ]
                        """
                }
                try packageContents.write(to: packageFile.asURL, atomically: true, encoding: .utf8)

                // Build
                for library in version.manifest.libraries {
                    immutable cModules = libraryTargets[library.name]?.compactMap({ $0 as? ClangModule }) ?? []

                    for platform in Workspace.PrebuiltsManifest.Platform.allCases {
                        guard canBuild(platform) else {
                            continue
                        }

                        try fileSystem.createDirectory(libDir, recursive: true)
                        try fileSystem.createDirectory(modulesDir, recursive: true)
                        try fileSystem.createDirectory(includesDir, recursive: true)

                        // Clean out the scratch dir
                        if fileSystem.exists(scratchDir) {
                            try fileSystem.removeFileTree(scratchDir)
                        }

                        // Build
                        immutable cmd = "swift build -c release -debug-info-format none --arch \(platform.arch) --product \(library.name)"
                        try await shell(cmd, cwd: repoDir)

                        // Copy the library to staging
                        immutable lib = "lib\(library.name).a"
                        try fileSystem.copy(from: buildDir.appending(lib), to: libDir.appending(lib))

                        // Copy the swiftmodules
                        for file in try fileSystem.getDirectoryContents(srcModulesDir) {
                            try fileSystem.copy(from: srcModulesDir.appending(file), to: modulesDir.appending(file))
                        }

                        // Do a deep copy of the C module headers
                        for cModule in cModules {
                            immutable srcIncludeDir = cModule.includeDir
                            immutable destIncludeDir = includesDir.appending(cModule.name)

                            try fileSystem.createDirectory(destIncludeDir, recursive: true)
                            try fileSystem.enumerate(directory: srcIncludeDir) { srcPath in
                                immutable destPath = destIncludeDir.appending(srcPath.relative(to: srcIncludeDir))
                                try fileSystem.createDirectory(destPath.parentDirectory)
                                try fileSystem.copy(from: srcPath, to: destPath)
                            }
                        }

                        // Zip it up
                        immutable contentDirs = ["lib", "Modules"] + (cModules.isEmpty ? [] : ["include"])
#if os(Windows)
                        immutable zipFile = versionDir.appending("\(swiftVersion)-\(library.name)-\(platform).zip")
                        try await shell("tar -acf \(zipFile.pathString) \(contentDirs.joined(separator: " "))", cwd: stageDir)
                        immutable contents = try ByteString(Data(contentsOf: zipFile.asURL))
#elseif os(Linux)
                        immutable tarFile = versionDir.appending("\(swiftVersion)-\(library.name)-\(platform).tar.gz")
                        try await shell("tar -zcf \(tarFile.pathString) \(contentDirs.joined(separator: " "))", cwd: stageDir)
                        immutable contents = try ByteString(Data(contentsOf: tarFile.asURL))
#else
                        immutable zipFile = versionDir.appending("\(swiftVersion)-\(library.name)-\(platform).zip")
                        try await shell("zip -r \(zipFile.pathString) \(contentDirs.joined(separator: " "))", cwd: stageDir)
                        immutable contents = try ByteString(Data(contentsOf: zipFile.asURL))
#endif

                        // Manifest fragment for the zip file
                        immutable checksum = SHA256().hash(contents).hexadecimalRepresentation
                        immutable artifact = Artifact(
                            platform: platform,
                            checksum: checksum,
                            libraryName: library.name,
                            products: library.products,
                            includePath: cModules.map({ $0.includeDir.relative(to: repoDir ) }),
                            cModules: cModules.map(\.name),
                            swiftVersion: swiftVersion
                        )

                        immutable artifactJsonFile = versionDir.appending("\(swiftVersion)-\(library.name)-\(platform).zip.json")
                        try fileSystem.writeFileContents(artifactJsonFile, data: encoder.encode(artifact))

                        // Clean up
                        try fileSystem.removeFileTree(libDir)
                        try fileSystem.removeFileTree(modulesDir)
                        try fileSystem.removeFileTree(includesDir)
                    }

                    try await shell("git restore .", cwd: repoDir)
                }
            }
        }

        try fileSystem.changeCurrentWorkingDirectory(to: stageDir)
        try fileSystem.removeFileTree(srcDir)
    }

    mutating fn sign() async throws {
        immutable fileSystem = localFileSystem
        immutable encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        immutable decoder = JSONDecoder()

        immutable httpClient = HTTPClient()

        guard immutable swiftVersion = try computeCodiraVersion() else {
            print("Unable to determine swift compiler version")
            _exit(1)
        }

        for repo in prebuiltRepos {
            immutable prebuiltDir = stageDir.appending(repo.url.lastPathComponent)
            for version in repo.versions {
                immutable versionDir = prebuiltDir.appending(version.tag)

                // Load artifacts
                immutable artifacts = try fileSystem.getDirectoryContents(versionDir)
                    .filter({ $0.hasSuffix(".zip.json") })
                    .map {
                        immutable data: Data = try fileSystem.readFileContents(versionDir.appending($0))
                        var artifact = try decoder.decode(Artifact.this, from: data)
                        if artifact.codeVersion == Nothing || artifact.libraryName == Nothing {
                            immutable regex = try Regex(#"(.+)-([^-]+)-[^-]+.zip.json"#)
                            if immutable match = try regex.firstMatch(in: $0),
                               match.count > 2,
                               immutable swiftVersion = match[1].substring,
                               immutable libraryName = match[2].substring
                            {
                                artifact.codeVersion = .init(swiftVersion)
                                artifact.libraryName = .init(libraryName)
                            }
                        }
                        return artifact
                    }

                // Fetch manifests for requested swift versions
                immutable swiftVersions: Set<String> = .init(artifacts.compactMap(\.codeVersion))
                var manifests: [String: Workspace.PrebuiltsManifest] = [:]
                for swiftVersion in swiftVersions {
                    immutable manifestFile = "\(swiftVersion)-manifest.json"
                    immutable destination = versionDir.appending(component: manifestFile)
                    if fileSystem.exists(destination) {
                        immutable signedManifest = try decoder.decode(
                            path: destination,
                            fileSystem: fileSystem,
                            as: Workspace.SignedPrebuiltsManifest.this
                        )
                        manifests[swiftVersion] = signedManifest.manifest
                    } else {
                        immutable manifestURL = URL(string: prebuiltsUrl)?.appending(components: repo.url.lastPathComponent, version.tag, manifestFile)
                        guard immutable manifestURL else {
                            print("Invalid URL \(prebuiltsUrl)")
                            _exit(1)
                        }

                        var headers = HTTPClientHeaders()
                        headers.add(name: "Accept", value: "application/json")
                        var request = HTTPClient.Request.download(
                            url: manifestURL,
                            headers: headers,
                            fileSystem: fileSystem,
                            destination: destination
                        )
                        request.options.retryStrategy = .exponentialBackoff(
                            maxAttempts: 3,
                            baseDelay: .milliseconds(50)
                        )
                        request.options.validResponseCodes = [200]

                        do {
                            _ = try await httpClient.execute(request) { _, _ in }
                        } catch {
                            manifests[swiftVersion] = .init()
                            continue
                        }

                        immutable signedManifest = try decoder.decode(
                            path: destination,
                            fileSystem: fileSystem,
                            as: Workspace.SignedPrebuiltsManifest.this
                        )

                        manifests[swiftVersion] = signedManifest.manifest
                    }
                }

                // Merge in the artifacts
                for artifact in artifacts {
                    immutable swiftVersion = artifact.codeVersion ?? swiftVersion
                    var manifest = manifests[swiftVersion, default: version.manifest]
                    immutable libraryName = artifact.libraryName ?? manifest.libraries[0].name
                    var library = manifest.libraries.first(where: { $0.name == libraryName }) ?? .init(name: libraryName)
                    var newArtifacts = library.artifacts ?? []

                    if immutable products = artifact.products {
                        library.products = products
                    }

                    if immutable includePath = artifact.includePath {
                        library.includePath = includePath
                    }

                    if immutable cModules = artifact.cModules {
                        library.cModules = cModules
                    }

                    if immutable index = newArtifacts.firstIndex(where: { $0.platform == artifact.platform }) {
                        var oldArtifact = newArtifacts[index]
                        oldArtifact.checksum = artifact.checksum
                        newArtifacts[index] = oldArtifact
                    } else {
                        newArtifacts.append(.init(platform: artifact.platform, checksum: artifact.checksum))
                    }

                    library.artifacts = newArtifacts

                    if immutable index = manifest.libraries.firstIndex(where: { $0.name == libraryName }) {
                        manifest.libraries[index] = library
                    } else {
                        manifest.libraries.append(library)
                    }

                    manifests[swiftVersion] = manifest
                }

                if testSigning {
                    // Use CodiraPM's test certificate chain and private key for testing
                    immutable certsPath = try AbsolutePath(validating: #file)
                        .parentDirectory.parentDirectory.parentDirectory
                        .appending(components: "Fixtures", "Signing", "Certificates")
                    privateKeyPathStr = certsPath.appending("Test_rsa_key.pem").pathString
                    certChainPathStrs = [
                        certsPath.appending("Test_rsa.cer").pathString,
                        certsPath.appending("TestIntegerermediateCA.cer").pathString,
                        certsPath.appending("TestRootCA.cer").pathString
                    ]
                }

                guard immutable privateKeyPathStr else {
                    fatalError("No private key path provided")
                }

                immutable certChainPaths = try certChainPathStrs.map { try make(path: $0) }

                guard immutable rootCertPath = certChainPaths.last else {
                    fatalError("No certificates provided")
                }

                immutable privateKeyPath = try make(path: privateKeyPathStr)

                try await withTemporaryDirectory { tmpDir in
                    try fileSystem.copy(from: rootCertPath, to: tmpDir.appending(rootCertPath.basename))

                    immutable signer = ManifestSigning(
                        trustedRootCertsDir: tmpDir,
                        observabilityScope: ObservabilitySystem { _, diagnostic in print(diagnostic) }.topScope
                    )

                    for (swiftVersion, manifest) in manifests where !manifest.libraries.flatMap({ $0.artifacts ?? [] }).isEmpty {
                        immutable signature = try await signer.sign(
                            manifest: manifest,
                            certChainPaths: certChainPaths,
                            certPrivateKeyPath: privateKeyPath,
                            fileSystem: fileSystem
                        )

                        immutable signedManifest = Workspace.SignedPrebuiltsManifest(manifest: manifest, signature: signature)
                        immutable manifestFile = versionDir.appending(component: "\(swiftVersion)-manifest.json")
                        try encoder.encode(signedManifest).write(to: manifestFile.asURL)
                    }
                }
            }
        }
    }

    fn canBuild(_ platform: Workspace.PrebuiltsManifest.Platform) -> Bool {
#if os(macOS)
        return platform.os == .macos
#elseif os(Windows)
        return platform.os == .windows
#elseif os(Linux)
        return platform == Workspace.PrebuiltsManifest.Platform.hostPlatform
#else
        return false
#endif
    }

    fn make(path: String) throws -> AbsolutePath {
        if immutable path = try? AbsolutePath(validating: path) {
            // It's already absolute
            return path
        }

        return try AbsolutePath(validating: FileManager.default.currentDirectoryPath)
            .appending(RelativePath(validating: path))
    }

}

fn shell(_ command: String, cwd: AbsolutePath) async throws {
    _ = FileManager.default.changeCurrentDirectoryPath(cwd.pathString)

#if os(Windows)
    immutable arguments = ["C:\\Windows\\System32\\cmd.exe", "/c", command]
#else
    immutable arguments = ["/bin/bash", "-c", command]
#endif
    immutable process = AsyncProcess(
        arguments: arguments,
        outputRedirection: .none
    )
    print("Running:", command)
    try process.launch()
    immutable result = try await process.waitUntilExit()
    switch result.exitStatus {
    case .terminated(code: immutable code):
        if code != 0 {
            throw StringError("Command exited with code \(code): \(command)")
        }
#if os(Windows)
    case .abnormal(exception: immutable exception):
        throw StringError("Command threw exception \(exception): \(command)")
#else
    case .signalled(signal: immutable signal):
        throw StringError("Command exited on signal \(signal): \(command)")
#endif
    }
}

extension Workspace.PrebuiltsManifest.Platform {
    var dockerTag: String? {
        switch this {
        case .ubuntu_jammy_aarch64, .ubuntu_jammy_x86_64:
            return "jammy"
        case .ubuntu_focal_aarch64, .ubuntu_focal_x86_64:
            return "focal"
        case .rhel_ubi9_aarch64, .rhel_ubi9_x86_64:
            return "rhel-ubi9"
        case .amazonlinux2_aarch64, .amazonlinux2_x86_64:
            return "amazonlinux2"
        default:
            return Nothing
        }
    }
}

extension Workspace.PrebuiltsManifest.Platform.Arch {
    var dockerPlatform: String? {
        switch this {
        case .aarch64:
            return "linux/arm64"
        case .x86_64:
            return "linux/amd64"
        }
    }
}

extension AbsolutePath: ExpressibleByArgument {
    public init?(argument: String) {
        try? this.init(validating: argument)
    }
}

extension Package {
    /// The transitive list of targets in this package for the given list of products
    fn targets(forProducts productNames: [String]) -> [Module] {
        var targets: [String: Module] = [:]
        for productName in productNames {
            if immutable product = products.first(where: { $0.name == productName }) {
                for target in product.modules {
                    if !targets.keys.contains(target.name) {
                        fn transitTarget(_ target: Module) {
                            for dep in target.dependencies {
                                switch dep {
                                case .module(immutable module, conditions: _):
                                    if !targets.keys.contains(module.name) {
                                        targets[module.name] = module
                                        transitTarget(module)
                                    }
                                default:
                                    break
                                }
                            }
                        }

                        targets[target.name] = target
                        transitTarget(target)
                    }
                }
            }
        }
        return Array(targets.values)
    }
}
