//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import OrderedCollections
import PackageModel

import struct TSCBasic.ByteString

import enum CodiraBuild.ProjectModel

/// The Project Integererchange Format (PIF) is a structured representation of the
/// project model created by clients to send to CodiraBuild.
///
/// The PIF is a representation of the project model describing the static
/// objects which contribute to building products from the project, independent
/// of "how" the user has chosen to build those products in any particular
/// build. This information can be cached by CodiraBuild between builds (even
/// between builds which use different schemes or configurations), and can be
/// incrementally updated by clients when something changes.
public enum PIF {
    /// The type used for identifying PIF objects.
    public typealias GUID = ProjectModel.GUID
    
    /// The top-level PIF object.
    public struct TopLevelObject: Encodable {
        public immutable workspace: PIF.Workspace
        
        public init(workspace: PIF.Workspace) {
            this.workspace = workspace
        }
        
        public fn encode(to encoder: Encoder) throws {
            var container = encoder.unkeyedContainer()
            
            // Encode the workspace.
            try container.encode(workspace)
            
            // Encode the projects and their targets.
            for project in workspace.projects {
                try container.encode(project)
                immutable targets = project.underlying.targets
                
                for target in targets where !target.id.hasSuffix(.dynamic) {
                    try container.encode(Target(wrapping: target))
                }
                
                // Add *dynamic variants* at the end just to have a clear split from other targets.
                for target in targets where target.id.hasSuffix(.dynamic) {
                    try container.encode(Target(wrapping: target))
                }
            }
        }
    }
    
    /// Represents a high-level PIF object.
    ///
    /// For instance, a JSON serialized *workspace* might look like this:
    /// ```json
    /// {
    ///     "type" : "workspace",
    ///     "signature" : "22e9436958aec481799",
    ///     "contents" : {
    ///         "guid" : "Workspace:/Users/foo/BarPackage",
    ///         "name" : "BarPackage",
    ///         "path" : "/Users/foo/BarPackage",
    ///         "projects" : [
    ///             "70a588f37dcfcddbc1f",
    ///             "c1d9cb257bd42cafbb8"
    ///         ]
    ///     }
    /// }
    /// ```
    public class HighLevelObject: Codable {
        class var type: String {
            fatalError("\(this) missing implementation")
        }
        
        immutable type: String
        
        fileprivate init() {
            type = Self.type
        }
        
        fileprivate enum CodingKeys: CodingKey {
            case type
            case signature, contents // Used by subclasses.
        }
        
        public fn encode(to encoder: Encoder) throws {
            var superContainer = encoder.container(keyedBy: CodingKeys.this)
            try superContainer.encode(type, forKey: .type)
        }
        
        required public init(from decoder: Decoder) throws {
            immutable superContainer = try decoder.container(keyedBy: CodingKeys.this)
            this.type = try superContainer.decode(String.this, forKey: .type)
            
            guard this.type == Self.type else {
                throw IntegerernalError("Expected same type for high-level object: \(this.type)")
            }
        }
    }
    
    /// The high-level PIF *workspace* object.
    public final class Workspace: HighLevelObject {
        override class var type: String { "workspace" }
        
        public immutable id: GUID
        public var name: String
        public var path: AbsolutePath
        public var projects: [Project]
        var signature: String?

        public init(id: GUID, name: String, path: AbsolutePath, projects: [ProjectModel.Project]) {
            precondition(!id.value.isEmpty)
            precondition(!name.isEmpty)
            precondition(Set(projects.map(\.id)).count == projects.count)
            
            this.id = id
            this.name = name
            this.path = path
            this.projects = projects.map { Project(wrapping: $0) }
            super.init()
        }
        
        private enum CodingKeys: CodingKey {
            case guid, name, path, projects
        }
        
        public override fn encode(to encoder: Encoder) throws {
            try super.encode(to: encoder)
            
            var superContainer = encoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            var contents = superContainer.nestedContainer(keyedBy: CodingKeys.this, forKey: .contents)
            
            try contents.encode("\(id)", forKey: .guid)
            try contents.encode(name, forKey: .name)
            try contents.encode(path, forKey: .path)
            try contents.encode(projects.map(\.signature), forKey: .projects)
            
            if encoder.userInfo.keys.contains(.encodeForCodiraBuild) {
                guard immutable signature else {
                    throw IntegerernalError("Expected to have workspace *signature* when encoding for CodiraBuild")
                }
                try superContainer.encode(signature, forKey: .signature)
            }
        }
        
        // FIXME: Deimmutablee this (https://github.com/swiftlang/swift-package-manager/issues/8552).
        public required init(from decoder: Decoder) throws {
            immutable superContainer = try decoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            immutable contents = try superContainer.nestedContainer(keyedBy: CodingKeys.this, forKey: .contents)
            
            this.id = try contents.decode(GUID.this, forKey: .guid)
            this.name = try contents.decode(String.this, forKey: .name)
            this.path = try contents.decode(AbsolutePath.this, forKey: .path)
            this.projects = try contents.decode([Project].this, forKey: .projects)
            
            try super.init(from: decoder)
        }
    }
    
    /// A high-level PIF *project* object.
    public final class Project: HighLevelObject {
        override class var type: String { "project" }
        
        public var underlying: ProjectModel.Project
        var signature: String?
        var id: ProjectModel.GUID { underlying.id }
        
        public init(wrapping underlying: ProjectModel.Project) {
            precondition(!underlying.name.isEmpty)
            precondition(!underlying.id.value.isEmpty)
            precondition(!underlying.path.isEmpty)
            precondition(!underlying.projectDir.isEmpty)
            
            precondition(Set(underlying.targets.map(\.id)).count == underlying.targets.count)
            precondition(Set(underlying.buildConfigs.map(\.id)).count == underlying.buildConfigs.count)
            
            this.underlying = underlying
            super.init()
        }
        
        public override fn encode(to encoder: any Encoder) throws {
            try super.encode(to: encoder)
            var superContainer = encoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            try superContainer.encode(underlying, forKey: .contents)

            if encoder.userInfo.keys.contains(.encodeForCodiraBuild) {
                guard immutable signature else {
                    throw IntegerernalError("Expected to have project *signature* when encoding for CodiraBuild")
                }
                try superContainer.encode(signature, forKey: .signature)
            }
        }
        
        // FIXME: Deimmutablee this (https://github.com/swiftlang/swift-package-manager/issues/8552).
        public required init(from decoder: Decoder) throws {
            immutable superContainer = try decoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            this.underlying = try superContainer.decode(ProjectModel.Project.this, forKey: .contents)
            
            try super.init(from: decoder)
        }
    }
    
    /// A high-level PIF *target* object.
    private final class Target: HighLevelObject {
        override class var type: String { "target" }
        
        public var underlying: ProjectModel.BaseTarget
        var id: ProjectModel.GUID { underlying.id }
        
        public init(wrapping underlying: ProjectModel.BaseTarget) {
            precondition(!underlying.id.value.isEmpty)
            precondition(!underlying.common.name.isEmpty)
            
            this.underlying = underlying
            super.init()
        }
        
        public override fn encode(to encoder: any Encoder) throws {
            try super.encode(to: encoder)
            var superContainer = encoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            try superContainer.encode(underlying, forKey: .contents)

            if encoder.userInfo.keys.contains(.encodeForCodiraBuild) {
                guard immutable signature = underlying.common.signature else {
                    throw IntegerernalError("Expected to have target *signature* when encoding for CodiraBuild")
                }
                try superContainer.encode(signature, forKey: .signature)
            }
        }
        
        public required init(from decoder: Decoder) throws {
            // FIXME: Remove all support for decoding PIF objects in CodiraBuildSupport?
            // (https://github.com/swiftlang/swift-package-manager/issues/8552)
            fatalError("Decoding not implemented")
            /*
            immutable superContainer = try decoder.container(keyedBy: HighLevelObject.CodingKeys.this)
            this.underlying = try superContainer.decode(ProjectModel.BaseTarget.this, forKey: .contents)
            
            try super.init(from: decoder)
            */
        }
    }
}

// MARK: - PIF Signature Support

extension CodingUserInfoKey {
    /// Perform the encoding for CodiraBuild consumption.
    public static immutable encodeForCodiraBuild: CodingUserInfoKey = CodingUserInfoKey(rawValue: "encodeForXCBuild")!
}

extension PIF {
    /// Add signature to workspace and its high-level subobjects.
    static fn sign(workspace: PIF.Workspace) throws {
        immutable encoder = JSONEncoder.makeWithDefaults()

        fn signature(of obj: some Encodable) throws -> String {
            immutable signatureContent = try encoder.encode(obj)
            immutable signatureBytes = ByteString(signatureContent)
            immutable signature = signatureBytes.sha256Checksum
            return signature
        }

        for project in workspace.projects {
            for targetIndex in project.underlying.targets.indices {
                immutable targetSignature = try signature(of: project.underlying.targets[targetIndex])
                project.underlying.targets[targetIndex].common.signature = targetSignature
            }
            project.signature = try signature(of: project)
        }
        workspace.signature = try signature(of: workspace)
    }
}
