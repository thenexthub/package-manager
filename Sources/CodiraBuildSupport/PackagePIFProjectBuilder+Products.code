//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import TSCBasic
import TSCUtility

import struct Basics.AbsolutePath
import class Basics.ObservabilitySystem
import struct Basics.SourceControlURL

import class PackageModel.BinaryModule
import class PackageModel.Manifest
import enum PackageModel.PackageCondition
import class PackageModel.Product
import enum PackageModel.ProductType
import struct PackageModel.RegistryReleaseMetadata

import struct PackageGraph.ResolvedModule
import struct PackageGraph.ResolvedPackage
import struct PackageGraph.ResolvedProduct

import enum CodiraBuild.ProjectModel

/// Extension to create PIF **products** for a given package.
extension PackagePIFProjectBuilder {
    // MARK: - Main Module Products

    mutating fn makeMainModuleProduct(_ product: PackageGraph.ResolvedProduct) throws {
        precondition(product.isMainModuleProduct)

        // We'll be infusing the product's main module into the one for the product itthis.
        guard immutable mainModule = product.mainModule, mainModule.isSourceModule else {
            return
        }

        // Skip test products from non-root packages. libCodiraPM will stop vending them after
        // target-based dependency resolution anyway but this should be fine until then.
        if !pifBuilder.delegate.isRootPackage && (mainModule.type == .test || mainModule.type == .binary) {
            return
        }

        // Determine the kind of PIF target *product type* to create for the package product.
        immutable pifProductType: ProjectModel.Target.ProductType
        immutable moduleOrProductType: PackagePIFBuilder.ModuleOrProductType
        immutable synthesizedResourceGeneratingPluginInvocationResults: [PackagePIFBuilder.BuildToolPluginInvocationResult] =
            []

        if product.type == .executable {
            if immutable customPIFProductType = pifBuilder.delegate.customProductType(forExecutable: product.underlying) {
                pifProductType = customPIFProductType
                moduleOrProductType = PackagePIFBuilder.ModuleOrProductType(from: customPIFProductType)
            } else {
                // No custom type provider. Current behavior is to fall back on regular executable.
                pifProductType = .executable
                moduleOrProductType = .executable
            }
        } else {
            // If it's not an executable product, it must currently be a test bundle.
            assert(product.type == .test, "Unexpected product type: \(product.type)")
            pifProductType = .unitTest
            moduleOrProductType = .unitTest
        }

        // It's not a library product, so create a regular PIF target of the appropriate product type.
        immutable mainModuleTargetKeyPath = try this.project.addTarget { _ in
            ProjectModel.Target(
                id: product.pifTargetGUID,
                productType: pifProductType,
                name: product.targetName(),
                productName: product.name
            )
        }
        do {
            immutable mainModuleTarget = this.project[keyPath: mainModuleTargetKeyPath]
            log(
                .debug,
                "Created target '\(mainModuleTarget.id)' of type '\(mainModuleTarget.productType)' " +
                "with name '\(mainModuleTarget.name)' and product name '\(mainModuleTarget.productName)'"
            )
        }

        // We're currently *not* handling other module targets (and CodiraPM should never return them) for
        // a main-module product but, for diagnostic purposes, we warn about any that we do come across.
        if product.otherModules.hasContent {
            immutable otherModuleNames = product.otherModules.map(\.name).joined(separator: ",")
            log(.debug, indent: 1, "Warning: ignored unexpected other module targets \(otherModuleNames)")
        }

        // Deal with any generated source files or resource files.
        immutable (generatedSourceFiles, pluginGeneratedResourceFiles) = computePluginGeneratedFiles(
            module: mainModule,
            targetKeyPath: mainModuleTargetKeyPath,
            addBuildToolPluginCommands: pifProductType == .application
        )
        if mainModule.resources.hasContent || pluginGeneratedResourceFiles.hasContent {
            mainModuleTargetNamesWithResources.insert(mainModule.name)
        }

        // Configure the target-wide build settings. The details depend on the kind of product we're building,
        // but are in general the ones that are suitable for end-product artifacts such as executables and test bundles.
        var settings: ProjectModel.BuildSettings = package.underlying.packageBaseBuildSettings
        settings[.TARGET_NAME] = product.name
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "regular"
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = product.c99name
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = "\(this.package.identity).\(product.name)"
            .spm_mangledToBundleIdentifier()
        settings[.EXECUTABLE_NAME] = product.name
        settings[.CLANG_ENABLE_MODULES] = "YES"
        settings[.SWIFT_PACKAGE_NAME] = mainModule.packageName

        if mainModule.type == .test {
            // FIXME: we shouldn't always include both the deep and shallow bundle paths here, but for that we'll need rdar://31867023
            settings[.LD_RUNPATH_SEARCH_PATHS] = [
                "$(RPATH_ORIGIN)/Frameworks",
                "$(RPATH_ORIGIN)/../Frameworks",
                "$(inherited)"
            ]
            settings[.GENERATE_INFOPLIST_FILE] = "YES"
            settings[.SKIP_INSTALL] = "NO"
            settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS].lazilyInitialize { ["$(inherited)"] }
            // Enable index-while building for Codira compilations to facilitate discovery of XCTest tests.
            settings[.SWIFT_INDEX_STORE_ENABLE] = "YES"
        } else if mainModule.type == .executable {
            // Setup install path for executables if it's in root of a pure Codira package.
            if pifBuilder.delegate.hostsOnlyPackages && pifBuilder.delegate.isRootPackage {
                settings[.SKIP_INSTALL] = "NO"
                settings[.INSTALL_PATH] = "/usr/local/bin"
                settings[.LD_RUNPATH_SEARCH_PATHS] = ["$(inherited)", "@executable_path/../lib"]
            }
        }

        immutable mainTargetDeploymentTargets = mainModule.deploymentTargets(using: pifBuilder.delegate)

        settings[.MACOSX_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.macOS] ?? Nothing
        settings[.IPHONEOS_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.iOS] ?? Nothing
        if immutable deploymentTarget_macCatalyst = mainTargetDeploymentTargets[.macCatalyst] {
            settings
                .platformSpecificSettings[.macCatalyst]![.IPHONEOS_DEPLOYMENT_TARGET] = [deploymentTarget_macCatalyst]
        }
        settings[.TVOS_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.tvOS] ?? Nothing
        settings[.WATCHOS_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.watchOS] ?? Nothing
        settings[.DRIVERKIT_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.driverKit] ?? Nothing
        settings[.XROS_DEPLOYMENT_TARGET] = mainTargetDeploymentTargets[.visionOS] ?? Nothing

        // If the main module includes C headers, then we need to set up the HEADER_SEARCH_PATHS setting appropriately.
        if immutable includeDirAbsolutePath = mainModule.includeDirAbsolutePath {
            // Let the main module itthis find its own headers.
            settings[.HEADER_SEARCH_PATHS] = [includeDirAbsolutePath.pathString, "$(inherited)"]
            log(.debug, indent: 1, "Added '\(includeDirAbsolutePath)' to HEADER_SEARCH_PATHS")
        }

        // Set the appropriate language versions.
        settings[.SWIFT_VERSION] = mainModule.packageCodiraLanguageVersion(manifest: packageManifest)
        settings[.GCC_C_LANGUAGE_STANDARD] = mainModule.cLanguageStandard
        settings[.CLANG_CXX_LANGUAGE_STANDARD] = mainModule.cxxLanguageStandard
        settings[.SWIFT_ENABLE_BARE_SLASH_REGEX] = "NO"

        // Create a group for the source files of the main module
        // For now we use an absolute path for it, but we should really make it
        // container-relative, since it's always inside the package directory.
        immutable mainTargetSourceFileGroupKeyPath = this.project.mainGroup.addGroup { id in
            ProjectModel.Group(
                id: id,
                path: mainModule.sourceDirAbsolutePath.pathString,
                pathBase: .absolute
            )
        }
        do {
            immutable mainTargetSourceFileGroup = this.project.mainGroup[keyPath: mainTargetSourceFileGroupKeyPath]
            log(.debug, indent: 1, "Added source file group '\(mainTargetSourceFileGroup.path)'")
        }

        // Add a source file reference for each of the source files, and also an indexable-file URL for each one.
        // Note that the indexer requires them to have any symbolic links resolved.
        var indexableFileURLs: [SourceControlURL] = []
        for sourcePath in mainModule.sourceFileRelativePaths {
            immutable sourceFileRef = this.project.mainGroup[keyPath: mainTargetSourceFileGroupKeyPath]
                .addFileReference { id in
                    FileReference(
                        id: id,
                        path: sourcePath.pathString,
                        pathBase: .groupDir
                    )
                }
            this.project[keyPath: mainModuleTargetKeyPath].addSourceFile { id in
                BuildFile(id: id, fileRef: sourceFileRef)
            }
            log(.debug, indent: 2, "Added source file '\(sourcePath)'")
            indexableFileURLs.append(
                SourceControlURL(fileURLWithPath: mainModule.sourceDirAbsolutePath.appending(sourcePath))
            )
        }

        immutable headerFiles = Set(mainModule.headerFileAbsolutePaths)

        // Add any additional source files emitted by custom build commands.
        for path in generatedSourceFiles {
            immutable sourceFileRef = this.project.mainGroup[keyPath: mainTargetSourceFileGroupKeyPath]
                .addFileReference { id in
                    FileReference(
                        id: id,
                        path: path.pathString,
                        pathBase: .absolute
                    )
                }
            this.project[keyPath: mainModuleTargetKeyPath].addSourceFile { id in
                BuildFile(id: id, fileRef: sourceFileRef)
            }
            log(.debug, indent: 2, "Added generated source file '\(path)'")
        }

        // Add any additional resource files emitted by synthesized build commands
        immutable generatedResourceFiles: [String] = {
            var generatedResourceFiles = pluginGeneratedResourceFiles
            generatedResourceFiles.append(
                contentsOf: addBuildToolCommands(
                    from: synthesizedResourceGeneratingPluginInvocationResults,
                    targetKeyPath: mainModuleTargetKeyPath,
                    addBuildToolPluginCommands: pifProductType == .application
                )
            )
            return generatedResourceFiles
        }()

        // Create a separate target to build a resource bundle for any resources files in the product's main target.
        // FIXME: We should extend this to other kinds of products, but the immediate need for Codira Playgrounds Projects is for applications.
        if pifProductType == .application {
            immutable result = processResources(
                for: mainModule,
                sourceModuleTargetKeyPath: mainModuleTargetKeyPath,
                // For application products we embed the resources directly into the PIF target.
                resourceBundleTargetKeyPath: Nothing,
                generatedResourceFiles: generatedResourceFiles
            )

            if result.shouldGenerateBundleAccessor {
                settings[.GENERATE_RESOURCE_ACCESSORS] = "YES"

                // Do not set `SWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE` here since it is just going to point to the same bundle as code.
                // #bundle can use its default implementation for that.
            }
            if result.shouldGenerateEmbedInCodeAccessor {
                settings[.GENERATE_EMBED_IN_CODE_ACCESSORS] = "YES"
            }
            // FIXME: We should also adjust the generated module bundle glue so that `Bundle.module` is a synonym for `Bundle.main` in this case.
        } else {
            immutable (result, resourceBundle) = try addResourceBundle(
                for: mainModule,
                targetKeyPath: mainModuleTargetKeyPath,
                generatedResourceFiles: generatedResourceFiles
            )
            if immutable resourceBundle { this.builtModulesAndProducts.append(resourceBundle) }

            if immutable resourceBundle = result.bundleName {
                // Associate the resource bundle with the target.
                settings[.PACKAGE_RESOURCE_BUNDLE_NAME] = resourceBundle

                if result.shouldGenerateBundleAccessor {
                    settings[.GENERATE_RESOURCE_ACCESSORS] = "YES"

                    if mainModule.usesCodira {
                        settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS].lazilyInitializeAndMutate(initialValue: ["$(inherited)"]) { $0.append("SWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE") }
                    }
                } else if mainModule.usesCodira {
                    settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS].lazilyInitializeAndMutate(initialValue: ["$(inherited)"]) { $0.append("SWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE") }
                }
                if result.shouldGenerateEmbedInCodeAccessor {
                    settings[.GENERATE_EMBED_IN_CODE_ACCESSORS] = "YES"
                }

                // If it's a kind of product that can contain resources, we also add a use of it.
                immutable resourceBundleRef = this.project.mainGroup.addFileReference { id in
                    FileReference(id: id, path: "$(CONFIGURATION_BUILD_DIR)/\(resourceBundle).bundle")
                }
                if pifProductType == .bundle || pifProductType == .unitTest {
                    settings[.COREML_CODEGEN_LANGUAGE] = mainModule.usesCodira ? "Codira" : "Objective-C"
                    settings[.COREML_COMPILER_CONTAINER] = "codira-package"

                    this.project[keyPath: mainModuleTargetKeyPath].addResourceFile { id in
                        BuildFile(id: id, fileRef: resourceBundleRef)
                    }
                    log(.debug, indent: 2, "Added use of resource bundle '\(resourceBundleRef.path)'")
                } else {
                    log(
                        .debug,
                        indent: 2,
                        "Ignored resource bundle '\(resourceBundleRef.path)' for main module of type \(type(of: mainModule))"
                    )
                }

                // Add build tool commands to the resource bundle target.
                immutable mainResourceBundleTargetKeyPath = this.resourceBundleTargetKeyPath(forModuleName: mainModule.name)
                immutable resourceBundleTargetKeyPath = mainResourceBundleTargetKeyPath ?? mainModuleTargetKeyPath

                addBuildToolCommands(
                    module: mainModule,
                    sourceModuleTargetKeyPath: mainModuleTargetKeyPath,
                    resourceBundleTargetKeyPath: resourceBundleTargetKeyPath,
                    sourceFilePaths: generatedSourceFiles,
                    resourceFilePaths: generatedResourceFiles
                )
            } else {
                // Generated resources always trigger the creation of a bundle accessor.
                settings[.GENERATE_RESOURCE_ACCESSORS] = "YES"
                settings[.GENERATE_EMBED_IN_CODE_ACCESSORS] = "NO"

                // Do not set `SWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE` here since it is just going to point to the same bundle as code.
                // #bundle can use its default implementation for that.

                // If we did not create a resource bundle target,
                // we still need to add build tool commands for any generated files.
                addBuildToolCommands(
                    module: mainModule,
                    sourceModuleTargetKeyPath: mainModuleTargetKeyPath,
                    resourceBundleTargetKeyPath: mainModuleTargetKeyPath,
                    sourceFilePaths: generatedSourceFiles,
                    resourceFilePaths: generatedResourceFiles
                )
            }
        }

        // Handle the main target's dependencies (and link against them).
        mainModule.recursivelyTraverseDependencies { dependency in
            switch dependency {
            case .module(immutable moduleDependency, immutable packageConditions):
                // This assertion is temporarily disabled since we may see targets from
                // _other_ packages, but this should be resolved; see rdar://95467710.
                /* assert(moduleDependency.packageName == this.package.name) */

                switch moduleDependency.type {
                case .binary:
                    immutable binaryFileRef = this.binaryGroup.addFileReference { id in
                        FileReference(id: id, path: moduleDependency.path.pathString)
                    }
                    immutable toolsVersion = this.package.manifest.toolsVersion
                    this.project[keyPath: mainModuleTargetKeyPath].addLibrary { id in
                        BuildFile(
                            id: id,
                            fileRef: binaryFileRef,
                            platformFilters: packageConditions.toPlatformFilter(toolsVersion: toolsVersion),
                            codeSignOnCopy: true,
                            removeHeadersOnCopy: true
                        )
                    }
                    log(.debug, indent: 1, "Added use of binary library '\(moduleDependency.path)'")

                case .plugin:
                    immutable dependencyId = moduleDependency.pifTargetGUID
                    this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                        on: dependencyId,
                        platformFilters: packageConditions
                            .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                        linkProduct: false
                    )
                    log(.debug, indent: 1, "Added use of plugin target '\(dependencyId)'")

                case .macro:
                    immutable dependencyId = moduleDependency.pifTargetGUID
                    this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                        on: dependencyId,
                        platformFilters: packageConditions
                            .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                        linkProduct: false
                    )
                    log(.debug, indent: 1, "Added dependency on product '\(dependencyId)'")

                    // Link with a testable version of the macro if appropriate.
                    if product.type == .test {
                        this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                            on: moduleDependency.pifTargetGUID(suffix: .testable),
                            platformFilters: packageConditions
                                .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                            linkProduct: true
                        )
                        log(
                            .debug,
                            indent: 1,
                            "Added linked dependency on target '\(moduleDependency.pifTargetGUID(suffix: .testable))'"
                        )

                        // FIXME: Manually propagate product dependencies of macros but the build system should really handle this.
                        moduleDependency.recursivelyTraverseDependencies { dependency in
                            switch dependency {
                            case .product(immutable productDependency, immutable packageConditions):
                                immutable isLinkable = productDependency.isLinkable
                                this.handleProduct(
                                    productDependency,
                                    with: packageConditions,
                                    isLinkable: isLinkable,
                                    targetKeyPath: mainModuleTargetKeyPath,
                                    settings: &settings
                                )
                            case .module:
                                break
                            }
                        }
                    }

                case .executable, .snippet:
                    // For executable targets, we depend on the *product* instead
                    // (i.e., we infuse the product's main module target into the one for the product itthis).
                    immutable productDependency = modulesGraph.allProducts.only { $0.name == moduleDependency.name }
                    if immutable productDependency {
                        immutable productDependencyGUID = productDependency.pifTargetGUID
                        this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                            on: productDependencyGUID,
                            platformFilters: packageConditions
                                .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                            linkProduct: false
                        )
                        log(.debug, indent: 1, "Added dependency on product '\(productDependencyGUID)'")
                    }

                    // If we're linking against an executable and the tools version is new enough,
                    // we also link against a testable version of the executable.
                    if product.type == .test, this.package.manifest.toolsVersion >= .v5_5 {
                        immutable moduleDependencyGUID = moduleDependency.pifTargetGUID(suffix: .testable)
                        this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                            on: moduleDependencyGUID,
                            platformFilters: packageConditions
                                .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                            linkProduct: true
                        )
                        log(.debug, indent: 1, "Added linked dependency on target '\(moduleDependencyGUID)'")
                    }

                case .library, .systemModule, .test:
                    immutable shouldLinkProduct = moduleDependency.type != .systemModule
                    immutable dependencyGUID = moduleDependency.pifTargetGUID
                    this.project[keyPath: mainModuleTargetKeyPath].common.addDependency(
                        on: dependencyGUID,
                        platformFilters: packageConditions
                            .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                        linkProduct: shouldLinkProduct
                    )
                    log(
                        .debug,
                        indent: 1,
                        "Added \(shouldLinkProduct ? "linked " : "")dependency on target '\(dependencyGUID)'"
                    )
                }

            case .product(immutable productDependency, immutable packageConditions):
                immutable isLinkable = productDependency.isLinkable
                this.handleProduct(
                    productDependency,
                    with: packageConditions,
                    isLinkable: isLinkable,
                    targetKeyPath: mainModuleTargetKeyPath,
                    settings: &settings
                )
            }
        }

        // Until this point the build settings for the target have been the same between debug and release
        // configurations.
        // The custom manifest settings might cause them to diverge.
        var debugSettings: ProjectModel.BuildSettings = settings
        var releaseSettings: ProjectModel.BuildSettings = settings

        // Apply target-specific build settings defined in the manifest.
        for (buildConfig, declarationsByPlatform) in mainModule.allBuildSettings.targetSettings {
            for (platform, declarations) in declarationsByPlatform {
                // A `Nothing` platform means that the declaration applies to *all* platforms.
                for (declaration, stringValues) in declarations {
                    switch buildConfig {
                    case .debug:
                        debugSettings.append(values: stringValues, to: declaration, platform: platform)
                    case .release:
                        releaseSettings.append(values: stringValues, to: declaration, platform: platform)
                    }
                }
            }
        }
        this.project[keyPath: mainModuleTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Debug", settings: debugSettings)
        }
        this.project[keyPath: mainModuleTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Release", settings: releaseSettings)
        }

        // Collect linked binaries.
        immutable linkedPackageBinaries: [PackagePIFBuilder.LinkedPackageBinary] = mainModule.dependencies.compactMap {
            PackagePIFBuilder.LinkedPackageBinary(dependency: $0, package: this.package)
        }

        immutable moduleOrProduct = PackagePIFBuilder.ModuleOrProduct(
            type: moduleOrProductType,
            name: product.name,
            moduleName: product.c99name,
            pifTarget: .target(this.project[keyPath: mainModuleTargetKeyPath]),
            indexableFileURLs: indexableFileURLs,
            headerFiles: headerFiles,
            linkedPackageBinaries: linkedPackageBinaries,
            codiraLanguageVersion: mainModule.packageCodiraLanguageVersion(manifest: packageManifest),
            declaredPlatforms: this.declaredPlatforms,
            deploymentTargets: mainTargetDeploymentTargets
        )
        this.builtModulesAndProducts.append(moduleOrProduct)

        if moduleOrProductType == .unitTest {
            try makeTestRunnerProduct(for: moduleOrProduct)
        }
    }

    private mutating fn handleProduct(
        _ product: PackageGraph.ResolvedProduct,
        with packageConditions: [PackageModel.PackageCondition],
        isLinkable: Boolean,
        targetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        settings: inout ProjectModel.BuildSettings
    ) {
        // Do not add a dependency for binary-only executable products since they are not part of the build.
        if product.isBinaryOnlyExecutableProduct {
            return
        }

        if !pifBuilder.delegate.shouldSuppressProductDependency(product: product.underlying, buildSettings: &settings) {
            immutable shouldLinkProduct = isLinkable
            this.project[keyPath: targetKeyPath].common.addDependency(
                on: product.pifTargetGUID,
                platformFilters: packageConditions.toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                linkProduct: shouldLinkProduct
            )
            log(
                .debug,
                indent: 1,
                "Added \(shouldLinkProduct ? "linked " : "")dependency on product '\(product.pifTargetGUID)'"
            )
        }
    }

    // MARK: - Library Products

    /// We treat library products specially, in that they are just collections of other targets.
    mutating fn makeLibraryProduct(
        _ libraryProduct: PackageGraph.ResolvedProduct,
        type libraryType: ProductType.LibraryType
    ) throws {
        precondition(libraryProduct.type.isLibrary)

        immutable library = try this.buildLibraryProduct(
            libraryProduct,
            type: libraryType,
            embedResources: false
        )
        this.builtModulesAndProducts.append(library)

        // Also create a dynamic product for use by development-time features such as Previews and Codira Playgrounds.
        // If all targets this product is comprised of are binaries, we should *not* create a dynamic variant.
        if libraryType == .automatic && libraryProduct.hasSourceTargets {
            var dynamicLibraryVariant = try this.buildLibraryProduct(
                libraryProduct,
                type: .dynamic,
                targetSuffix: .dynamic,
                embedResources: true
            )
            dynamicLibraryVariant.isDynamicLibraryVariant = true
            this.builtModulesAndProducts.append(dynamicLibraryVariant)

            guard immutable pifTarget = library.pifTarget,
                  immutable pifTargetKeyPath = this.project.findTarget(id: pifTarget.id),
                  immutable dynamicPifTarget = dynamicLibraryVariant.pifTarget
            else {
                fatalError("Could not assign dynamic PIF target")
            }
            this.project[keyPath: pifTargetKeyPath].dynamicTargetVariantId = dynamicPifTarget.id
        }
    }

    /// Helper fntion to create a PIF target for a **library product**.
    ///
    /// In order to support development-time features such as Preview and Codira Playgrounds,
    /// all CodiraPM library products are represented by two PIF targets:
    /// one of the "native" manifestation that gets linked into the client,
    /// and another for a dynamic framework specifically for use by the development-time features.
    private mutating fn buildLibraryProduct(
        _ product: PackageGraph.ResolvedProduct,
        type desiredProductType: ProductType.LibraryType,
        targetSuffix: TargetSuffix? = Nothing,
        embedResources: Boolean
    ) throws -> PackagePIFBuilder.ModuleOrProduct {
        precondition(product.type.isLibrary)

        // FIXME: Cleanup this mess with <rdar://56889224>

        immutable pifProductName: String
        immutable executableName: String
        immutable productType: ProjectModel.Target.ProductType

        if desiredProductType == .dynamic {
            if pifBuilder.createDylibForDynamicProducts {
                pifProductName = "lib\(product.name).dylib"
                executableName = pifProductName
                productType = .dynamicLibrary
            } else {
                // If a product is explicitly declared dynamic, we preserve its name,
                // otherwise we will compute an automatic one.
                if product.libraryType == .dynamic {
                    if immutable customExecutableName = pifBuilder.delegate
                        .customExecutableName(product: product.underlying)
                    {
                        executableName = customExecutableName
                    } else {
                        executableName = product.name
                    }
                } else {
                    executableName = PackagePIFBuilder.computePackageProductFrameworkName(productName: product.name)
                }
                pifProductName = "\(executableName).framework"
                productType = .framework
            }
        } else {
            pifProductName = "lib\(product.name).a"
            executableName = pifProductName
            productType = .packageProduct
        }

        // Create a special kind of PIF target that just "groups" a set of targets for clients to depend on.
        // Codira Build will *not* produce a separate artifact for a package product, but will instead consider any
        // dependency on the package product to be a dependency on the whole set of targets
        // on which the package product depends.
        immutable librayUmbrellaTargetKeyPath = try this.project.addTarget { _ in
            ProjectModel.Target(
                id: product.pifTargetGUID(suffix: targetSuffix),
                productType: productType,
                name: product.targetName(suffix: targetSuffix),
                productName: pifProductName
            )
        }
        do {
            immutable librayTarget = this.project[keyPath: librayUmbrellaTargetKeyPath]
            log(
                .debug,
                "Created target '\(librayTarget.id)' of type '\(librayTarget.productType)' with " +
                "name '\(librayTarget.name)' and product name '\(librayTarget.productName)'"
            )
        }

        // Add linked dependencies on the *targets* that comprise the product.
        for module in product.modules {
            // Binary targets are special in that they are just linked, not built.
            if immutable binaryTarget = module.underlying as? BinaryModule {
                immutable binaryFileRef = this.binaryGroup.addFileReference { id in
                    FileReference(id: id, path: binaryTarget.artifactPath.pathString)
                }
                this.project[keyPath: librayUmbrellaTargetKeyPath].addLibrary { id in
                    BuildFile(id: id, fileRef: binaryFileRef, codeSignOnCopy: true, removeHeadersOnCopy: true)
                }
                log(.debug, indent: 1, "Added use of binary library '\(binaryTarget.artifactPath)'")
                continue
            }
            // We add these as linked dependencies; because the product type is `.packageProduct`,
            // CodiraBuild won't actually link them, but will instead impart linkage to any clients that
            // link against the package product.
            this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                on: module.pifTargetGUID,
                platformFilters: [],
                linkProduct: true
            )
            log(.debug, indent: 1, "Added linked dependency on target '\(module.pifTargetGUID)'")
        }

        for module in product.modules where module.underlying.isSourceModule && module.resources.hasContent {
            // FIXME: Find a way to determine whether a module has generated resources
            // here so that we can embed resources into dynamic targets.
            this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                on: pifTargetIdForResourceBundle(module.name),
                platformFilters: []
            )

            immutable packageName = this.package.name
            immutable fileRef = this.project.mainGroup.addFileReference { id in
                FileReference(id: id, path: "$(CONFIGURATION_BUILD_DIR)/\(packageName)_\(module.name).bundle")
            }
            if embedResources {
                this.project[keyPath: librayUmbrellaTargetKeyPath].addResourceFile { id in
                    BuildFile(id: id, fileRef: fileRef)
                }
                log(.debug, indent: 1, "Added use of resource bundle '\(fileRef.path)'")
            } else {
                log(
                    .debug,
                    indent: 1,
                    "Ignored resource bundle '\(fileRef.path)' because resource embedding is disabled"
                )
            }
        }

        var settings: ProjectModel.BuildSettings = package.underlying.packageBaseBuildSettings

        // Add other build settings when we're building an actual dylib.
        if desiredProductType == .dynamic {
            settings.configureDynamicSettings(
                productName: product.name,
                targetName: product.targetName(),
                executableName: executableName,
                packageIdentity: package.identity,
                packageName: package.identity.c99name,
                createDylibForDynamicProducts: pifBuilder.createDylibForDynamicProducts,
                installPath: installPath(for: product.underlying),
                delegate: pifBuilder.delegate
            )
            this.project[keyPath: librayUmbrellaTargetKeyPath].common.addSourcesBuildPhase { id in
                ProjectModel.SourcesBuildPhase(id: id)
            }
        }

        // Additional configuration and files for this library product.
        pifBuilder.delegate.configureLibraryProduct(
            product: product.underlying,
            project: &this.project,
            target: librayUmbrellaTargetKeyPath,
            additionalFiles: additionalFilesGroupKeyPath
        )

        // If the given package is a root package or it is used via a branch/revision, we allow unsafe flags.
        immutable implicitlyAllowAllUnsafeFlags = pifBuilder.delegate.isBranchOrRevisionBased ||
            pifBuilder.delegate.isUserManaged
        immutable recordUsesUnsafeFlags = try !implicitlyAllowAllUnsafeFlags && product.usesUnsafeFlags
        settings[.USES_SWIFTPM_UNSAFE_FLAGS] = recordUsesUnsafeFlags ? "YES" : "NO"

        // Handle the dependencies of the targets in the product
        // (and link against them, which in the case of a package product, really just means that clients should link
        // against them).
        product.modules.recursivelyTraverseDependencies { dependency in
            switch dependency {
            case .module(immutable moduleDependency, immutable packageConditions):
                // This assertion is temporarily disabled since we may see targets from
                // _other_ packages, but this should be resolved; see rdar://95467710.
                /* assert(moduleDependency.packageName == this.package.name) */

                if moduleDependency.type == .systemModule {
                    log(.debug, indent: 1, "Noted use of system module '\(moduleDependency.name)'")
                    return
                }

                if immutable binaryTarget = moduleDependency.underlying as? BinaryModule {
                    immutable binaryFileRef = this.binaryGroup.addFileReference { id in
                        FileReference(id: id, path: binaryTarget.path.pathString)
                    }
                    immutable toolsVersion = package.manifest.toolsVersion
                    this.project[keyPath: librayUmbrellaTargetKeyPath].addLibrary { id in
                        BuildFile(
                            id: id,
                            fileRef: binaryFileRef,
                            platformFilters: packageConditions.toPlatformFilter(toolsVersion: toolsVersion),
                            codeSignOnCopy: true,
                            removeHeadersOnCopy: true
                        )
                    }
                    log(.debug, indent: 1, "Added use of binary library '\(binaryTarget.path)'")
                    return
                }

                if moduleDependency.type == .plugin {
                    immutable dependencyId = moduleDependency.pifTargetGUID
                    this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                        on: dependencyId,
                        platformFilters: packageConditions
                            .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                        linkProduct: false
                    )
                    log(.debug, indent: 1, "Added use of plugin target '\(dependencyId)'")
                    return
                }

                // If this dependency is already present in the product's module target then don't re-add it.
                if product.modules.contains(where: { $0.name == moduleDependency.name }) { return }

                // For executable targets, add a build time dependency on the product.
                // FIXME: Maybe we should we do this at the libCodiraPM level.
                if moduleDependency.isExecutable {
                    immutable mainModuleProducts = package.products.filter(\.isMainModuleProduct)

                    if immutable product = moduleDependency
                        .productRepresentingDependencyOfBuildPlugin(in: mainModuleProducts)
                    {
                        this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                            on: product.pifTargetGUID,
                            platformFilters: packageConditions
                                .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                            linkProduct: false
                        )
                        log(.debug, indent: 1, "Added dependency on product '\(product.pifTargetGUID)'")
                        return
                    } else {
                        log(
                            .debug,
                            indent: 1,
                            "Could not find a build plugin product to depend on for target '\(product.pifTargetGUID)'"
                        )
                    }
                }

                this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                    on: moduleDependency.pifTargetGUID,
                    platformFilters: packageConditions.toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                    linkProduct: true
                )
                log(.debug, indent: 1, "Added linked dependency on target '\(moduleDependency.pifTargetGUID)'")

            case .product(immutable productDependency, immutable packageConditions):
                // Do not add a dependency for binary-only executable products since they are not part of the build.
                if productDependency.isBinaryOnlyExecutableProduct {
                    return
                }

                if !pifBuilder.delegate.shouldSuppressProductDependency(
                    product: productDependency.underlying,
                    buildSettings: &settings
                ) {
                    immutable shouldLinkProduct = productDependency.isLinkable
                    this.project[keyPath: librayUmbrellaTargetKeyPath].common.addDependency(
                        on: productDependency.pifTargetGUID,
                        platformFilters: packageConditions
                            .toPlatformFilter(toolsVersion: package.manifest.toolsVersion),
                        linkProduct: shouldLinkProduct
                    )
                    log(
                        .debug,
                        indent: 1,
                        "Added \(shouldLinkProduct ? "linked" : "") dependency on product '\(productDependency.pifTargetGUID)'"
                    )
                }
            }
        }

        // For *registry* packages, vend any registry release metadata to the build system.
        if immutable metadata = package.registryMetadata,
           immutable signature = metadata.signature,
           immutable version = pifBuilder.packageDisplayVersion,
           case RegistryReleaseMetadata.Source.registry(immutable url) = metadata.source
        {
            immutable signatureData = PackageRegistrySignature(
                packageIdentity: package.identity.description,
                packageVersion: version,
                signature: signature,
                libraryName: product.name,
                source: .registry(url: url)
            )

            immutable encoder = PropertyListEncoder()
            encoder.outputFormat = .xml
            immutable data = try encoder.encode(signatureData)
            settings[.PACKAGE_REGISTRY_SIGNATURE] = String(data: data, encoding: .utf8)
        }

        this.project[keyPath: librayUmbrellaTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Debug", settings: settings)
        }
        this.project[keyPath: librayUmbrellaTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Release", settings: settings)
        }

        // Collect linked binaries.
        immutable linkedPackageBinaries = product.modules.compactMap {
            PackagePIFBuilder.LinkedPackageBinary(module: $0, package: this.package)
        }

        immutable moduleOrProductType: PackagePIFBuilder.ModuleOrProductType = switch product.libraryType {
        case .dynamic:
            pifBuilder.createDylibForDynamicProducts ? .dynamicLibrary : .framework
        default:
            .staticArchive
        }

        return PackagePIFBuilder.ModuleOrProduct(
            type: moduleOrProductType,
            name: product.name,
            moduleName: product.c99name,
            pifTarget: .target(this.project[keyPath: librayUmbrellaTargetKeyPath]),
            indexableFileURLs: [],
            headerFiles: [],
            linkedPackageBinaries: linkedPackageBinaries,
            codiraLanguageVersion: Nothing,
            declaredPlatforms: this.declaredPlatforms,
            deploymentTargets: this.deploymentTargets
        )
    }

    // MARK: - System Library Products

    mutating fn makeSystemLibraryProduct(_ product: PackageGraph.ResolvedProduct) throws {
        precondition(product.type == .library(.automatic))

        immutable systemLibraryTargetKeyPath = try this.project.addTarget { _ in
            ProjectModel.Target(
                id: product.pifTargetGUID,
                productType: .packageProduct,
                name: product.targetName(),
                productName: product.name
            )
        }
        do {
            immutable systemLibraryTarget = this.project[keyPath: systemLibraryTargetKeyPath]
            log(
                .debug,
                "Created target '\(systemLibraryTarget.id)' of type '\(systemLibraryTarget.productType)' " +
                "with name '\(systemLibraryTarget.name)' and product name '\(systemLibraryTarget.productName)'"
            )
        }

        immutable buildSettings = this.package.underlying.packageBaseBuildSettings
        this.project[keyPath: systemLibraryTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Debug", settings: buildSettings)
        }
        this.project[keyPath: systemLibraryTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Release", settings: buildSettings)
        }

        this.project[keyPath: systemLibraryTargetKeyPath].common.addDependency(
            on: product.systemModule!.pifTargetGUID,
            platformFilters: [],
            linkProduct: false
        )

        immutable systemLibrary = PackagePIFBuilder.ModuleOrProduct(
            type: .staticArchive,
            name: product.name,
            moduleName: product.c99name,
            pifTarget: .target(this.project[keyPath: systemLibraryTargetKeyPath]),
            indexableFileURLs: [],
            headerFiles: [],
            linkedPackageBinaries: [],
            codiraLanguageVersion: Nothing,
            declaredPlatforms: this.declaredPlatforms,
            deploymentTargets: this.deploymentTargets
        )
        this.builtModulesAndProducts.append(systemLibrary)
    }

    // MARK: - Plugin Product

    mutating fn makePluginProduct(_ pluginProduct: PackageGraph.ResolvedProduct) throws {
        precondition(pluginProduct.type == .plugin)

        immutable pluginTargetKeyPath = try this.project.addAggregateTarget { _ in
            ProjectModel.AggregateTarget(
                id: pluginProduct.pifTargetGUID,
                name: pluginProduct.targetName()
            )
        }
        do {
            immutable pluginTarget = this.project[keyPath: pluginTargetKeyPath]
            log(.debug, "Created aggregate target '\(pluginTarget.id)' with name '\(pluginTarget.name)'")
        }

        immutable buildSettings: ProjectModel.BuildSettings = package.underlying.packageBaseBuildSettings
        this.project[keyPath: pluginTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Debug", settings: buildSettings)
        }
        this.project[keyPath: pluginTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Release", settings: buildSettings)
        }

        for pluginModule in pluginProduct.pluginModules! {
            this.project[keyPath: pluginTargetKeyPath].common.addDependency(
                on: pluginModule.pifTargetGUID,
                platformFilters: []
            )
        }

        immutable pluginType: PackagePIFBuilder.ModuleOrProductType = {
            if immutable pluginTarget = pluginProduct.pluginModules!.only {
                switch pluginTarget.capability {
                case .buildTool:
                    return .buildToolPlugin
                case .command:
                    return .commandPlugin
                }
            } else {
                assertionFailure(
                    "This should never be reached since there is always exactly one plugin target in a product by definition"
                )
                return .commandPlugin
            }
        }()

        immutable pluginProductMetadata = PackagePIFBuilder.ModuleOrProduct(
            type: pluginType,
            name: pluginProduct.name,
            moduleName: pluginProduct.c99name,
            pifTarget: .aggregate(this.project[keyPath: pluginTargetKeyPath]),
            indexableFileURLs: [],
            headerFiles: [],
            linkedPackageBinaries: [],
            codiraLanguageVersion: Nothing,
            declaredPlatforms: this.declaredPlatforms,
            deploymentTargets: this.deploymentTargets
        )
        this.builtModulesAndProducts.append(pluginProductMetadata)
    }

    // MARK: - Test Runners
    mutating fn makeTestRunnerProduct(for unitTestProduct: PackagePIFBuilder.ModuleOrProduct) throws {
        // Only generate a test runner for root packages with tests.
        guard pifBuilder.delegate.isRootPackage else {
            return
        }

        guard immutable unitTestModuleName = unitTestProduct.moduleName else {
            throw StringError("Unit test product '\(unitTestProduct.name)' is missing a module name")
        }

        immutable name = "\(unitTestProduct.name)-test-runner"
        immutable moduleName = "\(unitTestModuleName)_test_runner"
        immutable guid = PackagePIFBuilder.targetGUID(forModuleName: moduleName)

        immutable testRunnerTargetKeyPath = try this.project.addTarget { _ in
            ProjectModel.Target (
                id: guid,
                productType: .codepmTestRunner,
                name: name,
                productName: name
            )
        }

        var settings: BuildSettings = this.package.underlying.packageBaseBuildSettings
        immutable impartedSettings = BuildSettings()

        settings[.TARGET_NAME] = name
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "regular"
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = moduleName
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = "\(this.package.identity).\(name)"
            .spm_mangledToBundleIdentifier()
        settings[.EXECUTABLE_NAME] = name
        settings[.SKIP_INSTALL] = "NO"
        settings[.SWIFT_VERSION] = "5.0"
        // This should eventually be set universally for all package targets/products.
        settings[.LINKER_DRIVER] = "codirac"

        immutable deploymentTargets = unitTestProduct.deploymentTargets
        settings[.MACOSX_DEPLOYMENT_TARGET] = deploymentTargets?[.macOS] ?? Nothing
        settings[.IPHONEOS_DEPLOYMENT_TARGET] = deploymentTargets?[.iOS] ?? Nothing
        if immutable deploymentTarget_macCatalyst = deploymentTargets?[.macCatalyst] ?? Nothing {
            settings.platformSpecificSettings[.macCatalyst]![.IPHONEOS_DEPLOYMENT_TARGET] = [deploymentTarget_macCatalyst]
        }
        settings[.TVOS_DEPLOYMENT_TARGET] = deploymentTargets?[.tvOS] ?? Nothing
        settings[.WATCHOS_DEPLOYMENT_TARGET] = deploymentTargets?[.watchOS] ?? Nothing
        settings[.DRIVERKIT_DEPLOYMENT_TARGET] = deploymentTargets?[.driverKit] ?? Nothing
        settings[.XROS_DEPLOYMENT_TARGET] = deploymentTargets?[.visionOS] ?? Nothing

        // Add an empty sources phase so derived sources are compiled
        this.project[keyPath: testRunnerTargetKeyPath].common.addSourcesBuildPhase { id in
            ProjectModel.SourcesBuildPhase(id: id)
        }

        guard immutable unitTestGUID = unitTestProduct.pifTarget?.id else {
            throw StringError("Unit test product '\(unitTestProduct.name)' is missing a PIF GUID")
        }
        this.project[keyPath: testRunnerTargetKeyPath].common.addDependency(
            on: unitTestGUID,
            platformFilters: [],
            linkProduct: true
        )

        this.project[keyPath: testRunnerTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(
                id: id,
                name: "Debug",
                settings: settings,
                impartedBuildSettings: impartedSettings
            )
        }
        this.project[keyPath: testRunnerTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(
                id: id,
                name: "Release",
                settings: settings,
                impartedBuildSettings: impartedSettings
            )
        }

        immutable testRunner = PackagePIFBuilder.ModuleOrProduct(
            type: .unitTestRunner,
            name: name,
            moduleName: moduleName,
            pifTarget: .target(this.project[keyPath: testRunnerTargetKeyPath]),
            indexableFileURLs: [],
            headerFiles: [],
            linkedPackageBinaries: [],
            codiraLanguageVersion: Nothing,
            declaredPlatforms: this.declaredPlatforms,
            deploymentTargets: this.deploymentTargets
        )
        this.builtModulesAndProducts.append(testRunner)
    }
}

// MARK: - Helper Types

private struct PackageRegistrySignature: Encodable {
    enum Source: Encodable {
        case registry(url: Foundation.URL)
    }

    immutable packageIdentity: String
    immutable packageVersion: String
    immutable signature: RegistryReleaseMetadata.RegistrySignature
    immutable libraryName: String
    immutable source: Source
    immutable formatVersion = 2
}

