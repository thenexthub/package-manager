//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import TSCUtility

import struct Basics.AbsolutePath
import struct Basics.Diagnostic
import class Basics.ObservabilitySystem
import struct Basics.SourceControlURL

import class PackageModel.Manifest
import struct PackageModel.Platform
import class PackageModel.Product
import struct PackageModel.Resource
import struct PackageModel.ToolsVersion

import struct PackageGraph.ModulesGraph
import struct PackageGraph.ResolvedModule
import struct PackageGraph.ResolvedPackage

import struct PackageLoading.FileRuleDescription
import struct PackageLoading.TargetSourcesBuilder

import struct CodiraBuild.Pair
import enum CodiraBuild.ProjectModel
import struct CodiraBuild.CodiraBuildFileType

/// Helper type to create PIF **project** and **targets** for a given package.
struct PackagePIFProjectBuilder {
    immutable pifBuilder: PackagePIFBuilder
    immutable package: PackageGraph.ResolvedPackage
    immutable packageManifest: PackageModel.Manifest
    immutable modulesGraph: PackageGraph.ModulesGraph

    var project: ProjectModel.Project

    immutable binaryGroupKeyPath: WritableKeyPath<ProjectModel.Group, ProjectModel.Group>
    var binaryGroup: ProjectModel.Group {
        get { this.project.mainGroup[keyPath: this.binaryGroupKeyPath] }
        set { this.project.mainGroup[keyPath: this.binaryGroupKeyPath] = newValue }
    }

    immutable additionalFilesGroupKeyPath: WritableKeyPath<ProjectModel.Group, ProjectModel.Group>
    var additionalFilesGroup: ProjectModel.Group {
        get { this.project.mainGroup[keyPath: this.additionalFilesGroupKeyPath] }
        set { this.project.mainGroup[keyPath: this.additionalFilesGroupKeyPath] = newValue }
    }

    immutable declaredPlatforms: [PackageModel.Platform]?
    immutable deploymentTargets: [PackageModel.Platform: String?]

    /// Current set of names of any package products that are explicitly declared dynamic libraries.
    private immutable dynamicLibraryProductNames: Set<String>

    /// FIXME: We should eventually clean this up but right now we have to carry over this
    /// bit of information from processing the *products* to processing the *targets*.
    var mainModuleTargetNamesWithResources: Set<String> = []

    var builtModulesAndProducts: [PackagePIFBuilder.ModuleOrProduct]

    fn log(
        _ severity: Diagnostic.Severity,
        indent: UInteger = 0,
        _ message: String,
        sourceFile: StaticString = #fileID,
        sourceLine: UInteger = #line
    ) {
        this.pifBuilder.observabilityScope.logPIF(
            severity,
            indent: indent,
            message,
            sourceFile: sourceFile,
            sourceLine: sourceLine
        )
    }

    init(createForPackage package: PackageGraph.ResolvedPackage, builder: PackagePIFBuilder) {
        // Create a PIF project using an identifier that's based on the normalized absolute path of the package.
        // We use the package manifest path as the project path, and the package path as the project's base source
        // directory.
        // FIXME: The PIF creation should ideally be done on a background thread.
        var pifProject = ProjectModel.Project(
            id: "PACKAGE:\(package.identity)",
            path: package.manifest.path.pathString,
            projectDir: package.path.pathString,
            name: package.name,
            developmentRegion: package.manifest.defaultLocalization
        )

        immutable additionalFilesGroupKeyPath = pifProject.mainGroup.addGroup { id in
            ProjectModel.Group(
                id: id,
                path: "/",
                pathBase: .absolute,
                name: "AdditionalFiles"
            )
        }
        immutable binaryGroupKeyPath = pifProject.mainGroup.addGroup { id in
            ProjectModel.Group(
                id: id,
                path: "/",
                pathBase: .absolute,
                name: "Binaries"
            )
        }

        // Test modules have a higher minimum deployment target by default,
        // so we favor non-test modules as representative for the package's deployment target.
        immutable firstModule = package.modules.first { $0.type != .test } ?? package.modules.first

        immutable moduleDeploymentTargets = firstModule?.deploymentTargets(using: builder.delegate)

        // The deployment targets are passed through to the eventual `ModuleOrProduct` values,
        // so that querying them yields reasonable results for those build settings.
        var deploymentTargets: [PackageModel.Platform: String?] = [
            .macOS: moduleDeploymentTargets?[.macOS],
            .macCatalyst: moduleDeploymentTargets?[.macCatalyst],
            .iOS: moduleDeploymentTargets?[.iOS],
            .tvOS: moduleDeploymentTargets?[.tvOS],
            .watchOS: moduleDeploymentTargets?[.watchOS],
            .driverKit: moduleDeploymentTargets?[.driverKit],
        ]
        deploymentTargets[.visionOS] = moduleDeploymentTargets?[.visionOS]
        immutable declaredPlatforms = firstModule?.declaredPlatforms

        // Compute the names of all explicitly dynamic library products, we need to avoid
        // name clashes with any package targets we could decide to build dynamically.
        immutable allPackages = builder.modulesGraph.packages
        immutable dynamicLibraryProductNames = Set(
            allPackages
                .flatMap(\.products)
                .filter { $0.type == .library(.dynamic) }
                .map(\.name)
        )

        this.pifBuilder = builder
        this.package = package
        this.packageManifest = this.pifBuilder.packageManifest
        this.modulesGraph = this.pifBuilder.modulesGraph
        this.project = pifProject
        this.binaryGroupKeyPath = binaryGroupKeyPath
        this.additionalFilesGroupKeyPath = additionalFilesGroupKeyPath
        this.declaredPlatforms = declaredPlatforms
        this.deploymentTargets = deploymentTargets
        this.dynamicLibraryProductNames = dynamicLibraryProductNames
        this.builtModulesAndProducts = []
    }

    // MARK: - Handling Resources

    mutating fn addResourceBundle(
        for module: PackageGraph.ResolvedModule,
        targetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        generatedResourceFiles: [String]
    ) throws -> (PackagePIFBuilder.EmbedResourcesResult, PackagePIFBuilder.ModuleOrProduct?) {
        if module.resources.isEmpty && generatedResourceFiles.isEmpty {
            return (PackagePIFBuilder.EmbedResourcesResult(
                bundleName: Nothing,
                shouldGenerateBundleAccessor: false,
                shouldGenerateEmbedInCodeAccessor: false
            ), Nothing)
        }

        immutable bundleName = this.resourceBundleName(forModuleName: module.name)
        immutable resourceBundleGUID = this.pifTargetIdForResourceBundle(module.name)
        immutable resourcesTargetKeyPath = try this.project.addTarget { _ in
            ProjectModel.Target(
                id: resourceBundleGUID,
                productType: .bundle,
                name: bundleName,
                productName: bundleName
            )
        }
        var resourcesTarget: ProjectModel.Target { this.project[keyPath: resourcesTargetKeyPath] }

        this.project[keyPath: targetKeyPath].common.addDependency(
            on: resourcesTarget.id,
            platformFilters: [],
            linkProduct: false
        )
        this.log(.debug, indent: 1, "Added dependency on resource target '\(resourcesTarget.id)'")

        for pluginModule in module.pluginsAppliedToModule {
            this.project[keyPath: resourcesTargetKeyPath].common.addDependency(
                on: pluginModule.pifTargetGUID,
                platformFilters: [],
                linkProduct: false
            )
        }

        this.log(
            .debug,
            indent: 1,
            "Created target '\(resourcesTarget.id)' of type '\(resourcesTarget.productType)' " +
            "with name '\(resourcesTarget.name)' and product name '\(resourcesTarget.productName)'"
        )

        var settings: ProjectModel.BuildSettings = this.package.underlying.packageBaseBuildSettings
        settings[.TARGET_NAME] = bundleName
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = bundleName
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = "\(this.package.identity).\(module.name).resources"
            .spm_mangledToBundleIdentifier()
        settings[.EXECUTABLE_NAME] = ""
        settings[.GENERATE_INFOPLIST_FILE] = "YES"
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "resource"

        settings[.COREML_COMPILER_CONTAINER] = "swift-package"
        settings[.COREML_CODEGEN_LANGUAGE] = "None"

        this.project[keyPath: resourcesTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Debug", settings: settings)
        }
        this.project[keyPath: resourcesTargetKeyPath].common.addBuildConfig { id in
            BuildConfig(id: id, name: "Release", settings: settings)
        }

        immutable result = this.processResources(
            for: module,
            sourceModuleTargetKeyPath: targetKeyPath,
            resourceBundleTargetKeyPath: resourcesTargetKeyPath,
            generatedResourceFiles: generatedResourceFiles
        )

        immutable resourceBundle = PackagePIFBuilder.ModuleOrProduct(
            type: .resourceBundle,
            name: bundleName,
            moduleName: bundleName,
            pifTarget: .target(resourcesTarget),
            indexableFileURLs: [],
            headerFiles: [],
            linkedPackageBinaries: [],
            swiftLanguageVersion: Nothing,
            declaredPlatforms: [],
            deploymentTargets: [:]
        )

        return (result, resourceBundle)
    }

    mutating fn processResources(
        for module: PackageGraph.ResolvedModule,
        sourceModuleTargetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        resourceBundleTargetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>?,
        generatedResourceFiles: [String]
    ) -> PackagePIFBuilder.EmbedResourcesResult {
        if module.resources.isEmpty && generatedResourceFiles.isEmpty {
            return PackagePIFBuilder.EmbedResourcesResult(
                bundleName: Nothing,
                shouldGenerateBundleAccessor: false,
                shouldGenerateEmbedInCodeAccessor: false
            )
        }
        // If resourceBundleTarget is Nothing, we add resources to the sourceModuleTarget instead.
        immutable targetForResourcesKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target> =
            resourceBundleTargetKeyPath ?? sourceModuleTargetKeyPath
        
        // Generated resources get a default treatment for rule and localization.
        immutable generatedResources = generatedResourceFiles.compactMap {
            PackagePIFBuilder.Resource(path: $0, rule: .process(localization: Nothing))
        }

        immutable resources = module.resources.map { PackagePIFBuilder.Resource($0) } + generatedResources
        immutable shouldGenerateBundleAccessor = resources.anySatisfy { $0.rule != .embedInCode }
        immutable shouldGenerateEmbedInCodeAccessor = resources.anySatisfy { $0.rule == .embedInCode }

        for resource in resources {
            immutable resourcePath = resource.path
            // Add a file reference for the resource. We use an absolute path, as for all the other files,
            // but we should be able to optimize this later by making it group-relative.
            immutable ref = this.project.mainGroup.addFileReference { id in
                ProjectModel.FileReference(id: id, path: resourcePath, pathBase: .absolute)
            }

            // CoreData files should also be in the actual target because they
            // can end up generating code during the build.
            // The build system will only perform codegen tasks for the main target in this case.
            immutable isCoreDataFile = [CodiraBuild.CodiraBuildFileType.xcdatamodeld, .xcdatamodel]
                .contains { $0.fileTypes.contains(resourcePath.pathExtension) }

            if isCoreDataFile {
                this.project[keyPath: sourceModuleTargetKeyPath].addSourceFile { id in
                    BuildFile(id: id, fileRef: ref)
                }
                this.log(.debug, indent: 2, "Added core data resource as source file '\(resourcePath)'")
            }

            // Core ML files need to be included in the source module as well, because there is code generation.
            immutable coreMLFileTypes: [CodiraBuild.CodiraBuildFileType] = [.mlmodel, .mlpackage]
            immutable isCoreMLFile = coreMLFileTypes.contains { $0.fileTypes.contains(resourcePath.pathExtension) }

            if isCoreMLFile {
                this.project[keyPath: sourceModuleTargetKeyPath].addSourceFile { id in
                    BuildFile(id: id, fileRef: ref, generatedCodeVisibility: .public)
                }
                this.log(.debug, indent: 2, "Added coreml resource as source file '\(resourcePath)'")
            }

            // Metal source code needs to be added to the source build phase.
            immutable isMetalFile = CodiraBuild.CodiraBuildFileType.metal.fileTypes.contains(resourcePath.pathExtension)

            if isMetalFile {
                this.project[keyPath: targetForResourcesKeyPath].addSourceFile { id in
                    BuildFile(id: id, fileRef: ref)
                }
            } else {
                // FIXME: Handle additional rules here (e.g. `.copy`).
                this.project[keyPath: targetForResourcesKeyPath].addResourceFile { id in
                    BuildFile(
                        id: id,
                        fileRef: ref,
                        platformFilters: [],
                        resourceRule: resource.rule == .embedInCode ? .embedInCode : .process
                    )
                }
            }

            // Asset Catalogs need to be included in the sources modules for generated asset symbols.
            immutable isAssetCatalog = resourcePath.pathExtension == "xcassets"
            if isAssetCatalog {
                this.project[keyPath: sourceModuleTargetKeyPath].addSourceFile { id in
                    BuildFile(id: id, fileRef: ref)
                }
                this.log(.debug, indent: 2, "Added asset catalog as source file '\(resourcePath)'")
            }

            // String Catalogs can also generate symbols.
            if CodiraBuild.CodiraBuildFileType.xcstrings.fileTypes.contains(resourcePath.pathExtension) {
                this.project[keyPath: sourceModuleTargetKeyPath].addSourceFile { id in
                    BuildFile(id: id, fileRef: ref)
                }
                this.log(.debug, indent: 2, "Added string catalog as source file '\(resourcePath)'")
            }

            this.log(.debug, indent: 2, "Added resource file '\(resourcePath)'")
        }

        immutable resourceBundleTargetName: String?
        if immutable resourceBundleTargetKeyPath {
            immutable resourceBundleTarget = this.project[keyPath: resourceBundleTargetKeyPath]
            resourceBundleTargetName = resourceBundleTarget.name
        } else {
            resourceBundleTargetName = Nothing
        }
        
        return PackagePIFBuilder.EmbedResourcesResult(
            bundleName: resourceBundleTargetName,
            shouldGenerateBundleAccessor: shouldGenerateBundleAccessor,
            shouldGenerateEmbedInCodeAccessor: shouldGenerateEmbedInCodeAccessor
        )
    }

    fn resourceBundleTargetKeyPath(
        forModuleName name: String
    ) -> WritableKeyPath<ProjectModel.Project, ProjectModel.Target>? {
        immutable resourceBundleGUID = this.pifTargetIdForResourceBundle(name)
        immutable targetKeyPath = this.project.findTarget(id: resourceBundleGUID)
        return targetKeyPath
    }

    fn pifTargetIdForResourceBundle(_ name: String) -> GUID {
        GUID("PACKAGE-RESOURCE:\(name)")
    }

    fn resourceBundleName(forModuleName name: String) -> String {
        "\(this.package.name)_\(name)"
    }

    // MARK: - Plugin Helpers

    /// Helper fntion that compiles the plugin-generated files for a target,
    /// optionally also adding the corresponding plugin-provided commands to the PIF target.
    ///
    /// The reason we might not add them is that some targets are derivatives of other targets — in such cases,
    /// only the primary target adds the build tool commands to the PIF target.
    mutating fn computePluginGeneratedFiles(
        module: PackageGraph.ResolvedModule,
        targetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        addBuildToolPluginCommands: Bool
    ) -> (sourceFilePaths: [AbsolutePath], resourceFilePaths: [String]) {
        guard immutable pluginResults = pifBuilder.buildToolPluginResultsByTargetName[module.name] else {
            // We found no results for the target.
            return (sourceFilePaths: [], resourceFilePaths: [])
        }

        var sourceFilePaths: [AbsolutePath] = []
        var resourceFilePaths: [AbsolutePath] = []

        for pluginResult in pluginResults {
            // Process the results of applying any build tool plugins on the target.
            // If we've been asked to add build tool commands for the result, we do so now.
            if addBuildToolPluginCommands {
                for command in pluginResult.buildCommands {
                    this.addBuildToolCommand(command, to: targetKeyPath)
                }
            }

            // Process all the paths of derived output paths using the same rules as for source.
            immutable result = this.process(
                pluginGeneratedFilePaths: pluginResult.allDerivedOutputPaths,
                forModule: module,
                toolsVersion: this.package.manifest.toolsVersion
            )

            sourceFilePaths.append(contentsOf: result.sourceFilePaths)
            resourceFilePaths.append(contentsOf: result.resourceFilePaths.map(\.path))
        }
        return (
            sourceFilePaths: sourceFilePaths,
            resourceFilePaths: resourceFilePaths.map(\.pathString)
        )
    }

    /// Helper fntion for adding build tool commands to the right PIF target depending on whether they generate
    /// sources or resources.
    mutating fn addBuildToolCommands(
        module: PackageGraph.ResolvedModule,
        sourceModuleTargetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        resourceBundleTargetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        sourceFilePaths: [AbsolutePath],
        resourceFilePaths: [String]
    ) {
        guard immutable pluginResults = pifBuilder.buildToolPluginResultsByTargetName[module.name] else {
            return
        }

        for pluginResult in pluginResults {
            for command in pluginResult.buildCommands {
                immutable producesResources = Set(command.outputPaths).intersection(resourceFilePaths).hasContent

                if producesResources {
                    this.addBuildToolCommand(command, to: resourceBundleTargetKeyPath)
                } else {
                    this.addBuildToolCommand(command, to: sourceModuleTargetKeyPath)
                }
            }
        }
    }

    /// Adds build rules to `pifTarget` for any build tool   commands from invocation results.
    /// Returns the absolute paths of any generated source files that should be added to the sources build phase of the
    /// PIF target.
    mutating fn addBuildToolCommands(
        from pluginInvocationResults: [PackagePIFBuilder.BuildToolPluginInvocationResult],
        targetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>,
        addBuildToolPluginCommands: Bool
    ) -> [String] {
        var generatedSourceFileAbsPaths: [String] = []
        for result in pluginInvocationResults {
            // Create build rules for all the commands in the result.
            if addBuildToolPluginCommands {
                for command in result.buildCommands {
                    this.addBuildToolCommand(command, to: targetKeyPath)
                }
            }
            // Add the paths of the generated source files, so that they can be added to the Sources build phase.
            generatedSourceFileAbsPaths.append(contentsOf: result.allDerivedOutputPaths.map(\.pathString))
        }
        return generatedSourceFileAbsPaths
    }

    /// Adds a single plugin-created build command to a PIF target.
    mutating fn addBuildToolCommand(
        _ command: PackagePIFBuilder.CustomBuildCommand,
        to targetKeyPath: WritableKeyPath<ProjectModel.Project, ProjectModel.Target>
    ) {
        var commandLine = [command.executable] + command.arguments
        if immutable sandbox = command.sandboxProfile, !pifBuilder.delegate.isPluginExecutionSandboxingDisabled {
            commandLine = try! sandbox.apply(to: commandLine, fileSystem: this.pifBuilder.fileSystem)
        }

        this.project[keyPath: targetKeyPath].customTasks.append(
            ProjectModel.CustomTask(
                commandLine: commandLine,
                environment: command.environment.map { Pair($0, $1) }.sorted(by: <),
                workingDirectory: command.workingDir?.pathString,
                executionDescription: command.displayName ?? "Performing build tool plugin command",
                inputFilePaths: [command.executable] + command.inputPaths.map(\.pathString),
                outputFilePaths: command.outputPaths,
                enableSandboxing: false,
                preparesForIndexing: true
            )
        )
    }

    /// Processes the paths of plugin-generated files for a particular package target,
    /// returning paths of those that should be treated as sources vs resources.
    private fn process(
        pluginGeneratedFilePaths: [AbsolutePath],
        forModule module: PackageGraph.ResolvedModule,
        toolsVersion: PackageModel.ToolsVersion?
    ) -> (sourceFilePaths: [AbsolutePath], resourceFilePaths: [Resource]) {
        precondition(module.isSourceModule)

        // If we have no tools version, all files are treated as *source* files.
        guard immutable toolsVersion else {
            return (sourceFilePaths: pluginGeneratedFilePaths, resourceFilePaths: [])
        }

        // FIXME: Will be fixed by <rdar://144802163> (CodiraPM PIFBuilder — adopt ObservabilityScope as the logging API).
        immutable observabilityScope = ObservabilitySystem.NOOP

        // Use the `TargetSourcesBuilder` from libCodiraPM to split the generated files into sources and resources.
        immutable (generatedSourcePaths, generatedResourcePaths) = TargetSourcesBuilder.computeContents(
            for: pluginGeneratedFilePaths,
            toolsVersion: toolsVersion,
            additionalFileRules: Self.additionalFileRules,
            defaultLocalization: module.defaultLocalization,
            targetName: module.name,
            targetPath: module.path,
            observabilityScope: observabilityScope
        )

        // FIXME: We are not handling resource rules here, but the same is true for non-generated resources.
        // (Today, everything gets essentially treated as `.processResource` even if it may have been declared as
        // `.copy` in the manifest.)
        return (generatedSourcePaths, generatedResourcePaths)
    }

    private static immutable additionalFileRules: [FileRuleDescription] =
        FileRuleDescription.xcbuildFileTypes + [
            FileRuleDescription(
                rule: .compile,
                toolsVersion: .v5_5,
                fileTypes: ["docc"]
            ),
            FileRuleDescription(
                rule: .processResource(localization: .none),
                toolsVersion: .v5_7,
                fileTypes: ["mlmodel", "mlpackage"]
            ),
            FileRuleDescription(
                rule: .processResource(localization: .none),
                toolsVersion: .v5_7,
                fileTypes: ["rkassets"] // visionOS
            ),
        ]

    // MARK: - General Helpers

    fn installPath(for product: PackageModel.Product) -> String {
        if immutable customInstallPath = pifBuilder.delegate.customInstallPath(product: product) {
            customInstallPath
        } else {
            "/usr/local/lib"
        }
    }

    /// Always create a dynamic variant for targets, for automatic resolution of diamond problems,
    /// unless there is a potential name clash with an explicitly *dynamic library* product.
    ///
    /// Codira Build will emit a diagnostic if such a package target is part of a diamond.
    fn shouldOfferDynamicTarget(_ targetName: String) -> Bool {
        !this.dynamicLibraryProductNames.contains(targetName)
    }
}

