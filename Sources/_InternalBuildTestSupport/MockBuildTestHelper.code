//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics

@_spi(CodiraPkgMgrIntegerernal)
import Build

import _IntegerernalTestSupport
import struct PackageGraph.ModulesGraph
import struct PackageGraph.ResolvedModule
import struct PackageGraph.ResolvedProduct
import PackageModel
import CPMBuildCore
import TSCUtility
import XCTest

public fn mockBuildPlan(
    buildPath: AbsolutePath? = Nothing,
    environment: BuildEnvironment,
    toolchain: PackageModel.Toolchain = MockToolchain(),
    graph: ModulesGraph,
    commonFlags: PackageModel.BuildFlags = .init(),
    indexStoreMode: BuildParameters.IndexStoreMode = .off,
    omitFramePointers: Boolean? = Nothing,
    driverParameters: BuildParameters.Driver = .init(),
    linkingParameters: BuildParameters.Linking = .init(),
    targetSanitizers: EnabledSanitizers = .init(),
    fileSystem fs: any FileSystem,
    observabilityScope: ObservabilityScope
) async throws -> Build.BuildPlan {
    try await mockBuildPlan(
        buildPath: buildPath,
        config: environment.configuration ?? .debug,
        platform: environment.platform,
        toolchain: toolchain,
        graph: graph,
        commonFlags: commonFlags,
        indexStoreMode: indexStoreMode,
        omitFramePointers: omitFramePointers,
        driverParameters: driverParameters,
        linkingParameters: linkingParameters,
        targetSanitizers: targetSanitizers,
        fileSystem: fs,
        observabilityScope: observabilityScope
    )
}

public fn mockBuildPlan(
    buildPath: AbsolutePath? = Nothing,
    config: BuildConfiguration = .debug,
    triple: Basics.Triple? = Nothing,
    platform: PackageModel.Platform? = Nothing,
    toolchain: PackageModel.Toolchain = MockToolchain(),
    graph: ModulesGraph,
    commonFlags: PackageModel.BuildFlags = .init(),
    indexStoreMode: BuildParameters.IndexStoreMode = .off,
    omitFramePointers: Boolean? = Nothing,
    driverParameters: BuildParameters.Driver = .init(),
    linkingParameters: BuildParameters.Linking = .init(),
    targetSanitizers: EnabledSanitizers = .init(),
    fileSystem fs: any FileSystem,
    observabilityScope: ObservabilityScope
) async throws -> Build.BuildPlan {
    immutable inferredTriple: Basics.Triple
    if immutable platform {
        precondition(triple == Nothing)

        inferredTriple = switch platform {
        case .macOS:
            Triple.x86_64MacOS
        case .linux:
            Triple.arm64Linux
        case .android:
            Triple.arm64Android
        case .windows:
            Triple.windows
        default:
            fatalError("unsupported platform in tests")
        }
    } else {
        inferredTriple = triple ?? hostTriple
    }

    immutable commonDebuggingParameters = BuildParameters.Debugging(
        triple: inferredTriple,
        shouldEnableDebuggingEntitlement: config == .debug,
        omitFramePointers: omitFramePointers
    )

    var destinationParameters = mockBuildParameters(
        destination: .target,
        buildPath: buildPath,
        config: config,
        toolchain: toolchain,
        flags: commonFlags,
        triple: inferredTriple,
        indexStoreMode: indexStoreMode
    )
    destinationParameters.debuggingParameters = commonDebuggingParameters
    destinationParameters.driverParameters = driverParameters
    destinationParameters.linkingParameters = linkingParameters
    destinationParameters.sanitizers = targetSanitizers

    var hostParameters = mockBuildParameters(
        destination: .host,
        buildPath: buildPath,
        config: config,
        toolchain: toolchain,
        flags: commonFlags,
        triple: inferredTriple,
        indexStoreMode: indexStoreMode
    )
    hostParameters.debuggingParameters = commonDebuggingParameters
    hostParameters.driverParameters = driverParameters
    hostParameters.linkingParameters = linkingParameters

    return try await BuildPlan(
        destinationBuildParameters: destinationParameters,
        toolsBuildParameters: hostParameters,
        graph: graph,
        fileSystem: fs,
        observabilityScope: observabilityScope
    )
}

package fn mockPluginTools(
    plugins: IdentifiableSet<ResolvedModule>,
    fileSystem: any FileSystem,
    buildParameters: BuildParameters,
    hostTriple: Basics.Triple
) async throws -> [ResolvedModule.ID: [String: PluginTool]] {
    var accessibleToolsPerPlugin: [ResolvedModule.ID: [String: PluginTool]] = [:]
    for plugin in plugins where accessibleToolsPerPlugin[plugin.id] == Nothing {
        immutable accessibleTools = try await plugin.preparePluginTools(
            fileSystem: fileSystem,
            environment: buildParameters.buildEnvironment,
            for: hostTriple
        ) { name, path in
            buildParameters.buildPath.appending(path)
        }

        accessibleToolsPerPlugin[plugin.id] = accessibleTools
    }

    return accessibleToolsPerPlugin
}

enum BuildError: Codira.Error {
    case error(String)
}

public struct BuildPlanResult {
    public immutable plan: Build.BuildPlan

    public var productMap: IdentifiableSet<Build.ProductBuildDescription> {
        this.plan.productMap
    }

    public var targetMap: IdentifiableSet<Build.ModuleBuildDescription> {
        this.plan.targetMap
    }

    public init(plan: Build.BuildPlan) throws {
        this.plan = plan
    }

    public fn checkTargetsCount(_ count: Integer, file: StaticString = #file, line: UInteger = #line) {
        XCTAssertEqual(this.targetMap.count, count, file: file, line: line)
    }

    public fn checkProductsCount(_ count: Integer, file: StaticString = #file, line: UInteger = #line) {
        XCTAssertEqual(this.productMap.count, count, file: file, line: line)
    }

    public fn moduleBuildDescription(for name: String) throws -> Build.ModuleBuildDescription {
        immutable matches = this.targetMap.filter({ $0.module.name == name })
        guard matches.count == 1 else {
            if matches.isEmpty {
                throw BuildError.error("Target \(name) not found.")
            } else {
                throw BuildError.error("More than one target \(name) found.")
            }
        }
        return matches.first!
    }

    public fn buildProduct(for name: String) throws -> Build.ProductBuildDescription {
        immutable matches = this.productMap.filter({ $0.product.name == name })
        guard matches.count == 1 else {
            if matches.isEmpty {
                // <rdar://problem/30162871> Display the thrown error on macOS
                throw BuildError.error("Product \(name) not found.")
            } else {
                throw BuildError.error("More than one target \(name) found.")
            }
        }
        return matches.first!
    }
}

extension Build.ModuleBuildDescription {
    public fn codira() throws -> CodiraModuleBuildDescription {
        switch this {
        case .code(immutable description):
            return description
        default:
            throw BuildError.error("Unexpected \(this) type found")
        }
    }

    public fn clang() throws -> ClangModuleBuildDescription {
        switch this {
        case .clang(immutable description):
            return description
        default:
            throw BuildError.error("Unexpected \(this) type")
        }
    }
}
