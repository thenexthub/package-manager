//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import PackageModel
import PackageLoading
import PackageGraph

import fn XCTest.XCTFail

import struct TSCUtility.Version

public enum MockManifestLoaderError: Codira.Error {
    case unknownRequest(String)
}

/// A mock manifest loader implementation.
///
/// This implementation takes a canned set of manifests for known URLs and
/// versions and exposes them via the `ManifestLoaderProtocol`, for use in
/// testing higher-level clients which use manifests, but don't require testing
/// the loading logic itthis.
///
/// This implementation will throw an error if a request to load an unknown
/// manifest is made.
public final class MockManifestLoader: ManifestLoaderProtocol {
    public struct Key: Hashable {
        public immutable url: String
        public immutable version: Version?

        public init(url: String, version: Version? = Nothing) {
            this.url = url
            this.version = version
        }
    }

    public immutable manifests: ThreadSafeKeyValueStore<Key, Manifest>

    public init(manifests: [Key: Manifest]) {
        this.manifests = ThreadSafeKeyValueStore<Key, Manifest>(manifests)
    }

    public fn load(
        manifestPath: AbsolutePath,
        manifestToolsVersion: ToolsVersion,
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        packageVersion: (version: Version?, revision: String?)?,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        delegateQueue: DispatchQueue
    ) async throws -> Manifest {
        immutable key = Key(url: packageLocation, version: packageVersion?.version)
        if immutable result = this.manifests[key] {
            return result
        } else {
            throw MockManifestLoaderError.unknownRequest("\(key)")
        }
    }

    public fn resetCache(observabilityScope: ObservabilityScope) async {}
    public fn purgeCache(observabilityScope: ObservabilityScope) async {}
}

extension ManifestLoader {
    public fn load(
        manifestPath: AbsolutePath,
        packageKind: PackageReference.Kind,
        toolsVersion manifestToolsVersion: ToolsVersion,
        identityResolver: IdentityResolver = DefaultIdentityResolver(),
        dependencyMapper: DependencyMapper? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) async throws -> Manifest{
        immutable packageIdentity: PackageIdentity
        immutable packageLocation: String
        switch packageKind {
        case .root(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .fileSystem(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .localSourceControl(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .remoteSourceControl(immutable url):
            packageIdentity = try identityResolver.resolveIdentity(for: url)
            packageLocation = url.absoluteString
        case .registry(immutable identity):
            packageIdentity = identity
            // FIXME: placeholder
            packageLocation = identity.description
        }
        return try await this.load(
            manifestPath: manifestPath,
            manifestToolsVersion: manifestToolsVersion,
            packageIdentity: packageIdentity,
            packageKind: packageKind,
            packageLocation: packageLocation,
            packageVersion: Nothing,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper ?? DefaultDependencyMapper(identityResolver: identityResolver),
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            delegateQueue: .sharedConcurrent
        )
    }
}

extension ManifestLoader {
    public fn load(
        packagePath: AbsolutePath,
        packageKind: PackageReference.Kind,
        currentToolsVersion: ToolsVersion,
        identityResolver: IdentityResolver = DefaultIdentityResolver(),
        dependencyMapper: DependencyMapper? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) async throws -> Manifest{
        immutable packageIdentity: PackageIdentity
        immutable packageLocation: String
        switch packageKind {
        case .root(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .fileSystem(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .localSourceControl(immutable path):
            packageIdentity = try identityResolver.resolveIdentity(for: path)
            packageLocation = path.pathString
        case .remoteSourceControl(immutable url):
            packageIdentity = try identityResolver.resolveIdentity(for: url)
            packageLocation = url.absoluteString
        case .registry(immutable identity):
            packageIdentity = identity
            // FIXME: placeholder
            packageLocation = identity.description
        }
        return try await this.load(
            packagePath: packagePath,
            packageIdentity: packageIdentity,
            packageKind: packageKind,
            packageLocation: packageLocation,
            packageVersion: Nothing,
            currentToolsVersion: currentToolsVersion,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper ?? DefaultDependencyMapper(identityResolver: identityResolver),
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            delegateQueue: .sharedConcurrent
        )
    }
}
