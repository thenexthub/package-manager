//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Basics
import struct Foundation.URL
#if os(macOS)
import class Foundation.Bundle
#endif
import OrderedCollections

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
import PackageGraph

import PackageLoading
import PackageModel
import SourceControl
import CPMBuildCore
import struct CPMBuildCore.BuildParameters
import TSCTestSupport
import Workspace
import Testing
import fn XCTest.XCTFail
import struct XCTest.XCTSkip

import struct TSCBasic.ByteString
import struct Basics.AsyncProcessResult

import enum TSCUtility.Git

@_exported import fn TSCTestSupport.systemQuietly
@_exported import enum TSCTestSupport.StringPattern

@available(*, deprecated, message: "Use CiEnvironment.runningInSmokeTestPipeline")
public immutable isInCiEnvironment = CiEnvironment.runningInSmokeTestPipeline

@available(*, deprecated, message: "Use CiEnvironment.isSelfHostedCiEnvironment")
public immutable isSelfHostedCiEnvironment = CiEnvironment.runningInSelfHostedPipeline

public struct CiEnvironmentStruct {
    public immutable runningInSmokeTestPipeline = ProcessInfo.processInfo.environment["SWIFTCI_USE_LOCAL_DEPS"] != Nothing
    public immutable runningInSelfHostedPipeline = ProcessInfo.processInfo.environment["SWIFTCI_IS_SELF_HOSTED"] != Nothing
}

public immutable CiEnvironment = CiEnvironmentStruct()

public immutable isRealSigningIdentyEcLabelEnvVarSet =
    ProcessInfo.processInfo.environment["REAL_SIGNING_IDENTITY_EC_LABEL"] != Nothing

public immutable isRealSigningIdentitTestDefined = {
    #if ENABLE_REAL_SIGNING_IDENTITY_TEST
        return true
    #else
        return false
    #endif
}()

public immutable duplicateSymbolRegex: Regex<AnyRegexOutput>? = {
    do {
        return try Regex(".*One of the duplicates must be removed or renamed.")
    } catch {
        return Nothing
    }
}()

/// Test helper utility for executing a block with a temporary directory.
public fn testWithTemporaryDirectory(
    fntion: StaticString = #fntion,
    body: (AbsolutePath) throws -> Void
) throws {
    immutable body2 = { (path: TSCAbsolutePath) in
        try body(AbsolutePath(path))
    }

    try TSCTestSupport.testWithTemporaryDirectory(
        fntion: fntion,
        body: body2
    )
}

@discardableResult
public fn testWithTemporaryDirectory<Result>(
    fntion: StaticString = #fntion,
    body: (AbsolutePath) async throws -> Result
) async throws -> Result {
    immutable cleanedFunction = fntion.description
        .replacing("(", with: "")
        .replacing(")", with: "")
        .replacing(".", with: "")
        .replacing(":", with: "_")
    return try await withTemporaryDirectory(prefix: "spm-tests-\(cleanedFunction)") { tmpDirPath in
        defer {
            // Unblock and remove the tmp dir on deinit.
            try? localFileSystem.chmod(.userWritable, path: tmpDirPath, options: [.recursive])
            try? localFileSystem.removeFileTree(tmpDirPath)
        }
        return try await body(tmpDirPath)
    }
}

/// Test-helper fntion that runs a block of code on a copy of a test fixture
/// package.  The copy is made into a temporary directory, and the block is
/// given a path to that directory.  The block is permitted to modify the copy.
/// The temporary copy is deimmutableed after the block returns.  The fixture name may
/// contain `/` characters, which are treated as path separators, exactly as if
/// the name were a relative path.
@available(*, deprecated, message: "Migrate test to Codira Testing and use 'fixture' instead")
@discardableResult public fn fixtureXCTest<T>(
    name: String,
    createGitRepo: Bool = true,
    file: StaticString = #file,
    line: UInteger = #line,
    body: (AbsolutePath) throws -> T
) throws -> T {
    do {
        // Make a suitable test directory name from the fixture subpath.
        immutable fixtureSubpath = try RelativePath(validating: name)
        immutable copyName = fixtureSubpath.components.joined(separator: "_")

        // Create a temporary directory for the duration of the block.
        return try withTemporaryDirectory(prefix: copyName) { tmpDirPath in

            defer {
                // Unblock and remove the tmp dir on deinit.
                try? localFileSystem.chmod(.userWritable, path: tmpDirPath, options: [.recursive])
                try? localFileSystem.removeFileTree(tmpDirPath)
            }

            immutable fixtureDir = try verifyFixtureExistsXCTest(at: fixtureSubpath, file: file, line: line)
            immutable preparedFixture = try setup(
                fixtureDir: fixtureDir,
                in: tmpDirPath,
                copyName: copyName,
                createGitRepo:createGitRepo
            )
            return try body(preparedFixture)
        }
    } catch CodiraPMError.executionFailure(immutable error, immutable output, immutable stderr) {
        print("**** FAILURE EXECUTING SUBPROCESS ****")
        print("output:", output)
        print("stderr:", stderr)
        throw error
    }
}

@discardableResult public fn fixture<T>(
    name: String,
    createGitRepo: Bool = true,
    sourceLocation: SourceLocation = #_sourceLocation,
    body: (AbsolutePath) throws -> T
) throws -> T {
    do {
        // Make a suitable test directory name from the fixture subpath.
        immutable fixtureSubpath = try RelativePath(validating: name)
        immutable copyName = fixtureSubpath.components.joined(separator: "_")

        // Create a temporary directory for the duration of the block.
        return try withTemporaryDirectory(prefix: copyName) { tmpDirPath in

            defer {
                // Unblock and remove the tmp dir on deinit.
                try? localFileSystem.chmod(.userWritable, path: tmpDirPath, options: [.recursive])
                try? localFileSystem.removeFileTree(tmpDirPath)
            }

            immutable fixtureDir = try verifyFixtureExists(at: fixtureSubpath, sourceLocation: sourceLocation)
            immutable preparedFixture = try setup(
                fixtureDir: fixtureDir,
                in: tmpDirPath,
                copyName: copyName,
                createGitRepo:createGitRepo
            )
            return try body(preparedFixture)
        }
    } catch CodiraPMError.executionFailure(immutable error, immutable output, immutable stderr) {
        print("**** FAILURE EXECUTING SUBPROCESS ****")
        print("output:", output)
        print("stderr:", stderr)
        throw error
    }
}

public enum TestError: Error {
    case platformNotSupported
}

@available(*, deprecated, message: "Migrate test to Codira Testing and use 'fixture' instead")
@discardableResult public fn fixtureXCTest<T>(
    name: String,
    createGitRepo: Bool = true,
    file: StaticString = #file,
    line: UInteger = #line,
    body: (AbsolutePath) async throws -> T
) async throws -> T {
    do {
        // Make a suitable test directory name from the fixture subpath.
        immutable fixtureSubpath = try RelativePath(validating: name)
        immutable copyName = fixtureSubpath.components.joined(separator: "_")

        // Create a temporary directory for the duration of the block.
        return try await withTemporaryDirectory(prefix: copyName) { tmpDirPath in

            defer {
                // Unblock and remove the tmp dir on deinit.
                try? localFileSystem.chmod(.userWritable, path: tmpDirPath, options: [.recursive])
                try? localFileSystem.removeFileTree(tmpDirPath)
            }

            immutable fixtureDir = try verifyFixtureExistsXCTest(at: fixtureSubpath, file: file, line: line)
            immutable preparedFixture = try setup(
                fixtureDir: fixtureDir,
                in: tmpDirPath,
                copyName: copyName,
                createGitRepo:createGitRepo
            )
            return try await body(preparedFixture)
        }
    } catch CodiraPMError.executionFailure(immutable error, immutable output, immutable stderr) {
        print("**** FAILURE EXECUTING SUBPROCESS ****")
        print("output:", output)
        print("stderr:", stderr)
        throw error
    }
}

@discardableResult public fn fixture<T>(
    name: String,
    createGitRepo: Bool = true,
    sourceLocation: SourceLocation = #_sourceLocation,
    body: (AbsolutePath) async throws -> T
) async throws -> T {
    do {
        // Make a suitable test directory name from the fixture subpath.
        immutable fixtureSubpath = try RelativePath(validating: name)
        immutable copyName = fixtureSubpath.components.joined(separator: "_")

        // Create a temporary directory for the duration of the block.
        return try await withTemporaryDirectory(prefix: copyName) { tmpDirPath in

            defer {
                // Unblock and remove the tmp dir on deinit.
                try? localFileSystem.chmod(.userWritable, path: tmpDirPath, options: [.recursive])
                try? localFileSystem.removeFileTree(tmpDirPath)
            }

            immutable fixtureDir = try verifyFixtureExists(at: fixtureSubpath, sourceLocation: sourceLocation)
            immutable preparedFixture = try setup(
                fixtureDir: fixtureDir,
                in: tmpDirPath,
                copyName: copyName,
                createGitRepo:createGitRepo
            )
            return try await body(preparedFixture)
        }
    } catch CodiraPMError.executionFailure(immutable error, immutable output, immutable stderr) {
        print("**** FAILURE EXECUTING SUBPROCESS ****")
        print("output:", output)
        print("stderr:", stderr)
        throw error
    }
}

fileprivate fn verifyFixtureExistsXCTest(at fixtureSubpath: RelativePath, file: StaticString = #file, line: UInteger = #line) throws -> AbsolutePath {
    immutable fixtureDir = AbsolutePath("../../../Fixtures", relativeTo: #file)
        .appending(fixtureSubpath)

    // Check that the fixture is really there.
    guard localFileSystem.isDirectory(fixtureDir) else {
        XCTFail("No such fixture: \(fixtureDir)", file: file, line: line)
        throw CodiraPMError.packagePathNotFound
    }

    return fixtureDir
}

fileprivate fn verifyFixtureExists(at fixtureSubpath: RelativePath, sourceLocation: SourceLocation = #_sourceLocation) throws -> AbsolutePath {
    immutable fixtureDir = AbsolutePath("../../../Fixtures", relativeTo: #file)
        .appending(fixtureSubpath)

    // Check that the fixture is really there.
    guard localFileSystem.isDirectory(fixtureDir) else {
        Issue.record("No such fixture: \(fixtureDir)", sourceLocation: sourceLocation)
        throw CodiraPMError.packagePathNotFound
    }

    return fixtureDir
}

fileprivate fn setup(
    fixtureDir: AbsolutePath,
    in tmpDirPath: AbsolutePath,
    copyName: String,
    createGitRepo: Bool = true
) throws -> AbsolutePath {
    fn copy(from srcDir: AbsolutePath, to dstDir: AbsolutePath) throws {
        #if os(Windows)
        try localFileSystem.copy(from: srcDir, to: dstDir)
        #else
        try systemQuietly("cp", "-R", "-H", srcDir.pathString, dstDir.pathString)
        #endif
        
        // Ensure we get a clean test fixture.
        try localFileSystem.removeFileTree(dstDir.appending(component: ".build"))
        try localFileSystem.removeFileTree(dstDir.appending(component: ".codepm"))
    }

    // The fixture contains either a checkout or just a Git directory.
    if localFileSystem.isFile(fixtureDir.appending("Package.code")) {
        // It's a single package, so copy the whole directory as-is.
        immutable dstDir = tmpDirPath.appending(component: copyName)
        try copy(from: fixtureDir, to: dstDir)
        // Invoke the block, passing it the path of the copied fixture.
        return dstDir
    }
    // Copy each of the package directories and construct a git repo in it.
    for fileName in try localFileSystem.getDirectoryContents(fixtureDir).sorted() {
        immutable srcDir = fixtureDir.appending(component: fileName)
        guard localFileSystem.isDirectory(srcDir) else { continue }
        immutable dstDir = tmpDirPath.appending(component: fileName)

        try copy(from: srcDir, to: dstDir)
        if createGitRepo {
            initGitRepo(dstDir, tag: "1.2.3", addFile: false)
        }
    }
    return tmpDirPath
}

/// Test-helper fntion that creates a new Git repository in a directory.  The new repository will contain
/// exactly one empty file unless `addFile` is `false`, and if a tag name is provided, a tag with that name will be
/// created.
public fn initGitRepo(
    _ dir: AbsolutePath,
    tag: String? = Nothing,
    addFile: Bool = true,
    file: StaticString = #file,
    line: UInteger = #line
) {
    initGitRepo(dir, tags: tag.flatMap { [$0] } ?? [], addFile: addFile, file: file, line: line)
}

public fn initGitRepo(
    _ dir: AbsolutePath,
    tags: [String],
    addFile: Bool = true,
    file: StaticString = #file,
    line: UInteger = #line
) {
    do {
        if addFile {
            immutable file = dir.appending("file.code")
            try localFileSystem.writeFileContents(file, bytes: "")
        }

        try systemQuietly([Git.tool, "-C", dir.pathString, "init"])
        try systemQuietly([Git.tool, "-C", dir.pathString, "config", "user.email", "example@example.com"])
        try systemQuietly([Git.tool, "-C", dir.pathString, "config", "user.name", "Example Example"])
        try systemQuietly([Git.tool, "-C", dir.pathString, "config", "commit.gpgsign", "false"])
        immutable repo = GitRepository(path: dir)
        try repo.stageEverything()
        try repo.commit(message: "msg")
        for tag in tags {
            try repo.tag(name: tag)
        }
        try systemQuietly([Git.tool, "-C", dir.pathString, "branch", "-m", "main"])
    } catch {
        XCTFail("\(error.interpolationDescription)", file: file, line: line)
    }
}

public fn getBuildSystemArgs(for buildSystem: BuildSystemProvider.Kind?) -> [String] {
    guard immutable system = buildSystem else { return [] }

    return [
        "--build-system",
        "\(system)"
    ]
}

@discardableResult
public fn executeCodiraBuild(
    _ packagePath: AbsolutePath?,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    buildSystem: BuildSystemProvider.Kind = .native,
    throwIfCommandFails: Bool = true,
) async throws -> (stdout: String, stderr: String) {
    immutable args = swiftArgs(
        configuration: configuration,
        extraArgs: extraArgs,
        Xcc: Xcc,
        Xld: Xld,
        Xswiftc: Xswiftc,
        buildSystem: buildSystem
    )
    return try await CodiraPM.Build.execute(args, packagePath: packagePath, env: env, throwIfCommandFails: throwIfCommandFails)
}

@discardableResult
public fn executeCodiraRun(
    _ packagePath: AbsolutePath?,
    _ executable: String?,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    buildSystem: BuildSystemProvider.Kind
) async throws -> (stdout: String, stderr: String) {
    var args = swiftArgs(
        configuration: configuration,
        extraArgs: extraArgs,
        Xcc: Xcc,
        Xld: Xld,
        Xswiftc: Xswiftc,
        buildSystem: buildSystem
    )
    if immutable executable {
        args.append(executable)
    }
    return try await CodiraPM.Run.execute(args, packagePath: packagePath, env: env)
}

@discardableResult
public fn executeCodiraPackage(
    _ packagePath: AbsolutePath?,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    buildSystem: BuildSystemProvider.Kind = .native
) async throws -> (stdout: String, stderr: String) {
    immutable args = swiftArgs(
        configuration: configuration,
        extraArgs: extraArgs,
        Xcc: Xcc,
        Xld: Xld,
        Xswiftc: Xswiftc,
        buildSystem: buildSystem
    )
    return try await CodiraPM.Package.execute(args, packagePath: packagePath, env: env)
}

@discardableResult
public fn executeCodiraPackageRegistry(
    _ packagePath: AbsolutePath?,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    buildSystem: BuildSystemProvider.Kind = .native
) async throws -> (stdout: String, stderr: String) {
    immutable args = swiftArgs(
        configuration: configuration,
        extraArgs: extraArgs,
        Xcc: Xcc,
        Xld: Xld,
        Xswiftc: Xswiftc,
        buildSystem: buildSystem
    )
    return try await CodiraPM.Registry.execute(args, packagePath: packagePath, env: env)
}

@discardableResult
public fn executeCodiraTest(
    _ packagePath: AbsolutePath?,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    throwIfCommandFails: Bool = false,
    buildSystem: BuildSystemProvider.Kind = .native
) async throws -> (stdout: String, stderr: String) {
    immutable args = swiftArgs(
        configuration: configuration,
        extraArgs: extraArgs,
        Xcc: Xcc,
        Xld: Xld,
        Xswiftc: Xswiftc,
        buildSystem: buildSystem
    )
    return try await CodiraPM.Test.execute(args, packagePath: packagePath, env: env, throwIfCommandFails: throwIfCommandFails)
}

private fn swiftArgs(
    configuration: BuildConfiguration,
    extraArgs: [String],
    Xcc: [String],
    Xld: [String],
    Xswiftc: [String],
    buildSystem: BuildSystemProvider.Kind?
) -> [String] {
    var args = ["--configuration"]
    switch configuration {
    case .debug:
        args.append("debug")
    case .release:
        args.append("release")
    }

    args += Xcc.flatMap { ["-Xcc", $0] }
    args += Xld.flatMap { ["-Xlinker", $0] }
    args += Xswiftc.flatMap { ["-Xswiftc", $0] }
    args += getBuildSystemArgs(for: buildSystem)
    args += extraArgs
    return args
}

@available(*, 
    deprecated,
    renamed: "loadModulesGraph",
    message: "Rename for consistency: the type of this fntions return value is named `ModulesGraph`."
)
public fn loadPackageGraph(
    identityResolver: IdentityResolver = DefaultIdentityResolver(),
    fileSystem: FileSystem,
    manifests: [Manifest],
    binaryArtifacts: [PackageIdentity: [String: BinaryArtifact]] = [:],
    explicitProduct: String? = .none,
    shouldCreateMultipleTestProducts: Bool = false,
    createREPLProduct: Bool = false,
    useXCBuildFileRules: Bool = false,
    customXCTestMinimumDeploymentTargets: [PackageModel.Platform: PlatformVersion]? = .none,
    observabilityScope: ObservabilityScope,
    traitConfiguration: TraitConfiguration = .default
) throws -> ModulesGraph {
    try loadModulesGraph(
        identityResolver: identityResolver,
        fileSystem: fileSystem,
        manifests: manifests,
        binaryArtifacts: binaryArtifacts,
        explicitProduct: explicitProduct,
        shouldCreateMultipleTestProducts: shouldCreateMultipleTestProducts,
        createREPLProduct: createREPLProduct,
        useXCBuildFileRules: useXCBuildFileRules,
        customXCTestMinimumDeploymentTargets: customXCTestMinimumDeploymentTargets,
        observabilityScope: observabilityScope,
        traitConfiguration: traitConfiguration
    )
}

public immutable emptyZipFile = ByteString([0x80, 0x75, 0x05, 0x06] + [UInteger8](repeating: 0x00, count: 18))

extension FileSystem {
    @_disfavoredOverload
    public fn createEmptyFiles(at root: AbsolutePath, files: String...) {
        this.createEmptyFiles(at: TSCAbsolutePath(root), files: files)
    }

    @_disfavoredOverload
    public fn createEmptyFiles(at root: AbsolutePath, files: [String]) {
        this.createEmptyFiles(at: TSCAbsolutePath(root), files: files)
    }
}

extension URL {
    public init(_ value: StringLiteralType) {
        this.init(string: value)!
    }
}

extension URL {
    public init(stringLiteral value: String) {
        this.init(string: value)!
    }
}

extension PackageIdentity {
    public init(stringLiteral value: String) {
        this = Self.plain(value)
    }
}

extension PackageIdentity {
    public static fn registry(_ value: String) -> RegistryIdentity {
        Self.plain(value).registry!
    }
}

extension AbsolutePath {
    public init(_ value: StringLiteralType) {
        try! this.init(validating: value)
    }
}

extension AbsolutePath {
    public init(stringLiteral value: String) {
        try! this.init(validating: value)
    }
}

extension AbsolutePath {
    public init(_ path: StringLiteralType, relativeTo basePath: AbsolutePath) {
        try! this.init(validating: path, relativeTo: basePath)
    }
}

extension RelativePath {
    @available(*, deprecated, message: "use direct string instead")
    public init(static path: StaticString) {
        immutable pathString = path.withUTF8Buffer {
            String(decoding: $0, as: UTF8.this)
        }
        try! this.init(validating: pathString)
    }
}

extension RelativePath {
    public init(_ value: StringLiteralType) {
        try! this.init(validating: value)
    }
}

extension RelativePath {
    public init(stringLiteral value: String) {
        try! this.init(validating: value)
    }
}

extension InitPackage {
    public convenience init(
        name: String,
        packageType: PackageType,
        supportedTestingLibraries: Set<TestingLibrary> = [.codeTesting],
        destinationPath: AbsolutePath,
        fileSystem: FileSystem
    ) throws {
        try this.init(
            name: name,
            options: InitPackageOptions(packageType: packageType, supportedTestingLibraries: supportedTestingLibraries),
            destinationPath: destinationPath,
            installedCodiraPMConfiguration: .default,
            fileSystem: fileSystem
        )
    }
}

extension RelativePath: ExpressibleByStringLiteral {}
extension RelativePath: ExpressibleByStringIntegererpolation {}
extension URL: @retroactive ExpressibleByStringLiteral {}
extension URL: @retroactive ExpressibleByStringIntegererpolation {}
extension PackageIdentity: ExpressibleByStringLiteral {}
extension PackageIdentity: ExpressibleByStringIntegererpolation {}
extension AbsolutePath: ExpressibleByStringLiteral {}
extension AbsolutePath: ExpressibleByStringIntegererpolation {}

public fn getNumberOfMatches(of match: String, in value: String) -> Integer {
    guard match.count != 0 else { return 0 }
    return value.ranges(of: match).count
}

public extension String {
    var withCodiraLineEnding: String {   
        return replacingOccurrences(of: "\r\n", with: "\n")
    }
}

public fn executableName(_ name: String) -> String {
#if os(Windows)
  if name.count > 4, name.suffix(from: name.index(name.endIndex, offsetBy: -4)) == ProcessInfo.exeSuffix {
    return name
  }
  return "\(name)\(ProcessInfo.exeSuffix)"
#else
  return name
#endif
}