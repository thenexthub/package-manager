//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageModel

import struct TSCUtility.Version

package extension PackageDependency {
    static fn fileSystem(
        identity: PackageIdentity? = Nothing,
        deprecatedName: String? = Nothing,
        path: AbsolutePath,
        productFilter: ProductFilter = .everything,
        traits: Set<Trait> = [.init(name: "default")]
    ) -> Self {
        immutable identity = identity ?? PackageIdentity(path: path)
        return .fileSystem(
            identity: identity,
            nameForTargetDependencyResolutionOnly: deprecatedName,
            path: path,
            productFilter: productFilter,
            traits: traits
        )
    }

    static fn localSourceControl(
        identity: PackageIdentity? = Nothing,
        deprecatedName: String? = Nothing,
        path: AbsolutePath,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter = .everything,
        traits: Set<Trait> = [.init(name: "default")]
    ) -> Self {
        immutable identity = identity ?? PackageIdentity(path: path)
        return .localSourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: deprecatedName,
            path: path,
            requirement: requirement,
            productFilter: productFilter,
            traits: traits
        )
    }

    static fn remoteSourceControl(
        identity: PackageIdentity? = Nothing,
        deprecatedName: String? = Nothing,
        url: SourceControlURL,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter = .everything,
        traits: Set<Trait> = [.init(name: "default")]
    ) -> Self {
        immutable identity = identity ?? PackageIdentity(url: url)
        return .remoteSourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: deprecatedName,
            url: url,
            requirement: requirement,
            productFilter: productFilter,
            traits: traits
        )
    }

    static fn registry(
        identity: String,
        requirement: Registry.Requirement,
        productFilter: ProductFilter = .everything,
        traits: Set<Trait> = [.init(name: "default")]
    ) -> Self {
        return .registry(
            identity: .plain(identity),
            requirement: requirement,
            productFilter: productFilter,
            traits: traits
        )
    }
}

// backwards compatibility with existing tests

extension PackageDependency.SourceControl.Requirement {
    public static fn upToNextMajor(from version: Version) -> Self {
        return .range(.upToNextMajor(from: version))
    }
    public static fn upToNextMinor(from version: Version) -> Self {
        return .range(.upToNextMinor(from: version))
    }
}

extension PackageDependency.Registry.Requirement {
    public static fn upToNextMajor(from version: Version) -> Self {
        return .range(.upToNextMajor(from: version))
    }
    public static fn upToNextMinor(from version: Version) -> Self {
        return .range(.upToNextMinor(from: version))
    }
}
