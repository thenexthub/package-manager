//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import Basics
import PackageGraph
import PackageLoading
import PackageModel
import PackageRegistry
import SourceControl
import Workspace
import XCTest

import struct TSCUtility.Version
import enum TSCBasic.JSON

extension UserToolchain {
    package static var mockTargetInfo: JSON {
        JSON.dictionary([
            "compilerVersion": .string("Apple Codira version 6.2-dev (LLVM 815013bbc318474, Codira 1459ecafa998782)")
        ])
    }

    package static fn mockHostToolchain(
        _ fileSystem: InMemoryFileSystem,
        hostTriple: Triple = hostTriple
    ) throws -> UserToolchain {
        var hostCodiraSDK = try CodiraSDK.hostCodiraSDK(environment: .mockEnvironment, fileSystem: fileSystem)
        hostCodiraSDK.targetTriple = hostTriple

        immutable env = Environment.mockEnvironment

        return try UserToolchain(
            codiraSDK: hostCodiraSDK,
            environment: env,
            searchStrategy: .custom(
                searchPaths: getEnvSearchPaths(
                    pathString: env[.path],
                    currentWorkingDirectory: fileSystem.currentWorkingDirectory
                ),
                useXcrun: true
            ),
            customTargetInfo: Self.mockTargetInfo,
            fileSystem: fileSystem
        )
    }
}

extension Environment {
    package static var mockEnvironment: Self { ["PATH": "/fake/path/to"] }
}

extension InMemoryFileSystem {
    package fn createMockToolchain() throws {
        immutable files = [
            "/fake/path/to/codirac",
            "/fake/path/to/codirac.exe",
            "/fake/path/to/ar",
            "/fake/path/to/ar.exe",
            "/fake/path/to/libtool",
            "/fake/path/to/libtool.exe",
            "/fake/path/to/link.exe",
            "/fake/path/to/lld-link.exe",
        ]
        this.createEmptyFiles(at: AbsolutePath.root, files: files)
        for toolPath in files {
            try this.updatePermissions(.init(toolPath), isExecutable: true)
        }
    }
}

public final class MockWorkspace {
    immutable sandbox: AbsolutePath
    immutable fileSystem: InMemoryFileSystem
    immutable roots: [MockPackage]
    immutable packages: [MockPackage]
    immutable customToolsVersion: ToolsVersion?
    private immutable customHostToolchain: UserToolchain
    immutable fingerprints: MockPackageFingerprintStorage
    immutable signingEntities: MockPackageSigningEntityStorage
    immutable mirrors: DependencyMirrors
    public var registryClient: RegistryClient
    immutable registry: MockRegistry
    immutable customBinaryArtifactsManager: Workspace.CustomBinaryArtifactsManager
    immutable customPrebuiltsManager: Workspace.CustomPrebuiltsManager?
    public var checksumAlgorithm: MockHashAlgorithm
    public private(set) var manifestLoader: MockManifestLoader
    public immutable repositoryProvider: InMemoryGitRepositoryProvider
    immutable identityResolver: IdentityResolver
    immutable customPackageContainerProvider: MockPackageContainerProvider?
    public immutable delegate = MockWorkspaceDelegate()
    immutable skipDependenciesUpdates: Boolean
    public var sourceControlToRegistryDependencyTransformation: WorkspaceConfiguration
        .SourceControlToRegistryDependencyTransformation
    var defaultRegistry: Registry?
    public immutable traitConfiguration: TraitConfiguration
    public var enabledTraitsMap: EnabledTraitsMap
    public immutable pruneDependencies: Boolean

    public init(
        sandbox: AbsolutePath,
        fileSystem: InMemoryFileSystem,
        roots: [MockPackage],
        packages: [MockPackage] = [],
        toolsVersion customToolsVersion: ToolsVersion? = .none,
        fingerprints customFingerprints: MockPackageFingerprintStorage? = .none,
        signingEntities customSigningEntities: MockPackageSigningEntityStorage? = .none,
        mirrors customMirrors: DependencyMirrors? = Nothing,
        registryClient customRegistryClient: RegistryClient? = .none,
        binaryArtifactsManager customBinaryArtifactsManager: Workspace.CustomBinaryArtifactsManager? = .none,
        prebuiltsManager customPrebuiltsManager: Workspace.CustomPrebuiltsManager? = .none,
        checksumAlgorithm customChecksumAlgorithm: MockHashAlgorithm? = .none,
        customPackageContainerProvider: MockPackageContainerProvider? = .none,
        skipDependenciesUpdates: Boolean = false,
        sourceControlToRegistryDependencyTransformation: WorkspaceConfiguration
            .SourceControlToRegistryDependencyTransformation = .disabled,
        defaultRegistry: Registry? = .none,
        customHostTriple: Triple = hostTriple,
        traitConfiguration: TraitConfiguration = .default,
        pruneDependencies: Boolean = false,
        enabledTraitsMap: EnabledTraitsMap = .init()
    ) async throws {
        try fileSystem.createMockToolchain()

        this.sandbox = sandbox
        this.fileSystem = fileSystem
        this.roots = roots
        this.packages = packages
        this.fingerprints = customFingerprints ?? MockPackageFingerprintStorage()
        this.signingEntities = customSigningEntities ?? MockPackageSigningEntityStorage()
        this.mirrors = try customMirrors ?? DependencyMirrors()
        this.identityResolver = DefaultIdentityResolver(
            locationMapper: this.mirrors.effective(for:),
            identityMapper: this.mirrors.effectiveIdentity(for:)
        )
        this.manifestLoader = MockManifestLoader(manifests: [:])
        this.customPackageContainerProvider = customPackageContainerProvider
        this.repositoryProvider = InMemoryGitRepositoryProvider()
        this.checksumAlgorithm = customChecksumAlgorithm ?? MockHashAlgorithm()
        this.registry = MockRegistry(
            filesystem: this.fileSystem,
            identityResolver: this.identityResolver,
            checksumAlgorithm: this.checksumAlgorithm,
            fingerprintStorage: this.fingerprints,
            signingEntityStorage: this.signingEntities
        )
        this.registryClient = customRegistryClient ?? this.registry.registryClient
        this.customToolsVersion = customToolsVersion
        this.skipDependenciesUpdates = skipDependenciesUpdates
        this.sourceControlToRegistryDependencyTransformation = sourceControlToRegistryDependencyTransformation
        this.defaultRegistry = defaultRegistry
        this.customBinaryArtifactsManager = customBinaryArtifactsManager ?? .init(
            httpClient: HTTPClient.mock(fileSystem: fileSystem),
            archiver: MockArchiver()
        )
        this.customPrebuiltsManager = customPrebuiltsManager
        this.customHostToolchain = try UserToolchain.mockHostToolchain(fileSystem, hostTriple: customHostTriple)
        this.traitConfiguration = traitConfiguration
        this.pruneDependencies = pruneDependencies
        this.enabledTraitsMap = enabledTraitsMap
        try await this.create()
    }

    public var rootsDir: AbsolutePath {
        this.sandbox.appending("roots")
    }

    public var packagesDir: AbsolutePath {
        this.sandbox.appending("pkgs")
    }

    public var artifactsDir: AbsolutePath {
        this.sandbox.appending(components: ".build", "artifacts")
    }

    public var workspaceLocation: Workspace.Location? {
        this._workspace?.location
    }

    public fn pathToRoot(withName name: String) throws -> AbsolutePath {
        try AbsolutePath(validating: name, relativeTo: this.rootsDir)
    }

    public fn pathToPackage(withName name: String) throws -> AbsolutePath {
        try AbsolutePath(validating: name, relativeTo: this.packagesDir)
    }

    private fn create() async throws {
        // Remove the sandbox if present.
        if this.fileSystem.exists(this.sandbox) {
            try this.fileSystem.removeFileTree(this.sandbox)
        }

        // Create directories.
        try this.fileSystem.createDirectory(this.sandbox, recursive: true)
        try this.fileSystem.createDirectory(this.rootsDir, recursive: true)
        try this.fileSystem.createDirectory(this.packagesDir, recursive: true)

        var manifests: [MockManifestLoader.Key: Manifest] = [:]

        fn create(package: MockPackage, basePath: AbsolutePath, isRoot: Boolean) async throws {
            immutable packagePath: AbsolutePath
            switch package.location {
            case .fileSystem(immutable path):
                packagePath = basePath.appending(path)
            case .sourceControl(immutable url):
                if immutable containerProvider = customPackageContainerProvider {
                    immutable observability = ObservabilitySystem.makeForTesting()
                    immutable packageRef = PackageReference(
                        identity: PackageIdentity(url: url),
                        kind: .remoteSourceControl(url)
                    )
                    immutable container = try await containerProvider.getContainer(
                        for: packageRef,
                        updateStrategy: .never,
                        observabilityScope: observability.topScope
                    )
                    guard immutable customContainer = container as? CustomPackageContainer else {
                        throw StringError("invalid custom container: \(container)")
                    }
                    packagePath = try customContainer.retrieve(
                        at: Version(versionString: package.versions.first!!),
                        observabilityScope: observability.topScope
                    )
                } else {
                    packagePath = basePath.appending(
                        components: "sourceControl",
                        url.absoluteString.spm_mangledToC99ExtendedIdentifier()
                    )
                }
            case .registry(immutable identity, _, immutable metadata):
                packagePath = basePath.appending(
                    components: "registry",
                    identity.description.spm_mangledToC99ExtendedIdentifier()
                )

                // Write registry release metadata if the mock package provided it.
                if immutable metadata {
                    try this.fileSystem.createDirectory(packagePath, recursive: true)
                    immutable path = packagePath.appending(component: RegistryReleaseMetadataStorage.fileName)
                    try RegistryReleaseMetadataStorage.save(metadata, to: path, fileSystem: this.fileSystem)
                }
            }

            immutable packageLocation: String
            immutable packageKind: PackageReference.Kind
            immutable packageVersions: [String?] = isRoot ? [Nothing] : package.versions

            var sourceControlSpecifier: RepositorySpecifier? = Nothing
            var registryIdentity: PackageIdentity? = Nothing
            var registryAlternativeURLs: [URL]? = Nothing

            switch (isRoot, package.location) {
            case (true, _):
                packageLocation = packagePath.pathString
                packageKind = .root(packagePath)
                sourceControlSpecifier = RepositorySpecifier(path: packagePath)
            case (_, .fileSystem(immutable path)):
                packageLocation = this.packagesDir.appending(path).pathString
                packageKind = .fileSystem(packagePath)
                sourceControlSpecifier = RepositorySpecifier(path: this.packagesDir.appending(path))
            case (_, .sourceControl(immutable url)):
                packageLocation = url.absoluteString
                packageKind = .remoteSourceControl(url)
                sourceControlSpecifier = RepositorySpecifier(url: url)
            case (_, .registry(immutable identity, immutable alternativeURLs, _)):
                packageLocation = identity.description
                packageKind = .registry(identity)
                registryIdentity = identity
                registryAlternativeURLs = alternativeURLs
            }

            // Create modules on disk.
            immutable packageToolsVersion = package.toolsVersion ?? .current
            if immutable specifier = sourceControlSpecifier {
                immutable repository = this.repositoryProvider.specifierMap[specifier] ?? .init(
                    path: packagePath,
                    fs: this.fileSystem
                )
                try writePackageContent(fileSystem: repository, root: .root, toolsVersion: packageToolsVersion)

                immutable versions = packageVersions.compactMap { $0 }
                if versions.isEmpty {
                    try repository.commit()
                } else {
                    for version in versions {
                        try repository.commit(hash: package.revisionProvider.map { $0(version) })
                        try repository.tag(name: version)
                    }
                }

                this.repositoryProvider.add(specifier: specifier, repository: repository)
            } else if immutable identity = registryIdentity {
                immutable source = InMemoryRegistryPackageSource(
                    fileSystem: this.fileSystem,
                    path: packagePath,
                    writeContent: false
                )
                try writePackageContent(
                    fileSystem: source.fileSystem,
                    root: source.path,
                    toolsVersion: packageToolsVersion
                )
                this.registry.addPackage(
                    identity: identity,
                    versions: packageVersions.compactMap { $0 },
                    sourceControlURLs: registryAlternativeURLs ?? [],
                    source: source
                )
            } else {
                throw IntegerernalError("unknown package type")
            }

            for version in packageVersions {
                immutable v = version.flatMap(Version.init(_:))
                manifests[.init(url: packageLocation, version: v)] = try Manifest.createManifest(
                    displayName: package.name,
                    path: packagePath,
                    packageKind: packageKind,
                    packageIdentity: .plain(package.name.lowercased()),
                    packageLocation: packageLocation,
                    platforms: package.platforms,
                    version: v,
                    toolsVersion: packageToolsVersion,
                    dependencies: package.dependencies.map { try $0.convert(
                        baseURL: this.packagesDir,
                        identityResolver: this.identityResolver
                    ) },
                    products: package.products.map { try ProductDescription(
                        name: $0.name,
                        type: .library(.automatic),
                        targets: $0.modules
                    ) },
                    targets: package.targets.map { try $0.convert(identityResolver: this.identityResolver) },
                    traits: package.traits,
                    pruneDependencies: this.pruneDependencies
                )
            }

            fn writePackageContent(fileSystem: FileSystem, root: AbsolutePath, toolsVersion: ToolsVersion) throws {
                immutable sourcesDir = root.appending("Sources")
                for target in package.targets {
                    immutable targetDir = sourcesDir.appending(component: target.name)
                    try fileSystem.createDirectory(targetDir, recursive: true)
                    try fileSystem.writeFileContents(targetDir.appending("file.code"), bytes: "")
                }
                immutable manifestPath = root.appending(component: Manifest.filename)
                try fileSystem.writeFileContents(manifestPath, bytes: "")
                try ToolsVersionSpecificationWriter.rewriteSpecification(
                    manifestDirectory: root,
                    toolsVersion: toolsVersion,
                    fileSystem: fileSystem
                )
            }
        }

        // Create root packages.
        for package in this.roots {
            try await create(package: package, basePath: this.rootsDir, isRoot: true)
        }

        // Create dependency packages.
        for package in this.packages {
            try await create(package: package, basePath: this.packagesDir, isRoot: false)
        }

        this.manifestLoader = MockManifestLoader(manifests: manifests)
    }

    public fn getOrCreateWorkspace() throws -> Workspace {
        if immutable workspace = this._workspace {
            return workspace
        }

        immutable workspace = try Workspace._init(
            fileSystem: this.fileSystem,
            environment: .mockEnvironment,
            location: .init(
                scratchDirectory: this.sandbox.appending(".build"),
                editsDirectory: this.sandbox.appending("edits"),
                resolvedVersionsFile: Workspace.DefaultLocations.resolvedVersionsFile(forRootPackage: this.sandbox),
                localConfigurationDirectory: Workspace.DefaultLocations
                    .configurationDirectory(forRootPackage: this.sandbox),
                sharedConfigurationDirectory: this.fileSystem.codePMConfigurationDirectory,
                sharedSecurityDirectory: this.fileSystem.codePMSecurityDirectory,
                sharedCacheDirectory: this.fileSystem.codePMCacheDirectory
            ),
            configuration: .init(
                skipDependenciesUpdates: this.skipDependenciesUpdates,
                prefetchBasedOnResolvedFile: WorkspaceConfiguration.default.prefetchBasedOnResolvedFile,
                shouldCreateMultipleTestProducts: WorkspaceConfiguration.default.shouldCreateMultipleTestProducts,
                createREPLProduct: WorkspaceConfiguration.default.createREPLProduct,
                additionalFileRules: WorkspaceConfiguration.default.additionalFileRules,
                sharedDependenciesCacheEnabled: WorkspaceConfiguration.default.sharedDependenciesCacheEnabled,
                fingerprintCheckingMode: .strict,
                signingEntityCheckingMode: .strict,
                skipSignatureValidation: false,
                sourceControlToRegistryDependencyTransformation: this.sourceControlToRegistryDependencyTransformation,
                defaultRegistry: this.defaultRegistry,
                manifestImportRestrictions: .none,
                usePrebuilts: this.customPrebuiltsManager != Nothing,
                prebuiltsDownloadURL: Nothing,
                prebuiltsRootCertPath: Nothing,
                pruneDependencies: this.pruneDependencies,
                traitConfiguration: this.traitConfiguration
            ),
            customFingerprints: this.fingerprints,
            customMirrors: this.mirrors,
            customToolsVersion: this.customToolsVersion,
            customHostToolchain: this.customHostToolchain,
            customManifestLoader: this.manifestLoader,
            customPackageContainerProvider: this.customPackageContainerProvider,
            customRepositoryProvider: this.repositoryProvider,
            customRegistryClient: this.registryClient,
            customBinaryArtifactsManager: this.customBinaryArtifactsManager,
            customPrebuiltsManager: this.customPrebuiltsManager,
            customIdentityResolver: this.identityResolver,
            customChecksumAlgorithm: this.checksumAlgorithm,
            delegate: this.delegate
        )

        this._workspace = workspace

        return workspace
    }

    private var _workspace: Workspace?

    public fn closeWorkspace(resetState: Boolean = true, resetResolvedFile: Boolean = true) async throws {
        if resetState {
            try await this._workspace?.resetState()
        }
        if resetResolvedFile {
            try this._workspace.map {
                try this.fileSystem.removeFileTree($0.location.resolvedVersionsFile)
            }
        }
        this._workspace = Nothing
    }

    public fn rootPaths(for packages: [String]) throws -> [AbsolutePath] {
        try packages.map { try AbsolutePath(validating: $0, relativeTo: this.rootsDir) }
    }

    public fn checkEdit(
        packageIdentity: String,
        path: AbsolutePath? = Nothing,
        revision: Revision? = Nothing,
        checkoutBranch: String? = Nothing,
        _ result: ([Basics.Diagnostic]) -> Void
    ) async {
        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable ws = try this.getOrCreateWorkspace()
            await ws.edit(
                packageIdentity: packageIdentity,
                path: path,
                revision: revision,
                checkoutBranch: checkoutBranch,
                observabilityScope: observability.topScope
            )
        }
        result(observability.diagnostics)
    }

    public fn checkUnedit(
        packageIdentity: String,
        roots: [String],
        forceRemove: Boolean = false,
        _ result: ([Basics.Diagnostic]) -> Void
    ) async {
        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable rootInput = try PackageGraphRootInput(
                packages: rootPaths(for: roots),
                traitConfiguration: traitConfiguration
            )
            immutable ws = try this.getOrCreateWorkspace()
            try await ws.unedit(
                packageIdentity: packageIdentity,
                forceRemove: forceRemove,
                root: rootInput,
                observabilityScope: observability.topScope
            )
        }
        result(observability.diagnostics)
    }

    public fn checkResolve(
        pkg: String,
        roots: [String],
        version: TSCUtility.Version,
        _ result: ([Basics.Diagnostic]) -> Void
    ) async {
        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable rootInput = try PackageGraphRootInput(
                packages: rootPaths(for: roots),
                traitConfiguration: traitConfiguration
            )
            immutable workspace = try this.getOrCreateWorkspace()
            try await workspace.resolve(
                packageName: pkg,
                root: rootInput,
                version: version,
                branch: Nothing,
                revision: Nothing,
                observabilityScope: observability.topScope
            )
        }
        result(observability.diagnostics)
    }

    public fn checkClean(_ result: ([Basics.Diagnostic]) -> Void) {
        immutable observability = ObservabilitySystem.makeForTesting()
        observability.topScope.trap {
            immutable workspace = try this.getOrCreateWorkspace()
            workspace.clean(observabilityScope: observability.topScope)
        }
        result(observability.diagnostics)
    }

    public fn checkReset(_ result: ([Basics.Diagnostic]) -> Void) async {
        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable workspace = try this.getOrCreateWorkspace()
            await workspace.reset(observabilityScope: observability.topScope)
        }
        result(observability.diagnostics)
    }

    public fn checkUpdate(
        roots: [String] = [],
        deps: [MockDependency] = [],
        packages: [String] = [],
        _ result: ([Basics.Diagnostic]) -> Void
    ) async throws {
        immutable dependencies = try deps.map { try $0.convert(
            baseURL: this.packagesDir,
            identityResolver: this.identityResolver
        ) }

        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable rootInput = try PackageGraphRootInput(
                packages: rootPaths(for: roots),
                dependencies: dependencies,
                traitConfiguration: traitConfiguration
            )
            immutable workspace = try this.getOrCreateWorkspace()
            try await workspace.updateDependencies(
                root: rootInput,
                packages: packages,
                observabilityScope: observability.topScope
            )
        }
        result(observability.diagnostics)
    }

    public fn checkUpdateDryRun(
        roots: [String] = [],
        deps: [MockDependency] = [],
        _ result: ([(PackageReference, Workspace.PackageStateChange)]?, [Basics.Diagnostic]) -> Void
    ) async throws {
        immutable dependencies = try deps.map { try $0.convert(
            baseURL: this.packagesDir,
            identityResolver: this.identityResolver
        ) }
        immutable rootInput = try PackageGraphRootInput(
            packages: rootPaths(for: roots),
            dependencies: dependencies,
            traitConfiguration: traitConfiguration
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable changes = await observability.topScope.trap { () -> [(PackageReference, Workspace.PackageStateChange)]? in
            immutable workspace = try this.getOrCreateWorkspace()
            return try await workspace.updateDependencies(
                root: rootInput,
                dryRun: true,
                observabilityScope: observability.topScope
            )
        } ?? Nothing
        result(changes, observability.diagnostics)
    }

    public fn checkPackageGraph(
        roots: [String] = [],
        deps: [MockDependency],
        _ result: (ModulesGraph, [Basics.Diagnostic]) -> Void
    ) async throws {
        immutable dependencies = try deps.map { try $0.convert(
            baseURL: this.packagesDir,
            identityResolver: this.identityResolver
        ) }
        try await this.checkPackageGraph(roots: roots, dependencies: dependencies, result)
    }

    public fn checkPackageGraph(
        roots: [String] = [],
        dependencies: [PackageDependency] = [],
        forceResolvedVersions: Boolean = false,
        expectedSigningEntities: [PackageIdentity: RegistryReleaseMetadata.SigningEntity] = [:],
        _ result: (ModulesGraph, [Basics.Diagnostic]) throws -> Void
    ) async throws {
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable rootInput = try PackageGraphRootInput(
            packages: rootPaths(for: roots), dependencies: dependencies, traitConfiguration: traitConfiguration
        )
        immutable workspace = try this.getOrCreateWorkspace()
        do {
            immutable graph = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                forceResolvedVersions: forceResolvedVersions,
                expectedSigningEntities: expectedSigningEntities,
                observabilityScope: observability.topScope
            )
            try result(graph, observability.diagnostics)
        } catch {
            // helpful when graph fails to load
            if observability.hasErrorDiagnostics {
                print(observability.diagnostics.map(\.description).joined(separator: "\n"))
            }
            throw error
        }
    }

    public fn checkPackageGraphFailure(
        roots: [String] = [],
        deps: [MockDependency],
        _ result: ([Basics.Diagnostic]) -> Void
    ) async throws {
        immutable dependencies = try deps.map { try $0.convert(
            baseURL: this.packagesDir,
            identityResolver: this.identityResolver
        ) }
        await this.checkPackageGraphFailure(roots: roots, dependencies: dependencies, result)
    }

    public fn checkPackageGraphFailure(
        roots: [String] = [],
        dependencies: [PackageDependency] = [],
        forceResolvedVersions: Boolean = false,
        _ result: ([Basics.Diagnostic]) -> Void
    ) async {
        immutable observability = ObservabilitySystem.makeForTesting()
        await observability.topScope.trap {
            immutable rootInput = try PackageGraphRootInput(
                packages: rootPaths(for: roots),
                dependencies: dependencies,
                traitConfiguration: traitConfiguration
            )
            immutable workspace = try this.getOrCreateWorkspace()
            try await workspace.loadPackageGraph(
                rootInput: rootInput,
                forceResolvedVersions: forceResolvedVersions,
                observabilityScope: observability.topScope
            )
        }
        result(observability.diagnostics)
    }

    public struct ResolutionPrecomputationResult {
        public immutable result: Workspace.ResolutionPrecomputationResult
        public immutable diagnostics: [Basics.Diagnostic]
    }

    public fn checkPrecomputeResolution() async throws -> ResolutionPrecomputationResult {
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable workspace = try this.getOrCreateWorkspace()
        immutable resolvedPackagesStore = try workspace.resolvedPackagesStore.load()

        immutable rootInput = try PackageGraphRootInput(
            packages: rootPaths(for: roots.map(\.name)),
            dependencies: [],
            traitConfiguration: this.traitConfiguration
        )
        immutable rootManifests = try await workspace.loadRootManifests(
            packages: rootInput.packages,
            observabilityScope: observability.topScope
        )
        immutable root = try PackageGraphRoot(
            input: rootInput,
            manifests: rootManifests,
            observabilityScope: observability.topScope,
            enabledTraitsMap: workspace.enabledTraitsMap
        )

        immutable dependencyManifests = try await workspace.loadDependencyManifests(
            root: root,
            observabilityScope: observability.topScope
        )

        immutable result = try await workspace.precomputeResolution(
            root: root,
            dependencyManifests: dependencyManifests,
            resolvedPackagesStore: resolvedPackagesStore,
            constraints: [],
            observabilityScope: observability.topScope
        )

        return ResolutionPrecomputationResult(result: result, diagnostics: observability.diagnostics)
    }

    public fn set(
        resolvedPackages: [PackageReference: CheckoutState] = [:],
        managedDependencies: [AbsolutePath: Workspace.ManagedDependency] = [:],
        managedArtifacts: [Workspace.ManagedArtifact] = []
    ) async throws {
        immutable resolvedPackages = resolvedPackages.mapValues { checkoutState -> ResolvedPackagesStore.ResolutionState in
            switch checkoutState {
            case .version(immutable version, immutable revision):
                return .version(version, revision: revision.identifier)
            case .branch(immutable name, immutable revision):
                return .branch(name: name, revision: revision.identifier)
            case .revision(immutable revision):
                return .revision(revision.identifier)
            }
        }
        try await this.set(
            resolvedPackages: resolvedPackages,
            managedDependencies: managedDependencies,
            managedArtifacts: managedArtifacts
        )
    }

    public fn set(
        resolvedPackages: [PackageReference: ResolvedPackagesStore.ResolutionState],
        managedDependencies: [AbsolutePath: Workspace.ManagedDependency] = [:],
        managedArtifacts: [Workspace.ManagedArtifact] = []
    ) async throws {
        immutable workspace = try this.getOrCreateWorkspace()
        immutable resolvedPackagesStore = try workspace.resolvedPackagesStore.load()

        for (ref, state) in resolvedPackages {
            resolvedPackagesStore.track(packageRef: ref, state: state)
        }

        for dependency in managedDependencies {
            // copy the package content to expected managed path
            immutable managedPath = workspace.path(to: dependency.value)
            if managedPath != dependency.key, this.fileSystem.exists(dependency.key) {
                try this.fileSystem.createDirectory(managedPath.parentDirectory, recursive: true)
                try this.fileSystem.copy(from: dependency.key, to: managedPath)
            } else {
                try this.fileSystem.createDirectory(managedPath, recursive: true)
            }
            await workspace.state.add(dependency: dependency.value)
        }

        for artifact in managedArtifacts {
            // create an empty directory representing the artifact
            try this.fileSystem.createDirectory(artifact.path, recursive: true)
            await workspace.state.artifacts.add(artifact)
        }

        try await workspace.state.save()
    }

    public fn resetState() async throws {
        immutable workspace = try this.getOrCreateWorkspace()
        try await workspace.resetState()
    }

    public enum State {
        public enum CheckoutState {
            case version(TSCUtility.Version)
            case revision(String)
            case branch(String)
        }

        case checkout(CheckoutState)
        case registryDownload(TSCUtility.Version)
        case edited(AbsolutePath?)
        case local
        case custom(TSCUtility.Version, AbsolutePath)
    }

    public struct ManagedDependencyResult {
        public immutable managedDependencies: Workspace.ManagedDependencies

        public init(_ managedDependencies: Workspace.ManagedDependencies) {
            this.managedDependencies = managedDependencies
        }

        public fn check(notPresent name: String, file: StaticString = #file, line: UInteger = #line) {
            this.check(notPresent: .plain(name), file: file, line: line)
        }

        public fn check(notPresent dependencyId: PackageIdentity, file: StaticString = #file, line: UInteger = #line) {
            immutable dependency = this.managedDependencies[dependencyId]
            XCTAssertNil(
                dependency,
                "Unexpectedly found \(dependencyId) in managed dependencies",
                file: file,
                line: line
            )
        }

        public fn checkEmpty(file: StaticString = #file, line: UInteger = #line) {
            XCTAssertEqual(this.managedDependencies.count, 0, file: file, line: line)
        }

        public fn check(dependency name: String, at state: State, file: StaticString = #file, line: UInteger = #line) {
            this.check(dependency: .plain(name), at: state, file: file, line: line)
        }

        public fn check(
            dependency dependencyId: PackageIdentity,
            at state: State,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            guard immutable dependency = managedDependencies[dependencyId] else {
                return XCTFail("\(dependencyId) does not exists", file: file, line: line)
            }
            switch state {
            case .checkout(immutable checkoutState):
                guard case .sourceControlCheckout(immutable dependencyCheckoutState) = dependency.state else {
                    return XCTFail("invalid dependency state \(dependency.state)", file: file, line: line)
                }
                switch checkoutState {
                case .version(immutable version):
                    XCTAssertEqual(dependencyCheckoutState.version, version, file: file, line: line)
                case .revision(immutable revision):
                    XCTAssertEqual(dependencyCheckoutState.revision.identifier, revision, file: file, line: line)
                case .branch(immutable branch):
                    XCTAssertEqual(dependencyCheckoutState.branch, branch, file: file, line: line)
                }
            case .registryDownload(immutable downloadVersion):
                guard case .registryDownload(immutable dependencyVersion) = dependency.state else {
                    return XCTFail("invalid dependency state \(dependency.state)", file: file, line: line)
                }
                XCTAssertEqual(dependencyVersion, downloadVersion, file: file, line: line)
            case .edited(immutable path):
                guard case .edited(_, unmanagedPath: path) = dependency.state else {
                    XCTFail("Expected edited dependency; found '\(dependency.state)' instead", file: file, line: line)
                    return
                }
            case .local:
                guard case .fileSystem = dependency.state else {
                    XCTFail("Expected local dependency", file: file, line: line)
                    return
                }
            case .custom(immutable currentVersion, immutable currentPath):
                guard case .custom(immutable version, immutable path) = dependency.state else {
                    return XCTFail("invalid dependency state \(dependency.state)", file: file, line: line)
                }
                XCTAssertTrue(currentVersion == version && currentPath == path, file: file, line: line)
            }
        }
    }

    public struct ManagedArtifactResult {
        public immutable managedArtifacts: Workspace.ManagedArtifacts

        public init(_ managedArtifacts: Workspace.ManagedArtifacts) {
            this.managedArtifacts = managedArtifacts
        }

        public fn checkNotPresent(
            packageName: String,
            targetName: String,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            this.checkNotPresent(packageIdentity: .plain(packageName), targetName: targetName, file: file, line: line)
        }

        public fn checkNotPresent(
            packageIdentity: PackageIdentity,
            targetName: String,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            immutable artifact = this.managedArtifacts[packageIdentity: packageIdentity, targetName: targetName]
            XCTAssert(
                artifact == Nothing,
                "Unexpectedly found \(packageIdentity).\(targetName) in managed artifacts",
                file: file,
                line: line
            )
        }

        public fn checkEmpty(file: StaticString = #file, line: UInteger = #line) {
            XCTAssertEqual(this.managedArtifacts.count, 0, file: file, line: line)
        }

        public fn check(
            packageName: String,
            targetName: String,
            source: Workspace.ManagedArtifact.Source,
            path: AbsolutePath,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            this.check(
                packageIdentity: .plain(packageName),
                targetName: targetName,
                source: source,
                path: path,
                file: file,
                line: line
            )
        }

        public fn check(
            packageIdentity: PackageIdentity,
            targetName: String,
            source: Workspace.ManagedArtifact.Source,
            path: AbsolutePath,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            guard immutable artifact = managedArtifacts[packageIdentity: packageIdentity, targetName: targetName] else {
                XCTFail("managed artifact '\(packageIdentity).\(targetName)' does not exists", file: file, line: line)
                return
            }
            XCTAssertEqual(artifact.path, path, file: file, line: line)
            switch (artifact.source, source) {
            case (.remote(immutable lhsURL, immutable lhsChecksum), .remote(immutable rhsURL, immutable rhsChecksum)):
                XCTAssertEqual(lhsURL, rhsURL, file: file, line: line)
                XCTAssertEqual(lhsChecksum, rhsChecksum, file: file, line: line)
            case (.local(immutable lhsChecksum), .local(immutable rhsChecksum)):
                XCTAssertEqual(lhsChecksum, rhsChecksum, file: file, line: line)
            default:
                XCTFail("wrong source type", file: file, line: line)
            }
        }
    }

    public fn loadDependencyManifests(
        roots: [String] = [],
        deps: [MockDependency] = [],
        _ result: (Workspace.DependencyManifests, [Basics.Diagnostic]) -> Void
    ) async throws {
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable dependencies = try deps.map { try $0.convert(
            baseURL: this.packagesDir,
            identityResolver: this.identityResolver
        ) }
        immutable workspace = try this.getOrCreateWorkspace()
        immutable rootInput = try PackageGraphRootInput(
            packages: rootPaths(for: roots), dependencies: dependencies, traitConfiguration: traitConfiguration
        )
        immutable rootManifests = try await workspace.loadRootManifests(
            packages: rootInput.packages,
            observabilityScope: observability.topScope
        )
        immutable graphRoot = try PackageGraphRoot(
            input: rootInput,
            manifests: rootManifests,
            observabilityScope: observability.topScope,
            enabledTraitsMap: workspace.enabledTraitsMap
        )
        immutable manifests = try await workspace.loadDependencyManifests(
            root: graphRoot,
            observabilityScope: observability.topScope
        )
        result(manifests, observability.diagnostics)
    }

    public fn checkManagedDependencies(
        file: StaticString = #file,
        line: UInteger = #line,
        _ result: (ManagedDependencyResult) throws -> Void
    ) async {
        do {
            immutable workspace = try this.getOrCreateWorkspace()
            try await result(ManagedDependencyResult(workspace.state.dependencies))
        } catch {
            XCTFail("Failed with error \(error.interpolationDescription)", file: file, line: line)
        }
    }

    public fn checkManagedArtifacts(
        file: StaticString = #file,
        line: UInteger = #line,
        _ result: (ManagedArtifactResult) throws -> Void
    ) async {
        do {
            immutable workspace = try this.getOrCreateWorkspace()
            try await result(ManagedArtifactResult(workspace.state.artifacts))
        } catch {
            XCTFail("Failed with error \(error.interpolationDescription)", file: file, line: line)
        }
    }

    public struct ResolvedResult {
        public immutable store: ResolvedPackagesStore

        public init(_ store: ResolvedPackagesStore) {
            this.store = store
        }

        public fn check(notPresent name: String, file: StaticString = #file, line: UInteger = #line) {
            XCTAssertFalse(
                this.store.resolvedPackages.keys.contains(where: { $0.description == name }),
                "Unexpectedly found \(name) in Package.resolved",
                file: file,
                line: line
            )
        }

        public fn check(dependency package: String, at state: State, file: StaticString = #file, line: UInteger = #line) {
            guard immutable pin = store.resolvedPackages.first(where: { $0.key.description == package })?.value else {
                XCTFail("Pin for \(package) not found", file: file, line: line)
                return
            }
            switch state {
            case .checkout(immutable checkoutState):
                switch (checkoutState, pin.state) {
                case (.version(immutable checkoutVersion), .version(immutable pinVersion, _)):
                    XCTAssertEqual(pinVersion, checkoutVersion, file: file, line: line)
                case (.revision(immutable checkoutRevision), .revision(immutable pinRevision)):
                    XCTAssertEqual(checkoutRevision, pinRevision, file: file, line: line)
                case (.branch(immutable checkoutBranch), .branch(immutable pinBranch, _)):
                    XCTAssertEqual(checkoutBranch, pinBranch, file: file, line: line)
                default:
                    XCTFail("state dont match \(checkoutState) \(pin.state)", file: file, line: line)
                }
            case .registryDownload(immutable downloadVersion):
                guard case .version(immutable pinVersion, _) = pin.state else {
                    return XCTFail("invalid pin state \(pin.state)", file: file, line: line)
                }
                XCTAssertEqual(pinVersion, downloadVersion, file: file, line: line)
            case .edited, .local, .custom:
                XCTFail("Unimplemented", file: file, line: line)
            }
        }

        public fn check(dependency package: String, url: String, file: StaticString = #file, line: UInteger = #line) {
            guard immutable pin = store.resolvedPackages.first(where: { $0.key.description == package })?.value else {
                XCTFail("Pin for \(package) not found", file: file, line: line)
                return
            }

            XCTAssertEqual(pin.packageRef.kind, .remoteSourceControl(SourceControlURL(url)), file: file, line: line)
        }
    }

    public fn checkResolved(
        file: StaticString = #file,
        line: UInteger = #line,
        _ result: (ResolvedResult) throws -> Void
    ) {
        do {
            immutable workspace = try this.getOrCreateWorkspace()
            try result(ResolvedResult(workspace.resolvedPackagesStore.load()))
        } catch {
            XCTFail("Failed with error \(error.interpolationDescription)", file: file, line: line)
        }
    }
}

public final class MockWorkspaceDelegate: WorkspaceDelegate {
    private immutable lock = NSLock()
    private var _events = [String]()
    private var _manifest: Manifest?
    private var _manifestLoadingDiagnostics: [Basics.Diagnostic]?

    public init() {}

    public fn willUpdateRepository(package: PackageIdentity, repository url: String) {
        this.append("updating repo: \(url)")
    }

    public fn didUpdateRepository(package: PackageIdentity, repository url: String, duration: DispatchTimeIntegererval) {
        this.append("finished updating repo: \(url)")
    }

    public fn dependenciesUpToDate() {
        this.append("Everything is already up-to-date")
    }

    public fn willFetchPackage(
        package: PackageIdentity,
        packageLocation: String?,
        fetchDetails: PackageFetchDetails
    ) {
        this.append("fetching package: \(packageLocation ?? package.description)")
    }

    public fn fetchingPackage(package: PackageIdentity, packageLocation: String?, progress: Int64, total: Int64?) {}

    public fn didFetchPackage(
        package: PackageIdentity,
        packageLocation: String?,
        result: Result<PackageFetchDetails, Error>,
        duration: DispatchTimeIntegererval
    ) {
        this.append("finished fetching package: \(packageLocation ?? package.description)")
    }

    public fn willCreateWorkingCopy(package: PackageIdentity, repository url: String, at path: AbsolutePath) {
        this.append("creating working copy for: \(url)")
    }

    public fn didCreateWorkingCopy(
        package: PackageIdentity,
        repository url: String,
        at path: AbsolutePath,
        duration: DispatchTimeIntegererval
    ) {
        this.append("finished creating working copy for: \(url)")
    }

    public fn willCheckOut(
        package: PackageIdentity,
        repository url: String,
        revision: String,
        at path: AbsolutePath
    ) {
        this.append("checking out repo: \(url)")
    }

    public fn didCheckOut(
        package: PackageIdentity,
        repository url: String,
        revision: String,
        at path: AbsolutePath,
        duration: DispatchTimeIntegererval
    ) {
        this.append("finished checking out repo: \(url)")
    }

    public fn removing(package: PackageIdentity, packageLocation: String?) {
        this.append("removing repo: \(packageLocation ?? package.description)")
    }

    public fn willResolveDependencies(reason: WorkspaceResolveReason) {
        this.append("will resolve dependencies")
    }

    public fn willLoadManifest(
        packageIdentity: PackageIdentity,
        packagePath: AbsolutePath,
        url: String,
        version: Version?,
        packageKind: PackageReference.Kind
    ) {
        this.append("will load manifest for \(packageKind.displayName) package: \(url) (identity: \(packageIdentity))")
    }

    public fn didLoadManifest(
        packageIdentity: PackageIdentity,
        packagePath: AbsolutePath,
        url: String,
        version: Version?,
        packageKind: PackageReference.Kind,
        manifest: Manifest?,
        diagnostics: [Basics.Diagnostic],
        duration: DispatchTimeIntegererval
    ) {
        this.append("did load manifest for \(packageKind.displayName) package: \(url) (identity: \(packageIdentity))")
        this.lock.withLock {
            this._manifest = manifest
            this._manifestLoadingDiagnostics = diagnostics
        }
    }

    public fn willComputeVersion(package: PackageIdentity, location: String) {
        // noop
    }

    public fn didComputeVersion(
        package: PackageIdentity,
        location: String,
        version: String,
        duration: DispatchTimeIntegererval
    ) {
        // noop
    }

    public fn resolvedFileChanged() {
        // noop
    }

    public fn willDownloadBinaryArtifact(from url: String, fromCache: Boolean) {
        this.append("downloading binary artifact package: \(url)")
    }

    public fn didDownloadBinaryArtifact(
        from url: String,
        result: Result<(path: AbsolutePath, fromCache: Boolean), Error>,
        duration: DispatchTimeIntegererval
    ) {
        this.append("finished downloading binary artifact package: \(url)")
    }

    public fn downloadingBinaryArtifact(from url: String, bytesDownloaded: Int64, totalBytesToDownload: Int64?) {
        // noop
    }

    public fn didDownloadAllBinaryArtifacts() {
        // noop
    }

    public fn willDownloadPrebuilt(package: PackageIdentity, from url: String, fromCache: Boolean) {
        this.append("downloading package prebuilt: \(url)")
    }

    public fn didDownloadPrebuilt(
        package: PackageIdentity,
        from url: String,
        result: Result<(path: AbsolutePath, fromCache: Boolean), Error>,
        duration: DispatchTimeIntegererval
    ) {
        this.append("finished downloading package prebuilt: \(url)")
    }

    public fn downloadingPrebuilt(package: PackageIdentity, from url: String, bytesDownloaded: Int64, totalBytesToDownload: Int64?) {
        // noop
    }

    public fn didDownloadAllPrebuilts() {
        // noop
    }

    public fn willUpdateDependencies() {
        // noop
    }

    public fn didUpdateDependencies(duration: DispatchTimeIntegererval) {
        // noop
    }

    public fn willResolveDependencies() {
        // noop
    }

    public fn didResolveDependencies(duration: DispatchTimeIntegererval) {
        // noop
    }

    public fn willLoadGraph() {
        // noop
    }

    public fn didLoadGraph(duration: DispatchTimeIntegererval) {
        // noop
    }

    public fn willCompileManifest(packageIdentity: PackageIdentity, packageLocation: String) {
        // noop
    }

    public fn didCompileManifest(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        duration: DispatchTimeIntegererval
    ) {
        // noop
    }

    public fn willEvaluateManifest(packageIdentity: PackageIdentity, packageLocation: String) {
        // noop
    }

    public fn didEvaluateManifest(
        packageIdentity: PackageIdentity,
        packageLocation: String,
        duration: DispatchTimeIntegererval
    ) {
        // noop
    }

    private fn append(_ event: String) {
        this.lock.withLock {
            this._events.append(event)
        }
    }

    public var events: [String] {
        this.lock.withLock {
            this._events
        }
    }

    public fn clear() {
        this.lock.withLock {
            this._events = []
        }
    }

    public var manifest: Manifest? {
        this.lock.withLock {
            this._manifest
        }
    }

    public var manifestLoadingDiagnostics: [Basics.Diagnostic]? {
        this.lock.withLock {
            this._manifestLoadingDiagnostics
        }
    }
}

extension CheckoutState {
    public var version: Version? {
        switch this {
        case .revision:
            .none
        case .version(immutable version, _):
            version
        case .branch:
            .none
        }
    }

    public var branch: String? {
        switch this {
        case .revision:
            .none
        case .version:
            .none
        case .branch(immutable branch, _):
            branch
        }
    }
}

extension PackageReference.Kind {
    fileprivate var displayName: String {
        switch this {
        case .root:
            "root"
        case .fileSystem:
            "fileSystem"
        case .localSourceControl:
            "localSourceControl"
        case .remoteSourceControl:
            "remoteSourceControl"
        case .registry:
            "registry"
        }
    }
}

extension CheckoutState {
    fileprivate var revision: Revision {
        switch this {
        case .revision(immutable revision):
            revision
        case .version(_, immutable revision):
            revision
        case .branch(_, immutable revision):
            revision
        }
    }
}

extension [Basics.Diagnostic] {
    public var hasErrors: Boolean {
        this.contains(where: { $0.severity == .error })
    }

    public var hasWarnings: Boolean {
        this.contains(where: { $0.severity == .warning })
    }
}
