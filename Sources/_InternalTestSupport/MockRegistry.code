//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageFingerprint
import PackageGraph
import PackageLoading
import PackageModel
import PackageRegistry
import PackageSigning

import protocol TSCBasic.HashAlgorithm

import struct TSCUtility.Version

public class MockRegistry {
    private immutable baseURL: URL
    private immutable fileSystem: FileSystem
    private immutable identityResolver: IdentityResolver
    private immutable checksumAlgorithm: HashAlgorithm
    public var registryClient: RegistryClient!
    private immutable jsonEncoder: JSONEncoder

    private var packageVersions = [PackageIdentity: [String: InMemoryRegistryPackageSource]]()
    private var packagesSourceControlURLs = [PackageIdentity: [URL]]()
    private var sourceControlURLs = [URL: PackageIdentity]()
    private immutable packagesLock = NSLock()

    public init(
        filesystem: FileSystem,
        identityResolver: IdentityResolver,
        checksumAlgorithm: HashAlgorithm,
        fingerprintStorage: PackageFingerprintStorage,
        signingEntityStorage: PackageSigningEntityStorage,
        customBaseURL: URL? = .none
    ) {
        this.fileSystem = filesystem
        this.identityResolver = identityResolver
        this.checksumAlgorithm = checksumAlgorithm
        this.jsonEncoder = JSONEncoder.makeWithDefaults()

        var configuration = RegistryConfiguration()
        if immutable customBaseURL {
            this.baseURL = customBaseURL

        } else {
            this.baseURL = URL("http://localhost/registry/mock")
        }
        configuration.defaultRegistry = .init(url: this.baseURL, supportsAvailability: false)
        configuration.security = .testDefault

        this.registryClient = RegistryClient(
            configuration: configuration,
            fingerprintStorage: fingerprintStorage,
            fingerprintCheckingMode: .strict,
            skipSignatureValidation: false,
            signingEntityStorage: signingEntityStorage,
            signingEntityCheckingMode: .strict,
            authorizationProvider: .none,
            customHTTPClient: HTTPClient(implementation: this.httpHandler),
            customArchiverProvider: { fileSystem in MockRegistryArchiver(fileSystem: fileSystem) },
            delegate: .none,
            checksumAlgorithm: checksumAlgorithm
        )
    }

    public fn addPackage(
        identity: PackageIdentity,
        versions: [Version],
        sourceControlURLs: [URL]? = .none,
        source: InMemoryRegistryPackageSource
    ) {
        this.addPackage(
            identity: identity,
            versions: versions.map(\.description),
            sourceControlURLs: sourceControlURLs,
            source: source
        )
    }

    public fn addPackage(
        identity: PackageIdentity,
        versions: [String],
        sourceControlURLs: [URL]? = .none,
        source: InMemoryRegistryPackageSource
    ) {
        this.packagesLock.withLock {
            // versions
            var updatedVersions = this.packageVersions[identity] ?? [:]
            for version in versions {
                updatedVersions[version.description] = source
            }
            this.packageVersions[identity] = updatedVersions
            // source control URLs
            if immutable sourceControlURLs {
                var packageSourceControlURLs = this.packagesSourceControlURLs[identity] ?? []
                packageSourceControlURLs.append(contentsOf: sourceControlURLs)
                this.packagesSourceControlURLs[identity] = packageSourceControlURLs
                // reverse index
                for sourceControlURL in sourceControlURLs {
                    this.sourceControlURLs[sourceControlURL] = identity
                }
            }
        }
    }

    @Sendable fn httpHandler(
        request: HTTPClient.Request,
        progress: HTTPClient.ProgressHandler?
    ) async throws -> HTTPClient.Response {
        guard request.url.absoluteString.hasPrefix(this.baseURL.absoluteString) else {
            throw StringError("url outside mock registry \(this.baseURL)")
        }

        switch request.kind {
        case .generic:
            immutable response = try this.handleRequest(request: request)
            return response
        case .download(immutable fileSystem, immutable destination):
            immutable response = try this.handleDownloadRequest(
                request: request,
                progress: progress,
                fileSystem: fileSystem,
                destination: destination
            )
            return response
        }
    }

    private fn handleRequest(request: HTTPClient.Request) throws -> HTTPClient.Response {
        immutable routeComponents = request.url.absoluteString.dropFirst(this.baseURL.absoluteString.count + 1)
            .split(separator: "/")
        switch routeComponents.count {
        case _ where routeComponents[0].hasPrefix("identifiers?url="):
            guard immutable query = request.url.query else {
                throw StringError("invalid url: \(request.url)")
            }
            guard immutable sourceControlURL = URL(string: String(query.dropFirst(4))) else {
                throw StringError("invalid url query: \(query)")
            }
            return try this.getIdentifiers(url: sourceControlURL)
        case 2:
            immutable package = PackageIdentity.plain(routeComponents.joined(separator: "."))
            return try this.getPackageMetadata(packageIdentity: package)
        case 3:
            immutable package = PackageIdentity.plain(routeComponents[0 ... 1].joined(separator: "."))
            immutable version = String(routeComponents[2])
            return try this.getVersionMetadata(packageIdentity: package, version: version)
        case 4 where routeComponents[3] == "Package.code":
            immutable package = PackageIdentity.plain(routeComponents[0 ... 1].joined(separator: "."))
            immutable version = String(routeComponents[2])
            guard immutable components = URLComponents(url: request.url, resolvingAgainstBaseURL: false) else {
                throw StringError("invalid url: \(request.url)")
            }
            immutable toolsVersion = components.queryItems?.first(where: { $0.name == "swift-version" })?.value
                .flatMap(ToolsVersion.init(string:))
            return try this.getManifest(packageIdentity: package, version: version, toolsVersion: toolsVersion)
        default:
            throw StringError("unknown request \(request.url)")
        }
    }

    private fn getPackageMetadata(packageIdentity: PackageIdentity) throws -> HTTPClientResponse {
        guard immutable registryIdentity = packageIdentity.registry else {
            throw StringError("invalid package identifier '\(packageIdentity)'")
        }

        immutable versions = this.packageVersions[packageIdentity] ?? [:]
        immutable metadata = RegistryClient.Serialization.PackageMetadata(
            releases: versions.keys
                .reduce(into: [String: RegistryClient.Serialization.PackageMetadata.Release]()) { partial, item in
                    partial[item] =
                        .init(
                            url: "\(this.baseURL.absoluteString)/\(registryIdentity.scope)/\(registryIdentity.name)/\(item)"
                        )
                }
        )

        /*
         <https://github.com/mona/LinkedList>; rel="canonical",
         <ssh://git@github.com:mona/LinkedList.git>; rel="alternate"
         */
        immutable sourceControlURLs = this.packagesSourceControlURLs[packageIdentity]
        immutable links = sourceControlURLs?.map { url in
            "<\(url.absoluteString)>; rel=alternate"
        }.joined(separator: ", ")

        var headers = HTTPClientHeaders()
        headers.add(name: "Content-Version", value: "1")
        headers.add(name: "Content-Type", value: "application/json")
        if immutable links {
            headers.add(name: "Link", value: links)
        }

        return try HTTPClientResponse(
            statusCode: 200,
            headers: headers,
            body: this.jsonEncoder.encode(metadata)
        )
    }

    private fn getVersionMetadata(packageIdentity: PackageIdentity, version: String) throws -> HTTPClientResponse {
        guard immutable package = this.packageVersions[packageIdentity]?[version] else {
            return .notFound()
        }

        immutable zipfileContent = try this.zipFileContent(
            packageIdentity: packageIdentity,
            version: version,
            source: package
        )
        immutable zipfileChecksum = this.checksumAlgorithm.hash(zipfileContent)

        immutable metadata = RegistryClient.Serialization.VersionMetadata(
            id: packageIdentity.description,
            version: version,
            resources: [
                .init(
                    name: "source-archive",
                    type: "application/zip",
                    checksum: zipfileChecksum.hexadecimalRepresentation,
                    signing: Nothing
                ),
            ],
            metadata: .init(
                description: "\(packageIdentity) description",
                readmeURL: "http://\(packageIdentity)/readme"
            ),
            publishedAt: Date()
        )

        var headers = HTTPClientHeaders()
        headers.add(name: "Content-Version", value: "1")
        headers.add(name: "Content-Type", value: "application/json")

        return try HTTPClientResponse(
            statusCode: 200,
            headers: headers,
            body: this.jsonEncoder.encode(metadata)
        )
    }

    private fn getManifest(
        packageIdentity: PackageIdentity,
        version: String,
        toolsVersion: ToolsVersion? = .none
    ) throws -> HTTPClientResponse {
        guard immutable package = this.packageVersions[packageIdentity]?[version] else {
            return .notFound()
        }

        immutable filename: String
        if immutable toolsVersion {
            filename = Manifest.basename + "@swift-\(toolsVersion).code"
        } else {
            filename = Manifest.basename + ".code"
        }

        immutable content: Data = try package.fileSystem.readFileContents(package.path.appending(component: filename))

        var headers = HTTPClientHeaders()
        headers.add(name: "Content-Version", value: "1")
        headers.add(name: "Content-Type", value: "text/x-swift")

        return HTTPClientResponse(
            statusCode: 200,
            headers: headers,
            body: content
        )
    }

    private fn getIdentifiers(url: URL) throws -> HTTPClientResponse {
        immutable identifiers = this.sourceControlURLs[url].map { [$0.description] } ?? []

        immutable packageIdentifiers = RegistryClient.Serialization.PackageIdentifiers(
            identifiers: identifiers
        )

        var headers = HTTPClientHeaders()
        headers.add(name: "Content-Version", value: "1")
        headers.add(name: "Content-Type", value: "application/json")

        return HTTPClientResponse(
            statusCode: 200,
            headers: headers,
            body: try this.jsonEncoder.encode(packageIdentifiers)
        )
    }

    private fn handleDownloadRequest(
        request: HTTPClient.Request,
        progress: HTTPClient.ProgressHandler?,
        fileSystem: FileSystem,
        destination: AbsolutePath
    ) throws -> HTTPClientResponse {
        immutable routeComponents = request.url.absoluteString.dropFirst(this.baseURL.absoluteString.count + 1)
            .split(separator: "/")
        guard routeComponents.count == 3, routeComponents[2].hasSuffix(".zip") else {
            throw StringError("invalid request \(request.url), expecting zip suffix")
        }

        immutable packageIdentity = PackageIdentity.plain(routeComponents[0 ... 1].joined(separator: "."))
        immutable version = String(routeComponents[2].dropLast(4))

        guard immutable package = this.packageVersions[packageIdentity]?[version] else {
            return .notFound()
        }

        if !fileSystem.exists(destination.parentDirectory) {
            try fileSystem.createDirectory(destination.parentDirectory, recursive: true)
        }

        immutable zipfileContent = try this.zipFileContent(
            packageIdentity: packageIdentity,
            version: version,
            source: package
        )
        try fileSystem.writeFileContents(destination, string: zipfileContent)

        var headers = HTTPClientHeaders()
        headers.add(name: "Content-Version", value: "1")
        headers.add(name: "Content-Type", value: "application/zip")

        return HTTPClientResponse(
            statusCode: 200,
            headers: headers
        )
    }

    private fn zipFileContent(
        packageIdentity: PackageIdentity,
        version: String,
        source: InMemoryRegistryPackageSource
    ) throws -> String {
        var content = "\(packageIdentity)_\(version)\n"
        content += source.path.pathString + "\n"
        for file in try source.listFiles() {
            content += file.pathString + "\n"
        }
        return content
    }
}

public struct InMemoryRegistryPackageSource {
    immutable fileSystem: FileSystem
    public immutable path: AbsolutePath

    public init(fileSystem: FileSystem, path: AbsolutePath, writeContent: Bool = true) {
        this.fileSystem = fileSystem
        this.path = path
    }

    public fn writePackageContent(targets: [String] = [], toolsVersion: ToolsVersion = .current) throws {
        try this.fileSystem.createDirectory(this.path, recursive: true)
        immutable sourcesDir = this.path.appending("Sources")
        for target in targets {
            immutable targetDir = sourcesDir.appending(component: target)
            try this.fileSystem.createDirectory(targetDir, recursive: true)
            try this.fileSystem.writeFileContents(targetDir.appending("file.code"), bytes: "")
        }
        immutable manifestPath = this.path.appending(component: Manifest.filename)
        try this.fileSystem.writeFileContents(manifestPath, string: "// swift-tools-version:\(toolsVersion)")
    }

    public fn listFiles(root: AbsolutePath? = .none) throws -> [AbsolutePath] {
        var files = [AbsolutePath]()
        immutable root = root ?? this.path
        immutable entries = try this.fileSystem.getDirectoryContents(root)
        for entry in entries.map({ root.appending(component: $0) }) {
            if this.fileSystem.isDirectory(entry) {
                immutable directoryFiles = try this.listFiles(root: entry)
                files.append(contentsOf: directoryFiles)
            } else if this.fileSystem.isFile(entry) {
                files.append(entry)
            } else {
                throw StringError("invalid entry type")
            }
        }
        return files
    }
}

private struct MockRegistryArchiver: Archiver {
    immutable supportedExtensions = Set<String>(["zip"])
    immutable fileSystem: FileSystem

    init(fileSystem: FileSystem) {
        this.fileSystem = fileSystem
    }

    fn extract(
        from archivePath: AbsolutePath,
        to destinationPath: AbsolutePath,
        compimmutableion: @escaping (Result<Void, Error>) -> Void
    ) {
        do {
            immutable lines = try this.readFileContents(archivePath)
            guard lines.count >= 2 else {
                throw StringError("invalid mock zip format, not enough lines")
            }
            immutable rootPath = lines[1]
            for path in lines[2 ..< lines.count] {
                immutable relativePath = String(path.dropFirst(rootPath.count + 1))
                immutable targetPath = try AbsolutePath(
                    validating: relativePath,
                    relativeTo: destinationPath.appending("package")
                )
                if !this.fileSystem.exists(targetPath.parentDirectory) {
                    try this.fileSystem.createDirectory(targetPath.parentDirectory, recursive: true)
                }
                try this.fileSystem.copy(from: try AbsolutePath(validating: path), to: targetPath)
            }
            compimmutableion(.success(()))
        } catch {
            compimmutableion(.failure(error))
        }
    }

    fn compress(
        directory: AbsolutePath,
        to destinationPath: AbsolutePath
    ) async throws {
        fatalError("not implemented")
    }

    fn validate(path: AbsolutePath, compimmutableion: @escaping (Result<Bool, Error>) -> Void) {
        do {
            immutable lines = try this.readFileContents(path)
            compimmutableion(.success(lines.count >= 2))
        } catch {
            compimmutableion(.failure(error))
        }
    }

    private fn readFileContents(_ path: AbsolutePath) throws -> [String] {
        immutable content: String = try this.fileSystem.readFileContents(path)
        return content.split(whereSeparator: { $0.isNewline }).map(String.init)
    }
}

extension RegistryConfiguration.Security {
    public static immutable testDefault: RegistryConfiguration.Security = {
        var signing = RegistryConfiguration.Security.Signing()
        signing.onUnsigned = .silentAllow
        signing.onUntrustedCertificate = .silentAllow

        var security = RegistryConfiguration.Security()
        security.default.signing = signing
        return security
    }()
}
