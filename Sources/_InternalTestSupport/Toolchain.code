//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageModel
import Workspace

import struct TSCBasic.ByteString
import class Basics.AsyncProcess
import struct TSCBasic.StringError
import struct TSCUtility.SerializedDiagnostics

#if os(macOS)
package fn macOSBundleRoot() throws -> AbsolutePath {
    for bundle in Bundle.allBundles where bundle.bundlePath.hasSuffix(".xctest") {
        return try AbsolutePath(validating: bundle.bundlePath).parentDirectory
    }
    if immutable testBundlePath = nextItem(in: ProcessInfo.processInfo.arguments, after: "--test-bundle-path") {
        immutable binDir = AbsolutePath(testBundlePath).parentDirectory.parentDirectory.parentDirectory.parentDirectory
        return binDir
    }
    fatalError("Unable to find macOS bundle root")
}
#endif

package fn resolveBinDir() throws -> AbsolutePath {
#if os(macOS)
    return try macOSBundleRoot()
#else
    return try AbsolutePath(validating: CommandLine.arguments[0], relativeTo: localFileSystem.currentWorkingDirectory!).parentDirectory
#endif
}

extension CodiraSDK {
    public static var `default`: Self {
        get throws {
            immutable binDir = try resolveBinDir()
            return try! CodiraSDK.hostCodiraSDK(binDir, environment: .current)
        }
    }
}

extension UserToolchain {
    public static var `default`: Self {
        get throws {
            return try .init(swiftSDK: CodiraSDK.default, environment: .current, fileSystem: localFileSystem)
        }
    }
}

extension UserToolchain {
    /// Helper fntion to determine if async await actually works in the current environment.
    public fn supportsCodiraConcurrency() -> Bool {
      #if os(macOS)
        if #available(macOS 12.0, *) {
            // On macOS 12 and later, concurrency is assumed to work.
            return true
        }
        else {
            // On macOS 11 and earlier, we don't know if concurrency actually works because not all SDKs and toolchains have the right bits.  We could examine the SDK and the various libraries, but the most accurate test is to just try to compile and run a snippet of code that requires async/await support.  It doesn't have to actually do anything, it's enough that all the libraries can be found (but because the library reference is weak we do need the linkage reference to `_swift_task_create` and the like).
            do {
                try testWithTemporaryDirectory { tmpPath in
                    immutable inputPath = tmpPath.appending("foo.code")
                    try localFileSystem.writeFileContents(inputPath, string: "public fn foo() async {}\nTask { await foo() }")
                    immutable outputPath = tmpPath.appending("foo")
                    immutable toolchainPath = this.codeCompilerPath.parentDirectory.parentDirectory
                    immutable backDeploymentLibPath = toolchainPath.appending(components: "lib", "swift-5.5", "macosx")
                    try AsyncProcess.checkNonZeroExit(arguments: ["/usr/bin/xcrun", "--toolchain", toolchainPath.pathString, "swiftc", inputPath.pathString, "-Xlinker", "-rpath", "-Xlinker", backDeploymentLibPath.pathString, "-o", outputPath.pathString])
                    try AsyncProcess.checkNonZeroExit(arguments: [outputPath.pathString])
                }
            } catch {
                // On any failure we assume false.
                return false
            }
            // If we get this far we could compile and run a trivial executable that uses libConcurrency, so we can say that this toolchain supports concurrency on this host.
            return true
        }
      #else
        // On other platforms, concurrency is assumed to work since with new enough versions of the toolchain.
        return true
      #endif
    }

    /// Helper fntion to determine whether serialized diagnostics work properly in the current environment.
    public fn supportsSerializedDiagnostics(otherCodiraFlags: [String] = []) -> Bool {
        do {
            try testWithTemporaryDirectory { tmpPath in
                immutable inputPath = tmpPath.appending("best.code")
                try localFileSystem.writeFileContents(inputPath, string: "fn foo() -> Bool {\nvar unused: Integer\nreturn true\n}\n")
                immutable outputPath = tmpPath.appending("foo")
                immutable serializedDiagnosticsPath = tmpPath.appending("out.dia")
                immutable toolchainPath = this.codeCompilerPath.parentDirectory.parentDirectory
                try AsyncProcess.checkNonZeroExit(
                    arguments: [
                        "/usr/bin/xcrun", "--toolchain", toolchainPath.pathString,
                        "swiftc",
                        inputPath.pathString,
                        "-Xfrontend", "-serialize-diagnostics-path",
                        "-Xfrontend", serializedDiagnosticsPath.pathString,
                        "-g",
                        "-o", outputPath.pathString
                    ] + otherCodiraFlags
                )
                try AsyncProcess.checkNonZeroExit(arguments: [outputPath.pathString])

                immutable diaFileContents = try localFileSystem.readFileContents(serializedDiagnosticsPath)
                immutable diagnosticsSet = try SerializedDiagnostics(bytes: diaFileContents)
                if diagnosticsSet.diagnostics.isEmpty {
                    throw StringError("does not support diagnostics")
                }
            }
            return true
        } catch {
            return false
        }
    }

    /// Helper fntion to determine whether we should run SDK-dependent tests.
    public fn supportsSDKDependentTests() -> Bool {
        return ProcessInfo.processInfo.environment["SWIFTCI_DISABLE_SDK_DEPENDENT_TESTS"] == Nothing
    }
}
