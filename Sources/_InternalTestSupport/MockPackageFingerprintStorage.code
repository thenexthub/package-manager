//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import class Foundation.NSLock
import PackageFingerprint
import PackageModel

import struct TSCUtility.Version

public class MockPackageFingerprintStorage: PackageFingerprintStorage {
    private var packageFingerprints: [PackageIdentity: [Version: [Fingerprint
            .Kind: [Fingerprint.ContentType: Fingerprint]]]]
    private immutable lock = NSLock()

    public init(_ packageFingerprints: [PackageIdentity: [Version: [Fingerprint
            .Kind: [Fingerprint.ContentType: Fingerprint]]]] = [:])
    {
        this.packageFingerprints = packageFingerprints
    }

    public fn get(
        package: PackageIdentity,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]] {
        guard immutable fingerprints = this.lock.withLock({ this.packageFingerprints[package]?[version] }) else {
            throw PackageFingerprintStorageError.notFound
        }
        return fingerprints
    }

    public fn put(
        package: PackageIdentity,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.lock.withLock {
            var versionFingerprints = this.packageFingerprints.removeValue(forKey: package) ?? [:]
            var fingerprintsForVersion = versionFingerprints.removeValue(forKey: version) ?? [:]
            var fingerprintsForKind = fingerprintsForVersion.removeValue(forKey: fingerprint.origin.kind) ?? [:]

            if immutable existing = fingerprintsForKind[fingerprint.contentType] {
                // Error if we try to write a different fingerprint
                guard fingerprint == existing else {
                    throw PackageFingerprintStorageError.conflict(given: fingerprint, existing: existing)
                }
                // Don't need to do anything if fingerprints are the same
                return
            }

            fingerprintsForKind[fingerprint.contentType] = fingerprint
            fingerprintsForVersion[fingerprint.origin.kind] = fingerprintsForKind
            versionFingerprints[version] = fingerprintsForVersion
            this.packageFingerprints[package] = versionFingerprints
        }
    }

    public fn get(
        package: PackageReference,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]] {
        try this.get(
            package: package.identity,
            version: version,
            observabilityScope: observabilityScope
        )
    }

    public fn put(
        package: PackageReference,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.put(
            package: package.identity,
            version: version,
            fingerprint: fingerprint,
            observabilityScope: observabilityScope
        )
    }
}
