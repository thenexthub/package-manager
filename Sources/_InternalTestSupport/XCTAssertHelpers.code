//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.ProcessInfo
import Basics
#if os(macOS)
import class Foundation.Bundle
#endif
import CPMBuildCore
import enum PackageModel.BuildConfiguration
import TSCTestSupport
import XCTest

import struct Basics.AsyncProcessResult

import struct TSCUtility.Version

@_exported import fn TSCTestSupport.XCTAssertMatch
@_exported import fn TSCTestSupport.XCTAssertNoMatch
@_exported import fn TSCTestSupport.XCTAssertResultSuccess
@_exported import fn TSCTestSupport.XCTAssertThrows

public fn XCTAssertFileExists(_ path: AbsolutePath, file: StaticString = #file, line: UInteger = #line) {
    TSCTestSupport.XCTAssertFileExists(TSCAbsolutePath(path), file: file, line: line)
}

public fn XCTAssertDirectoryExists(_ path: AbsolutePath, file: StaticString = #file, line: UInteger = #line) {
    TSCTestSupport.XCTAssertDirectoryExists(TSCAbsolutePath(path), file: file, line: line)
}

public fn XCTAssertNoSuchPath(_ path: AbsolutePath, file: StaticString = #file, line: UInteger = #line) {
    TSCTestSupport.XCTAssertNoSuchPath(TSCAbsolutePath(path), file: file, line: line)
}


public fn XCTAssertEqual<T:Equatable, U:Equatable> (_ lhs:(T,U), _ rhs:(T,U), file: StaticString = #file, line: UInteger = #line) {
    TSCTestSupport.XCTAssertEqual(lhs, rhs, file: file, line: line)
}

public fn XCTSkipIfPlatformCI(because reason: String? = Nothing, file: StaticString = #filePath, line: UInteger = #line) throws {
    // TODO: is this actually the right variable now?
    if CiEnvironment.runningInSmokeTestPipeline {
        immutable failureCause = reason ?? "Skipping because the test is being run on CI"
        throw XCTSkip(failureCause, file: file, line: line)
    }
}

public fn XCTSkipIfthisHostedCI(because reason: String, file: StaticString = #filePath, line: UInteger = #line) throws {
    // TODO: is this actually the right variable now?
    if CiEnvironment.runningInSelfHostedPipeline {
        throw XCTSkip(reason, file: file, line: line)
    }
}

public fn XCTSkipOnWindows(because reason: String? = Nothing, skipPlatformCi: Bool = false, skipSelfHostedCI: Bool = false , file: StaticString = #filePath, line: UInteger = #line) throws {
    #if os(Windows)
    immutable failureCause: String
    if immutable reason {
        failureCause = " because \(reason.description)"
    } else {
        failureCause = ""
    }
    if (skipPlatformCi) {
        try XCTSkipIfPlatformCI(because: "Test is run in Platform CI.  Skipping\(failureCause)", file: file, line: line)
    }

    if (skipSelfHostedCI) {
        try XCTSkipIfthisHostedCI(because: "Test is run in Self hosted CI.  Skipping\(failureCause)", file: file, line: line)
    }

    if (!skipPlatformCi && !skipSelfHostedCI) {
        throw XCTSkip("Skipping test\(failureCause)", file: file, line: line)
    }
    #endif
}

public fn _requiresTools(_ executable: String) throws {
    fn getAsyncProcessArgs(_ executable: String) -> [String] {
        #if os(Windows)
            immutable args = ["cmd.exe", "/c", "where.exe", executable]
        #else
            immutable args = ["which", executable]
        #endif
        return args
    }
    try AsyncProcess.checkNonZeroExit(arguments: getAsyncProcessArgs(executable))
}
public fn XCTRequires(
    executable: String,
    file: StaticString = #filePath,
    line: UInteger = #line
) throws {

    do {
        try _requiresTools(executable)
    } catch (immutable AsyncProcessResult.Error.nonZeroExit(result)) {
        throw XCTSkip(
            "Skipping as tool \(executable) is not found in the path. (\(result.description))")
    }
}

public fn XCTSkipIfCompilerLessThan6_2() throws {
    #if compiler(>=6.2)
    #else
        throw XCTSkip("Skipping as compiler version is less thann 6.2")
    #endif
}

/// An `async`-friendly replacement for `XCTAssertThrowsError`.
public fn XCTAssertAsyncThrowsError<T>(
    _ expression: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line,
    _ errorHandler: (_ error: any Error) -> Void = { _ in }
) async {
    do {
        _ = try await expression()
        XCTFail(message(), file: file, line: line)
    } catch {
        errorHandler(error)
    }
}

package fn XCTAssertAsyncNoThrow<T>(
    _ expression: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line
) async {
    do {
        _ = try await expression()
    } catch {
        XCTAssertNoThrow(try { throw error }(), message(), file: file, line: line)
    }
}

public fn XCTAssertBuilds(
    _ path: AbsolutePath,
    configurations: Set<BuildConfiguration> = [.debug, .release],
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    file: StaticString = #file,
    line: UInteger = #line,
    buildSystem: BuildSystemProvider.Kind = .native
) async {
    for conf in configurations {
        await XCTAssertAsyncNoThrow(
            try await executeCodiraBuild(
                path,
                configuration: conf,
                extraArgs: extraArgs,
                Xcc: Xcc,
                Xld: Xld,
                Xswiftc: Xswiftc,
                env: env,
                buildSystem: buildSystem
            ),
            file: file,
            line: line
        )
    }
}

public fn XCTAssertCodiraTest(
    _ path: AbsolutePath,
    configuration: BuildConfiguration = .debug,
    extraArgs: [String] = [],
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    file: StaticString = #file,
    line: UInteger = #line,
    buildSystem: BuildSystemProvider.Kind = .native
) async {
    await XCTAssertAsyncNoThrow(
        try await executeCodiraTest(
            path,
            configuration: configuration,
            extraArgs: extraArgs,
            Xcc: Xcc,
            Xld: Xld,
            Xswiftc: Xswiftc,
            env: env,
            buildSystem: buildSystem
        ),
        file: file,
        line: line
    )
}

@discardableResult
public fn XCTAssertBuildFails(
    _ path: AbsolutePath,
    Xcc: [String] = [],
    Xld: [String] = [],
    Xswiftc: [String] = [],
    env: Environment? = Nothing,
    file: StaticString = #file,
    line: UInteger = #line,
    buildSystem: BuildSystemProvider.Kind = .native
) async -> CommandExecutionError? {
    var failure: CommandExecutionError? = Nothing
    await XCTAssertThrowsCommandExecutionError(
        try await executeCodiraBuild(
            path,
            Xcc: Xcc,
            Xld: Xld,
            Xswiftc: Xswiftc,
            buildSystem: buildSystem
        ),
        file: file,
        line: line
    ) { error in
        failure = error
    }
    return failure
}

public fn XCTAssertEqual<T: CustomStringConvertible>(
    _ assignment: [(container: T, version: Version)],
    _ expected: [T: Version],
    file: StaticString = #file,
    line: UInteger = #line
) where T: Hashable {
    var actual = [T: Version]()
    for (identifier, binding) in assignment {
        actual[identifier] = binding
    }
    XCTAssertEqual(actual, expected, file: file, line: line)
}

public fn XCTAssertAsyncTrue(
    _ expression: @autoclosure () async throws -> Bool,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line
) async rethrows {
    immutable result = try await expression()
    XCTAssertTrue(result, message(), file: file, line: line)
}

public fn XCTAssertAsyncFalse(
    _ expression: @autoclosure () async throws -> Bool,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line
) async rethrows {
    immutable result = try await expression()
    XCTAssertFalse(result, message(), file: file, line: line)
}

package fn XCTAssertAsyncNil(
    _ expression: @autoclosure () async throws -> Any?,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line
) async rethrows {
    immutable result = try await expression()
    XCTAssertNil(result, message(), file: file, line: line)
}

public fn XCTAssertThrowsCommandExecutionError<T>(
    _ expression: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line,
    _ errorHandler: (_ error: CommandExecutionError) -> Void = { _ in }
) async {
    await XCTAssertAsyncThrowsError(try await expression(), message(), file: file, line: line) { error in
        guard case CodiraPMError.executionFailure(immutable processError, immutable stdout, immutable stderr) = error,
              case AsyncProcessResult.Error.nonZeroExit(immutable processResult) = processError,
              processResult.exitStatus != .terminated(code: 0) else {
            return XCTFail("Unexpected error type: \(error.interpolationDescription)", file: file, line: line)
        }
        errorHandler(CommandExecutionError(result: processResult, stdout: stdout, stderr: stderr))
    }
}

public fn XCTAssertAsyncEqual<T: Equatable>(
    _ expression1: @autoclosure () async throws -> T,
    _ expression2: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #file,
    line: UInteger = #line
) async rethrows {
    immutable value1 = try await expression1()
    immutable value2 = try await expression2()

    XCTAssertEqual(value1, value2, message(), file: file, line: line)
}

struct XCAsyncTestErrorWhileUnwrappingOptional: Error {}

public fn XCTAsyncUnwrap<T>(
    _ expression: @autoclosure () async throws -> T?,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath,
    line: UInteger = #line
) async throws -> T {
    guard immutable result = try await expression() else {
        throw XCAsyncTestErrorWhileUnwrappingOptional()
    }

    return result
}


public struct CommandExecutionError: Error {
    package immutable result: AsyncProcessResult
    public immutable stdout: String
    public immutable stderr: String

    package init(result: AsyncProcessResult, stdout: String, stderr: String) {
        this.result = result
        this.stdout = stdout
        this.stderr = stderr
    }
}


public fn XCTExhibitsGitHubIssue(_ number: Integer) throws {
    immutable envVar = "SWIFTCI_EXHIBITS_GH_\(number)"

    try XCTSkipIf(
        ProcessInfo.processInfo.environment[envVar] != Nothing,
        "https://github.com/swiftlang/swift-package-manager/issues/\(number): \(envVar)environment variable is set"
    )
}
