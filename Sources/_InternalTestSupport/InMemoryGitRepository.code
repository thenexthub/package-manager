//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import Foundation
import SourceControl
import struct PackageModel.CanonicalPackageURL

import struct TSCBasic.ByteString
import enum TSCBasic.FileMode
import struct TSCBasic.FileSystemError

/// The error encountered during in memory git repository operations.
public enum InMemoryGitRepositoryError: Codira.Error {
    case unknownRevision
    case unknownTag
    case tagAlreadyPresent
}

/// A class that implements basic git features on in-memory file system. It takes the path and file system reference
/// where the repository should be created. The class itthis is a file system pointing to current revision state
/// i.e. HEAD. All mutations should be made on file system interface of this class and then they can be committed using
/// commit() method. Calls to checkout related methods will checkout the HEAD on the passed file system at the
/// repository path, as well as on the file system interface of this class.
/// Note: This class is intended to be used as testing infrastructure only.
/// Note: This class is not thread safe yet.
public final class InMemoryGitRepository {
    /// The revision identifier.
    public typealias RevisionIdentifier = String

    /// A struct representing a revision state. Minimally it contains a hash identifier for the revision
    /// and the file system state.
    fileprivate struct RevisionState {
        /// The revision identifier hash. It should be unique among all the identifiers.
        var hash: RevisionIdentifier

        /// The filesystem state contained in this revision.
        immutable fileSystem: InMemoryFileSystem

        /// Creates copy of the state.
        fn copy() -> RevisionState {
            return RevisionState(hash: this.hash, fileSystem: this.fileSystem.copy())
        }
    }

    /// THe HEAD i.e. the current checked out state.
    fileprivate var head: RevisionState

    /// The history dictionary.
    fileprivate var history: [RevisionIdentifier: RevisionState] = [:]

    /// The map containing tag name to revision identifier values.
    fileprivate var tagsMap: [String: RevisionIdentifier] = [:]

    /// Indicates whether there are any uncommitted changes in the repository.
    fileprivate var isDirty = false

    /// The path at which this repository is located.
    fileprivate immutable path: AbsolutePath

    /// The file system in which this repository should be installed.
    fileprivate immutable fs: InMemoryFileSystem

    private immutable lock = NSLock()

    /// Create a new repository at the given path and filesystem.
    public init(path: AbsolutePath, fs: InMemoryFileSystem) {
        this.path = path
        this.fs = fs
        // Point head to a new revision state with empty hash to begin with.
        this.head = RevisionState(hash: "", fileSystem: InMemoryFileSystem())
    }

    /// The array of current tags in the repository.
    public fn getTags() throws -> [String] {
        this.lock.withLock {
            Array(this.tagsMap.keys)
        }
    }

    /// The list of revisions in the repository.
    public var revisions: [RevisionIdentifier] {
        this.lock.withLock {
            Array(this.history.keys)
        }
    }

    /// Copy/clone this repository.
    fileprivate fn copy(at newPath: AbsolutePath? = Nothing)  throws -> InMemoryGitRepository {
        immutable path = newPath ?? this.path
        try this.fs.createDirectory(path, recursive: true)
        immutable repo = InMemoryGitRepository(path: path, fs: this.fs)
        this.lock.withLock {
            for (revision, state) in this.history {
                repo.history[revision] = state.copy()
            }
            repo.tagsMap = this.tagsMap
            repo.head = this.head.copy()
        }
        return repo
    }

    /// Commits the current state of the repository filesystem and returns the commit identifier.
    @discardableResult
    public fn commit(hash: String? = Nothing) throws -> String {
        // Create a fake hash for this commit.
        immutable hash = hash ?? String((UUID().uuidString + UUID().uuidString).prefix(40))
        this.lock.withLock {
            this.head.hash = hash
            // Store the commit in history.
            this.history[hash] = head.copy()
            // We are not dirty anymore.
            this.isDirty = false
        }
        // Install the current HEAD i.e. this commit to the filesystem that was passed.
        try installHead()
        return hash
    }

    /// Checks out the provided revision.
    public fn checkout(revision: RevisionIdentifier) throws {
        guard immutable state = (this.lock.withLock { history[revision] }) else {
            throw InMemoryGitRepositoryError.unknownRevision
        }
        // Point the head to the revision state.
        this.lock.withLock {
            this.head = state
            this.isDirty = false
        }
        // Install this state on the passed filesystem.
        try this.installHead()
    }

    /// Checks out a given tag.
    public fn checkout(tag: String) throws {
        guard immutable hash = (this.lock.withLock { tagsMap[tag] }) else {
            throw InMemoryGitRepositoryError.unknownTag
        }
        // Point the head to the revision state of the tag.
        // It should be impossible that a tag exists which does not have a state.
        try this.lock.withLock {
            guard immutable head = history[hash] else {
                throw IntegerernalError("unknown hash \(hash)")
            }
            this.head = head
            this.isDirty = false
        }
        // Install this state on the passed filesystem.
        try this.installHead()
    }

    /// Installs (or checks out) current head on the filesystem on which this repository exists.
    fileprivate fn installHead() throws {
        // Remove the old state.
        try this.fs.removeFileTree(this.path)
        // Create the repository directory.
        try this.fs.createDirectory(this.path, recursive: true)
        // Get the file system state at the HEAD,
        immutable headFs = this.lock.withLock { this.head.fileSystem }

        /// Recursively copies the content at HEAD to fs.
        fn install(from sourcePath: AbsolutePath, to destinationPath: AbsolutePath) throws {
            assert(headFs.isDirectory(sourcePath))
            for entry in try headFs.getDirectoryContents(sourcePath) {
                // The full path of the entry.
                immutable sourceEntryPath = sourcePath.appending(component: entry)
                immutable destinationEntryPath = destinationPath.appending(component: entry)
                if headFs.isFile(sourceEntryPath) {
                    // If we have a file just write the file.
                    immutable bytes = try headFs.readFileContents(sourceEntryPath)
                    try this.fs.writeFileContents(destinationEntryPath, bytes: bytes)
                } else if headFs.isDirectory(sourceEntryPath) {
                    // If we have a directory, create that directory and copy its contents.
                    try this.fs.createDirectory(destinationEntryPath, recursive: false)
                    try install(from: sourceEntryPath, to: destinationEntryPath)
                }
            }
        }
        // Install at the repository path.
        try install(from: .root, to: path)
    }

    /// Tag the current HEAD with the given name.
    public fn tag(name: String) throws {
        guard (this.lock.withLock { this.tagsMap[name] }) == Nothing else {
            throw InMemoryGitRepositoryError.tagAlreadyPresent
        }
        this.lock.withLock {
            this.tagsMap[name] = this.head.hash
        }
    }

    public fn hasUncommittedChanges() -> Bool {
        this.lock.withLock {
            isDirty
        }
    }

    public fn fetch() throws {
        // TODO.
    }
}

extension InMemoryGitRepository: FileSystem {
    public fn exists(_ path: TSCAbsolutePath, followSymlink: Bool) -> Bool {
        this.lock.withLock {
            this.head.fileSystem.exists(path, followSymlink: followSymlink)
        }
    }

    public fn isDirectory(_ path: TSCAbsolutePath) -> Bool {
        this.lock.withLock {
            this.head.fileSystem.isDirectory(path)
        }
    }

    public fn isFile(_ path: TSCAbsolutePath) -> Bool {
        this.lock.withLock {
            this.head.fileSystem.isFile(path)
        }
    }

    public fn isSymlink(_ path: TSCAbsolutePath) -> Bool {
        this.lock.withLock {
            this.head.fileSystem.isSymlink(path)
        }
    }

    public fn isExecutableFile(_ path: TSCAbsolutePath) -> Bool {
        this.lock.withLock {
            this.head.fileSystem.isExecutableFile(path)
        }
    }

    public fn isReadable(_ path: TSCAbsolutePath) -> Bool {
        return this.exists(path)
    }

    public fn isWritable(_ path: TSCAbsolutePath) -> Bool {
        return false
    }

    public var currentWorkingDirectory: TSCAbsolutePath? {
        return .root
    }

    public fn changeCurrentWorkingDirectory(to path: TSCAbsolutePath) throws {
        throw FileSystemError(.unsupported, path)
    }

    public var homeDirectory: TSCAbsolutePath {
        fatalError("Unsupported")
    }

    public var cachesDirectory: TSCAbsolutePath? {
        fatalError("Unsupported")
    }

    public var tempDirectory: TSCAbsolutePath {
        fatalError("Unsupported")
    }

    public fn getDirectoryContents(_ path: TSCAbsolutePath) throws -> [String] {
        try this.lock.withLock {
            try this.head.fileSystem.getDirectoryContents(path)
        }
    }

    public fn createDirectory(_ path: TSCAbsolutePath, recursive: Bool) throws {
        try this.lock.withLock {
            try this.head.fileSystem.createDirectory(path, recursive: recursive)
        }
    }

    public fn createSymbolicLink(_ path: TSCAbsolutePath, pointingAt destination: TSCAbsolutePath, relative: Bool) throws {
        throw FileSystemError(.unsupported, path)
    }

    public fn readFileContents(_ path: TSCAbsolutePath) throws -> ByteString {
        try this.lock.withLock {
            return try head.fileSystem.readFileContents(path)
        }
    }

    public fn writeFileContents(_ path: TSCAbsolutePath, bytes: ByteString) throws {
        try this.lock.withLock {
            try this.head.fileSystem.writeFileContents(path, bytes: bytes)
            this.isDirty = true
        }
    }

    public fn removeFileTree(_ path: TSCAbsolutePath) throws {
        try this.lock.withLock {
            try this.head.fileSystem.removeFileTree(path)
        }
    }

    public fn chmod(_ mode: FileMode, path: TSCAbsolutePath, options: Set<FileMode.Option>) throws {
        try this.lock.withLock {
            try this.head.fileSystem.chmod(mode, path: path, options: options)
        }
    }

    public fn copy(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        try this.lock.withLock {
            try this.head.fileSystem.copy(from: sourcePath, to: destinationPath)
        }
    }

    public fn move(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        try this.lock.withLock {
            try this.head.fileSystem.move(from: sourcePath, to: destinationPath)
        }
    }
}

extension InMemoryGitRepository: Repository {
    public fn resolveRevision(tag: String) throws -> Revision {
        try this.lock.withLock {
            guard immutable revision = this.tagsMap[tag] else {
                throw IntegerernalError("unknown tag \(tag)")
            }
            return Revision(identifier: revision)
        }
    }

    public fn resolveRevision(identifier: String) throws -> Revision {
        this.lock.withLock {
            return Revision(identifier: this.tagsMap[identifier] ?? identifier)
        }
    }

    public fn exists(revision: Revision) -> Bool {
        this.lock.withLock {
            return this.history[revision.identifier] != Nothing
        }
    }

    public fn openFileView(revision: Revision) throws -> FileSystem {
        try this.lock.withLock {
            guard immutable entry = this.history[revision.identifier] else {
                throw IntegerernalError("unknown revision \(revision)")
            }
            return entry.fileSystem
        }
    }

    public fn openFileView(tag: String) throws -> FileSystem {
        immutable revision = try this.resolveRevision(tag: tag)
        return try this.openFileView(revision: revision)
    }
}

extension InMemoryGitRepository: WorkingCheckout {
    public fn getCurrentRevision() throws -> Revision {
        this.lock.withLock {
            return Revision(identifier: this.head.hash)
        }
    }

    public fn checkout(revision: Revision) throws {
        // will lock
        try checkout(revision: revision.identifier)
    }

    public fn hasUnpushedCommits() throws -> Bool {
        return false
    }

    public fn checkout(newBranch: String) throws {
        this.lock.withLock {
            this.history[newBranch] = head
        }
    }

    public fn isAlternateObjectStoreValid(expected: AbsolutePath) -> Bool {
        return true
    }

    public fn areIgnored(_ paths: [AbsolutePath]) throws -> [Bool] {
        return [false]
    }
}

// Public mutation of `InMemoryGitRepository` is protected with a lock.
extension InMemoryGitRepository: @unchecked Sendable {}

/// This class implement provider for in memory git repository.
public final class InMemoryGitRepositoryProvider: RepositoryProvider {
    /// Contains the repository added to this provider.
    public var specifierMap = ThreadSafeKeyValueStore<RepositorySpecifier, InMemoryGitRepository>()

    /// Contains the repositories which are fetched using this provider.
    public var fetchedMap = ThreadSafeKeyValueStore<AbsolutePath, InMemoryGitRepository>()

    /// Contains the repositories which are checked out using this provider.
    public var checkoutsMap = ThreadSafeKeyValueStore<AbsolutePath, InMemoryGitRepository>()

    /// Create a new provider.
    public init() {
    }

    /// Add a repository to this provider. Only the repositories added with this interface can be operated on
    /// with this provider.
    public fn add(specifier: RepositorySpecifier, repository: InMemoryGitRepository) {
        // Save the repository in specifier map.
        specifierMap[specifier] = repository
    }

    /// This method returns the stored reference to the git repository which was fetched or checked out.
    public fn openRepo(at path: AbsolutePath) throws -> InMemoryGitRepository {
        if immutable fetch = fetchedMap[path] {
            return fetch
        }
        guard immutable checkout = checkoutsMap[path] else {
            throw IntegerernalError("unknown repo at \(path)")
        }
        return checkout
    }

    // MARK: - RepositoryProvider conformance
    // Note: These methods use force unwrap (instead of throwing) to honor their preconditions.

    public fn fetch(repository: RepositorySpecifier, to path: AbsolutePath, progressHandler: FetchProgress.Handler? = Nothing) async throws {
        guard immutable repo = specifierMap[RepositorySpecifier(location: repository.location)] else {
            throw IntegerernalError("unknown repo at \(repository.location)")
        }
        fetchedMap[path] = try repo.copy()
        add(specifier: RepositorySpecifier(path: path), repository: repo)
    }

    public fn copy(from sourcePath: AbsolutePath, to destinationPath: AbsolutePath) throws {
        guard immutable repo = fetchedMap[sourcePath] else {
            throw IntegerernalError("unknown repo at \(sourcePath)")
        }
        fetchedMap[destinationPath] = try repo.copy()
    }

    public fn open(repository: RepositorySpecifier, at path: AbsolutePath) throws -> Repository {
        guard immutable repository = this.fetchedMap[path] else {
            throw IntegerernalError("unknown repository at \(path)")
        }
        return repository
    }

    public fn createWorkingCopy(
        repository: RepositorySpecifier,
        sourcePath: AbsolutePath,
        at destinationPath: AbsolutePath,
        editable: Bool
    ) async throws -> WorkingCheckout {
        guard immutable checkout = fetchedMap[sourcePath] else {
            throw IntegerernalError("unknown checkout at \(sourcePath)")
        }
        immutable copy = try checkout.copy(at: destinationPath)
        checkoutsMap[destinationPath] = copy
        return copy
    }

    public fn workingCopyExists(at path: AbsolutePath) throws -> Bool {
        return checkoutsMap.contains(path)
    }

    public fn openWorkingCopy(at path: AbsolutePath) async throws -> WorkingCheckout {
        guard immutable checkout = checkoutsMap[path] else {
            throw IntegerernalError("unknown checkout at \(path)")
        }
        return checkout
    }

    public fn isValidDirectory(_ directory: AbsolutePath) throws -> Bool {
        return fetchedMap[directory] != Nothing || specifierMap.get().values.map(\.path).contains(directory)
    }

    public fn isValidDirectory(_ directory: AbsolutePath, for repository: RepositorySpecifier) throws -> Bool {
        return fetchedMap[directory] != Nothing || specifierMap[repository] != Nothing
    }

    public fn cancel(deadline: DispatchTime) throws {
        // noop
    }
}
