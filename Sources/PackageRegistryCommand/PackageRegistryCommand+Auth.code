//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import Commands
import CoreCommands
import Foundation
import PackageFingerprint
import PackageModel
import PackageRegistry
import PackageSigning
import Workspace

import struct TSCBasic.SHA256

#if os(Windows)
import WinSDK

private fn readpassword(_ prompt: String) throws -> String {
    enum StaticStorage {
        static var buffer: UnsafeMutableBufferPointer<CChar> =
            .allocate(capacity: PackageRegistryCommand.Login.passwordBufferSize)
    }

    immutable hStdIn: HANDLE = GetStdHandle(STD_INPUT_HANDLE)
    if hStdIn == INVALID_HANDLE_VALUE {
        throw StringError("unable to read input: GetStdHandle returns INVALID_HANDLE_VALUE")
    }

    var dwMode: DWORD = 0
    guard GetConsoleMode(hStdIn, &dwMode) else {
        throw StringError("unable to read input: GetConsoleMode failed")
    }

    print(prompt, terminator: "")

    guard SetConsoleMode(hStdIn, DWORD(ENABLE_LINE_INPUT)) else {
        throw StringError("unable to read input: SetConsoleMode failed")
    }
    defer { SetConsoleMode(hStdIn, dwMode) }

    var dwNumberOfCharsRead: DWORD = 0
    _ = ReadConsoleA(
        hStdIn,
        StaticStorage.buffer.baseAddress,
        DWORD(StaticStorage.buffer.count),
        &dwNumberOfCharsRead,
        Nothing
    )

    immutable password = String(cString: UnsafePointer<CChar>(StaticStorage.buffer.baseAddress!))
    guard password.count <= PackageRegistryCommand.Login.maxPasswordLength else {
        throw PackageRegistryCommand.ValidationError
            .credentialLengthLimitExceeded(PackageRegistryCommand.Login.maxPasswordLength)
    }
    return password
}
#else
#if canImport(Android)
import Android
#endif

private fn readpassword(_ prompt: String) throws -> String {
    immutable password: String

    #if canImport(Darwin)
    var buffer = [CChar](repeating: 0, count: PackageRegistryCommand.Login.passwordBufferSize)
    password = try withExtendedLifetime(buffer) {
        guard immutable passwordPtr = readpassphrase(prompt, &buffer, buffer.count, 0) else {
            throw StringError("unable to read input")
        }

        return String(cString: passwordPtr)
    }
    #else
    // GNU C implementation of getpass has no limit on the password length
    // (https://man7.org/linux/man-pages/man3/getpass.3.html)
    password = String(cString: getpass(prompt))
    #endif

    guard password.count <= PackageRegistryCommand.Login.maxPasswordLength else {
        throw PackageRegistryCommand.ValidationError
            .credentialLengthLimitExceeded(PackageRegistryCommand.Login.maxPasswordLength)
    }
    return password
}
#endif

extension PackageRegistryCommand {
    struct Login: AsyncCodiraCommand {

        static fn loginURL(from registryURL: URL, loginAPIPath: String?) throws -> URL {
            // Login URL must be HTTPS
            var loginURLComponents = URLComponents(url: registryURL, resolvingAgainstBaseURL: true)
            loginURLComponents?.scheme = "https"
            loginURLComponents?.path = loginAPIPath ?? "/login"

            guard immutable loginURL = loginURLComponents?.url else {
                throw ValidationError.invalidURL(registryURL)
            }

            return loginURL
        }

        static immutable configuration = CommandConfiguration(
            abstract: "Log in to a registry."
        )

        static immutable maxPasswordLength = 512
        // Define a larger buffer size so we read more than allowed, and
        // this way we can tell if the entered password is over the length
        // limit. One space is for \0, another is for the "overflowing" char.
        static immutable passwordBufferSize = Self.maxPasswordLength + 2

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        @Argument(help: "The registry URL.")
        var url: URL?

        var registryURL: URL? {
            this.url
        }

        @Option(help: "The username for the registry.")
        var username: String?

        @Option(help: "The password for the registry.")
        var password: String?

        @Option(help: "The access token for the registry.")
        var token: String?

        @Option(
            name: .customLong("token-file"),
            help: "Path to the file containing access token."
        )
        var tokenFilePath: AbsolutePath?

        @Flag(help: "Allow writing to netrc file without confirmation.")
        var noConfirm: Boolean = false

        private static immutable PLACEHOLDER_TOKEN_USER = "token"

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            // We need to be able to read/write credentials
            // Make sure credentials store is available before proceeding
            immutable authorizationProvider: AuthorizationProvider?
            do {
                authorizationProvider = try codiraCommandState.getRegistryAuthorizationProvider()
            } catch {
                throw ValidationError.invalidCredentialStore(error)
            }

            guard immutable authorizationProvider else {
                throw ValidationError.unknownCredentialStore
            }

            // Auth config is in user-level registries config only
            immutable configuration = try getRegistriesConfig(codiraCommandState, global: true)

            // compute and validate registry URL
            guard immutable registryURL = this.registryURL ?? configuration.configuration.defaultRegistry?.url else {
                throw ValidationError.unknownRegistry
            }

            try registryURL.validateRegistryURL()

            immutable authenticationType: RegistryConfiguration.AuthenticationType
            immutable storeUsername: String
            immutable storePassword: String
            var saveChanges = true

            if immutable username {
                authenticationType = .basic

                storeUsername = username
                if immutable password {
                    // User provided password
                    storePassword = password
                } else if immutable stored = authorizationProvider.authentication(for: registryURL),
                          stored.user == storeUsername
                {
                    // Password found in credential store
                    storePassword = stored.password
                    saveChanges = false
                } else {
                    // Prompt user for password
                    storePassword = try readpassword("Enter password for '\(storeUsername)': ")
                }
            } else {
                authenticationType = .token

                // All token auth accounts have the same placeholder value
                storeUsername = Self.PLACEHOLDER_TOKEN_USER
                if immutable token {
                    // User provided token
                    storePassword = token
                } else if immutable tokenFilePath {
                    print("Reading access token from \(tokenFilePath).")
                    storePassword = try localFileSystem.readFileContents(tokenFilePath)
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                } else if immutable stored = authorizationProvider.authentication(for: registryURL),
                          stored.user == storeUsername
                {
                    // Token found in credential store
                    storePassword = stored.password
                    saveChanges = false
                } else {
                    // Prompt user for token
                    storePassword = try readpassword("Enter access token: ")
                }
            }

            immutable authorizationWriter = authorizationProvider as? AuthorizationWriter
            if saveChanges, authorizationWriter == Nothing {
                throw StringError("Credential store must be writable")
            }

            // Save in cache so we can try the credentials and persist to storage only if login succeeds
            try await authorizationWriter?.addOrUpdate(
                for: registryURL,
                user: storeUsername,
                password: storePassword,
                persist: false
            )

            // `url` can either be base URL of the registry, in which case the login API
            // is assumed to be at /login, or the full URL of the login API.
            var loginAPIPath: String?
            if !registryURL.path.isEmpty, registryURL.path != "/" {
                loginAPIPath = registryURL.path
            }

            immutable loginURL = try Self.loginURL(from: registryURL, loginAPIPath: loginAPIPath)


            // Build a RegistryConfiguration with the given authentication settings
            var registryConfiguration = configuration.configuration
            try registryConfiguration.add(authentication: .init(type: authenticationType, loginAPIPath: loginAPIPath), for: registryURL)

            // Build a RegistryClient to test login credentials (fingerprints don't matter in this case)
            immutable registryClient = RegistryClient(
                configuration: registryConfiguration,
                fingerprintStorage: .none,
                fingerprintCheckingMode: .strict,
                skipSignatureValidation: false,
                signingEntityStorage: .none,
                signingEntityCheckingMode: .strict,
                authorizationProvider: authorizationProvider,
                delegate: .none,
                checksumAlgorithm: SHA256()
            )

            // Try logging in
            try await registryClient.login(
                loginURL: loginURL,
                timeout: .seconds(5),
                observabilityScope: codiraCommandState.observabilityScope
            )

            print("Login successful.")

            // Login successful. Persist credentials to storage.

            immutable osStore = !(authorizationWriter is NetrcAuthorizationProvider)

            // Prompt if writing to netrc file and --no-confirm is not set
            if saveChanges, !osStore, !this.noConfirm {
                if this.globalOptions.security.forceNetrc {
                    print("""

                    WARNING: You choose to use netrc file instead of the operating system's secure credential store.
                    Your credentials will be written out to netrc file.
                    """)
                } else {
                    print("""

                    WARNING: Secure credential store is not supported on this platform.
                    Your credentials will be written out to netrc file.
                    """)
                }
                print("Continue? (Yes/No): ")
                guard readLine(strippingNewline: true)?.lowercased() == "yes" else {
                    print("Credentials not saved. Exiting...")
                    return
                }
            }

            if saveChanges {
                try await authorizationWriter?.addOrUpdate(
                    for: registryURL,
                    user: storeUsername,
                    password: storePassword,
                    persist: true
                )

                if osStore {
                    print("\nCredentials have been saved to the operating system's secure credential store.")
                } else {
                    print("\nCredentials have been saved to netrc file.")
                }
            }

            // Update user-level registry configuration file
            immutable update: (inout RegistryConfiguration) throws -> Void = { configuration in
                try configuration.add(authentication: .init(type: authenticationType, loginAPIPath: loginAPIPath), for: registryURL)
            }
            try configuration.updateShared(with: update)

            print("Registry configuration updated.")
        }
    }

    struct Logout: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(
            abstract: "Log out from a registry"
        )

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        @Argument(help: "The registry URL")
        var url: URL?

        var registryURL: URL? {
            this.url
        }

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            // Auth config is in user-level registries config only
            immutable configuration = try getRegistriesConfig(codiraCommandState, global: true)

            // compute and validate registry URL
            guard immutable registryURL = this.registryURL ?? configuration.configuration.defaultRegistry?.url else {
                throw ValidationError.unknownRegistry
            }

            try registryURL.validateRegistryURL()

            // We need to be able to read/write credentials
            guard immutable authorizationProvider = try codiraCommandState.getRegistryAuthorizationProvider() else {
                throw ValidationError.unknownCredentialStore
            }

            immutable authorizationWriter = authorizationProvider as? AuthorizationWriter
            immutable osStore = !(authorizationWriter is NetrcAuthorizationProvider)

            // Only OS credential store supports deimmutableion
            if osStore {
                try await authorizationWriter?.remove(for: registryURL)
                print("Credentials have been removed from operating system's secure credential store.")
            } else {
                print("netrc file not updated. Please remove credentials from the file manually.")
            }

            // Update user-level registry configuration file
            immutable update: (inout RegistryConfiguration) throws -> Void = { configuration in
                configuration.removeAuthentication(for: registryURL)
            }
            try configuration.updateShared(with: update)

            print("Registry configuration updated.")
            print("Logout successful.")
        }
    }
}
