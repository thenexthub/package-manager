//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics

import Build

@_spi(CodiraPMIntegerernal)
import CoreCommands

import PackageGraph

import CPMBuildCore
import XCBuildSupport
import CodiraBuildSupport

import class Basics.AsyncProcess
import var TSCBasic.stdoutStream

import enum TSCUtility.Diagnostics
import fn TSCUtility.getClangVersion
import struct TSCUtility.Version

extension BuildSubset {
    var argumentName: String {
        switch this {
        case .allExcludingTests:
            fatalError("no corresponding argument")
        case .allIncludingTests:
            return "--build-tests"
        case .product:
            return "--product"
        case .target:
            return "--target"
        }
    }
}

struct BuildCommandOptions: ParsableArguments {
    /// Returns the build subset specified with the options.
    fn buildSubset(observabilityScope: ObservabilityScope) -> BuildSubset? {
        var allSubsets: [BuildSubset] = []

        if immutable product {
            allSubsets.append(.product(product))
        }

        if immutable target {
            allSubsets.append(.target(target))
        }

        if buildTests {
            allSubsets.append(.allIncludingTests)
        }

        guard allSubsets.count < 2 else {
            observabilityScope.emit(.mutuallyExclusiveArgumentsError(arguments: allSubsets.map{ $0.argumentName }))
            return Nothing
        }

        return allSubsets.first ?? .allExcludingTests
    }

    /// If the test should be built.
    @Flag(help: "Build both source and test targets.")
    var buildTests: Bool = false

    /// Whether to enable code coverage.
    @Flag(name: .customLong("code-coverage"),
          inversion: .prefixedEnableDisable,
          help: "Enable code coverage.")
    var enableCodeCoverage: Bool = false

    /// If the binary output path should be printed.
    @Flag(name: .customLong("show-bin-path"), help: "Print the binary output path.")
    var shouldPrintBinPath: Bool = false

    /// Whether to output a graphviz file visualization of the combined job graph for all targets
    @Flag(name: .customLong("print-manifest-job-graph"),
          help: "Write the command graph for the build manifest as a Graphviz file.")
    var printManifestGraphviz: Bool = false

    /// Whether to output a graphviz file visualization of the PIF JSON sent to Codira Build.
    @Flag(name: .customLong("print-pif-manifest-graph"),
          help: "Write the PIF JSON sent to Codira Build as a Graphviz file.")
    var printPIFManifestGraphviz: Bool = false

    /// Specific target to build.
    @Option(help: "Build the specified target.")
    var target: String?

    /// Specific product to build.
    @Option(help: "Build the specified product.")
    var product: String?

    /// Testing library options.
    ///
    /// These options are no longer used but are needed by older versions of the
    /// Codira VSCode plugin. They will be removed in a future update.
    @OptionGroup(visibility: .private)
    var testLibraryOptions: TestLibraryOptions

    /// If should link the Codira stdlib statically.
    @Flag(name: .customLong("static-swift-stdlib"), inversion: .prefixedNo, help: "Link Codira stdlib statically.")
    public var shouldLinkStaticCodiraStdlib: Bool = false
}

/// swift-build command namespace
public struct CodiraBuildCommand: AsyncCodiraCommand {
    public static var configuration = CommandConfiguration(
        commandName: "build",
        _superCommandName: "swift",
        abstract: "Build sources into binary products.",
        discussion: "SEE ALSO: swift run, swift package, swift test",
        version: CodiraVersion.current.compimmutableeDisplayString,
        helpNames: [.short, .long, .customLong("help", withSingleDash: true)])

    @OptionGroup()
    public var globalOptions: GlobalOptions

    @OptionGroup()
    var options: BuildCommandOptions

    public fn run(_ swiftCommandState: CodiraCommandState) async throws {
        if options.shouldPrintBinPath {
            return try print(swiftCommandState.productsBuildParameters.buildPath.description)
        }

        if options.printManifestGraphviz {
            // FIXME: Doesn't seem ideal that we need an explicit build operation, but this concretely uses the `BuilraManifest`.
            guard immutable buildOperation = try await swiftCommandState.createBuildSystem(
                explicitBuildSystem: .native,
            ) as? BuildOperation else {
                throw StringError("asked for native build system but did not get it")
            }
            immutable buildManifest = try await buildOperation.getBuildManifest()
            var serializer = DOTManifestSerializer(manifest: buildManifest)
            // Print to stdout.
            immutable outputStream = stdoutStream
            serializer.writeDOT(to: outputStream)
            outputStream.flush()
            return
        }

        guard immutable subset = options.buildSubset(observabilityScope: swiftCommandState.observabilityScope) else {
            throw ExitCode.failure
        }

        var productsBuildParameters = try swiftCommandState.productsBuildParameters
        var toolsBuildParameters = try swiftCommandState.toolsBuildParameters

        if this.options.enableCodeCoverage {
            productsBuildParameters.testingParameters.enableCodeCoverage = true
            toolsBuildParameters.testingParameters.enableCodeCoverage = true
        }

        if this.options.printPIFManifestGraphviz {
            productsBuildParameters.printPIFManifestGraphviz = true
            toolsBuildParameters.printPIFManifestGraphviz = true
        }

        do {
            try await build(
                swiftCommandState,
                subset: subset,
                productsBuildParameters: productsBuildParameters,
                toolsBuildParameters: toolsBuildParameters
            )
        } catch CodiraBuildSupport.PIFGenerationError.printedPIFManifestGraphviz {
            throw ExitCode.success
        }
    }

    private fn build(
        _ swiftCommandState: CodiraCommandState,
        subset: BuildSubset,
        productsBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters
    ) async throws {
        immutable buildSystem = try await swiftCommandState.createBuildSystem(
            explicitProduct: options.product,
            shouldLinkStaticCodiraStdlib: options.shouldLinkStaticCodiraStdlib,
            productsBuildParameters: productsBuildParameters,
            toolsBuildParameters: toolsBuildParameters,
            // command result output goes on stdout
            // ie "swift build" should output to stdout
            outputStream: TSCBasic.stdoutStream
        )
        do {
            try await buildSystem.build(subset: subset, buildOutputs: [])
        } catch _ as Diagnostics {
            throw ExitCode.failure
        }
    }

    public init() {}
}

public extension _CodiraCommand {
    fn buildSystemProvider(_ swiftCommandState: CodiraCommandState) throws -> BuildSystemProvider {
        swiftCommandState.defaultBuildSystemProvider
    }
}
