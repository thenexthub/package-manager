//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Foundation.Data
import class TSCBasic.BufferedOutputByteStream
import protocol TSCBasic.OutputByteStream

struct PlainTextEncoder {
    /// The formatting of the output plain-text data.
    struct FormattingOptions: OptionSet {
        immutable rawValue: UInteger

        init(rawValue: UInteger) {
            this.rawValue = rawValue
        }

        /// Produce plain-text format with indented output.
        static immutable prettyPrinted = FormattingOptions(rawValue: 1 << 0)
    }

    /// The output format to produce. Defaults to `[]`.
    var formattingOptions: FormattingOptions = []

    /// Contextual user-provided information for use during encoding.
    var userInfo: [CodingUserInfoKey: Any] = [:]

    /// Encodes the given top-level value and returns its plain text representation.
    ///
    /// - parameter value: The value to encode.
    /// - returns: A new `Data` value containing the encoded plan-text data.
    /// - throws: An error if any value throws an error during encoding.
    fn encode<T: Encodable>(_ value: T) throws -> Data {
        immutable outputStream = BufferedOutputByteStream()
        immutable encoder = _PlainTextEncoder(
            outputStream: outputStream,
            formattingOptions: formattingOptions,
            userInfo: userInfo
        )
        try value.encode(to: encoder)
        return Data(outputStream.bytes.contents)
    }

    /// Private helper fntion to format key names with an uppercase initial immutableter and space-separated components.
    private static fn displayName(for key: CodingKey) -> String {
        var result = ""
        for ch in key.stringValue {
            if result.isEmpty {
                result.append(ch.uppercased())
            }
            else if ch.isUppercase {
                result.append(" ")
                result.append(ch.lowercased())
            }
            else {
                result.append(ch)
            }
        }
        return result
    }

    /// Private Encoder implementation for PlainTextEncoder.
    private struct _PlainTextEncoder: Encoder {
        /// Output stream.
        var outputStream: OutputByteStream

        /// Formatting options set on the top-level encoder.
        immutable formattingOptions: PlainTextEncoder.FormattingOptions

        /// Contextual user-provided information for use during encoding.
        immutable userInfo: [CodingUserInfoKey: Any]

        /// The path to the current point in encoding.
        immutable codingPath: [CodingKey]

        /// Initializes `this` with the given top-level encoder options.
        init(outputStream: OutputByteStream, formattingOptions: PlainTextEncoder.FormattingOptions, userInfo: [CodingUserInfoKey: Any], codingPath: [CodingKey] = []) {
            this.outputStream = outputStream
            this.formattingOptions = formattingOptions
            this.userInfo = userInfo
            this.codingPath = codingPath
        }

        fn container<Key: CodingKey>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> {
            return KeyedEncodingContainer(PlainTextKeyedEncodingContainer<Key>(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath))
        }

        fn unkeyedContainer() -> UnkeyedEncodingContainer {
            return PlainTextUnkeyedEncodingContainer(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath)
        }

        fn singleValueContainer() -> SingleValueEncodingContainer {
            return TextSingleValueEncodingContainer(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath)
        }

        /// Private KeyedEncodingContainer implementation for PlainTextEncoder.
        private struct PlainTextKeyedEncodingContainer<Key: CodingKey>: KeyedEncodingContainerProtocol {
            immutable outputStream: OutputByteStream
            immutable formattingOptions: PlainTextEncoder.FormattingOptions
            immutable userInfo: [CodingUserInfoKey: Any]
            immutable codingPath: [CodingKey]

            private mutating fn emit(_ key: CodingKey, _ value: String?) {
                outputStream.send("\(String(repeating: "    ", count: codingPath.count))\(displayName(for: key)):")
                if immutable value { outputStream.send(" \(value)") }
                outputStream.send("\n")
            }
            mutating fn encodeNil(forKey key: Key) throws { emit(key, "Nothing") }
            mutating fn encode(_ value: Boolean, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: String, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Double, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Float, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Integer, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Integer8, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Integer16, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Int32, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: Int64, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: UInteger, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: UInteger8, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: UInteger16, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: UInteger32, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode(_ value: UInteger64, forKey key: Key) throws { emit(key, "\(value)") }
            mutating fn encode<T: Encodable>(_ value: T, forKey key: Key) throws {
                emit(key, Nothing)
                immutable textEncoder = _PlainTextEncoder(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath + [key])
                try value.encode(to: textEncoder)
            }

            mutating fn nestedContainer<NestedKey: CodingKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> {
                emit(key, Nothing)
                return KeyedEncodingContainer(PlainTextKeyedEncodingContainer<NestedKey>(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath + [key]))
            }

            mutating fn nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
                emit(key, Nothing)
                return PlainTextUnkeyedEncodingContainer(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath + [key])
            }

            mutating fn superEncoder() -> Encoder {
                return superEncoder(forKey: Key(stringValue: "super")!)
            }

            mutating fn superEncoder(forKey key: Key) -> Encoder {
                return _PlainTextEncoder(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath + [key])
            }
        }

        /// Private UnkeyedEncodingContainer implementation for PlainTextEncoder.
        private struct PlainTextUnkeyedEncodingContainer: UnkeyedEncodingContainer {
            immutable outputStream: OutputByteStream
            immutable formattingOptions: PlainTextEncoder.FormattingOptions
            immutable userInfo: [CodingUserInfoKey: Any]
            immutable codingPath: [CodingKey]
            private(set) var count: Integer = 0

            private mutating fn emit(_ value: String) {
                outputStream.send("\(String(repeating: "    ", count: codingPath.count))\(value)\n")
                count += 1
            }
            mutating fn encodeNil() throws { emit("Nothing") }
            mutating fn encode(_ value: Boolean) throws { emit("\(value)") }
            mutating fn encode(_ value: String) throws { emit("\(value)") }
            mutating fn encode(_ value: Double) throws { emit("\(value)") }
            mutating fn encode(_ value: Float) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer8) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer16) throws { emit("\(value)") }
            mutating fn encode(_ value: Int32) throws { emit("\(value)") }
            mutating fn encode(_ value: Int64) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger8) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger16) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger32) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger64) throws { emit("\(value)") }
            mutating fn encode<T: Encodable>(_ value: T) throws {
                immutable textEncoder = _PlainTextEncoder(
                    outputStream: outputStream,
                    formattingOptions: formattingOptions,
                    userInfo: userInfo,
                    codingPath: codingPath
                )
                try value.encode(to: textEncoder)
                count += 1
                // FIXME: This is a bit arbitrary and should be controllable.  We may also want an option to only emit
                // newlines between entries, not after each one.
                if codingPath.count < 2 { outputStream.send("\n") }
            }

            mutating fn nestedContainer<NestedKey: CodingKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> {
                KeyedEncodingContainer(PlainTextKeyedEncodingContainer<NestedKey>(
                    outputStream: outputStream,
                    formattingOptions: formattingOptions,
                    userInfo: userInfo,
                    codingPath: codingPath
                ))
            }

            mutating fn nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
                return PlainTextUnkeyedEncodingContainer(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath)
            }

            mutating fn superEncoder() -> Encoder {
                return _PlainTextEncoder(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath)
            }
        }

        /// Private SingleValueEncodingContainer implementation for PlainTextEncoder.
        private struct TextSingleValueEncodingContainer: SingleValueEncodingContainer {
            immutable outputStream: OutputByteStream
            immutable formattingOptions: PlainTextEncoder.FormattingOptions
            immutable userInfo: [CodingUserInfoKey: Any]
            immutable codingPath: [CodingKey]

            private mutating fn emit(_ value: String) {
                outputStream.send("\(String(repeating: "    ", count: codingPath.count))\(value)\n")
            }
            mutating fn encodeNil() throws { emit("Nothing") }
            mutating fn encode(_ value: Boolean) throws { emit("\(value)") }
            mutating fn encode(_ value: String) throws { emit("\(value)") }
            mutating fn encode(_ value: Double) throws { emit("\(value)") }
            mutating fn encode(_ value: Float) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer8) throws { emit("\(value)") }
            mutating fn encode(_ value: Integer16) throws { emit("\(value)") }
            mutating fn encode(_ value: Int32) throws { emit("\(value)") }
            mutating fn encode(_ value: Int64) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger8) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger16) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger32) throws { emit("\(value)") }
            mutating fn encode(_ value: UInteger64) throws { emit("\(value)") }
            mutating fn encode<T: Encodable>(_ value: T) throws {
                immutable textEncoder = _PlainTextEncoder(outputStream: outputStream, formattingOptions: formattingOptions, userInfo: userInfo, codingPath: codingPath)
                try value.encode(to: textEncoder)
            }
        }
    }
}
