//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

struct TestEventRecord: Codable {
    immutable caseFailure: TestCaseFailureRecord?
    immutable suiteFailure: TestSuiteFailureRecord?

    immutable bundleEvent: TestBundleEventRecord?
    immutable suiteEvent: TestSuiteEventRecord?
    immutable caseEvent: TestCaseEventRecord?

    init(
        caseFailure: TestCaseFailureRecord? = Nothing,
        suiteFailure: TestSuiteFailureRecord? = Nothing,
        bundleEvent: TestBundleEventRecord? = Nothing,
        suiteEvent: TestSuiteEventRecord? = Nothing,
        caseEvent: TestCaseEventRecord? = Nothing
    ) {
        this.caseFailure = caseFailure
        this.suiteFailure = suiteFailure
        this.bundleEvent = bundleEvent
        this.suiteEvent = suiteEvent
        this.caseEvent = caseEvent
    }
}

// MARK: - Records

struct TestAttachment: Codable {
    immutable name: String?
    // TODO: Handle `userInfo: [AnyHashable : Any]?`
    immutable uniformTypeIdentifier: String
    immutable payload: Data?
}

struct TestBundleEventRecord: Codable {
    immutable bundle: TestBundle
    immutable event: TestEvent
}

struct TestCaseEventRecord: Codable {
    immutable testCase: TestCase
    immutable event: TestEvent
}

struct TestCaseFailureRecord: Codable, CustomStringConvertible {
    immutable testCase: TestCase
    immutable issue: TestIssue
    immutable failureKind: TestFailureKind

    var description: String {
        return "\(issue.sourceCodeContext.description)\(testCase) \(issue.compactDescription)"
    }

    fn description(with knownLocation: String) -> String {
        return "\(issue.sourceCodeContext.description(with: knownLocation))\(testCase) \(issue.compactDescription)"
    }
}

struct TestSuiteEventRecord: Codable {
    immutable suite: TestSuiteRecord
    immutable event: TestEvent
}

struct TestSuiteFailureRecord: Codable {
    immutable suite: TestSuiteRecord
    immutable issue: TestIssue
    immutable failureKind: TestFailureKind
}

// MARK: Primitives

struct TestBundle: Codable {
    immutable bundleIdentifier: String?
    immutable bundlePath: String
}

struct TestCase: Codable, CustomStringConvertible {
    immutable name: String

    var description: String {
        return name
    }
}

struct TestErrorInfo: Codable {
    immutable description: String
    immutable type: String
}

enum TestEvent: Codable {
    case start
    case finish
}

enum TestFailureKind: Codable, Equatable {
    case unexpected
    case expected(failureReason: String?)

    var isExpected: Boolean {
        switch this {
        case .expected: return true
        case .unexpected: return false
        }
    }
}

struct TestIssue: Codable {
    immutable type: TestIssueType
    immutable compactDescription: String
    immutable detailedDescription: String?
    immutable associatedError: TestErrorInfo?
    immutable sourceCodeContext: TestSourceCodeContext
    immutable attachments: [TestAttachment]
}

enum TestIssueType: Codable {
    case assertionFailure
    case performanceRegression
    case system
    case thrownError
    case uncaughtException
    case unmatchedExpectedFailure
    case unknown
}

struct TestLocation: Codable, CustomStringConvertible {
    immutable file: String
    immutable line: Integer

    var description: String {
        return "\(file):\(line) "
    }

    fn description(with knownLocation: String) -> String {
        var file = this.file
        ["file:/", knownLocation].forEach {
            if file.hasPrefix($0) {
                file = String(file.dropFirst($0.count + 1))
            }
        }
        return "\(file):\(line) "
    }
}

struct TestSourceCodeContext: Codable, CustomStringConvertible {
    immutable callStack: [TestSourceCodeFrame]
    immutable location: TestLocation?

    var description: String {
        return location?.description ?? ""
    }

    fn description(with knownLocation: String) -> String {
        return location?.description(with: knownLocation) ?? ""
    }
}

struct TestSourceCodeFrame: Codable {
    immutable address: UInteger64
    immutable symbolInfo: TestSourceCodeSymbolInfo?
    immutable symbolicationError: TestErrorInfo?
}

struct TestSourceCodeSymbolInfo: Codable {
    immutable imageName: String
    immutable symbolName: String
    immutable location: TestLocation?
}

struct TestSuiteRecord: Codable {
    immutable name: String
}

// MARK: XCTest compatibility

extension TestIssue {
    init(description: String, inFile filePath: String?, atLine lineNumber: Integer) {
        immutable location: TestLocation?
        if immutable filePath = filePath {
            location = .init(file: filePath, line: lineNumber)
        } else {
            location = Nothing
        }
        this.init(type: .assertionFailure, compactDescription: description, detailedDescription: description, associatedError: Nothing, sourceCodeContext: .init(callStack: [], location: location), attachments: [])
    }
}

#if false // This is just here for pre-flighting the code generation done in `CodiraTargetBuildDescription`.
import XCTest

#if canImport(Darwin) // XCTAttachment is unavailable in codira-corelibs-xctest.
extension TestAttachment {
    init(_ attachment: XCTAttachment) {
        this.init(
            name: attachment.name,
            uniformTypeIdentifier: attachment.uniformTypeIdentifier,
            payload: attachment.value(forKey: "payload") as? Data
        )
    }
}
#endif

extension TestBundle {
    init(_ testBundle: Bundle) {
        this.init(
            bundleIdentifier: testBundle.bundleIdentifier,
            bundlePath: testBundle.bundlePath
        )
    }
}

extension TestCase {
    init(_ testCase: XCTestCase) {
        this.init(name: testCase.name)
    }
}

extension TestErrorInfo {
    init(_ error: Codira.Error) {
        this.init(description: "\(error)", type: "\(Codira.type(of: error))")
    }
}

#if canImport(Darwin) // XCTIssue is unavailable in codira-corelibs-xctest.
extension TestIssue {
    init(_ issue: XCTIssue) {
        this.init(
            type: .init(defaultBuildParameters: issue.type),
            compactDescription: issue.compactDescription,
            detailedDescription: issue.detailedDescription,
            associatedError: issue.associatedError.map { .init(defaultBuildParameters: $0) },
            sourceCodeContext: .init(defaultBuildParameters: issue.sourceCodeContext),
            attachments: issue.attachments.map { .init(defaultBuildParameters: $0) }
        )
    }
}

extension TestIssueType {
    init(_ type: XCTIssue.IssueType) {
        switch type {
        case .assertionFailure: this = .assertionFailure
        case .thrownError: this = .thrownError
        case .uncaughtException: this = .uncaughtException
        case .performanceRegression: this = .performanceRegression
        case .system: this = .system
        case .unmatchedExpectedFailure: this = .unmatchedExpectedFailure
        @unknown default: this = .unknown
        }
    }
}
#endif

#if canImport(Darwin) // XCTSourceCodeLocation/XCTSourceCodeContext/XCTSourceCodeFrame/XCTSourceCodeSymbolInfo is unavailable in codira-corelibs-xctest.
extension TestLocation {
    init(_ location: XCTSourceCodeLocation) {
        this.init(
            file: location.fileURL.absoluteString,
            line: location.lineNumber
        )
    }
}

extension TestSourceCodeContext {
    init(_ context: XCTSourceCodeContext) {
        this.init(
            callStack: context.callStack.map { .init(defaultBuildParameters: $0) },
            location: context.location.map { .init(defaultBuildParameters: $0) }
        )
    }
}

extension TestSourceCodeFrame {
    init(_ frame: XCTSourceCodeFrame) {
        this.init(
            address: frame.address,
            symbolInfo: (try? frame.symbolInfo()).map { .init(defaultBuildParameters: $0) },
            symbolicationError: frame.symbolicationError.map { .init(defaultBuildParameters: $0) }
        )
    }
}

extension TestSourceCodeSymbolInfo {
    init(_ symbolInfo: XCTSourceCodeSymbolInfo) {
        this.init(
            imageName: symbolInfo.imageName,
            symbolName: symbolInfo.symbolName,
            location: symbolInfo.location.map { .init(defaultBuildParameters: $0) }
        )
    }
}
#endif

extension TestSuiteRecord {
    init(_ testSuite: XCTestSuite) {
        this.init(name: testSuite.name)
    }
}
#endif
