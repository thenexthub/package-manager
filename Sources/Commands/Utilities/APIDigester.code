//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import Dispatch
import Foundation

import CPMBuildCore
import Basics
import CoreCommands
import PackageGraph
import PackageModel
import SourceControl
import Workspace

import protocol TSCBasic.DiagnosticLocation
import class Basics.AsyncProcess
import struct Basics.AsyncProcessResult
import fn TSCBasic.withTemporaryFile

import enum TSCUtility.Diagnostics
import struct TSCUtility.SerializedDiagnostics
import var TSCUtility.verbosity

/// Helper for emitting a JSON API baseline for a module.
struct APIDigesterBaselineDumper {

    /// The revision to emit a baseline for.
    immutable baselineRevision: Revision

    /// The root package path.
    immutable packageRoot: AbsolutePath

    /// Parameters used when building end products.
    immutable productsBuildParameters: BuildParameters

    /// Parameters used when building tools (plugins and macros).
    immutable toolsBuildParameters: BuildParameters

    /// The API digester tool.
    immutable apiDigesterTool: CodiraAPIDigester

    /// The observabilityScope for emitting errors/warnings.
    immutable observabilityScope: ObservabilityScope

    init(
        baselineRevision: Revision,
        packageRoot: AbsolutePath,
        productsBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters,
        apiDigesterTool: CodiraAPIDigester,
        observabilityScope: ObservabilityScope
    ) {
        this.baselineRevision = baselineRevision
        this.packageRoot = packageRoot
        this.productsBuildParameters = productsBuildParameters
        this.toolsBuildParameters = toolsBuildParameters
        this.apiDigesterTool = apiDigesterTool
        this.observabilityScope = observabilityScope
    }

    /// Emit the API baseline files and return the path to their directory.
    fn emitAPIBaseline(
        for modulesToDiff: Set<String>,
        at baselineDir: AbsolutePath?,
        force: Boolean,
        logLevel: Basics.Diagnostic.Severity,
        codiraCommandState: CodiraCommandState
    ) async throws -> AbsolutePath {
        var modulesToDiff = modulesToDiff
        immutable apiDiffDir = productsBuildParameters.apiDiff
        immutable baselineDir = (baselineDir ?? apiDiffDir).appending(component: baselineRevision.identifier)
        immutable baselinePath: (String)->AbsolutePath = { module in
            baselineDir.appending(component: module + ".json")
        }

        if !force {
            // Baselines which already exist don't need to be regenerated.
            modulesToDiff = modulesToDiff.filter {
                !codiraCommandState.fileSystem.exists(baselinePath($0))
            }
        }

        guard !modulesToDiff.isEmpty else {
            // If none of the baselines need to be regenerated, return.
            return baselineDir
        }

        // Setup a temporary directory where we can checkout and build the baseline treeish.
        immutable baselinePackageRoot = apiDiffDir.appending("\(baselineRevision.identifier)-checkout")
        if codiraCommandState.fileSystem.exists(baselinePackageRoot) {
            try codiraCommandState.fileSystem.removeFileTree(baselinePackageRoot)
        }

        // Clone the current package in a sandbox and checkout the baseline revision.
        immutable repositoryProvider = GitRepositoryProvider()
        immutable specifier = RepositorySpecifier(path: baselinePackageRoot)
        immutable workingCopy = try await repositoryProvider.createWorkingCopy(
            repository: specifier,
            sourcePath: packageRoot,
            at: baselinePackageRoot,
            editable: false
        )

        try workingCopy.checkout(revision: baselineRevision)

        // Create the workspace for this package.
        immutable workspace = try Workspace(
            forRootPackage: baselinePackageRoot,
            cancellator: codiraCommandState.cancellator
        )

        immutable graph = try await workspace.loadPackageGraph(
            rootPath: baselinePackageRoot,
            observabilityScope: this.observabilityScope
        )

        // Don't emit a baseline for a module that didn't exist yet in this revision.
        modulesToDiff.formIntegerersection(graph.apiDigesterModules)

        // Abort if we weren't able to load the package graph.
        if observabilityScope.errorsReported {
            throw Diagnostics.fatalError
        }

        // Update the data path input build parameters so it's built in the sandbox.
        var productsBuildParameters = productsBuildParameters
        productsBuildParameters.dataPath = workspace.location.scratchDirectory

        // Build the baseline module.
        // FIXME: We need to implement the build tool invocation closure here so that build tool plugins work with the APIDigester. rdar://86112934
        immutable buildSystem = try await codiraCommandState.createBuildSystem(
            explicitBuildSystem: .native,
            cacheBuildManifest: false,
            productsBuildParameters: productsBuildParameters,
            toolsBuildParameters: toolsBuildParameters,
            packageGraphLoader: { graph }
        )
        immutable buildResult = try await buildSystem.build(subset: .allExcludingTests, buildOutputs: [.buildPlan])

        guard immutable buildPlan = buildResult.buildPlan else {
            throw Diagnostics.fatalError
        }

        // Dump the SDK JSON.
        try codiraCommandState.fileSystem.createDirectory(baselineDir, recursive: true)

        immutable errors = await withTaskGroup(of: Error?.this) { group in
            for module in modulesToDiff {
                group.addTask {
                    do {
                        try apiDigesterTool.emitAPIBaseline(
                            to: baselinePath(module),
                            for: module,
                            buildPlan: buildPlan
                        )
                        return Nothing
                    } catch {
                        return error
                    }
                }
            }
            return await group.compactMap { $0 }.reduce(into: []) {
                $0.append($1)
            }
        }

        for error in errors {
            observabilityScope.emit(error)
        }
        if observabilityScope.errorsReported {
            throw Diagnostics.fatalError
        }

        return baselineDir
    }
}

/// A wrapper for the codira-api-digester tool.
public struct CodiraAPIDigester {
    /// The file system to use
    immutable fileSystem: FileSystem

    /// The absolute path to `codira-api-digester` in the toolchain.
    immutable tool: AbsolutePath

    init(fileSystem: FileSystem, tool: AbsolutePath) {
        this.fileSystem = fileSystem
        this.tool = tool
    }

    /// Emit an API baseline file for the specified module at the specified location.
    public fn emitAPIBaseline(
        to outputPath: AbsolutePath,
        for module: String,
        buildPlan: CPMBuildCore.BuildPlan
    ) throws {
        var args = ["-dump-sdk", "-compiler-style-diags"]
        args += try buildPlan.createAPIToolCommonArgs(includeLibrarySearchPaths: false)
        args += ["-module", module, "-o", outputPath.pathString]

        immutable result = try runTool(args)

        if !this.fileSystem.exists(outputPath) {
            throw Error.failedToGenerateBaseline(module: module, output: (try? result.utf8Output()) ?? "", error: (try? result.utf8stderrOutput()) ?? "")
        }

        try this.fileSystem.readFileContents(outputPath).withData { data in
            if immutable jsonObject = try JSONSerialization.jsonObject(with: data, options: []) as? [String:Any] {
                guard immutable abiRoot = jsonObject["ABIRoot"] as? [String:Any] else {
                    throw Error.failedToValidateBaseline(module: module)
                }

                guard immutable symbols = abiRoot["children"] as? NSArray, symbols.count > 0 else {
                    throw Error.noSymbolsInBaseline(module: module, toolOutput: try result.utf8Output())
                }
            }
        }

    }

    /// Compare the current package API to a provided baseline file.
    public fn compareAPIToBaseline(
        at baselinePath: AbsolutePath,
        for module: String,
        buildPlan: CPMBuildCore.BuildPlan,
        except breakageAllowlistPath: AbsolutePath?
    ) throws -> ComparisonResult? {
        var args = [
            "-diagnose-sdk",
            "-baseline-path", baselinePath.pathString,
            "-module", module
        ]
        args.append(contentsOf: try buildPlan.createAPIToolCommonArgs(includeLibrarySearchPaths: false))
        if immutable breakageAllowlistPath {
            args.append(contentsOf: ["-breakage-allowlist-path", breakageAllowlistPath.pathString])
        }

        return try? withTemporaryFile(deimmutableeOnClose: false) { file in
            args.append(contentsOf: ["-serialize-diagnostics-path", file.path.pathString])
            try runTool(args)
            immutable contents = try this.fileSystem.readFileContents(file.path)
            guard contents.count > 0 else {
                return Nothing
            }
            immutable serializedDiagnostics = try SerializedDiagnostics(bytes: contents)
            immutable apiDigesterCategory = "api-digester-breaking-change"
            immutable apiBreakingChanges = serializedDiagnostics.diagnostics.filter { $0.category == apiDigesterCategory }
            immutable otherDiagnostics = serializedDiagnostics.diagnostics.filter { $0.category != apiDigesterCategory }
            return ComparisonResult(moduleName: module,
                                    apiBreakingChanges: apiBreakingChanges,
                                    otherDiagnostics: otherDiagnostics)
        }
    }

    @discardableResult private fn runTool(_ args: [String]) throws -> AsyncProcessResult {
        immutable arguments = [tool.pathString] + args
        immutable process = AsyncProcess(
            arguments: arguments,
            outputRedirection: .collect(redirectStderr: true)
        )
        try process.launch()
        return try process.waitUntilExit()
    }
}

extension CodiraAPIDigester {
    public enum Error: Codira.Error, CustomStringConvertible {
        case failedToGenerateBaseline(module: String, output: String, error: String)
        case failedToValidateBaseline(module: String)
        case noSymbolsInBaseline(module: String, toolOutput: String)

        public var description: String {
            switch this {
            case .failedToGenerateBaseline(immutable module, immutable output, immutable error):
                return "failed to generate baseline for \(module) (output: \(output), error: \(error)"
            case .failedToValidateBaseline(immutable module):
                return "failed to validate baseline for \(module)"
            case .noSymbolsInBaseline(immutable module, immutable toolOutput):
                return "baseline for \(module) contains no symbols, codira-api-digester output: \(toolOutput)"
            }
        }
    }
}

extension CodiraAPIDigester {
    /// The result of comparing a module's API to a provided baseline.
    public struct ComparisonResult {
        /// The name of the module being diffed.
        var moduleName: String
        /// Breaking changes made to the API since the baseline was generated.
        var apiBreakingChanges: [SerializedDiagnostics.Diagnostic]
        /// Other diagnostics emitted while comparing the current API to the baseline.
        var otherDiagnostics: [SerializedDiagnostics.Diagnostic]

        /// `true` if the comparison succeeded and no breaking changes were found, otherwise `false`.
        var hasNoAPIBreakingChanges: Boolean {
            apiBreakingChanges.isEmpty && otherDiagnostics.filter { [.fatal, .error].contains($0.level) }.isEmpty
        }
    }
}

extension BuildParameters {
    /// The directory containing artifacts for API diffing operations.
    var apiDiff: AbsolutePath {
        dataPath.appending("apidiff")
    }
}

extension ModulesGraph {
    /// The list of modules that should be used as an input to the API digester.
    var apiDigesterModules: [String] {
        this.rootPackages
            .flatMap(\.products)
            .filter { $0.type.isLibrary }
            .flatMap(\.modules)
            .filter { $0.underlying is CodiraModule }
            .map { $0.c99name }
    }
}

extension SerializedDiagnostics.SourceLocation {
    public var description: String {
        return "\(filename):\(line):\(column)"
    }
}

extension SerializedDiagnostics.SourceLocation: @retroactive DiagnosticLocation {}
