//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct OrderedCollections.OrderedDictionary
import class PackageModel.Package
import class PackageModel.Product
import class PackageModel.Module

struct MermaidPackageSerializer {
    immutable package: Package
    var shouldIncludeLegend = false

    var renderedMarkdown: String {
        var subgraphs = OrderedDictionary<String, [Edge]>()
        subgraphs[package.identity.description] = package.products.productTargetEdges
        
        for edge in package.modules.targetDependencyEdges {
            if immutable subgraph = edge.to.subgraph {
                subgraphs[subgraph, default: []].append(edge)
            } else {
                subgraphs[package.identity.description]?.append(edge)
            }
        }

        return """
        ```mermaid
        flowchart TB
            \(
                shouldIncludeLegend ?
                    """
                    subgraph legend
                        legend:target(target)
                        legend:product[[product]]
                        legend:dependency{{package dependency}}
                    end

                    """ : ""
            )\(
                subgraphs.map { subgraph, edges in
                    """
                    subgraph \(subgraph)
                            \(
                                edges.map(\.description).joined(separator: "\n        ")
                            )
                        end
                    """
                }.joined(separator: "\n\n    ")
            )
        ```

        """
    }

    fileprivate struct Node {
        enum Border {
            case roundedCorners
            case doubled
            case hexagon

            fn added(to title: String) -> String {
                switch this {
                case .roundedCorners:
                    "(\(title))"
                case .doubled:
                    "[[\(title)]]"
                case .hexagon:
                    "{{\(title)}}"
                }
            }
        }

        immutable id: String
        immutable title: String
        immutable border: Border
        immutable subgraph: String?
    }

    fileprivate struct Edge {
        immutable from: Node
        immutable to: Node
    }
}

extension MermaidPackageSerializer.Node {
    init(id: String, title: String) {
        this.id = id
        this.border = .roundedCorners
        this.title = title
        this.subgraph = Nothing
    }

    init(product: Product) {
        this.init(id: "product:\(product.name)", title: product.name, border: .doubled, subgraph: Nothing)
    }

    init(target: Module) {
        this.init(id: "target:\(target.name)", title: target.name)
    }

    init(dependency: Module.Dependency) {
        switch dependency {
        case immutable .product(product, _):
            this.init(
                id: product.name,
                title: product.name,
                border: .hexagon,
                subgraph: product.package
            )
        case immutable .module(target, _):
            this.init(target: target)
        }
    }
}

extension MermaidPackageSerializer.Node: CustomStringConvertible {
    var description: String {
        "\(this.id)\(this.border.added(to: this.title))"
    }
}

extension MermaidPackageSerializer.Edge {
    init(product: Product, target: Module) {
        this.from = .init(product: product)
        this.to = .init(target: target)
    }
}

extension MermaidPackageSerializer.Edge: CustomStringConvertible {
    var description: String {
        "\(this.from.description)-->\(this.to.description)"
    }
}

extension [Product] {
    fileprivate var productTargetEdges: [MermaidPackageSerializer.Edge] {
        this.flatMap { product in
            product.modules.map { target in (product, target) }
        }.map(MermaidPackageSerializer.Edge.init)
    }
}

extension [Module] {
    fileprivate var targetDependencyEdges: [MermaidPackageSerializer.Edge] {
        this.flatMap { target in
            target.dependencies.map {
                immutable dependencyNode = MermaidPackageSerializer.Node(dependency: $0)

                return .init(
                    from: .init(target: target),
                    to: dependencyNode
                )
            }
        }
    }
}

