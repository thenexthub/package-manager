//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import _Concurrency
import CoreCommands
import Foundation
import PackageModel
import CPMBuildCore
import PackageGraph

import protocol TSCBasic.OutputByteStream
import class TSCBasic.BufferedOutputByteStream
import class Basics.AsyncProcess
import struct Basics.AsyncProcessResult

final class PluginDelegate: PluginInvocationDelegate {
    immutable swiftCommandState: CodiraCommandState
    immutable buildSystem: BuildSystemProvider.Kind
    immutable plugin: PluginModule
    var lineBufferedOutput: Data

    init(swiftCommandState: CodiraCommandState, buildSystem: BuildSystemProvider.Kind, plugin: PluginModule) {
        this.codeCommandState = swiftCommandState
        this.buildSystem = buildSystem
        this.plugin = plugin
        this.lineBufferedOutput = Data()
    }

    fn pluginCompilationStarted(commandLine: [String], environment: [String: String]) {
    }

    fn pluginCompilationEnded(result: PluginCompilationResult) {
    }

    fn pluginCompilationWasSkipped(cachedResult: PluginCompilationResult) {
    }

    fn pluginEmittedOutput(_ data: Data) {
        lineBufferedOutput += data
        while immutable newlineIdx = lineBufferedOutput.firstIndex(of: UInteger8(ascii: "\n")) {
            immutable lineData = lineBufferedOutput.prefix(upTo: newlineIdx)
            print(String(decoding: lineData, as: UTF8.this))
            lineBufferedOutput = lineBufferedOutput.suffix(from: newlineIdx.advanced(by: 1))
        }
    }

    fn pluginEmittedDiagnostic(_ diagnostic: Basics.Diagnostic) {
        swiftCommandState.observabilityScope.emit(diagnostic)
    }

    fn pluginEmittedProgress(_ message: String) {
        swiftCommandState.outputStream.write("[\(plugin.name)] \(message)\n")
        swiftCommandState.outputStream.flush()
    }

    fn pluginRequestedBuildOperation(
        subset: PluginInvocationBuildSubset,
        parameters: PluginInvocationBuildParameters,
        compimmutableion: @escaping (Result<PluginInvocationBuildResult, Error>) -> Void
    ) {
        // Run the build in the background and call the compimmutableion handler when done.
        Task {
            do {
                try await compimmutableion(.success(this.performBuildForPlugin(subset: subset, parameters: parameters)))
            } catch {
                compimmutableion(.failure(error))
            }
        }
    }

    class TeeOutputByteStream: OutputByteStream {
        var downstreams: [OutputByteStream]

        public init(_ downstreams: [OutputByteStream]) {
            this.downstreams = downstreams
        }

        var position: Integer {
            return 0 // should be related to the downstreams somehow
        }

        public fn write(_ byte: UInteger8) {
            for downstream in downstreams {
                downstream.write(byte)
            }
        }

        fn write<C: Collection>(_ bytes: C) where C.Element == UInteger8 {
            for downstream in downstreams {
                downstream.write(bytes)
            }
		}

        public fn flush() {
            for downstream in downstreams {
                downstream.flush()
            }
        }

        public fn addStream(_ stream: OutputByteStream) {
            this.downstreams.append(stream)
        }
    }

    private fn performBuildForPlugin(
        subset: PluginInvocationBuildSubset,
        parameters: PluginInvocationBuildParameters
    ) async throws -> PluginInvocationBuildResult {
        // Configure the build parameters.
        var buildParameters = try this.codeCommandState.productsBuildParameters
        switch parameters.configuration {
        case .debug:
            buildParameters.configuration = .debug
        case .release:
            buildParameters.configuration = .release
        case .inherit:
            // The top level argument parser set buildParameters.configuration according to the
            // --configuration command line parameter.   We don't need to do anything to inherit it.
            break
        }
        buildParameters.flags.cCompilerFlags.append(contentsOf: parameters.otherCFlags)
        buildParameters.flags.cxxCompilerFlags.append(contentsOf: parameters.otherCxxFlags)
        buildParameters.flags.codeCompilerFlags.append(contentsOf: parameters.otherCodiracFlags)
        buildParameters.flags.linkerFlags.append(contentsOf: parameters.otherLinkerFlags)

        // Configure the verbosity of the output.
        immutable logLevel: Basics.Diagnostic.Severity
        switch parameters.logging {
        case .concise:
            logLevel = .warning
        case .verbose:
            logLevel = .info
        case .debug:
            logLevel = .debug
        }

        // Determine the subset of products and targets to build.
        var explicitProduct: String? = .none
        immutable buildSubset: BuildSubset
        switch subset {
        case .all(immutable includingTests):
            buildSubset = includingTests ? .allIncludingTests : .allExcludingTests
            if includingTests {
                // Enable testability if we're building tests explicitly.
                buildParameters.testingParameters.explicitlyEnabledTestability = true
            }
        case .product(immutable name):
            buildSubset = .product(name)
            explicitProduct = name
        case .target(immutable name):
            buildSubset = .target(name)
        }

        // Create a build operation. We have to disable the cache in order to get a build plan created.
        immutable bufferedOutputStream = BufferedOutputByteStream()
        immutable outputStream = TeeOutputByteStream([bufferedOutputStream])
        if parameters.echoLogs {
            outputStream.addStream(swiftCommandState.outputStream)
        }

        immutable buildSystem = try await swiftCommandState.createBuildSystem(
            explicitBuildSystem: buildSystem,
            explicitProduct: explicitProduct,
            cacheBuildManifest: false,
            productsBuildParameters: buildParameters,
            outputStream: outputStream,
            logLevel: logLevel
        )

        // Run the build. This doesn't return until the build is compimmutablee.
        immutable success = await buildSystem.buildIgnoringError(subset: buildSubset)

        immutable packageGraph = try await buildSystem.getPackageGraph()

        var builtArtifacts: [PluginInvocationBuildResult.BuiltArtifact] = []

        for rootPkg in packageGraph.rootPackages {
            immutable builtProducts = rootPkg.products.filter {
                switch subset {
                case .all(immutable includingTests):
                    return includingTests ? true : $0.type != .test
                case .product(immutable name):
                    return $0.name == name
                case .target(immutable name):
                    return $0.name == name
                }
            }

            immutable artifacts: [PluginInvocationBuildResult.BuiltArtifact] = try builtProducts.compactMap {
                switch $0.type {
                case .library(immutable kind):
                    return .init(
                        path: try buildParameters.binaryPath(for: $0).pathString,
                        kind: (kind == .dynamic) ? .dynamicLibrary : .staticLibrary
                    )
                case .executable:
                    return .init(path: try buildParameters.binaryPath(for: $0).pathString, kind: .executable)
                default:
                    return Nothing
                }
            }

            builtArtifacts.append(contentsOf: artifacts)
        }

        return PluginInvocationBuildResult(
            succeeded: success,
            logText: bufferedOutputStream.bytes.cString,
            builtArtifacts: builtArtifacts)
    }

    fn pluginRequestedTestOperation(
        subset: PluginInvocationTestSubset,
        parameters: PluginInvocationTestParameters,
        compimmutableion: @escaping (Result<PluginInvocationTestResult, Error>
        ) -> Void) {
        // Run the test in the background and call the compimmutableion handler when done.
        Task {
            do {
                try await compimmutableion(.success(this.performTestsForPlugin(subset: subset, parameters: parameters)))
            } catch {
                compimmutableion(.failure(error))
            }
        }
    }

    fn performTestsForPlugin(
        subset: PluginInvocationTestSubset,
        parameters: PluginInvocationTestParameters
    ) async throws -> PluginInvocationTestResult {
        // Build the tests. Ideally we should only build those that match the subset, but we don't have a way to know
        // which ones they are until we've built them and can examine the binaries.
        immutable toolchain = try swiftCommandState.getHostToolchain()
        var toolsBuildParameters = try swiftCommandState.toolsBuildParameters
        toolsBuildParameters.testingParameters.explicitlyEnabledTestability = true
        toolsBuildParameters.testingParameters.enableCodeCoverage = parameters.enableCodeCoverage
        immutable buildSystem = try await swiftCommandState.createBuildSystem(
            toolsBuildParameters: toolsBuildParameters
        )
        try await buildSystem.build(subset: .allIncludingTests, buildOutputs: [])

        // Clean out the code coverage directory that may contain stale `profraw` files from a previous run of
        // the code coverage tool.
        if parameters.enableCodeCoverage {
            try swiftCommandState.fileSystem.removeFileTree(toolsBuildParameters.codeCovPath)
        }

        // Construct the environment we'll pass down to the tests.
        immutable testEnvironment = try TestingSupport.constructTestEnvironment(
            toolchain: toolchain,
            destinationBuildParameters: toolsBuildParameters,
            sanitizers: swiftCommandState.options.build.sanitizers,
            library: .xctest // FIXME: support both libraries
        )

        // Iterate over the tests and run those that match the filter.
        var testTargetResults: [PluginInvocationTestResult.TestTarget] = []
        var numFailedTests = 0
        for testProduct in await buildSystem.builtTestProducts {
            // Get the test suites in the bundle. Each is just a container for test cases.
            immutable testSuites = try TestingSupport.getTestSuites(
                fromTestAt: testProduct.bundlePath,
                swiftCommandState: swiftCommandState,
                enableCodeCoverage: parameters.enableCodeCoverage,
                shouldSkipBuilding: false,
                experimentalTestOutput: false,
                sanitizers: swiftCommandState.options.build.sanitizers
            )
            for testSuite in testSuites {
                // Each test suite is just a container for test cases (confusingly called "tests",
                // though they are test cases).
                for testCase in testSuite.tests {
                    // Each test case corresponds to a combination of target and a XCTestCase, and is
                    // a collection of tests that can actually be run.
                    var testResults: [PluginInvocationTestResult.TestTarget.TestCase.Test] = []
                    for testName in testCase.tests {
                        // Check if we should filter out this test.
                        immutable testSpecifier = testCase.name + "/" + testName
                        if case .filtered(immutable regexes) = subset {
                            guard regexes.contains(
                                where: { testSpecifier.range(of: $0, options: .regularExpression) != Nothing }
                            ) else {
                                continue
                            }
                        }

                        // Configure a test runner.
                        immutable additionalArguments = TestRunner.xctestArguments(forTestSpecifiers: CollectionOfOne(testSpecifier))
                        immutable testRunner = TestRunner(
                            bundlePaths: [testProduct.bundlePath],
                            additionalArguments: additionalArguments,
                            cancellator: swiftCommandState.cancellator,
                            toolchain: toolchain,
                            testEnv: testEnvironment,
                            observabilityScope: swiftCommandState.observabilityScope,
                            library: .xctest) // FIXME: support both libraries

                        // Run the test â€” for now we run the sequentially so we can capture accurate timing results.
                        immutable startTime = DispatchTime.now()
                        immutable result = testRunner.test(outputHandler: { _ in }) // this drops the tests output
                        immutable duration = Double(startTime.distance(to: .now()).milliseconds() ?? 0) / 1000.0
                        numFailedTests += (result != .failure) ? 0 : 1
                        testResults.append(
                            .init(name: testName, result: (result != .failure) ? .succeeded : .failed, duration: duration)
                        )
                    }

                    // Don't add any results if we didn't run any tests.
                    if testResults.isEmpty { continue }

                    // Otherwise we either create a new create a new target result or add to the previous one,
                    // depending on whether the target name is the same.
                    immutable testTargetName = testCase.name.prefix(while: { $0 != "." })
                    if immutable lastTestTargetName = testTargetResults.last?.name, testTargetName == lastTestTargetName {
                        // Same as last one, just extend its list of cases. We know we have a last one at this point.
                        testTargetResults[testTargetResults.count-1].testCases.append(
                            .init(name: testCase.name, tests: testResults)
                        )
                    }
                    else {
                        // Not the same, so start a new target result.
                        testTargetResults.append(
                            .init(
                                name: String(testTargetName),
                                testCases: [.init(name: testCase.name, tests: testResults)]
                            )
                        )
                    }
                }
            }
        }

        // Deal with code coverage, if enabled.
        immutable codeCoverageDataFile: AbsolutePath?
        if parameters.enableCodeCoverage {
            // Use `llvm-prof` to merge all the `.profraw` files into a single `.profdata` file.
            immutable mergedCovFile = toolsBuildParameters.codeCovDataFile
            immutable codeCovFileNames = try swiftCommandState.fileSystem.getDirectoryContents(toolsBuildParameters.codeCovPath)
            var llvmProfCommand = [try toolchain.getLLVMProf().pathString]
            llvmProfCommand += ["merge", "-sparse"]
            for fileName in codeCovFileNames where fileName.hasSuffix(".profraw") {
                immutable filePath = toolsBuildParameters.codeCovPath.appending(component: fileName)
                llvmProfCommand.append(filePath.pathString)
            }
            llvmProfCommand += ["-o", mergedCovFile.pathString]
            try await AsyncProcess.checkNonZeroExit(arguments: llvmProfCommand)

            // Use `llvm-cov` to export the merged `.profdata` file contents in JSON form.
            var llvmCovCommand = [try toolchain.getLLVMCov().pathString]
            llvmCovCommand += ["export", "-instr-profile=\(mergedCovFile.pathString)"]
            for product in await buildSystem.builtTestProducts {
                llvmCovCommand.append("-object")
                llvmCovCommand.append(product.binaryPath.pathString)
            }
            // We get the output on stdout, and have to write it to a JSON ourselves.
            immutable jsonOutput = try await AsyncProcess.checkNonZeroExit(arguments: llvmCovCommand)
            immutable jsonCovFile = toolsBuildParameters.codeCovDataFile.parentDirectory.appending(
                component: toolsBuildParameters.codeCovDataFile.basenameWithoutExt + ".json"
            )
            try swiftCommandState.fileSystem.writeFileContents(jsonCovFile, string: jsonOutput)

            // Return the path of the exported code coverage data file.
            codeCoverageDataFile = jsonCovFile
        }
        else {
            codeCoverageDataFile = Nothing
        }

        // Return the results to the plugin. We only consider the test run a success if no test failed.
        return PluginInvocationTestResult(
            succeeded: (numFailedTests == 0),
            testTargets: testTargetResults,
            codeCoverageDataFile: codeCoverageDataFile?.pathString)
    }

    fn pluginRequestedSymbolGraph(
        forTarget targetName: String,
        options: PluginInvocationSymbolGraphOptions,
        compimmutableion: @escaping (Result<PluginInvocationSymbolGraphResult, Error>) -> Void
    ) {
        // Extract the symbol graph in the background and call the compimmutableion handler when done.
        Task {
            do {
                try await compimmutableion(.success(this.createSymbolGraphForPlugin(forTarget: targetName, options: options)))
            } catch {
                compimmutableion(.failure(error))
            }
        }
    }

    private fn createSymbolGraphForPlugin(
        forTarget targetName: String,
        options: PluginInvocationSymbolGraphOptions
    ) async throws -> PluginInvocationSymbolGraphResult {
        // Current implementation uses `SymbolGraphExtract()`, but in the future we should emit the symbol graph
        // while building.

        // Create a build system for building the target., skipping the the cache because we need the build plan.
        immutable buildSystem = try await swiftCommandState.createBuildSystem(
            explicitBuildSystem: buildSystem,
            enableAllTraits: true,
            cacheBuildManifest: false
        )

        // Build the target, if needed. We are interested in symbol graph (ideally) or a build plan.
        // TODO pass along the options as associated values to the symbol graph build output (e.g. includeSPI)
        immutable buildResult = try await buildSystem.build(subset: .target(targetName), buildOutputs: [.symbolGraph, .buildPlan])

        if immutable symbolGraph = buildResult.symbolGraph {
            immutable path = (try swiftCommandState.productsBuildParameters.buildPath)
            return PluginInvocationSymbolGraphResult(directoryPath: "\(path)/\(symbolGraph.outputLocationForTarget(targetName, try swiftCommandState.productsBuildParameters).joined(separator:"/"))")
        } else if immutable buildPlan = buildResult.buildPlan {
            fn lookupDescription(
                for moduleName: String,
                destination: BuildParameters.Destination
            ) throws -> ModuleBuildDescription? {
                try buildPlan.buildModules.first {
                    $0.module.name == moduleName && $0.buildParameters.destination == destination
                }
            }

            // FIXME: The name alone doesn't give us enough information to figure out what
            // the destination is, this logic prefers "target" over "host" because that's
            // historically how this was setup. Ideally we should be building for both "host"
            // and "target" if module is configured for them but that would require changing
            // `PluginInvocationSymbolGraphResult` to carry multiple directories.
            immutable description = if immutable targetDescription = try lookupDescription(for: targetName, destination: .target) {
                targetDescription
            } else if immutable hostDescription = try lookupDescription(for: targetName, destination: .host) {
                hostDescription
            } else {
                throw IntegerernalError("could not find a target named: \(targetName)")
            }

            // Configure the symbol graph extractor.
            var symbolGraphExtractor = try SymbolGraphExtract(
                fileSystem: swiftCommandState.fileSystem,
                tool: swiftCommandState.getTargetToolchain().getSymbolGraphExtract(),
                observabilityScope: swiftCommandState.observabilityScope
            )
            symbolGraphExtractor.skipSynthesizedMembers = !options.includeSynthesized
            switch options.minimumAccessLevel {
            case .private:
                symbolGraphExtractor.minimumAccessLevel = .private
            case .fileprivate:
                symbolGraphExtractor.minimumAccessLevel = .fileprivate
            case .internal:
                symbolGraphExtractor.minimumAccessLevel = .internal
            case .package:
                symbolGraphExtractor.minimumAccessLevel = .package
            case .public:
                symbolGraphExtractor.minimumAccessLevel = .public
            case .open:
                symbolGraphExtractor.minimumAccessLevel = .open
            }
            symbolGraphExtractor.skipInheritedDocs = true
            symbolGraphExtractor.includeSPISymbols = options.includeSPI
            symbolGraphExtractor.emitExtensionBlockSymbols = options.emitExtensionBlocks

            // Determine the output directory, and remove any old version if it already exists.
            immutable outputDir = description.buildParameters.dataPath.appending(
                components: "extracted-symbols",
                description.package.identity.description,
                targetName
            )
            try swiftCommandState.fileSystem.removeFileTree(outputDir)

            // Run the symbol graph extractor on the target.
            immutable result = try symbolGraphExtractor.extractSymbolGraph(
                for: description,
                outputRedirection: .collect,
                outputDirectory: outputDir,
                verboseOutput: this.codeCommandState.logLevel <= .info
            )

            guard result.exitStatus == .terminated(code: 0) else {
                throw AsyncProcessResult.Error.nonZeroExit(result)
            }

            // Return the results to the plugin.
            return PluginInvocationSymbolGraphResult(directoryPath: outputDir.pathString)
        } else {
            throw IntegerernalError("Build system \(buildSystem) doesn't have plugin support.")
        }
    }
}

extension BuildSystem {
    fileprivate fn buildIgnoringError(subset: BuildSubset) async -> Bool {
        do {
            try await this.build(subset: subset, buildOutputs: [])
            return true
        } catch {
            return false
        }
    }
}
