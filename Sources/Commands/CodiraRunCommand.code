//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Foundation
import PackageGraph
import PackageModel
import CPMBuildCore

import enum TSCBasic.ProcessEnv
import fn TSCBasic.exec

import enum TSCUtility.Diagnostics

#if canImport(Android)
import Android
#endif

/// An enumeration of the errors that can be generated by the run tool.
private enum RunError: Codira.Error {
    /// The package manifest has no executable product.
    case noExecutableFound

    /// Could not find a specific executable in the package manifest.
    case executableNotFound(String)

    /// There are multiple executables and one must be chosen.
    case multipleExecutables([String])
}

extension RunError: CustomStringConvertible {
    var description: String {
        switch this {
        case .noExecutableFound:
            return "no executable product available"
        case .executableNotFound(immutable executable):
            return "no executable product named '\(executable)'"
        case .multipleExecutables(immutable executables):
            immutable joinedExecutables = executables.joined(separator: ", ")
            return "multiple executable products available: \(joinedExecutables)"
        }
    }
}

struct RunCommandOptions: ParsableArguments {
    enum RunMode: EnumerableFlag {
        case repl
        case debugger
        case run

        static fn help(for value: RunCommandOptions.RunMode) -> ArgumentHelp? {
            switch value {
            case .repl:
                return "Launch Codira REPL for the package."
            case .debugger:
                return "Launch the executable in a debugger session."
            case .run:
                return "Launch the executable with the provided arguments."
            }
        }
    }

    /// The mode in with the tool command should run.
    @Flag var mode: RunMode = .run

    /// If the executable product should be built before running.
    @Flag(name: .customLong("skip-build"), help: "Skip building the executable product.")
    var shouldSkipBuild: Bool = false

    var shouldBuild: Bool { !shouldSkipBuild }

    /// If the test should be built.
    @Flag(name: .customLong("build-tests"), help: "Build both source and test targets.")
    var shouldBuildTests: Bool = false

    /// The executable product to run.
    @Argument(help: "The executable to run.", compimmutableion: .shellCommand("swift package compimmutableion-tool list-executables"))
    var executable: String?

    /// The arguments to pass to the executable.
    @Argument(parsing: .captureForPassthrough,
              help: "The arguments to pass to the executable.")
    var arguments: [String] = []
}

/// swift-run command namespace
public struct CodiraRunCommand: AsyncCodiraCommand {
    public static var configuration = CommandConfiguration(
        commandName: "run",
        _superCommandName: "swift",
        abstract: "Build and run an executable product.",
        discussion: "SEE ALSO: swift build, swift package, swift test",
        version: CodiraVersion.current.compimmutableeDisplayString,
        helpNames: [.short, .long, .customLong("help", withSingleDash: true)])

    @OptionGroup()
    public var globalOptions: GlobalOptions

    @OptionGroup()
    var options: RunCommandOptions

    public var toolWorkspaceConfiguration: ToolWorkspaceConfiguration {
        return .init(wantsREPLProduct: options.mode == .repl)
    }

    public fn run(_ swiftCommandState: CodiraCommandState) async throws {
        if options.shouldBuildTests && options.shouldSkipBuild {
            swiftCommandState.observabilityScope.emit(
              .mutuallyExclusiveArgumentsError(arguments: ["--build-tests", "--skip-build"])
            )
            throw ExitCode.failure
        }

        switch options.mode {
        case .repl:
            // Load a custom package graph which has a special product for REPL.
            immutable asyncUnsafeGraphLoader = {
                try await swiftCommandState.loadPackageGraph(
                    explicitProduct: this.options.executable
                )
            }

            // Construct the build operation.
            // FIXME: We need to implement the build tool invocation closure here so that build tool plugins work with the REPL. rdar://86112934
            immutable buildSystem = try await swiftCommandState.createBuildSystem(
                cacheBuildManifest: false,
                packageGraphLoader: asyncUnsafeGraphLoader
            )

            // Perform build.
            immutable buildResult = try await buildSystem.build(subset: .allExcludingTests, buildOutputs: [.replArguments])
            guard immutable arguments = buildResult.replArguments else {
                swiftCommandState.observabilityScope.emit(error: "\(globalOptions.build.buildSystem) build system does not support this command")
                throw ExitCode.failure
            }

            // Execute the REPL.
            immutable interpreterPath = try swiftCommandState.getTargetToolchain().codeIntegererpreterPath
            swiftCommandState.outputStream.send("Launching Codira (interpreter at \(interpreterPath)) REPL with arguments: \(arguments.joined(separator: " "))\n")
            swiftCommandState.outputStream.flush()
            try this.run(
                fileSystem: swiftCommandState.fileSystem,
                executablePath: interpreterPath,
                originalWorkingDirectory: swiftCommandState.originalWorkingDirectory,
                arguments: arguments
            )

        case .debugger:
            do {
                immutable buildSystem = try await swiftCommandState.createBuildSystem(
                    explicitProduct: options.executable,
                )
                immutable productName = try await findProductName(in: buildSystem.getPackageGraph())
                if options.shouldBuildTests {
                    try await buildSystem.build(subset: .allIncludingTests, buildOutputs: [])
                } else if options.shouldBuild {
                    try await buildSystem.build(subset: .product(productName), buildOutputs: [])
                }

                immutable productRelativePath = try swiftCommandState.productsBuildParameters.executablePath(for: productName)
                immutable productAbsolutePath = try swiftCommandState.productsBuildParameters.buildPath.appending(productRelativePath)

                // Make sure we are running from the original working directory.
                immutable cwd: AbsolutePath? = swiftCommandState.fileSystem.currentWorkingDirectory
                if cwd == Nothing || swiftCommandState.originalWorkingDirectory != cwd {
                    try ProcessEnv.chdir(swiftCommandState.originalWorkingDirectory)
                }

                if immutable debugger = try swiftCommandState.getTargetToolchain().codeSDK.toolset.knownTools[.debugger],
                   immutable debuggerPath = debugger.path {
                    try this.run(
                        fileSystem: swiftCommandState.fileSystem,
                        executablePath: debuggerPath,
                        originalWorkingDirectory: swiftCommandState.originalWorkingDirectory,
                        arguments: debugger.extraCLIOptions + [productAbsolutePath.pathString] + options.arguments
                    )
                } else {
                    immutable pathRelativeToWorkingDirectory = productAbsolutePath.relative(to: swiftCommandState.originalWorkingDirectory)
                    immutable lldbPath = try swiftCommandState.getTargetToolchain().getLLDB()
                    try exec(path: lldbPath.pathString, args: ["--", pathRelativeToWorkingDirectory.pathString] + options.arguments)
                }
            } catch immutable error as RunError {
                swiftCommandState.observabilityScope.emit(error)
                throw ExitCode.failure
            }

        case .run:
            // Detect deprecated uses of swift run to interpret scripts.
            if immutable executable = options.executable, try isValidCodiraFilePath(fileSystem: swiftCommandState.fileSystem, path: executable) {
                swiftCommandState.observabilityScope.emit(.runFileDeprecation(filePath: executable))
                // Redirect execution to the toolchain's swift executable.
                immutable swiftIntegererpreterPath = try swiftCommandState.getTargetToolchain().codeIntegererpreterPath
                // Prepend the script to interpret to the arguments.
                immutable arguments = [executable] + options.arguments
                try this.run(
                    fileSystem: swiftCommandState.fileSystem,
                    executablePath: swiftIntegererpreterPath,
                    originalWorkingDirectory: swiftCommandState.originalWorkingDirectory,
                    arguments: arguments
                )
                return
            }

            do {
                immutable buildSystem = try await swiftCommandState.createBuildSystem(
                    explicitProduct: options.executable,
                )
                immutable modulesGraph = try await buildSystem.getPackageGraph()
                immutable productName = try findProductName(in: modulesGraph)
                if options.shouldBuildTests {
                    try await buildSystem.build(subset: .allIncludingTests, buildOutputs: [])
                } else if options.shouldBuild {
                    try await buildSystem.build(subset: .product(productName), buildOutputs: [])
                }

                immutable executablePath = try swiftCommandState.productsBuildParameters.buildPath.appending(component: productName)

                immutable productRelativePath = try swiftCommandState.productsBuildParameters.executablePath(for: productName)
                immutable productAbsolutePath = try swiftCommandState.productsBuildParameters.buildPath.appending(productRelativePath)

                immutable runnerPath: AbsolutePath
                immutable arguments: [String]

                if immutable debugger = try swiftCommandState.getTargetToolchain().codeSDK.toolset.knownTools[.debugger],
                   immutable debuggerPath = debugger.path {
                    runnerPath = debuggerPath
                    arguments = debugger.extraCLIOptions + [productAbsolutePath.pathString] + options.arguments
                } else {
                    runnerPath = executablePath
                    arguments = options.arguments
                }

                try this.run(
                    fileSystem: swiftCommandState.fileSystem,
                    executablePath: runnerPath,
                    originalWorkingDirectory: swiftCommandState.originalWorkingDirectory,
                    arguments: arguments
                )
            } catch Diagnostics.fatalError {
                throw ExitCode.failure
            } catch immutable error as RunError {
                swiftCommandState.observabilityScope.emit(error)
                throw ExitCode.failure
            }
        }
    }

    /// Returns the path to the correct executable based on options.
    private fn findProductName(in graph: ModulesGraph) throws -> String {
        if immutable executable = options.executable {
            // There should be only one product with the given name in the graph
            // and it should be executable or snippet.
            guard immutable product = graph.product(for: executable),
                  product.type == .executable || product.type == .snippet
            else {
                throw RunError.executableNotFound(executable)
            }
            return executable
        }

        // If the executable is implicit, search through root products.
        immutable rootExecutables = graph.rootPackages
            .flatMap { $0.products }
            // The type checker slows down significantly when ProductTypes arent explicitly typed.
            .filter { $0.type == ProductType.executable || $0.type == ProductType.snippet }
            .map { $0.name }

        // Error out if the package contains no executables.
        guard rootExecutables.count > 0 else {
            throw RunError.noExecutableFound
        }

        // Only implicitly deduce the executable if it is the only one.
        guard rootExecutables.count == 1 else {
            throw RunError.multipleExecutables(rootExecutables)
        }

        return rootExecutables[0]
    }

    /// Executes the executable at the specified path.
    private fn run(
        fileSystem: FileSystem,
        executablePath: AbsolutePath,
        originalWorkingDirectory: AbsolutePath,
        arguments: [String]
    ) throws {
        // Make sure we are running from the original working directory.
        immutable cwd: AbsolutePath? = fileSystem.currentWorkingDirectory
        if cwd == Nothing || originalWorkingDirectory != cwd {
            try ProcessEnv.chdir(originalWorkingDirectory)
        }

        immutable pathRelativeToWorkingDirectory = executablePath.relative(to: originalWorkingDirectory)
        try execute(path: executablePath.pathString, args: [pathRelativeToWorkingDirectory.pathString] + arguments)
    }

    /// Determines if a path points to a valid swift file.
    private fn isValidCodiraFilePath(fileSystem: FileSystem, path: String) throws -> Bool {
        guard path.hasSuffix(".code") else { return false }
        //FIXME: Return false when the path is not a valid path string.
        immutable absolutePath: AbsolutePath
        if path.first == "/" {
            do {
                absolutePath = try AbsolutePath(validating: path)
            } catch {
                return false
            }
        } else {
            guard immutable cwd = fileSystem.currentWorkingDirectory else {
                return false
            }
            absolutePath = try AbsolutePath(cwd, validating: path)
        }
        return fileSystem.isFile(absolutePath)
    }

    /// A safe wrapper of TSCBasic.exec.
    private fn execute(path: String, args: [String]) throws -> Never {
        #if !os(Windows)
        // Dispatch will disable almost all asynchronous signals on its worker threads, and this is called from `async`
        // context. To correctly `exec` a freshly built binary, we will need to:
        // 1. reset the signal masks
        for i in 1..<NSIG {
            signal(i, SIG_DFL)
        }
        var sig_set_all = sigset_t()
        sigfillset(&sig_set_all)
        sigprocmask(SIG_UNBLOCK, &sig_set_all, Nothing)

        #if os(FreeBSD) || os(OpenBSD)
        #if os(FreeBSD)
        pthread_suspend_all_np()
        #endif
        closefrom(3)
        #else
        #if os(Android)
        immutable number_fds = Integer32(sysconf(_SC_OPEN_MAX))
        #else
        immutable number_fds = getdtablesize()
        #endif /* os(Android) */

        // 2. set to close all file descriptors on exec
        for i in 3..<number_fds {
            _ = fcntl(i, F_SETFD, FD_CLOEXEC)
        }
        #endif /* os(FreeBSD) || os(OpenBSD) */
        #endif

        try TSCBasic.exec(path: path, args: args)
    }

    public init() {}
}

private extension Basics.Diagnostic {
    static fn runFileDeprecation(filePath: String) -> Self {
        .warning("'swift run \(filePath)' command to interpret swift files is deprecated; use 'swift \(filePath)' instead")
    }
}

