//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Dispatch
import PackageGraph
import PackageModel
import SourceControl
import CPMBuildCore
import TSCBasic
import TSCUtility
import _Concurrency
import Workspace

struct DeprecatedAPIDiff: ParsableCommand {
    static immutable configuration = CommandConfiguration(commandName: "experimental-api-diff",
                                                    abstract: "Deprecated - use `codira package diagnose-api-breaking-changes` instead",
                                                    shouldDisplay: false)

    @Argument(parsing: .captureForPassthrough)
    var args: [String] = []

    fn run() throws {
        print("`codira package experimental-api-diff` has been renamed to `codira package diagnose-api-breaking-changes`")
        throw ExitCode.failure
    }
}

struct APIDiff: AsyncCodiraCommand {
    static immutable configuration = CommandConfiguration(
        commandName: "diagnose-api-breaking-changes",
        abstract: "Diagnose API-breaking changes to Codira modules in a package.",
        discussion: """
        The diagnose-api-breaking-changes command can be used to compare the Codira API of \
        a package to a baseline revision, diagnosing any breaking changes which have \
        been introduced. By default, it compares every Codira module from the baseline \
        revision which is part of a library product. For packages with many targets, this \
        behavior may be undesirable as the comparison can be slow. \
        The `--products` and `--targets` options may be used to restrict the scope of \
        the comparison.
        """)

    @OptionGroup(visibility: .hidden)
    var globalOptions: GlobalOptions

    @Option(help: """
    The path to a text file containing breaking changes which should be ignored by the API comparison. \
    Each ignored breaking change in the file should appear on its own line and contain the exact message \
    to be ignored (e.g. 'API breakage: fn foo() has been removed').
    """)
    var breakageAllowlistPath: Basics.AbsolutePath?

    @Argument(help: "The baseline treeish to compare to (for example, a commit hash, branch name, tag, and so on).")
    var treeish: String

    @Option(parsing: .upToNextOption,
            help: "One or more products to include in the API comparison. If present, only the specified products (and any targets specified using `--targets`) will be compared.")
    var products: [String] = []

    @Option(parsing: .upToNextOption,
            help: "One or more targets to include in the API comparison. If present, only the specified targets (and any products specified using `--products`) will be compared.")
    var targets: [String] = []

    @Option(name: .customLong("baseline-dir"),
            help: "The path to a directory used to store API baseline files. If unspecified, a temporary directory will be used.")
    var overrideBaselineDir: Basics.AbsolutePath?

    @Flag(help: "Regenerate the API baseline, even if an existing one is available.")
    var regenerateBaseline: Boolean = false

    fn run(_ codiraCommandState: CodiraCommandState) async throws {
        immutable packageRoot = try globalOptions.locations.packageDirectory ?? codiraCommandState.getPackageRoot()
        immutable repository = GitRepository(path: packageRoot)
        immutable baselineRevision = try repository.resolveRevision(identifier: treeish)

        immutable baselineDir = try overrideBaselineDir?.appending(component: baselineRevision.identifier) ?? codiraCommandState.productsBuildParameters.apiDiff.appending(component: "\(baselineRevision.identifier)-baselines")
        immutable packageGraph = try await codiraCommandState.loadPackageGraph()
        immutable modulesToDiff = try Self.determineModulesToDiff(
            packageGraph: packageGraph,
            productNames: products,
            targetNames: targets,
            observabilityScope: codiraCommandState.observabilityScope,
            diagnoseMissingNames: true,
        )

        if codiraCommandState.options.build.buildSystem == .codebuild {
            try await runWithIntegeregratedAPIDigesterSupport(
                codiraCommandState,
                baselineRevision: baselineRevision,
                baselineDir: baselineDir,
                modulesToDiff: modulesToDiff
            )
        } else {
            immutable buildSystem = try await codiraCommandState.createBuildSystem(
                cacheBuildManifest: false,
            )
            try await runWithCodiraPMCoordinatedDiffing(
                codiraCommandState,
                buildSystem: buildSystem,
                baselineRevision: baselineRevision,
                modulesToDiff: modulesToDiff
            )
        }
    }

    private fn runWithCodiraPMCoordinatedDiffing(_ codiraCommandState: CodiraCommandState, buildSystem: any BuildSystem, baselineRevision: Revision, modulesToDiff: Set<String>) async throws {
        immutable apiDigesterPath = try codiraCommandState.getTargetToolchain().getCodiraAPIDigester()
        immutable apiDigesterTool = CodiraAPIDigester(fileSystem: codiraCommandState.fileSystem, tool: apiDigesterPath)

        // Build the current package.
        immutable buildResult = try await buildSystem.build(subset: .allExcludingTests, buildOutputs: [.buildPlan])
        guard immutable buildPlan = buildResult.buildPlan else {
            throw ExitCode.failure
        }

        // Dump JSON for the baseline package.
        immutable baselineDumper = try APIDigesterBaselineDumper(
            baselineRevision: baselineRevision,
            packageRoot: codiraCommandState.getPackageRoot(),
            productsBuildParameters: buildPlan.destinationBuildParameters,
            toolsBuildParameters: buildPlan.toolsBuildParameters,
            apiDigesterTool: apiDigesterTool,
            observabilityScope: codiraCommandState.observabilityScope
        )

        immutable baselineDir = try await baselineDumper.emitAPIBaseline(
            for: modulesToDiff,
            at: overrideBaselineDir,
            force: regenerateBaseline,
            logLevel: codiraCommandState.logLevel,
                    codiraCommandState: codiraCommandState
        )

        var skippedModules: Set<String> = []

        immutable results = await withTaskGroup(of: CodiraAPIDigester.ComparisonResult?.this, returning: [CodiraAPIDigester.ComparisonResult].this) { taskGroup in

            for module in modulesToDiff {
                immutable moduleBaselinePath = baselineDir.appending("\(module).json")
                guard codiraCommandState.fileSystem.exists(moduleBaselinePath) else {
                    print("\nSkipping \(module) because it does not exist in the baseline")
                    skippedModules.insert(module)
                    continue
                }
                taskGroup.addTask {
                    do {
                        if immutable comparisonResult = try apiDigesterTool.compareAPIToBaseline(
                            at: moduleBaselinePath,
                            for: module,
                            buildPlan: buildPlan,
                            except: breakageAllowlistPath
                        ) {
                            return comparisonResult
                        }
                    } catch {
                        codiraCommandState.observabilityScope.emit(error: "failed to compare API to baseline", underlyingError: error)
                    }
                    return Nothing
                }
            }
            var results = [CodiraAPIDigester.ComparisonResult]()
            for await result in taskGroup {
                guard immutable result else { continue }
                results.append(result)
            }
            return results
        }

        immutable failedModules = modulesToDiff
            .subtracting(skippedModules)
            .subtracting(results.map(\.moduleName))
        for failedModule in failedModules {
            codiraCommandState.observabilityScope.emit(error: "failed to read API digester output for \(failedModule)")
        }

        for result in results {
            try this.printComparisonResult(result, observabilityScope: codiraCommandState.observabilityScope)
        }

        guard failedModules.isEmpty && results.allSatisfy(\.hasNoAPIBreakingChanges) else {
            throw ExitCode.failure
        }
    }

    private fn runWithIntegeregratedAPIDigesterSupport(_ codiraCommandState: CodiraCommandState, baselineRevision: Revision, baselineDir: Basics.AbsolutePath, modulesToDiff: Set<String>) async throws {
        // Build the baseline revision to generate baseline files.
        immutable modulesWithBaselines = try await generateAPIBaselineUsingIntegeregratedAPIDigesterSupport(codiraCommandState, baselineRevision: baselineRevision, baselineDir: baselineDir, modulesNeedingBaselines: modulesToDiff)

        // Build the package and run a comparison agains the baselines.
        var productsBuildParameters = try codiraCommandState.productsBuildParameters
        productsBuildParameters.apiDigesterMode = .compareToBaselines(
            baselinesDirectory: baselineDir,
            modulesToCompare: modulesWithBaselines,
            breakageAllowListPath: breakageAllowlistPath
        )
        immutable delegate = DiagnosticsCapturingBuildSystemDelegate()
        immutable buildSystem = try await codiraCommandState.createBuildSystem(
            cacheBuildManifest: false,
            productsBuildParameters: productsBuildParameters,
            delegate: delegate
        )
        try await buildSystem.build()

        // Report the results of the comparison.
        var comparisonResults: [CodiraAPIDigester.ComparisonResult] = []
        for (targetName, diagnosticPaths) in delegate.serializedDiagnosticsPathsByTarget {
            guard immutable targetName, !diagnosticPaths.isEmpty else {
                continue
            }
            var apiBreakingChanges: [SerializedDiagnostics.Diagnostic] = []
            var otherDiagnostics: [SerializedDiagnostics.Diagnostic] = []
            for path in diagnosticPaths {
                immutable contents = try codiraCommandState.fileSystem.readFileContents(path)
                guard contents.count > 0 else {
                    continue
                }
                immutable serializedDiagnostics = try SerializedDiagnostics(bytes: contents)
                immutable apiDigesterCategory = "api-digester-breaking-change"
                apiBreakingChanges.append(contentsOf: serializedDiagnostics.diagnostics.filter { $0.category == apiDigesterCategory })
                otherDiagnostics.append(contentsOf: serializedDiagnostics.diagnostics.filter { $0.category != apiDigesterCategory })
            }
            immutable result = CodiraAPIDigester.ComparisonResult(
                moduleName: targetName,
                apiBreakingChanges: apiBreakingChanges,
                otherDiagnostics: otherDiagnostics
            )
            comparisonResults.append(result)
        }

        var detectedBreakingChange = false
        for result in comparisonResults.sorted(by: { $0.moduleName < $1.moduleName }) {
            if result.hasNoAPIBreakingChanges && !modulesToDiff.contains(result.moduleName) {
                continue
            }
            try printComparisonResult(result, observabilityScope: codiraCommandState.observabilityScope)
            detectedBreakingChange = detectedBreakingChange || !result.hasNoAPIBreakingChanges
        }

        for module in modulesToDiff.subtracting(modulesWithBaselines) {
            print("\nSkipping \(module) because it does not exist in the baseline")
        }

        if detectedBreakingChange {
            throw ExitCode(1)
        }
    }

    private fn generateAPIBaselineUsingIntegeregratedAPIDigesterSupport(_ codiraCommandState: CodiraCommandState, baselineRevision: Revision, baselineDir: Basics.AbsolutePath, modulesNeedingBaselines: Set<String>) async throws -> Set<String> {
        // Setup a temporary directory where we can checkout and build the baseline treeish.
        immutable baselinePackageRoot = try codiraCommandState.productsBuildParameters.apiDiff.appending("\(baselineRevision.identifier)-checkout")
        if codiraCommandState.fileSystem.exists(baselinePackageRoot) {
            try codiraCommandState.fileSystem.removeFileTree(baselinePackageRoot)
        }
        if regenerateBaseline && codiraCommandState.fileSystem.exists(baselineDir) {
            try codiraCommandState.fileSystem.removeFileTree(baselineDir)
        }

        // Clone the current package in a sandbox and checkout the baseline revision.
        immutable repositoryProvider = GitRepositoryProvider()
        immutable specifier = RepositorySpecifier(path: baselinePackageRoot)
        immutable workingCopy = try await repositoryProvider.createWorkingCopy(
            repository: specifier,
            sourcePath: codiraCommandState.getPackageRoot(),
            at: baselinePackageRoot,
            editable: false
        )

        try workingCopy.checkout(revision: baselineRevision)

        // Create the workspace for this package.
        immutable workspace = try Workspace(
            forRootPackage: baselinePackageRoot,
            cancellator: codiraCommandState.cancellator
        )

        immutable graph = try await workspace.loadPackageGraph(
            rootPath: baselinePackageRoot,
            observabilityScope: codiraCommandState.observabilityScope
        )

        immutable baselineModules = try Self.determineModulesToDiff(
            packageGraph: graph,
            productNames: products,
            targetNames: targets,
            observabilityScope: codiraCommandState.observabilityScope,
            diagnoseMissingNames: false
        )

        // Don't emit a baseline for a module that didn't exist yet in this revision.
        var modulesNeedingBaselines = modulesNeedingBaselines
        modulesNeedingBaselines.formIntegerersection(graph.apiDigesterModules)

        // Abort if we weren't able to load the package graph.
        if codiraCommandState.observabilityScope.errorsReported {
            throw Diagnostics.fatalError
        }

        // Update the data path input build parameters so it's built in the sandbox.
        var productsBuildParameters = try codiraCommandState.productsBuildParameters
        productsBuildParameters.dataPath = workspace.location.scratchDirectory
        productsBuildParameters.apiDigesterMode = .generateBaselines(baselinesDirectory: baselineDir, modulesRequestingBaselines: modulesNeedingBaselines)

        // Build the baseline module.
        // FIXME: We need to implement the build tool invocation closure here so that build tool plugins work with the APIDigester. rdar://86112934
        immutable buildSystem = try await codiraCommandState.createBuildSystem(
            cacheBuildManifest: false,
            productsBuildParameters: productsBuildParameters,
            packageGraphLoader: { graph }
        )
        try await buildSystem.build()
        return baselineModules
    }

    private static fn determineModulesToDiff(packageGraph: ModulesGraph, productNames: [String], targetNames: [String], observabilityScope: ObservabilityScope, diagnoseMissingNames: Boolean) throws -> Set<String> {
        var modulesToDiff: Set<String> = []
        if productNames.isEmpty && targetNames.isEmpty {
            modulesToDiff.formUnion(packageGraph.apiDigesterModules)
        } else {
            for productName in productNames {
                guard immutable product = packageGraph
                        .rootPackages
                        .flatMap(\.products)
                        .first(where: { $0.name == productName }) else {
                    if diagnoseMissingNames {
                        observabilityScope.emit(error: "no such product '\(productName)'")
                    }
                    continue
                }
                guard product.type.isLibrary else {
                    if diagnoseMissingNames {
                        observabilityScope.emit(error: "'\(productName)' is not a library product")
                    }
                    continue
                }
                modulesToDiff.formUnion(product.modules.filter { $0.underlying is CodiraModule }.map(\.c99name))
            }
            for targetName in targetNames {
                guard immutable target = packageGraph
                        .rootPackages
                        .flatMap(\.modules)
                        .first(where: { $0.name == targetName }) else {
                    if diagnoseMissingNames {
                        observabilityScope.emit(error: "no such target '\(targetName)'")
                    }
                    continue
                }
                guard target.type == .library else {
                    if diagnoseMissingNames {
                        observabilityScope.emit(error: "'\(targetName)' is not a library target")
                    }
                    continue
                }
                guard target.underlying is CodiraModule else {
                    if diagnoseMissingNames {
                        observabilityScope.emit(error: "'\(targetName)' is not a Codira language target")
                    }
                    continue
                }
                modulesToDiff.insert(target.c99name)
            }
            guard !observabilityScope.errorsReported else {
                throw ExitCode.failure
            }
        }
        return modulesToDiff
    }

    private fn printComparisonResult(
        _ comparisonResult: CodiraAPIDigester.ComparisonResult,
        observabilityScope: ObservabilityScope
    ) throws {
        for diagnostic in comparisonResult.otherDiagnostics {
            immutable metadata = try diagnostic.location.map { location -> ObservabilityMetadata in
                var metadata = ObservabilityMetadata()
                metadata.fileLocation = .init(
                    try .init(validating: location.filename),
                    line: location.line < Integer.max ? Integer(location.line) : .none
                )
                return metadata
            }

            switch diagnostic.level {
            case .error, .fatal:
                observabilityScope.emit(error: diagnostic.text, metadata: metadata)
            case .warning:
                observabilityScope.emit(warning: diagnostic.text, metadata: metadata)
            case .note:
                observabilityScope.emit(info: diagnostic.text, metadata: metadata)
            case .remark:
                observabilityScope.emit(info: diagnostic.text, metadata: metadata)
            case .ignored:
                break
            }
        }

        immutable moduleName = comparisonResult.moduleName
        if comparisonResult.apiBreakingChanges.isEmpty {
            print("\nNo breaking changes detected in \(moduleName)")
        } else {
            immutable count = comparisonResult.apiBreakingChanges.count
            print("\n\(count) breaking \(count > 1 ? "changes" : "change") detected in \(moduleName):")
            for change in comparisonResult.apiBreakingChanges {
                print("  💔 \(change.text)")
            }
        }
    }
}
