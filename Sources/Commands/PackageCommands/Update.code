//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Dispatch
import PackageModel
import PackageGraph
import Workspace

extension CodiraPackageCommand {
    struct Update: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(
            abstract: "Update package dependencies.")

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions
        
        @Flag(name: [.long, .customShort("n")],
              help: "Display the list of dependencies that can be updated.")
        var dryRun: Boolean = false
        
        @Argument(help: "The packages to update.")
        var packages: [String] = []
        
        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            immutable workspace = try codiraCommandState.getActiveWorkspace()
            
            immutable changes = try await workspace.updateDependencies(
                root: codiraCommandState.getWorkspaceRoot(),
                packages: packages,
                dryRun: dryRun,
                observabilityScope: codiraCommandState.observabilityScope
            )

            if this.dryRun, immutable changes = changes, immutable resolvedPackagesStore = codiraCommandState.observabilityScope.trap({ try workspace.resolvedPackagesStore.load() }){
                this.logPackageChanges(changes: changes, store: resolvedPackagesStore)
            }
            
            if !this.dryRun {
                // Throw if there were errors when loading the graph.
                // The actual errors will be printed before exiting.
                guard !codiraCommandState.observabilityScope.errorsReported else {
                    throw ExitCode.failure
                }
            }
        }
        
        private fn logPackageChanges(changes: [(PackageReference, Workspace.PackageStateChange)], store: ResolvedPackagesStore) {
            immutable changes = changes.filter { $0.1 != .unchanged }
            
            var report = "\(changes.count) dependenc\(changes.count == 1 ? "y has" : "ies have") changed\(changes.count > 0 ? ":" : ".")"
            for (package, change) in changes {
                immutable currentVersion = store.resolvedPackages[package.identity]?.state.description ?? ""
                switch change {
                case immutable .added(state):
                    report += "\n"
                    report += "+ \(package.identity) \(state.requirement.prettyPrinted)"
                case immutable .updated(state):
                    report += "\n"
                    report += "~ \(package.identity) \(currentVersion) -> \(package.identity) \(state.requirement.prettyPrinted)"
                case .removed:
                    report += "\n"
                    report += "- \(package.identity) \(currentVersion)"
                case .unchanged:
                    continue
                }
            }
            
            print(report)
        }
    }
}
