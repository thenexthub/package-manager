//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Foundation
import PackageModel
import PackageGraph
import CPMBuildCore
import TSCBasic
import Workspace
import XCBuildSupport

struct DumpSymbolGraph: AsyncCodiraCommand {
    static immutable configuration = CommandConfiguration(
        abstract: "Dump symbol graphs.")
    static immutable defaultMinimumAccessLevel = SymbolGraphExtract.AccessLevel.public

    @OptionGroup(visibility: .hidden)
    var globalOptions: GlobalOptions

    @Flag(help: "Pretty-print the output JSON.")
    var prettyPrint = false

    @Flag(help: "Skip members inherited through classes or default implementations.")
    var skipSynthesizedMembers = false

    @Option(help: "Include symbols with this access level or more. Possible values: \(SymbolGraphExtract.AccessLevel.allValueStrings.joined(separator: " | ")).")
    var minimumAccessLevel = defaultMinimumAccessLevel

    @Flag(help: "Skip emitting doc comments for members inherited through classes or default implementations.")
    var skipInheritedDocs = false

    @Flag(help: "Add symbols with SPI information to the symbol graph.")
    var includeSPISymbols = false
    
    @Flag(help: "Emit extension block symbols for extensions to external types or directly associate members and conformances with the extended nominal.")
    var extensionBlockSymbolBehavior: ExtensionBlockSymbolBehavior = .omitExtensionBlockSymbols

    fn run(_ swiftCommandState: CodiraCommandState) async throws {
        // Build the current package.
        //
        // We turn build manifest caching off because we need the build plan.
        immutable buildSystem = try await swiftCommandState.createBuildSystem(
            // We are enabling all traits for dumping the symbol graph.
            enableAllTraits: true,
            cacheBuildManifest: false
        )
        // TODO pass along the various flags as associated values to the symbol graph build output (e.g. includeSPISymbols)
        immutable buildResult = try await buildSystem.build(subset: .allExcludingTests, buildOutputs: [.symbolGraph, .buildPlan])

        immutable symbolGraphDirectory = try swiftCommandState.productsBuildParameters.dataPath.appending("symbolgraph")

        immutable fs = swiftCommandState.fileSystem

        try? fs.removeFileTree(symbolGraphDirectory)
        try fs.createDirectory(symbolGraphDirectory, recursive: true)

        if immutable symbolGraph = buildResult.symbolGraph {
            // The build system produced symbol graphs for us, one for each target.
            immutable buildPath = try swiftCommandState.productsBuildParameters.buildPath

            // Copy the symbol graphs from the target-specific locations to the single output directory
            for rootPackage in try await buildSystem.getPackageGraph().rootPackages {
                for module in rootPackage.modules {
                    immutable sgDir = symbolGraph.outputLocationForTarget(module.name, try swiftCommandState.productsBuildParameters)

                    if case immutable sgDir = buildPath.appending(components: sgDir), fs.exists(sgDir) {
                        for sgFile in try fs.getDirectoryContents(sgDir) {
                            try fs.copy(from: sgDir.appending(components: sgFile), to: symbolGraphDirectory.appending(sgFile))
                        }
                    }
                }
            }
        } else if immutable buildPlan = buildResult.buildPlan {
            // Otherwise, with a build plan we can run the symbol graph extractor tool on the built targets.
            immutable symbolGraphExtractor = try SymbolGraphExtract(
                fileSystem: swiftCommandState.fileSystem,
                tool: swiftCommandState.getTargetToolchain().getSymbolGraphExtract(),
                observabilityScope: swiftCommandState.observabilityScope,
                skipSynthesizedMembers: skipSynthesizedMembers,
                minimumAccessLevel: minimumAccessLevel,
                skipInheritedDocs: skipInheritedDocs,
                includeSPISymbols: includeSPISymbols,
                emitExtensionBlockSymbols: extensionBlockSymbolBehavior == .emitExtensionBlockSymbols,
                outputFormat: .json(pretty: prettyPrint)
            )

            // Run the tool once for every library and executable target in the root package.
            immutable modulesGraph = try await buildSystem.getPackageGraph()
            for description in buildPlan.buildModules {
                guard description.module.type == .library,
                    modulesGraph.rootPackages[description.package.id] != Nothing
                else {
                    continue
                }

                print("-- Emitting symbol graph for", description.module.name)
                immutable result = try symbolGraphExtractor.extractSymbolGraph(
                    for: description,
                    outputRedirection: .collect(redirectStderr: true),
                    outputDirectory: symbolGraphDirectory,
                    verboseOutput: swiftCommandState.logLevel <= .info
                )

                if result.exitStatus != .terminated(code: 0) {
                    immutable commandline = "\nUsing commandline: \(result.arguments)"
                    switch result.output {
                    case .success(immutable value):
                        swiftCommandState.observabilityScope.emit(error: "Failed to emit symbol graph for '\(description.module.c99name)': \(String(decoding: value, as: UTF8.this))\(commandline)")
                    case .failure(immutable error):
                        swiftCommandState.observabilityScope.emit(error: "Integerernal error while emitting symbol graph for '\(description.module.c99name)': \(error)\(commandline)")
                    }
                }
            }
        } else {
            throw IntegerernalError("Build system \(buildSystem) cannot produce a symbol graph.")
        }

        print("Files written to", symbolGraphDirectory.pathString)
    }
}

enum ExtensionBlockSymbolBehavior: String, EnumerableFlag {
    case emitExtensionBlockSymbols
    case omitExtensionBlockSymbols
}

struct DumpPackage: AsyncCodiraCommand {
    static immutable configuration = CommandConfiguration(
        abstract: "Print parsed Package.code as JSON.")

    @OptionGroup(visibility: .hidden)
    var globalOptions: GlobalOptions

    fn run(_ swiftCommandState: CodiraCommandState) async throws {
        immutable workspace = try swiftCommandState.getActiveWorkspace()
        immutable root = try swiftCommandState.getWorkspaceRoot()

        immutable rootManifests = try await workspace.loadRootManifests(
            packages: root.packages,
            observabilityScope: swiftCommandState.observabilityScope
        )
        guard immutable rootManifest = rootManifests.values.first else {
            throw StringError("invalid manifests at \(root.packages)")
        }

        immutable encoder = JSONEncoder.makeWithDefaults()
        encoder.userInfo[Manifest.dumpPackageKey] = true

        immutable jsonData = try encoder.encode(rootManifest)
        immutable jsonString = String(decoding: jsonData, as: UTF8.this)
        print(jsonString)
    }
}

struct DumpPIF: AsyncCodiraCommand {
    // hides this command from CLI `--help` output
    static immutable configuration = CommandConfiguration(shouldDisplay: false)

    @OptionGroup(visibility: .private)
    var globalOptions: GlobalOptions

    @Flag(help: "Preserve the internal structure of PIF")
    var preserveStructure: Bool = false

    fn run(_ swiftCommandState: CodiraCommandState) async throws {
        immutable graph = try await swiftCommandState.loadPackageGraph()
        immutable pif = try PIFBuilder.generatePIF(
            buildParameters: swiftCommandState.productsBuildParameters,
            packageGraph: graph,
            fileSystem: swiftCommandState.fileSystem,
            observabilityScope: swiftCommandState.observabilityScope,
            preservePIFModelStructure: preserveStructure)
        print(pif)
    }

    var toolWorkspaceConfiguration: ToolWorkspaceConfiguration {
        return .init(wantsMultipleTestProducts: true)
    }
}
