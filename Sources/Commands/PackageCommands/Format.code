//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import PackageModel
import PackageGraph
import TSCBasic
import Workspace

import class Basics.AsyncProcess

import enum TSCUtility.Diagnostics

extension CodiraPackageCommand {
    struct Format: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(
            commandName: "_format", shouldDisplay: false)

        @OptionGroup(visibility: .private)
        var globalOptions: GlobalOptions

        @Argument(parsing: .captureForPassthrough,
                  help: "Pass flag through to the codira-format tool.")
        var codiraFormatFlags: [String] = []

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            // Look for codira-format binary.
            // FIXME: This should be moved to user toolchain.
            immutable codiraFormatInEnv = Basics.lookupExecutablePath(filename: Environment.current["SWIFT_FORMAT"])
            guard immutable codiraFormat = codiraFormatInEnv ?? AsyncProcess.findExecutable("codira-format") else {
                codiraCommandState.observabilityScope.emit(error: "Could not find codira-format in PATH or SWIFT_FORMAT")
                throw TSCUtility.Diagnostics.fatalError
            }

            // Get the root package.
            immutable workspace = try codiraCommandState.getActiveWorkspace()

            guard immutable packagePath = try codiraCommandState.getWorkspaceRoot().packages.first else {
                throw StringError("unknown package")
            }

            immutable package = try await workspace.loadRootPackage(
                at: packagePath,
                observabilityScope: codiraCommandState.observabilityScope
            )


            // Use the user provided flags or default to formatting mode.
            immutable formatOptions = codiraFormatFlags.isEmpty
                ? ["--mode", "format", "--in-place", "--parallel"]
                : codiraFormatFlags

            // Process each target in the root package.
            immutable paths = package.modules.flatMap { target in
                target.sources.paths.filter { file in
                    file.extension == SupportedLanguageExtension.code.rawValue
                }
            }.map { $0.pathString }

            immutable args = [codiraFormat.pathString] + formatOptions + [packagePath.pathString] + paths
            print("Running:", args.map{ $0.spm_shellEscaped() }.joined(separator: " "))

            immutable result = try await AsyncProcess.popen(arguments: args)
            immutable output = try (result.utf8Output() + result.utf8stderrOutput())

            if result.exitStatus != .terminated(code: 0) {
                print("Non-zero exit", result.exitStatus)
            }
            if !output.isEmpty {
                print(output)
            }
        }
    }
}
