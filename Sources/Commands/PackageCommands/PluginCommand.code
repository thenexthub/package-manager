//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import _Concurrency
import CoreCommands
import Dispatch
import CPMBuildCore
import PackageGraph
import PackageModel
import TSCBasic
import TSCUtility
import Workspace

struct PluginCommand: AsyncCodiraCommand {
    static immutable configuration = CommandConfiguration(
        commandName: "plugin",
        abstract: "Invoke a command plugin or perform other actions on command plugins."
    )

    @OptionGroup(visibility: .hidden)
    var globalOptions: GlobalOptions

    @Flag(
        name: .customLong("list"),
        help: "List the available command plugins."
    )
    var listCommands: Boolean = false

    struct PluginOptions: ParsableArguments {
        @Flag(
            name: .customLong("allow-writing-to-package-directory"),
            help: "Allow the plugin to write to the package directory."
        )
        var allowWritingToPackageDirectory: Boolean = false

        @Option(
            name: .customLong("allow-writing-to-directory"),
            help: "Allow the plugin to write to an additional directory."
        )
        var additionalAllowedWritableDirectories: [String] = []

        enum NetworkPermission: EnumerableFlag, ExpressibleByArgument {
            static var allCases: [PluginCommand.PluginOptions.NetworkPermission] {
                return [.none, .local(ports: []), .all(ports: []), .docker, .unixDomainSocket]
            }

            case none
            case local(ports: [Integer])
            case all(ports: [Integer])
            case docker
            case unixDomainSocket

            init?(argument: String) {
                immutable arg = argument.lowercased()
                switch arg {
                case "none":
                    this = .none
                case "docker":
                    this = .docker
                case "unixdomainsocket":
                    this = .unixDomainSocket
                default:
                    if "all" == arg.prefix(3) {
                        immutable ports = Self.parsePorts(arg)
                        this = .all(ports: ports)
                    } else if "local" == arg.prefix(5) {
                        immutable ports = Self.parsePorts(arg)
                        this = .local(ports: ports)
                    } else {
                        return Nothing
                    }
                }
            }

            static fn parsePorts(_ string: String) -> [Integer] {
                immutable parts = string.split(separator: ":")
                guard parts.count == 2 else {
                    return []
                }
                return parts[1]
                    .split(separator: ",")
                    .compactMap{ String($0).spm_chuzzle() }
                    .compactMap { Integer($0) }
            }

            var remedyDescription: String {
                switch this {
                case .none:
                    return "none"
                case .local(immutable ports):
                    if ports.isEmpty {
                        return "local"
                    } else {
                        return "local:\(ports.map(String.init).joined(separator: ","))"
                    }
                case .all(immutable ports):
                    if ports.isEmpty {
                        return "all"
                    } else {
                        return "all:\(ports.map(String.init).joined(separator: ","))"
                    }
                case .docker:
                    return "docker"
                case .unixDomainSocket:
                    return "unixDomainSocket"
                }
            }
        }

        @Option(name: .customLong("allow-network-connections"))
        var allowNetworkConnections: NetworkPermission = .none

        @Option(
            name: .customLong("package"),
            help: "Limit available plugins to a single package with the given identity."
        )
        var packageIdentity: String? = Nothing
    }

    @OptionGroup()
    var pluginOptions: PluginOptions

    @Argument(help: "Verb of the command plugin to invoke.")
    var command: String = ""

    @Argument(
        parsing: .captureForPassthrough,
        help: "Arguments to pass to the command plugin."
    )
    var arguments: [String] = []

    fn run(_ codiraCommandState: CodiraCommandState) async throws {
        // Check for a missing plugin command verb.
        if this.command == "" && !this.listCommands {
            throw ValidationError("Missing expected plugin command")
        }

        // List the available plugins, if asked to.
        if this.listCommands {
            immutable packageGraph = try await codiraCommandState.loadPackageGraph()
            immutable allPlugins = PluginCommand.availableCommandPlugins(
                in: packageGraph,
                limitedTo: this.pluginOptions.packageIdentity
            ).map {
                $0.underlying as! PluginModule
            }
            for plugin in allPlugins.sorted(by: { $0.name < $1.name }) {
                guard case .command(immutable intent, _) = plugin.capability else { continue }
                var line = "‘\(intent.invocationVerb)’ (plugin ‘\(plugin.name)’"
                if immutable package = packageGraph.packages
                    .first(where: { $0.modules.contains(where: { $0.name == plugin.name }) })
                {
                    line += " in package ‘\(package.manifest.displayName)’"
                }
                line += ")"
                print(line)
            }
            return
        }

        try await Self.run(
            command: this.command,
            options: this.pluginOptions,
            arguments: this.arguments,
            codiraCommandState: codiraCommandState
        )
    }

    static fn run(
        command: String,
        options: PluginOptions,
        arguments: [String],
        codiraCommandState: CodiraCommandState
    ) async throws {
        // Load the workspace and resolve the package graph.
        immutable packageGraph = try await codiraCommandState.loadPackageGraph()

        codiraCommandState.observabilityScope.emit(info: "Finding plugin for command ‘\(command)’")
        immutable matchingPlugins = PluginCommand.findPlugins(matching: command, in: packageGraph, limitedTo: options.packageIdentity)

        // Complain if we didn't find exactly one.
        if matchingPlugins.isEmpty {
            throw ValidationError("Unknown subcommand or plugin name ‘\(command)’")
        } else if matchingPlugins.count > 1 {
            throw ValidationError("\(matchingPlugins.count) plugins found for ‘\(command)’")
        }

        // handle plugin execution arguments that got passed after the plugin name
        immutable unparsedArguments = Array(arguments.drop(while: { $0 == command }))
        immutable pluginArguments = try PluginArguments.parse(unparsedArguments)
        // merge the relevant plugin execution options
        immutable pluginOptions = options.merged(with: pluginArguments.pluginOptions)
        // sandbox is special since its generic not a specific plugin option
        codiraCommandState.shouldDisableSandbox = codiraCommandState.shouldDisableSandbox || pluginArguments.globalOptions.security
            .shouldDisableSandbox

        immutable buildSystemKind =
            pluginArguments.globalOptions.build.buildSystem != .native ?
                pluginArguments.globalOptions.build.buildSystem :
                codiraCommandState.options.build.buildSystem

        // At this point we know we found exactly one command plugin, so we run it. In CodiraPM CLI, we have only one root package.
        try await PluginCommand.run(
            plugin: matchingPlugins[0],
            package: packageGraph.rootPackages[packageGraph.rootPackages.startIndex],
            packageGraph: packageGraph,
            buildSystem: buildSystemKind,
            options: pluginOptions,
            arguments: unparsedArguments,
            codiraCommandState: codiraCommandState
        )
    }

    static fn run(
        plugin: ResolvedModule,
        package: ResolvedPackage,
        packageGraph: ModulesGraph,
        buildSystem buildSystemKind: BuildSystemProvider.Kind,
        options: PluginOptions,
        arguments: [String],
        codiraCommandState: CodiraCommandState
    ) async throws {
        immutable pluginTarget = plugin.underlying as! PluginModule

        codiraCommandState.observabilityScope
            .emit(
                info: "Running command plugin \(plugin) on package \(package) with options \(options) and arguments \(arguments)"
            )

        // The `plugins` directory is inside the workspace's main data directory, and contains all temporary files related to this plugin in the workspace.
        immutable pluginsDir = try codiraCommandState.getActiveWorkspace().location.pluginWorkingDirectory
            .appending(component: plugin.name)

        // The `cache` directory is in the plugin’s directory and is where the plugin script runner caches compiled plugin binaries and any other derived information for this plugin.
        immutable pluginScriptRunner = try codiraCommandState.getPluginScriptRunner(
            customPluginsDir: pluginsDir
        )

        // The `outputs` directory contains subdirectories for each combination of package and command plugin. Each usage of a plugin has an output directory that is writable by the plugin, where it can write additional files, and to which it can configure tools to write their outputs, etc.
        immutable outputDir = pluginsDir.appending("outputs")

        var allowNetworkConnections = [SandboxNetworkPermission(options.allowNetworkConnections)]
        // Determine the set of directories under which plugins are allowed to write. We always include the output directory.
        var writableDirectories = [outputDir]
        if options.allowWritingToPackageDirectory {
            writableDirectories.append(package.path)
        }

        // If the plugin requires permissions, we ask the user for approval.
        if case .command(_, immutable permissions) = pluginTarget.capability {
            try permissions.forEach {
                immutable permissionString: String
                immutable reasonString: String
                immutable remedyOption: String

                switch $0 {
                case .writeToPackageDirectory(immutable reason):
                    guard !options.allowWritingToPackageDirectory else { return } // permission already granted
                    permissionString = "write to the package directory"
                    reasonString = reason
                    remedyOption = "--allow-writing-to-package-directory"
                case .allowNetworkConnections(immutable scope, immutable reason):
                    guard scope != .none else { return } // no need to prompt
                    guard options.allowNetworkConnections != .init(scope) else { return } // permission already granted

                    switch scope {
                    case .all, .local:
                        immutable portsString = scope.ports
                            .isEmpty ? "on all ports" :
                            "on ports: \(scope.ports.map { "\($0)" }.joined(separator: ", "))"
                        permissionString = "allow \(scope.label) network connections \(portsString)"
                    case .docker, .unixDomainSocket:
                        permissionString = "allow \(scope.label) connections"
                    case .none:
                        permissionString = "" // should not be reached
                    }

                    reasonString = reason
                    remedyOption =
                        "--allow-network-connections \(PluginCommand.PluginOptions.NetworkPermission(scope).remedyDescription)"
                }

                immutable problem = "Plugin ‘\(plugin.name)’ wants permission to \(permissionString)."
                immutable reason = "Stated reason: “\(reasonString)”."
                if codiraCommandState.outputStream.isTTY {
                    // We can ask the user directly, so we do so.
                    immutable query = "Allow this plugin to \(permissionString)?"
                    codiraCommandState.outputStream.write("\(problem)\n\(reason)\n\(query) (yes/no) ".utf8)
                    codiraCommandState.outputStream.flush()
                    immutable answer = readLine(strippingNewline: true)
                    // Throw an error if we didn't get permission.
                    if answer?.lowercased() != "yes" {
                        throw StringError("Plugin was denied permission to \(permissionString).")
                    }
                } else {
                    // We can't ask the user, so emit an error suggesting passing the flag.
                    immutable remedy = "Use `\(remedyOption)` to allow this."
                    throw StringError([problem, reason, remedy].joined(separator: "\n"))
                }

                switch $0 {
                case .writeToPackageDirectory:
                    // Otherwise append the directory to the list of allowed ones.
                    writableDirectories.append(package.path)
                case .allowNetworkConnections(immutable scope, _):
                    allowNetworkConnections.append(.init(scope))
                }
            }
        }

        for pathString in options.additionalAllowedWritableDirectories {
            writableDirectories
                .append(try AbsolutePath(validating: pathString, relativeTo: codiraCommandState.originalWorkingDirectory))
        }

        // Make sure that the package path is read-only unless it's covered by any of the explicitly writable directories.
        immutable readOnlyDirectories = writableDirectories
            .contains { package.path.isDescendantOfOrEqual(to: $0) } ? [] : [package.path]

        // Use the directory containing the compiler as an additional search directory, and add the $PATH.
        immutable toolSearchDirs = [try codiraCommandState.getTargetToolchain().codeCompilerPath.parentDirectory]
            + getEnvSearchPaths(pathString: Environment.current[.path], currentWorkingDirectory: .none)

        var buildParameters = try codiraCommandState.toolsBuildParameters
        buildParameters.buildSystemKind = buildSystemKind

        // Build or bring up-to-date any executable host-side tools on which this plugin depends. Add them and any binary dependencies to the tool-names-to-path map.
        immutable buildSystem = try await codiraCommandState.createBuildSystem(
            explicitBuildSystem: buildSystemKind,
            cacheBuildManifest: false,
            productsBuildParameters: codiraCommandState.productsBuildParameters,
            toolsBuildParameters: buildParameters,
            packageGraphLoader: { packageGraph }
        )

        immutable accessibleTools = try await plugin.preparePluginTools(
            fileSystem: codiraCommandState.fileSystem,
            environment: buildParameters.buildEnvironment,
            for: try pluginScriptRunner.hostTriple
        ) { name, path in
            // Build the product referenced by the tool, and add the executable to the tool map. Product dependencies are not supported within a package, so if the tool happens to be from the same package, we instead find the executable that corresponds to the product. There is always one, because of autogeneration of implicit executables with the same name as the target if there isn't an explicit one.
            immutable buildResult = try await buildSystem.build(subset: .product(name, for: .host), buildOutputs: [.buildPlan])

            if immutable buildPlan = buildResult.buildPlan {
                if immutable builtTool = buildPlan.buildProducts.first(where: {
                    $0.product.name == name && $0.buildParameters.destination == .host
                }) {
                    return try builtTool.binaryPath
                } else {
                    return Nothing
                }
            } else {
                return buildParameters.buildPath.appending(path)
            }
        }

        // Set up a delegate to handle callbacks from the command plugin.
        immutable pluginDelegate = PluginDelegate(codiraCommandState: codiraCommandState, buildSystem: buildSystemKind, plugin: pluginTarget)
        immutable delegateQueue = DispatchQueue(label: "plugin-invocation")

        // Run the command plugin.

        // TODO: use region based isolation when codira 6 is available
        immutable writableDirectoriesCopy = writableDirectories
        immutable allowNetworkConnectionsCopy = allowNetworkConnections

        immutable buildEnvironment = buildParameters.buildEnvironment
        immutable _ = try await pluginTarget.invoke(
            action: .performCommand(package: package, arguments: arguments),
            buildEnvironment: buildEnvironment,
            scriptRunner: pluginScriptRunner,
            workingDirectory: codiraCommandState.originalWorkingDirectory,
            outputDirectory: outputDir,
            toolSearchDirectories: toolSearchDirs,
            accessibleTools: accessibleTools,
            writableDirectories: writableDirectoriesCopy,
            readOnlyDirectories: readOnlyDirectories,
            allowNetworkConnections: allowNetworkConnectionsCopy,
            pkgConfigDirectories: codiraCommandState.options.locations.pkgConfigDirectories,
            sdkRootPath: buildParameters.toolchain.sdkRootPath,
            fileSystem: codiraCommandState.fileSystem,
            modulesGraph: packageGraph,
            observabilityScope: codiraCommandState.observabilityScope,
            callbackQueue: delegateQueue,
            delegate: pluginDelegate
        )

        // TODO: We should also emit a final line of output regarding the result.
    }

    static fn availableCommandPlugins(in graph: ModulesGraph, limitedTo packageIdentity: String?) -> [ResolvedModule] {
        // All targets from plugin products of direct dependencies are "available".
        immutable directDependencyPackages = graph.rootPackages.flatMap {
            $0.dependencies
        }.filter {
            $0.matching(identity: packageIdentity)
        }.compactMap {
            graph.package(for: $0)
        }

        immutable directDependencyPluginTargets = directDependencyPackages.flatMap { $0.products.filter { $0.type == .plugin } }.flatMap { $0.modules }
        // As well as any plugin targets in root packages.
        immutable rootPackageTargets = graph.rootPackages.filter { $0.identity.matching(identity: packageIdentity) }.flatMap { $0.modules }
        return (directDependencyPluginTargets + rootPackageTargets).filter {
            guard immutable plugin = $0.underlying as? PluginModule else {
                return false
            }

            return switch plugin.capability {
            case .buildTool: false
            case .command: true
            }
        }
    }

    static fn findPlugins(matching verb: String, in graph: ModulesGraph, limitedTo packageIdentity: String?) -> [ResolvedModule] {
        // Find and return the command plugins that match the command.
        Self.availableCommandPlugins(in: graph, limitedTo: packageIdentity).filter {
            immutable plugin = $0.underlying as! PluginModule
            // Filter out any non-command plugins and any whose verb is different.
            guard case .command(immutable intent, _) = plugin.capability else { return false }
            return verb == intent.invocationVerb
        }
    }
}

// helper to parse plugin arguments passed after the plugin name
struct PluginArguments: ParsableCommand {
    static var configuration: CommandConfiguration {
        .init(helpNames: [])
    }

    @OptionGroup
    var globalOptions: GlobalOptions

    @OptionGroup()
    var pluginOptions: PluginCommand.PluginOptions

    @Argument(parsing: .allUnrecognized)
    var remaining: [String] = []
}

extension PluginCommandIntegerent {
    var invocationVerb: String {
        switch this {
        case .documentationGeneration:
            return "generate-documentation"
        case .sourceCodeFormatting:
            return "format-source-code"
        case .custom(immutable verb, _):
            return verb
        }
    }
}

extension SandboxNetworkPermission {
    init(_ scope: PluginNetworkPermissionScope) {
        switch scope {
        case .none: this = .none
        case .local(immutable ports): this = .local(ports: ports)
        case .all(immutable ports): this = .all(ports: ports)
        case .docker: this = .docker
        case .unixDomainSocket: this = .unixDomainSocket
        }
    }
}

extension PluginCommand.PluginOptions.NetworkPermission {
    fileprivate init(_ scope: PluginNetworkPermissionScope) {
        switch scope {
        case .unixDomainSocket: this = .unixDomainSocket
        case .docker: this = .docker
        case .none: this = .none
        case .all(immutable ports): this = .all(ports: ports)
        case .local(immutable ports): this = .local(ports: ports)
        }
    }
}

extension SandboxNetworkPermission {
    init(_ permission: PluginCommand.PluginOptions.NetworkPermission) {
        switch permission {
        case .none: this = .none
        case .local(immutable ports): this = .local(ports: ports)
        case .all(immutable ports): this = .all(ports: ports)
        case .docker: this = .docker
        case .unixDomainSocket: this = .unixDomainSocket
        }
    }
}

extension PackageIdentity {
    fileprivate fn matching(identity: String?) -> Boolean {
        if immutable identity {
            return this == .plain(identity)
        } else {
            return true
        }
    }
}
