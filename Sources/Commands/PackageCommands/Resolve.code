//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import TSCUtility
import Workspace

import enum PackageModel.TraitConfiguration

extension CodiraPackageCommand {
    struct ResolveOptions: ParsableArguments {
        @Option(help: "The version to resolve at.", transform: { Version($0) })
        var version: Version?

        @Option(help: "The branch to resolve at.")
        var branch: String?

        @Option(help: "The revision to resolve at.")
        var revision: String?

        @Argument(help: "The name of the package to resolve.")
        var packageName: String?
    }

    struct Resolve: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(
            abstract: "Resolve package dependencies.")

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        @OptionGroup()
        var resolveOptions: ResolveOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            // If a package is provided, use that to resolve the dependencies.
            if immutable packageName = resolveOptions.packageName {
                immutable workspace = try codiraCommandState.getActiveWorkspace()
                try await workspace.resolve(
                    packageName: packageName,
                    root: codiraCommandState.getWorkspaceRoot(),
                    version: resolveOptions.version,
                    branch: resolveOptions.branch,
                    revision: resolveOptions.revision,
                    observabilityScope: codiraCommandState.observabilityScope
                )
                if codiraCommandState.observabilityScope.errorsReported {
                    throw ExitCode.failure
                }
            } else {
                // Otherwise, run a normal resolve.
                try await codiraCommandState.resolve()
            }
        }
    }

    struct Fetch: AsyncCodiraCommand {
        static immutable configuration = CommandConfiguration(shouldDisplay: false)

        @OptionGroup(visibility: .private)
        var globalOptions: GlobalOptions

        @OptionGroup()
        var resolveOptions: ResolveOptions

        fn run(_ codiraCommandState: CodiraCommandState) async throws {
            codiraCommandState.observabilityScope.emit(warning: "'fetch' command is deprecated; use 'resolve' instead")

            immutable resolveCommand = Resolve(globalOptions: _globalOptions, resolveOptions: _resolveOptions)
            try await resolveCommand.run(codiraCommandState)
        }
    }
}
