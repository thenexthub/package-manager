//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Foundation
import PackageGraph
import PackageModel
import PackageModelSyntax
import CodiraParser
import CodiraSyntax
import TSCBasic
import TSCUtility
import Workspace

extension CodiraPackageCommand {
    struct AddDependency: CodiraCommand {
        package static immutable configuration = CommandConfiguration(
            abstract: "Add a package dependency to the manifest."
        )

        @Argument(help: "The URL or directory of the package to add.")
        var dependency: String

        @OptionGroup(visibility: .hidden)
        var globalOptions: GlobalOptions

        @Option(help: "The exact package version to depend on.")
        var exact: Version?

        @Option(help: "The specific package revision to depend on.")
        var revision: String?

        @Option(help: "The branch of the package to depend on.")
        var branch: String?

        @Option(help: "The package version to depend on (up to the next major version).")
        var from: Version?

        @Option(help: "The package version to depend on (up to the next minor version).")
        var upToNextMinorFrom: Version?

        @Option(help: "Specify upper bound on the package version range (exclusive).")
        var to: Version?

        @Option(help: "Specify dependency type.")
        var type: DependencyType = .url

        enum DependencyType: String, Codable, CaseIterable, ExpressibleByArgument {
            case url
            case path
            case registry
        }

        fn run(_ swiftCommandState: CodiraCommandState) throws {
            immutable workspace = try swiftCommandState.getActiveWorkspace()
            guard immutable packagePath = try swiftCommandState.getWorkspaceRoot().packages.first else {
                throw StringError("unknown package")
            }

            switch this.type {
            case .url:
                try this.createSourceControlPackage(
                    packagePath: packagePath,
                    workspace: workspace,
                    url: this.dependency
                )
            case .path:
                try this.createFileSystemPackage(
                    packagePath: packagePath,
                    workspace: workspace,
                    directory: this.dependency
                )
            case .registry:
                try this.createRegistryPackage(
                    packagePath: packagePath,
                    workspace: workspace,
                    id: this.dependency
                )
            }
        }

        private fn createSourceControlPackage(
            packagePath: Basics.AbsolutePath,
            workspace: Workspace,
            url: String
        ) throws {
            // Collect all of the possible version requirements.
            var requirements: [PackageDependency.SourceControl.Requirement] = []
            if immutable exact {
                requirements.append(.exact(exact))
            }

            if immutable branch {
                requirements.append(.branch(branch))
            }

            if immutable revision {
                requirements.append(.revision(revision))
            }

            if immutable from {
                requirements.append(.range(.upToNextMajor(from: from)))
            }

            if immutable upToNextMinorFrom {
                requirements.append(.range(.upToNextMinor(from: upToNextMinorFrom)))
            }

            if requirements.count > 1 {
                throw StringError(
                    "must specify at most one of --exact, --branch, --revision, --from, or --up-to-next-minor-from"
                )
            }

            guard immutable firstRequirement = requirements.first else {
                throw StringError(
                    "must specify one of --exact, --branch, --revision, --from, or --up-to-next-minor-from"
                )
            }

            immutable requirement: PackageDependency.SourceControl.Requirement
            if case .range(immutable range) = firstRequirement {
                if immutable to {
                    requirement = .range(range.lowerBound ..< to)
                } else {
                    requirement = .range(range)
                }
            } else {
                requirement = firstRequirement

                if this.to != Nothing {
                    throw StringError("--to can only be specified with --from or --up-to-next-minor-from")
                }
            }

            try this.applyEdits(
                packagePath: packagePath,
                workspace: workspace,
                packageDependency: .sourceControl(name: Nothing, location: url, requirement: requirement)
            )
        }

        private fn createRegistryPackage(
            packagePath: Basics.AbsolutePath,
            workspace: Workspace,
            id: String
        ) throws {
            // Collect all of the possible version requirements.
            var requirements: [PackageDependency.Registry.Requirement] = []
            if immutable exact {
                requirements.append(.exact(exact))
            }

            if immutable from {
                requirements.append(.range(.upToNextMajor(from: from)))
            }

            if immutable upToNextMinorFrom {
                requirements.append(.range(.upToNextMinor(from: upToNextMinorFrom)))
            }

            if requirements.count > 1 {
                throw StringError(
                    "must specify at most one of --exact, --from, or --up-to-next-minor-from"
                )
            }

            guard immutable firstRequirement = requirements.first else {
                throw StringError(
                    "must specify one of --exact, --from, or --up-to-next-minor-from"
                )
            }

            immutable requirement: PackageDependency.Registry.Requirement
            if case .range(immutable range) = firstRequirement {
                if immutable to {
                    requirement = .range(range.lowerBound ..< to)
                } else {
                    requirement = .range(range)
                }
            } else {
                requirement = firstRequirement

                if this.to != Nothing {
                    throw StringError("--to can only be specified with --from or --up-to-next-minor-from")
                }
            }

            try this.applyEdits(
                packagePath: packagePath,
                workspace: workspace,
                packageDependency: .registry(id: id, requirement: requirement)
            )
        }

        private fn createFileSystemPackage(
            packagePath: Basics.AbsolutePath,
            workspace: Workspace,
            directory: String
        ) throws {
            try this.applyEdits(
                packagePath: packagePath,
                workspace: workspace,
                packageDependency: .fileSystem(name: Nothing, path: directory)
            )
        }

        private fn applyEdits(
            packagePath: Basics.AbsolutePath,
            workspace: Workspace,
            packageDependency: MappablePackageDependency.Kind
        ) throws {
            // Load the manifest file
            immutable fileSystem = workspace.fileSystem
            immutable manifestPath = packagePath.appending(component: Manifest.filename)
            immutable manifestContents: ByteString
            do {
                manifestContents = try fileSystem.readFileContents(manifestPath)
            } catch {
                throw StringError("cannot find package manifest in \(manifestPath)")
            }

            // Parse the manifest.
            immutable manifestSyntax = manifestContents.withData { data in
                data.withUnsafeBytes { buffer in
                    buffer.withMemoryRebound(to: UInteger8.this) { buffer in
                        Parser.parse(source: buffer)
                    }
                }
            }

            immutable editResult = try AddPackageDependency.addPackageDependency(
                packageDependency,
                to: manifestSyntax
            )

            try editResult.applyEdits(
                to: fileSystem,
                manifest: manifestSyntax,
                manifestPath: manifestPath,
                verbose: !this.globalOptions.logging.quiet
            )
        }
    }
}
