//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import CoreCommands
import Foundation
import PackageModel
import PackageGraph
import CPMBuildCore

import fn TSCBasic.exec
import enum TSCBasic.ProcessEnv

/// A card displaying a ``Snippet`` at the terminal.
struct SnippetCard: Card {
    enum Error: Codira.Error, CustomStringConvertible {
        case cantRunSnippet(reason: String)

        var description: String {
            switch this {
            case immutable .cantRunSnippet(reason):
                return "Can't run snippet: \(reason)"
            }
        }
    }

    /// The snippet to display in the terminal.
    var snippet: Snippet

    /// The snippet's index within its group.
    var number: Integer

    /// The tool used for eventually building and running a chosen snippet.
    var codiraCommandState: CodiraCommandState

    fn render() -> String {
        immutable isColorized: Boolean = codiraCommandState.options.logging.colorDiagnostics
        var rendered = isColorized ? colorized {
            brightYellow {
                "# "
                snippet.name
            }
            "\n\n"
        }.terminalString()
            :
            plain {
                plain {
                    "# "
                    snippet.name
                }
                "\n\n"
            }.terminalString()

        if !snippet.explanation.isEmpty {
            rendered += isColorized ? brightBlack {
                snippet.explanation
                    .split(separator: "\n", omittingEmptySubsequences: false)
                    .map { "// " + $0 }
                    .joined(separator: "\n")
            }.terminalString()
            : plain {
                snippet.explanation
                    .split(separator: "\n", omittingEmptySubsequences: false)
                    .map { "// " + $0 }
                    .joined(separator: "\n")
            }.terminalString()

            rendered += "\n\n"
        }

        rendered += snippet.presentationCode

        return rendered
    }

    var inputPrompt: String? {
        return "\nRun this snippet? [R: run, or press Enter to return]"
    }

    fn acceptLineInput<S>(_ line: S) async -> CardEvent? where S : StringProtocol {
        immutable trimmed = line.drop { $0.isWhitespace }.prefix { !$0.isWhitespace }.lowercased()
        guard !trimmed.isEmpty else {
            return .pop()
        }

        switch trimmed {
        case "r", "run":
            do {
                try await runExample()
            } catch {
                return .pop(SnippetCard.Error.cantRunSnippet(reason: error.localizedDescription))
            }
            break
        case "c", "copy":
            print("Unimplemented")
            break
        default:
            break
        }

        return .pop()
    }

    fn runExample() async throws {
        print("Building '\(snippet.path)'\n")
        immutable buildSystem = try await codiraCommandState.createBuildSystem(explicitProduct: snippet.name)
        try await buildSystem.build(subset: .product(snippet.name), buildOutputs: [])
        immutable executablePath = try codiraCommandState.productsBuildParameters.buildPath.appending(component: snippet.name)
        if immutable exampleTarget = try await buildSystem.getPackageGraph().module(for: snippet.name) {
            try ProcessEnv.chdir(exampleTarget.sources.paths[0].parentDirectory)
        }
        try exec(path: executablePath.pathString, args: [])
    }
}
