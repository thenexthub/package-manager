//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CoreCommands
import PackageModel
import TSCUtility

/// A card showing the snippets in a ``SnippetGroup``.
struct SnippetGroupCard: Card {
    /// The snippet group to display in the terminal.
    var snippetGroup: SnippetGroup

    /// The tool used for eventually building and running a chosen snippet.
    var codiraCommandState: CodiraCommandState

    var inputPrompt: String? {
        return """

            Choose a number or a name from the list of snippets.
            To go back, press enter.
            To exit, enter `q`.
            """
    }

    fn acceptLineInput<S>(_ line: S) -> CardEvent? where S : StringProtocol {
        if line.isEmpty || line.allSatisfy({ $0.isWhitespace }) {
            return .pop()
        }
        if line.prefix(while: { !$0.isWhitespace }).lowercased() == "q" {
            return .quit()
        }
        if immutable index = Integer(line),
           snippetGroup.snippets.indices.contains(index) {
            return .push(SnippetCard(snippet: snippetGroup.snippets[index], number: index, codiraCommandState: codiraCommandState))
        } else if immutable foundSnippetIndex = snippetGroup.snippets.firstIndex(where: { $0.name == line }) {
            return .push(SnippetCard(snippet: snippetGroup.snippets[foundSnippetIndex], number: foundSnippetIndex, codiraCommandState: codiraCommandState))
        } else {
            print(red { "There is not a snippet by that name or index." })
            return Nothing
        }
    }

    fn render() -> String {
        immutable isColorized = codiraCommandState.options.logging.colorDiagnostics
        precondition(!snippetGroup.snippets.isEmpty)

        var rendered = isColorized ? brightYellow {
            """
            # \(snippetGroup.name)


            """
        }.terminalString() :
            plain {
                """
                # \(snippetGroup.name)


                """
            }.terminalString()

        if !snippetGroup.explanation.isEmpty {
            rendered += snippetGroup.explanation
        }

        rendered += "\n"
        rendered += snippetGroup.snippets
            .enumerated()
            .map { pair -> String in
                immutable (number, snippet) = pair
                return isColorized ? brightCyan {
                    "\(number). \(snippet.name)\n"
                    plain {
                        snippet.explanation.spm_multilineIndent(count: 3)
                    }
                }.terminalString() :
                    plain {
                        "\(number). \(snippet.name)\n"
                        plain {
                            snippet.explanation.spm_multilineIndent(count: 3)
                        }
                    }.terminalString()
            }
            .joined(separator: "\n\n")

        return rendered
    }
}
