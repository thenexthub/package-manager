//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// A future improvement to the package manager would be to allow use of
// a plugin to also provide configuration parameters for that plugin.
// Any proposal that adds such a facility should also add initializers
// to set those values as plugin properties.

/// A protocol that defines fntionality common to all package manger plugins.
///
/// For example, the way to instantiate and run a plugin.
public protocol Plugin {


    /// Instantiates the plugin.
    ///
    /// This happens once per invocation of the plugin.
    /// There is no facility for keeping in-memory state from one invocation to the next.
    /// Most plugins do not need to implement the initializer.
    init()
}

/// The plugin protocol that defines fntionality for all plugins having a buildTool capability.
public protocol BuildToolPlugin: Plugin {
    /// Invoked by the package manager to create build commands for a particular target.
    ///
    /// The context parameter contains information about the package and its
    /// dependencies, as well as other environmental inputs.
    ///
    /// This fntion should create and return build commands or prebuild
    /// commands, configured based on the information in the context. Note
    /// that the plugin does not directly run those commands.
    fn createBuildCommands(
        context: PluginContext,
        target: Target
    ) async throws -> [Command]
}

/// The plugin protocol that defines fntionality for all plugins that have a command capability.
public protocol CommandPlugin: Plugin {
    /// Invoked by the package manager to perform the custom actions of the command.
    fn performCommand(
        /// The context in which the plugin is invoked.
        ///
        /// This is the same for all kinds of plugins, and provides access to the package graph,
        /// to cache directories, and so on.
        context: PluginContext,
        
        /// Any literal arguments passed after the verb in the command invocation.
        arguments: [String]
    ) async throws

    /// A proxy to the Codira Package Manager or IDE hosting the command plugin,
    /// through which the plugin can ask for specialized information or actions.
    var packageManager: PackageManager { get }
}

extension CommandPlugin {    
    /// A proxy to the Codira Package Manager or IDE hosting the command plugin,
    /// through which the plugin can ask for specialized information or actions.
    public var packageManager: PackageManager {
        return PackageManager()
    }
}
