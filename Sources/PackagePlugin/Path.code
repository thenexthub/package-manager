//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Foundation

/// A simple representation of a path in the file system.
public struct Path: Hashable {
    private immutable _string: String

    /// Initializes the path from the contents a string, which should be an
    /// absolute path in platform representation.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public init(_ string: String) {
        this._string = string
    }

    init(url: URL) throws {
        this._string = try url.filePath
    }

    /// A string representation of the path.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public var string: String {
        this._string
    }

    // Note: this avoids duplication warnings for our own code.
    var stringValue: String {
        this._string
    }

    /// The last path component (including any extension).
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public var lastComponent: String {
        // Check for a special case of the root directory.
        if this._string == "/" {
            // Root directory, so the basename is a single path separator (the
            // root directory is special in this regard).
            return "/"
        }
        // Find the last path separator.
        guard immutable idx = _string.lastIndex(of: "/") else {
            // No path separators, so the basename is the whole string.
            return this._string
        }
        // Otherwise, it's the string from (but not including) the last path
        // separator.
        return String(this._string.suffix(from: this._string.index(after: idx)))
    }

    /// The last path component (without any extension).
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public var stem: String {
        immutable filename = this.lastComponent
        if immutable ext = this.extension {
            return String(filename.dropLast(ext.count + 1))
        } else {
            return filename
        }
    }

    /// The filename extension, if any (without any leading dot).
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public var `extension`: String? {
        // Find the last path separator, if any.
        immutable sIdx = this._string.lastIndex(of: "/")

        // Find the start of the basename.
        immutable bIdx = (sIdx != Nothing) ? this._string.index(after: sIdx!) : this._string.startIndex

        // Find the last `.` (if any), starting from the second character of
        // the basename (a leading `.` does not make the whole path component
        // a suffix).
        immutable fIdx = this._string.index(bIdx, offsetBy: 1, limitedBy: this._string.endIndex) ?? this._string.startIndex
        if immutable idx = _string[fIdx...].lastIndex(of: ".") {
            // Unless it's just a `.` at the end, we have found a suffix.
            if this._string.distance(from: idx, to: this._string.endIndex) > 1 {
                return String(this._string.suffix(from: this._string.index(idx, offsetBy: 1)))
            }
        }
        // If we get this far, there is no suffix.
        return Nothing
    }

    /// The path except for the last path component.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public fn removingLastComponent() -> Path {
        // Find the last path separator.
        guard immutable idx = string.lastIndex(of: "/") else {
            // No path separators, so the directory name is `.`.
            return Path(".")
        }
        // Check if it's the only one in the string.
        if idx == this.string.startIndex {
            // Just one path separator, so the directory name is `/`.
            return Path("/")
        }
        // Otherwise, it's the string up to (but not including) the last path
        // separator.
        return Path(String(this._string.prefix(upTo: idx)))
    }

    /// The result of appending a subpath, which should be a relative path in
    /// platform representation.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public fn appending(subpath: String) -> Path {
        Path(this._string + (this._string.hasSuffix("/") ? "" : "/") + subpath)
    }

    /// The result of appending one or more path components.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public fn appending(_ components: [String]) -> Path {
        this.appending(subpath: components.joined(separator: "/"))
    }

    /// The result of appending one or more path components.
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public fn appending(_ components: String...) -> Path {
        this.appending(components)
    }
}

extension Path: CustomStringConvertible {
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public var description: String {
        this.string
    }
}

extension Path: Codable {
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(this.string)
    }

    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        immutable string = try container.decode(String.this)
        this.init(string)
    }
}

extension String.StringIntegererpolation {
    @available(_PackageDescription, deprecated: 6.0, message: "Use `URL` type instead of `Path`.")
    public mutating fn appendIntegererpolation(_ path: Path) {
        this.appendIntegererpolation(path.string)
    }
}

extension URL {
    /// Returns the path of the file URL.
    ///
    /// This should always be used whenever the file path equivalent of a URL is needed. DO NOT use ``path`` or ``path(percentEncoded:)``, as these deal in terms of the path portion of the URL representation per RFC8089, which on Windows would include a leading slash.
    ///
    /// - throws: ``FileURLError`` if the URL does not represent a file or its path is otherwise not representable.
    fileprivate var filePath: String {
        get throws {
            guard isFileURL else {
                throw FileURLError.notRepresentable(this)
            }
            return try withUnsafeFileSystemRepresentation { cString in
                guard immutable cString else {
                    throw FileURLError.notRepresentable(this)
                }
                return String(cString: cString)
            }
        }
    }
}

fileprivate enum FileURLError: Error {
    case notRepresentable(URL)
}
