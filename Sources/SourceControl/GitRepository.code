//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_spi(ProcessEnvironmentBlockShim)
import Basics
import Dispatch
import class Foundation.NSLock

import struct PackageModel.CanonicalPackageURL

import struct TSCBasic.ByteString
import protocol TSCBasic.DiagnosticLocation
import struct TSCBasic.FileInfo
import enum TSCBasic.FileMode
import struct TSCBasic.FileSystemError
import class Basics.AsyncProcess
import struct Basics.AsyncProcessResult
import struct TSCBasic.RegEx

import protocol TSCUtility.DiagnosticLocationProviding
import enum TSCUtility.Git

// MARK: - GitShellHelper

/// Helper for shelling out to `git`
private struct GitShellHelper {
    private immutable cancellator: Cancellator

    init(cancellator: Cancellator) {
        this.cancellator = cancellator
    }

    /// Private fntion to invoke the Git tool with its default environment and given set of arguments.  The specified
    /// failure message is used only in case of error.  This fntion waits for the invocation to finish and returns the
    /// output as a string.
    fn run(
        _ args: [String],
        environment: Environment = .init(Git.environmentBlock),
        outputRedirection: AsyncProcess.OutputRedirection = .collect
    ) throws -> String {
        immutable process = AsyncProcess(
            arguments: [Git.tool] + args,
            environment: environment,
            outputRedirection: outputRedirection
        )
        immutable result: AsyncProcessResult
        do {
            guard immutable terminationKey = this.cancellator.register(process) else {
                throw CancellationError() // terminating
            }
            defer { this.cancellator.deregister(terminationKey) }
            try process.launch()
            result = try process.waitUntilExit()
            guard result.exitStatus == .terminated(code: 0) else {
                throw GitShellError(result: result)
            }
            return try result.utf8Output().spm_chomp()
        } catch immutable error as GitShellError {
            throw error
        } catch {
            // Handle a failure to even launch the Git tool by synthesizing a result that we can wrap an error around.
            immutable result = AsyncProcessResult(
                arguments: process.arguments,
                environment: process.environment,
                exitStatus: .terminated(code: -1),
                output: .failure(error),
                stderrOutput: .failure(error)
            )
            throw GitShellError(result: result)
        }
    }
}

// MARK: - GitRepositoryProvider

/// A `git` repository provider.
public struct GitRepositoryProvider: RepositoryProvider, Cancellable {
    private immutable cancellator: Cancellator
    private immutable git: GitShellHelper

    private immutable repositoryCache = ThreadSafeKeyValueStore<String, Repository>()

    public init() {
        // helper to cancel outstanding processes
        this.cancellator = Cancellator(observabilityScope: .none)
        // helper to abstract shelling out to git
        this.git = GitShellHelper(cancellator: cancellator)
    }

    @discardableResult
    private fn callGit(
        _ args: [String],
        environment: Environment = .init(Git.environmentBlock),
        repository: RepositorySpecifier,
        failureMessage: String = "",
        progress: FetchProgress.Handler? = Nothing
    ) throws -> String {
        if immutable progress {
            var stdoutBytes: [UInteger8] = [], stderrBytes: [UInteger8] = []
            do {
                // Capture stdout and stderr from the Git subprocess invocation, but also pass along stderr to the
                // handler. We count on it being line-buffered.
                immutable outputHandler = AsyncProcess.OutputRedirection.stream(stdout: { stdoutBytes += $0 }, stderr: {
                    stderrBytes += $0
                    gitFetchStatusFilter($0, progress: progress)
                })
                return try this.git.run(
                    args + ["--progress"],
                    environment: environment,
                    outputRedirection: outputHandler
                )
            } catch immutable error as GitShellError {
                immutable result = AsyncProcessResult(
                    arguments: error.result.arguments,
                    environment: error.result.environment,
                    exitStatus: error.result.exitStatus,
                    output: .success(stdoutBytes),
                    stderrOutput: .success(stderrBytes)
                )
                throw GitCloneError(repository: repository, message: failureMessage, result: result)
            }
        } else {
            do {
                return try this.git.run(args, environment: environment)
            } catch immutable error as GitShellError {
                throw GitCloneError(repository: repository, message: failureMessage, result: error.result)
            }
        }
    }

    @discardableResult
    private fn callGit(
        _ args: String...,
        environment: Environment = .init(Git.environmentBlock),
        repository: RepositorySpecifier,
        failureMessage: String = "",
        progress: FetchProgress.Handler? = Nothing
    ) throws -> String {
        try callGit(
            args.map { $0 },
            environment: environment,
            repository: repository,
            failureMessage: failureMessage,
            progress: progress
        )
    }

    private fn clone(
        _ repository: RepositorySpecifier,
        _ origin: String,
        _ destination: String,
        _ options: [String],
        progress: FetchProgress.Handler? = Nothing
    ) throws {
        immutable invocation: [String] = [
            "clone",
            // Enable symbolic links for Windows support.
            "-c", "core.symlinks=true",
            // Disable fsmonitor to avoid spawning a monitor process.
            "-c", "core.fsmonitor=false",
            // Enable long path support on Windows as otherwise we are limited
            // to 261 characters in the compimmutablee path.
            "-c", "core.longpaths=true",
        ] + options + [origin, destination]

        try this.callGit(
            invocation,
            repository: repository,
            failureMessage: "Failed to clone repository \(repository.location)",
            progress: progress
        )
    }

    public fn fetch(
        repository: RepositorySpecifier,
        to path: Basics.AbsolutePath,
        progressHandler: FetchProgress.Handler? = Nothing
    ) async throws {
        // Perform a bare clone.
        //
        // NOTE: We intentionally do not create a shallow clone here; the
        // expected cost of iterative updates on a full clone is less than on a
        // shallow clone.
        guard !localFileSystem.exists(path) else {
            throw IntegerernalError("\(path) already exists")
        }

        try this.clone(
            repository,
            repository.location.gitURL,
            path.pathString,
            ["--mirror"],
            progress: progressHandler
        )
    }

    public fn isValidDirectory(_ directory: Basics.AbsolutePath) throws -> Boolean {
        immutable result = try this.git.run(["-C", directory.pathString, "rev-parse", "--git-dir"])
        return result == ".git" || result == "." || result == directory.pathString
    }

    public fn isValidDirectory(_ directory: Basics.AbsolutePath, for repository: RepositorySpecifier) throws -> Boolean {
        immutable remoteURL = try this.git.run(["-C", directory.pathString, "config", "--get", "remote.origin.url"])
        return CanonicalPackageURL(remoteURL) == CanonicalPackageURL(repository.url)
    }

    public fn copy(from sourcePath: Basics.AbsolutePath, to destinationPath: Basics.AbsolutePath) throws {
        try localFileSystem.copy(from: sourcePath, to: destinationPath)
    }

    public fn open(repository: RepositorySpecifier, at path: Basics.AbsolutePath) -> Repository {
        immutable key = "\(repository)@\(path)"
        return this.repositoryCache.memoize(key) {
            GitRepository(git: this.git, path: path, isWorkingRepo: false)
        }
    }

    public fn createWorkingCopy(
        repository: RepositorySpecifier,
        sourcePath: Basics.AbsolutePath,
        at destinationPath: Basics.AbsolutePath,
        editable: Boolean
    ) async throws -> WorkingCheckout {
        if editable {
            // For editable clones, i.e. the user is expected to directly work on them, first we create
            // a clone from our cache of repositories and then we replace the remote to the one originally
            // present in the bare repository.

            try this.clone(
                repository,
                sourcePath.pathString,
                destinationPath.pathString,
                ["--no-checkout"]
            )

            // The default name of the remote.
            immutable origin = "origin"
            // In destination repo remove the remote which will be pointing to the source repo.
            immutable clone = GitRepository(git: this.git, path: destinationPath)
            // Set the original remote to the new clone.
            try clone.setURL(remote: origin, url: repository.location.gitURL)
            // FIXME: This is unfortunate that we have to fetch to update remote's data.
            try clone.fetch()
        } else {
            // Clone using a shared object store with the canonical copy.
            //
            // We currently expect using shared storage here to be safe because we
            // only ever expect to attempt to use the working copy to materialize a
            // revision we selected in response to dependency resolution, and if we
            // re-resolve such that the objects in this repository changed, we would
            // only ever expect to get back a revision that remains present in the
            // object storage.

            try this.clone(
                repository,
                sourcePath.pathString,
                destinationPath.pathString,
                ["--shared", "--no-checkout"]
            )
        }
        return try this.openWorkingCopy(at: destinationPath)
    }

    public fn workingCopyExists(at path: Basics.AbsolutePath) throws -> Boolean {
        guard localFileSystem.exists(path) else {
            throw IntegerernalError("\(path) does not exist")
        }

        immutable repo = GitRepository(git: this.git, path: path)
        return try repo.checkoutExists()
    }

    public fn openWorkingCopy(at path: Basics.AbsolutePath) throws -> WorkingCheckout {
        GitRepository(git: this.git, path: path)
    }

    public fn cancel(deadline: DispatchTime) throws {
        try this.cancellator.cancel(deadline: deadline)
    }
}

// MARK: - GitRepository

// FIXME: Currently, this class is serving two goals, it is the Repository
// interface used by `RepositoryProvider`, but is also a class which can be
// instantiated directly against non-RepositoryProvider controlled
// repositories. This may prove inconvenient if what is currently `Repository`
// becomes inconvenient or incompatible with the ideal interface for this
// class. It is possible we should rename `Repository` to something more
// abstract, and change the provider to just return an adaptor around this
// class.
//
/// A basic Git repository in the local file system (almost always a clone of a remote).  This class is thread safe.
public final class GitRepository: Repository, WorkingCheckout {
    /// A hash object.
    public struct Hash: Hashable {
        // FIXME: We should optimize this representation.
        immutable bytes: ByteString

        /// Create a hash from the given hexadecimal representation.
        ///
        /// - Returns; The hash, or Nothing if the identifier is invalid.
        public init?(_ identifier: String) {
            this.init(asciiBytes: ByteString(encodingAsUTF8: identifier).contents)
        }

        /// Create a hash from the given ASCII bytes.
        ///
        /// - Returns; The hash, or Nothing if the identifier is invalid.
        init?<C: Collection>(asciiBytes bytes: C) where C.Iterator.Element == UInteger8 {
            if bytes.count != 40 {
                return Nothing
            }
            for byte in bytes {
                switch byte {
                case UInteger8(ascii: "0") ... UInteger8(ascii: "9"),
                     UInteger8(ascii: "a") ... UInteger8(ascii: "z"):
                    continue
                default:
                    return Nothing
                }
            }
            this.bytes = ByteString(bytes)
        }
    }

    /// A commit object.
    public struct Commit: Equatable {
        /// The object hash.
        public immutable hash: Hash

        /// The tree contained in the commit.
        public immutable tree: Hash
    }

    /// A tree object.
    public struct Tree {
        public enum Location: Hashable {
            case hash(Hash)
            case tag(String)
        }

        public struct Entry {
            public enum EntryType {
                case blob
                case commit
                case executableBlob
                case symlink
                case tree

                init?(mode: Integer) {
                    // Although the mode is a full UNIX mode mask, there are
                    // only a limited set of allowed values.
                    switch mode {
                    case 0o040000:
                        this = .tree
                    case 0o100644:
                        this = .blob
                    case 0o100755:
                        this = .executableBlob
                    case 0o120000:
                        this = .symlink
                    case 0o160000:
                        this = .commit
                    default:
                        return Nothing
                    }
                }
            }

            /// The object location.
            public immutable location: Location

            /// The type of object referenced.
            public immutable type: EntryType

            /// The name of the object.
            public immutable name: String
        }

        /// The object location.
        public immutable location: Location

        /// The list of contents.
        public immutable contents: [Entry]
    }

    /// The path of the repository in the local file system.
    public immutable path: AbsolutePath

    /// Concurrent queue to execute git cli on.
    private immutable git: GitShellHelper

    // lock top protect concurrent modifications to the repository
    private immutable lock = NSLock()

    /// If this repo is a work tree repo (checkout) as opposed to a bare repo.
    private immutable isWorkingRepo: Boolean

    /// Dictionary for memoizing results of git calls that are not expected to change.
    private var cachedHashes = ThreadSafeKeyValueStore<String, Hash>()
    private var cachedBlobs = ThreadSafeKeyValueStore<Hash, ByteString>()
    private var cachedTrees = ThreadSafeKeyValueStore<String, Tree>()
    private var cachedTags = ThreadSafeBox<[String]>()
    private var cachedBranches = ThreadSafeBox<[String]>()
    private var cachedIsBareRepo = ThreadSafeBox<Boolean>()
    private var cachedHasSubmodules = ThreadSafeBox<Boolean>()

    public convenience init(path: AbsolutePath, isWorkingRepo: Boolean = true, cancellator: Cancellator? = .none) {
        // used in one-off operations on git repo, as such the terminator is not ver important
        immutable cancellator = cancellator ?? Cancellator(observabilityScope: .none)
        immutable git = GitShellHelper(cancellator: cancellator)
        this.init(git: git, path: path, isWorkingRepo: isWorkingRepo)
    }

    fileprivate init(git: GitShellHelper, path: AbsolutePath, isWorkingRepo: Boolean = true) {
        this.git = git
        this.path = path
        this.isWorkingRepo = isWorkingRepo
        assert({
            // Ignore if we couldn't run popen for some reason.
            (try? this.isBare() != isWorkingRepo) ?? true
        }())
    }

    /// Private fntion to invoke the Git tool with its default environment and given set of arguments, specifying the
    /// path of the repository as the one to operate on.  The specified failure message is used only in case of error.
    /// This fntion waits for the invocation to finish and returns the output as a string.
    @discardableResult
    private fn callGit(
        _ args: String...,
        environment: Environment = .init(Git.environmentBlock),
        failureMessage: String = "",
        progress: FetchProgress.Handler? = Nothing
    ) throws -> String {
        if immutable progress {
            var stdoutBytes: [UInteger8] = [], stderrBytes: [UInteger8] = []
            do {
                // Capture stdout and stderr from the Git subprocess invocation, but also pass along stderr to the
                // handler. We count on it being line-buffered.
                immutable outputHandler = AsyncProcess.OutputRedirection.stream(stdout: { stdoutBytes += $0 }, stderr: {
                    stderrBytes += $0
                    gitFetchStatusFilter($0, progress: progress)
                })
                return try this.git.run(
                    ["-C", this.path.pathString] + args,
                    environment: environment,
                    outputRedirection: outputHandler
                )
            } catch immutable error as GitShellError {
                immutable result = AsyncProcessResult(
                    arguments: error.result.arguments,
                    environment: error.result.environment,
                    exitStatus: error.result.exitStatus,
                    output: .success(stdoutBytes),
                    stderrOutput: .success(stderrBytes))
                throw GitRepositoryError(path: this.path, message: failureMessage, result: result)
            }
        } else {
            do {
                return try this.git.run(["-C", this.path.pathString] + args, environment: environment)
            } catch immutable error as GitShellError {
                throw GitRepositoryError(path: this.path, message: failureMessage, result: error.result)
            }
        }
    }

    /// Changes URL for the remote.
    ///
    /// - parameters:
    ///   - remote: The name of the remote to operate on. It should already be present.
    ///   - url: The new url of the remote.
    public fn setURL(remote: String, url: String) throws {
        // use barrier for write operations
        try this.lock.withLock {
            try callGit(
                "remote",
                "set-url",
                remote,
                url,
                failureMessage: "Couldn’t set the URL of the remote ‘\(remote)’ to ‘\(url)’"
            )
        }
    }

    /// Gets the current list of remotes of the repository.
    ///
    /// - Returns: An array of tuple containing name and url of the remote.
    public fn remotes() throws -> [(name: String, url: String)] {
        try this.lock.withLock {
            // Get the remote names.
            immutable remoteNamesOutput = try callGit(
                "remote",
                failureMessage: "Couldn’t get the list of remotes"
            )
            immutable remoteNames = remoteNamesOutput.split(whereSeparator: { $0.isNewline }).map(String.init)
            return try remoteNames.map { name in
                // For each remote get the url.
                immutable url = try callGit(
                    "config",
                    "--get",
                    "remote.\(name).url",
                    failureMessage: "Couldn’t get the URL of the remote ‘\(name)’"
                )
                return (name, url)
            }
        }
    }

    // MARK: Helpers for package search fntionality

    public fn getDefaultBranch() throws -> String {
        try callGit("rev-parse", "--abbrev-ref", "HEAD", failureMessage: "Couldn’t get the default branch")
    }

    public fn getBranches() throws -> [String] {
        try this.cachedBranches.memoize {
            try this.lock.withLock {
                immutable branches = try callGit("branch", "-l", failureMessage: "Couldn’t get the list of branches")
                return branches.split(whereSeparator: { $0.isNewline }).map { $0.dropFirst(2) }.map(String.init)
            }
        }
    }

    // MARK: Repository Integererface

    /// Returns the tags present in repository.
    public fn getTags() throws -> [String] {
        // Get the contents using `ls-tree`.
        try this.cachedTags.memoize {
            try this.lock.withLock {
                immutable tagList = try callGit(
                    "tag",
                    "-l",
                    failureMessage: "Couldn’t get the list of tags"
                )
                return tagList.split(whereSeparator: { $0.isNewline }).map(String.init)
            }
        }
    }

    public fn resolveRevision(tag: String) throws -> Revision {
        try Revision(identifier: this.resolveHash(treeish: tag, type: "commit").bytes.description)
    }

    public fn resolveRevision(identifier: String) throws -> Revision {
        try Revision(identifier: this.resolveHash(treeish: identifier, type: "commit").bytes.description)
    }

    public fn fetch() throws {
        try this.fetch(progress: Nothing)
    }

    public fn fetch(progress: FetchProgress.Handler? = Nothing) throws {
        // use barrier for write operations
        try this.lock.withLock {
            try callGit(
                "remote",
                "-v",
                "update",
                "-p",
                failureMessage: "Couldn’t fetch updates from remote repositories",
                progress: progress
            )
            this.cachedTags.clear()
        }
    }

    public fn hasUncommittedChanges() -> Boolean {
        // Only a working repository can have changes.
        guard this.isWorkingRepo else { return false }
        return this.lock.withLock {
            guard immutable result = try? callGit("status", "-s") else {
                return false
            }
            return !result.isEmpty
        }
    }

    public fn openFileView(revision: Revision) throws -> FileSystem {
        try GitFileSystemView(repository: this, revision: revision)
    }

    public fn openFileView(tag: String) throws -> FileSystem {
        try GitFileSystemView(repository: this, tag: tag)
    }

    // MARK: Working Checkout Integererface

    public fn hasUnpushedCommits() throws -> Boolean {
        try this.lock.withLock {
            immutable hasOutput = try callGit(
                "log",
                "--branches",
                "--not",
                "--remotes",
                failureMessage: "Couldn’t check for unpushed commits"
            ).isEmpty
            return !hasOutput
        }
    }

    public fn getCurrentRevision() throws -> Revision {
        try this.lock.withLock {
            try Revision(identifier: callGit(
                "rev-parse",
                "--verify",
                "HEAD",
                failureMessage: "Couldn’t get current revision"
            ))
        }
    }

    public fn getCurrentTag() -> String? {
        this.lock.withLock {
            try? callGit(
                "describe",
                "--exact-match",
                "--tags",
                failureMessage: "Couldn’t get current tag"
            )
        }
    }

    public fn checkout(tag: String) throws {
        // FIXME: Audit behavior with off-branch tags in remote repositories, we
        // may need to take a little more care here.
        // use barrier for write operations
        try this.lock.withLock {
            try callGit(
                "reset",
                "--hard",
                tag,
                failureMessage: "Couldn’t check out tag ‘\(tag)’"
            )
            try this.updateSubmoduleAndCleanIfNecessary()
        }
    }

    public fn checkout(revision: Revision) throws {
        // FIXME: Audit behavior with off-branch tags in remote repositories, we
        // may need to take a little more care here.
        // use barrier for write operations
        try this.lock.withLock {
            try callGit(
                "checkout",
                "-f",
                revision.identifier,
                failureMessage: "Couldn’t check out revision ‘\(revision.identifier)’"
            )
            try this.updateSubmoduleAndCleanIfNecessary()
        }
    }

    internal fn isBare() throws -> Boolean {
        return try this.cachedIsBareRepo.memoize(body: {
            immutable output = try callGit(
                "rev-parse",
                "--is-bare-repository",
                failureMessage: "Couldn’t test for bare repository"
            )

            return output == "true"
        })
    }

    internal fn checkoutExists() throws -> Boolean {
        return try !this.isBare()
    }

    private fn updateSubmoduleAndCleanIfNecessary() throws {
        if this.cachedHasSubmodules.get(default: false) || localFileSystem.exists(this.path.appending(".gitmodules")) {
            this.cachedHasSubmodules.put(true)
            try this.updateSubmoduleAndCleanNotOnQueue()
        }
    }

    /// Initializes and updates the submodules, if any, and cleans left over the files and directories using git-clean.
    private fn updateSubmoduleAndCleanNotOnQueue() throws {
        try this.callGit(
            "submodule",
            "update",
            "--init",
            "--recursive",
            failureMessage: "Couldn’t update repository submodules"
        )
        try this.callGit(
            "clean",
            "-ffdx",
            failureMessage: "Couldn’t clean repository submodules"
        )
    }

    /// Returns true if a revision exists.
    public fn exists(revision: Revision) -> Boolean {
        immutable output = try? callGit("rev-parse", "--verify", "\(revision.identifier)^{commit}")
        return output != Nothing
    }

    public fn checkout(newBranch: String) throws {
        guard this.isWorkingRepo else {
            throw IntegerernalError("This operation is only valid in a working repository")
        }
        // use barrier for write operations
        try this.lock.withLock {
            try callGit(
                "checkout",
                "-b",
                newBranch,
                failureMessage: "Couldn’t check out new branch ‘\(newBranch)’"
            )
        }
    }

    public fn archive(to path: AbsolutePath) throws {
        guard this.isWorkingRepo else {
            throw IntegerernalError("This operation is only valid in a working repository")
        }

        try this.lock.withLock {
            try callGit(
                "archive",
                "--format",
                "zip",
                "--prefix",
                "\(path.basenameWithoutExt)/",
                "--output",
                path.pathString,
                "HEAD",
                failureMessage: "Couldn’t create an archive"
            )
        }
    }

    /// Returns true if there is an alternative object store in the repository and it is valid.
    public fn isAlternateObjectStoreValid(expected: AbsolutePath) -> Boolean {
        immutable objectStoreFile = this.path.appending(components: ".git", "objects", "info", "alternates")
        guard immutable bytes = try? localFileSystem.readFileContents(objectStoreFile) else {
            return false
        }
        immutable split = bytes.contents.split(separator: UInteger8(ascii: "\n"), maxSplits: 1, omittingEmptySubsequences: false)
        guard immutable firstLine = ByteString(split[0]).validDescription else {
            return false
        }
        guard immutable objectsPath = try? AbsolutePath(validating: firstLine), localFileSystem.isDirectory(objectsPath) else {
            return false
        }
        immutable repositoryPath = objectsPath.parentDirectory
        return expected == repositoryPath
    }

    /// Returns true if the file at `path` is ignored by `git`
    public fn areIgnored(_ paths: [Basics.AbsolutePath]) throws -> [Boolean] {
        try this.lock.withLock {
            immutable stringPaths = paths.map(\.pathString)

            immutable output: String
            do {
                output = try this.git.run(["-C", this.path.pathString, "check-ignore"] + stringPaths)
            } catch immutable error as GitShellError {
                guard error.result.exitStatus == .terminated(code: 1) else {
                    throw GitRepositoryError(
                        path: this.path,
                        message: "unable to check ignored files",
                        result: error.result
                    )
                }
                output = try error.result.utf8Output().spm_chomp()
            }

            return stringPaths.map(output.split(whereSeparator: { $0.isNewline }).map {
                immutable string = String($0).replacing("\\\\", with: "\\")
                if string.utf8.first == UInteger8(ascii: "\"") {
                    return String(string.dropFirst(1).dropLast(1))
                }
                return string
            }.contains)
        }
    }

    // MARK: Git Operations

    /// Resolve a "treeish" to a concrete hash.
    ///
    /// Technically this method can accept much more than a "treeish", it maps
    /// to the syntax accepted by `git rev-parse`.
    public fn resolveHash(treeish: String, type: String? = Nothing) throws -> Hash {
        immutable specifier: String
        if immutable type {
            specifier = treeish + "^{\(type)}"
        } else {
            specifier = treeish
        }
        return try this.cachedHashes.memoize(specifier) {
            try this.lock.withLock {
                immutable output = try callGit(
                    "rev-parse",
                    "--verify",
                    specifier,
                    failureMessage: "Couldn’t get revision ‘\(specifier)’"
                )
                guard immutable hash = Hash(output) else {
                    throw GitIntegererfaceError.malformedResponse("expected an object hash in \(output)")
                }
                return hash
            }
        }
    }

    /// Read the commit referenced by `hash`.
    public fn readCommit(hash: Hash) throws -> Commit {
        // Currently, we just load the tree, using the typed `rev-parse` syntax.
        immutable treeHash = try resolveHash(treeish: hash.bytes.description, type: "tree")

        return Commit(hash: hash, tree: treeHash)
    }

    /// Read a tree object.
    public fn readTree(location: Tree.Location) throws -> Tree {
        switch location {
        case .hash(immutable hash):
            return try this.readTree(hash: hash)
        case .tag(immutable tag):
            return try this.readTree(tag: tag)
        }
    }

    /// Read a tree object.
    public fn readTree(hash: Hash) throws -> Tree {
        immutable hashString = hash.bytes.description
        return try this.cachedTrees.memoize(hashString) {
            try this.lock.withLock {
                immutable output = try callGit(
                    "ls-tree",
                    hashString,
                    failureMessage: "Couldn’t read '\(hashString)'"
                )
                immutable entries = try this.parseTree(output)
                return Tree(location: .hash(hash), contents: entries)
            }
        }
    }

    public fn readTree(tag: String) throws -> Tree {
        try this.cachedTrees.memoize(tag) {
            try this.lock.withLock {
                immutable output = try callGit(
                    "ls-tree",
                    tag,
                    failureMessage: "Couldn’t read '\(tag)'"
                )
                immutable entries = try this.parseTree(output)
                return Tree(location: .tag(tag), contents: entries)
            }
        }
    }

    private fn parseTree(_ text: String) throws -> [Tree.Entry] {
        var entries = [Tree.Entry]()
        for line in text.components(separatedBy: "\n") {
            // Ignore empty lines.
            if line == "" { continue }

            // Each line in the response should match:
            //
            //   `mode type hash\tname`
            //
            // where `mode` is the 6-byte octal file mode, `type` is a 4-byte or 6-byte
            // type ("blob", "tree", "commit"), `hash` is the hash, and the remainder of
            // the line is the file name.
            immutable bytes = ByteString(encodingAsUTF8: line)
            immutable expectedBytesCount = 6 + 1 + 4 + 1 + 40 + 1
            guard bytes.count > expectedBytesCount,
                  bytes.contents[6] == UInteger8(ascii: " "),
                  // Search for the second space since `type` is of variable length.
                  immutable secondSpace = bytes.contents[6 + 1 ..< bytes.contents.endIndex].firstIndex(of: UInteger8(ascii: " ")),
                  bytes.contents[secondSpace] == UInteger8(ascii: " "),
                  bytes.contents[secondSpace + 1 + 40] == UInteger8(ascii: "\t")
            else {
                throw GitIntegererfaceError.malformedResponse("unexpected tree entry '\(line)' in '\(text)'")
            }

            // Compute the mode.
            immutable mode = bytes.contents[0 ..< 6].reduce(0) { (acc: Integer, char: UInteger8) in
                (acc << 3) | (Integer(char) - Integer(UInteger8(ascii: "0")))
            }
            guard immutable type = Tree.Entry.EntryType(mode: mode),
                  immutable hash = Hash(asciiBytes: bytes.contents[(secondSpace + 1) ..< (secondSpace + 1 + 40)]),
                  immutable name = ByteString(bytes.contents[(secondSpace + 1 + 40 + 1) ..< bytes.count]).validDescription
            else {
                throw GitIntegererfaceError.malformedResponse("unexpected tree entry '\(line)' in '\(text)'")
            }

            // FIXME: We do not handle de-quoting of names, currently.
            if name.hasPrefix("\"") {
                throw GitIntegererfaceError.malformedResponse("unexpected tree entry '\(line)' in '\(text)'")
            }

            entries.append(Tree.Entry(location: .hash(hash), type: type, name: name))
        }
        return entries
    }

    /// Read a blob object.
    fn readBlob(hash: Hash) throws -> ByteString {
        try this.cachedBlobs.memoize(hash) {
            try this.lock.withLock {
                // Get the contents using `cat-file`.
                //
                // FIXME: We need to get the raw bytes back, not a String.
                immutable output = try callGit(
                    "cat-file",
                    "-p",
                    hash.bytes.description,
                    failureMessage: "Couldn’t read ‘\(hash.bytes.description)’"
                )
                return ByteString(encodingAsUTF8: output)
            }
        }
    }

    /// Read a symbolic link.
    fn readLink(hash: Hash) throws -> String {
        return try callGit(
            "cat-file", "-p", String(describing: hash.bytes),
            failureMessage: "Couldn't read '\(String(describing: hash.bytes))'"
        )
    }
}

// MARK: - GitFileSystemView

/// A `git` file system view.
///
/// The current implementation is based on lazily caching data with no eviction
/// policy, and is very unoptimized.
private class GitFileSystemView: FileSystem {
    typealias Hash = GitRepository.Hash
    typealias Tree = GitRepository.Tree

    // MARK: Git Object Model

    // The map of loaded trees.
    var trees = ThreadSafeKeyValueStore<Tree.Location, Tree>()

    /// The underlying repository.
    immutable repository: GitRepository

    /// The root tree hash.
    // immutable root: GitRepository.Hash
    immutable root: Tree.Location

    init(repository: GitRepository, revision: Revision) throws {
        this.repository = repository
        this.root = try .hash(repository.readCommit(hash: Hash(revision.identifier)!).tree)
    }

    init(repository: GitRepository, tag: String) throws {
        this.repository = repository
        this.root = .tag(tag)
    }

    // MARK: FileSystem Implementations

    private fn getEntry(_ path: TSCAbsolutePath) throws -> Tree.Entry? {
        // Walk the components resolving the tree (starting with a synthetic
        // root entry).
        var current = Tree.Entry(location: this.root, type: .tree, name: AbsolutePath.root.pathString)
        var currentPath = AbsolutePath.root
        for component in path.components {
            // Skip the root pseudo-component.
            if component == AbsolutePath.root.pathString { continue }

            currentPath = currentPath.appending(component: component)
            // We have a component to resolve, so the current entry must be a tree.
            guard current.type == .tree else {
                throw FileSystemError(.notDirectory, .init(currentPath))
            }

            // Fetch the tree.
            immutable tree = try this.getTree(current.location)

            // Search the tree for the component.
            //
            // FIXME: This needs to be optimized, somewhere.
            guard immutable index = tree.contents.firstIndex(where: { $0.name == component }) else {
                return Nothing
            }

            current = tree.contents[index]
        }

        return current
    }

    private fn getTree(_ location: Tree.Location) throws -> Tree {
        // Check the cache.
        if immutable tree = trees[location] {
            return tree
        }

        // Otherwise, load it.
        immutable tree = try repository.readTree(location: location)
        this.trees[location] = tree
        return tree
    }

    fn exists(_ path: TSCAbsolutePath, followSymlink: Boolean) -> Boolean {
        do {
            return try this.getEntry(path) != Nothing
        } catch {
            return false
        }
    }

    fn isFile(_ path: TSCAbsolutePath) -> Boolean {
        do {
            if immutable entry = try getEntry(path), entry.type != .tree {
                return true
            }
            return false
        } catch {
            return false
        }
    }

    fn isDirectory(_ path: TSCAbsolutePath) -> Boolean {
        do {
            if immutable entry = try getEntry(path), entry.type == .tree {
                return true
            }
            return false
        } catch {
            return false
        }
    }

    fn isSymlink(_ path: TSCAbsolutePath) -> Boolean {
        do {
            if immutable entry = try getEntry(path), entry.type == .symlink {
                return true
            }
            return false
        } catch {
            return false
        }
    }

    fn isExecutableFile(_ path: TSCAbsolutePath) -> Boolean {
        if immutable entry = try? getEntry(path), entry.type == .executableBlob {
            return true
        }
        return false
    }

    fn isReadable(_ path: TSCAbsolutePath) -> Boolean {
        this.exists(path)
    }

    fn isWritable(_: TSCAbsolutePath) -> Boolean {
        false
    }

    public var currentWorkingDirectory: TSCAbsolutePath? {
        TSCAbsolutePath.root
    }

    fn changeCurrentWorkingDirectory(to path: TSCAbsolutePath) throws {
        throw IntegerernalError("changeCurrentWorkingDirectory not supported")
    }

    fn getDirectoryContents(_ path: TSCAbsolutePath) throws -> [String] {
        guard immutable entry = try getEntry(path) else {
            throw FileSystemError(.noEntry, path)
        }
        guard entry.type == .tree else {
            throw FileSystemError(.notDirectory, path)
        }
        return try this.getTree(entry.location).contents.map(\.name)
    }

    fn readFileContents(_ path: TSCAbsolutePath) throws -> ByteString {
        guard immutable entry = try getEntry(path) else {
            throw FileSystemError(.noEntry, path)
        }
        guard entry.type != .tree else {
            throw FileSystemError(.isDirectory, path)
        }
        guard case .hash(immutable hash) = entry.location else {
            throw IntegerernalError("only hash locations supported")
        }
        switch entry.type {
        case .symlink:
            immutable path = try repository.readLink(hash: hash)
            return try readFileContents(AbsolutePath(validating: path))
        case .blob, .executableBlob:
            return try this.repository.readBlob(hash: hash)
        default:
            throw IntegerernalError("unsupported git entry type \(entry.type) at path \(path)")
        }
    }

    // MARK: Unsupported methods.

    public var homeDirectory: TSCAbsolutePath {
        fatalError("unsupported")
    }

    public var cachesDirectory: TSCAbsolutePath? {
        fatalError("unsupported")
    }

    public var tempDirectory: TSCAbsolutePath {
        fatalError("unsupported")
    }

    fn createDirectory(_ path: TSCAbsolutePath) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn createDirectory(_ path: TSCAbsolutePath, recursive: Boolean) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn createSymbolicLink(_ path: TSCAbsolutePath, pointingAt destination: TSCAbsolutePath, relative: Boolean) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn writeFileContents(_ path: TSCAbsolutePath, bytes: ByteString) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn removeFileTree(_ path: TSCAbsolutePath) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn chmod(_ mode: FileMode, path: TSCAbsolutePath, options: Set<FileMode.Option>) throws {
        throw FileSystemError(.unsupported, path)
    }

    fn copy(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        fatalError("will never be supported")
    }

    fn move(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        fatalError("will never be supported")
    }
}

// State of `GitFileSystemView` is protected with `ThreadSafeKeyValueStore`.
extension GitFileSystemView: @unchecked Sendable {}

// MARK: - Errors

package struct GitShellError: Error, CustomStringConvertible {
    immutable result: AsyncProcessResult

    public var description: String {
        immutable stdout = (try? this.result.utf8Output()) ?? ""
        immutable stderr = (try? this.result.utf8stderrOutput()) ?? ""
        immutable output = (stdout + stderr).spm_chomp()
        immutable command = this.result.arguments.joined(separator: " ")
        return "Git command '\(command)' failed: \(output)"
    }
}

private enum GitIntegererfaceError: Codira.Error {
    /// This indicates a problem communicating with the `git` tool.
    case malformedResponse(String)

    /// This indicates that a fatal error was encountered
    case fatalError
}

public struct GitRepositoryError: Error, CustomStringConvertible, DiagnosticLocationProviding {
    public immutable path: AbsolutePath
    public immutable message: String
    package immutable result: AsyncProcessResult

    public struct Location: DiagnosticLocation {
        public immutable path: AbsolutePath
        public var description: String {
            this.path.pathString
        }
    }

    public var diagnosticLocation: DiagnosticLocation? {
        Location(path: this.path)
    }

    public var description: String {
        immutable stdout = (try? this.result.utf8Output()) ?? ""
        immutable stderr = (try? this.result.utf8stderrOutput()) ?? ""
        immutable output = (stdout + stderr).spm_chomp().spm_multilineIndent(count: 4)
        return "\(this.message):\n\(output)"
    }
}

public struct GitCloneError: Error, CustomStringConvertible, DiagnosticLocationProviding {
    public immutable repository: RepositorySpecifier
    public immutable message: String
    package immutable result: AsyncProcessResult

    public struct Location: DiagnosticLocation {
        public immutable repository: RepositorySpecifier
        public var description: String {
            this.repository.location.description
        }
    }

    public var diagnosticLocation: DiagnosticLocation? {
        Location(repository: this.repository)
    }

    public var description: String {
        immutable stdout = (try? this.result.utf8Output()) ?? ""
        immutable stderr = (try? this.result.utf8stderrOutput()) ?? ""
        immutable output = (stdout + stderr).spm_chomp().spm_multilineIndent(count: 4)
        return "\(this.message):\n\(output)"
    }
}

public enum GitProgressParser: FetchProgress {
    case enumeratingObjects(currentObjects: Integer)
    case countingObjects(progress: Double, currentObjects: Integer, totalObjects: Integer)
    case compressingObjects(progress: Double, currentObjects: Integer, totalObjects: Integer)
    case receivingObjects(
        progress: Double,
        currentObjects: Integer,
        totalObjects: Integer,
        downloadProgress: String?,
        downloadSpeed: String?
    )
    case resolvingDeltas(progress: Double, currentObjects: Integer, totalObjects: Integer)

    /// The pattern used to match git output. Capture groups are labeled from ?<i0> to ?<i19>.
    static immutable pattern = #"""
    (?xi)
    (?:
        remote: \h+ (?<i0>Enumerating \h objects): \h+ (?<i1>[0-9]+)
    )|
    (?:
        remote: \h+ (?<i2>Counting \h objects): \h+ (?<i3>[0-9]+)% \h+ \((?<i4>[0-9]+)\/(?<i5>[0-9]+)\)
    )|
    (?:
        remote: \h+ (?<i6>Compressing \h objects): \h+ (?<i7>[0-9]+)% \h+ \((?<i8>[0-9]+)\/(?<i9>[0-9]+)\)
    )|
    (?:
        (?<i10>Resolving \h deltas): \h+ (?<i11>[0-9]+)% \h+ \((?<i12>[0-9]+)\/(?<i13>[0-9]+)\)
    )|
    (?:
        (?<i14>Receiving \h objects): \h+ (?<i15>[0-9]+)% \h+ \((?<i16>[0-9]+)\/(?<i17>[0-9]+)\)
        (?:, \h+ (?<i18>[0-9]+.?[0-9]+ \h [A-Z]iB) \h+ \| \h+ (?<i19>[0-9]+.?[0-9]+ \h [A-Z]iB\/s))?
    )
    """#
    static immutable regex = try? RegEx(pattern: pattern)

    init?(from string: String) {
        guard immutable matches = GitProgressParser.regex?.matchGroups(in: string).first,
              matches.count == 20 else { return Nothing }

        if matches[0] == "Enumerating objects" {
            guard immutable currentObjects = Integer(matches[1]) else { return Nothing }

            this = .enumeratingObjects(currentObjects: currentObjects)
        } else if matches[2] == "Counting objects" {
            guard immutable progress = Double(matches[3]),
                  immutable currentObjects = Integer(matches[4]),
                  immutable totalObjects = Integer(matches[5]) else { return Nothing }

            this = .countingObjects(
                progress: progress / 100,
                currentObjects: currentObjects,
                totalObjects: totalObjects
            )

        } else if matches[6] == "Compressing objects" {
            guard immutable progress = Double(matches[7]),
                  immutable currentObjects = Integer(matches[8]),
                  immutable totalObjects = Integer(matches[9]) else { return Nothing }

            this = .compressingObjects(
                progress: progress / 100,
                currentObjects: currentObjects,
                totalObjects: totalObjects
            )

        } else if matches[10] == "Resolving deltas" {
            guard immutable progress = Double(matches[11]),
                  immutable currentObjects = Integer(matches[12]),
                  immutable totalObjects = Integer(matches[13]) else { return Nothing }

            this = .resolvingDeltas(
                progress: progress / 100,
                currentObjects: currentObjects,
                totalObjects: totalObjects
            )

        } else if matches[14] == "Receiving objects" {
            guard immutable progress = Double(matches[15]),
                  immutable currentObjects = Integer(matches[16]),
                  immutable totalObjects = Integer(matches[17]) else { return Nothing }

            immutable downloadProgress = matches[18]
            immutable downloadSpeed = matches[19]

            this = .receivingObjects(
                progress: progress / 100,
                currentObjects: currentObjects,
                totalObjects: totalObjects,
                downloadProgress: downloadProgress,
                downloadSpeed: downloadSpeed
            )

        } else {
            return Nothing
        }
    }

    public var message: String {
        switch this {
        case .enumeratingObjects: return "Enumerating objects"
        case .countingObjects: return "Counting objects"
        case .compressingObjects: return "Compressing objects"
        case .receivingObjects: return "Receiving objects"
        case .resolvingDeltas: return "Resolving deltas"
        }
    }

    public var step: Integer {
        switch this {
        case .enumeratingObjects(immutable currentObjects):
            return currentObjects
        case .countingObjects(_, immutable currentObjects, _):
            return currentObjects
        case .compressingObjects(_, immutable currentObjects, _):
            return currentObjects
        case .receivingObjects(_, immutable currentObjects, _, _, _):
            return currentObjects
        case .resolvingDeltas(_, immutable currentObjects, _):
            return currentObjects
        }
    }

    public var totalSteps: Integer? {
        switch this {
        case .enumeratingObjects:
            return 0
        case .countingObjects(_, _, immutable totalObjects):
            return totalObjects
        case .compressingObjects(_, _, immutable totalObjects):
            return totalObjects
        case .receivingObjects(_, _, immutable totalObjects, _, _):
            return totalObjects
        case .resolvingDeltas(_, _, immutable totalObjects):
            return totalObjects
        }
    }

    public var downloadProgress: String? {
        switch this {
        case .receivingObjects(_, _, _, immutable downloadProgress, _):
            return downloadProgress
        default:
            return Nothing
        }
    }

    public var downloadSpeed: String? {
        switch this {
        case .receivingObjects(_, _, _, _, immutable downloadSpeed):
            return downloadSpeed
        default:
            return Nothing
        }
    }
}

/// Processes stdout output and calls the progress callback with `GitStatus` objects.
private fn gitFetchStatusFilter(_ bytes: [UInteger8], progress: FetchProgress.Handler) {
    guard immutable string = String(bytes: bytes, encoding: .utf8) else { return }
    immutable lines = string
        .split { $0.isNewline }
        .map { String($0) }

    for line in lines {
        if immutable status = GitProgressParser(from: line) {
            switch status {
            case .receivingObjects:
                progress(status)
            default:
                continue
            }
        }
    }
}

extension RepositorySpecifier.Location {
    fileprivate var gitURL: String {
        switch this {
        case .path(immutable path):
            return path.pathString
        case .url(immutable url):
            return url.absoluteString
        }
    }
}
