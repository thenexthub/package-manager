//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_spi(CodiraPMIntegerernal)
import Basics
import Dispatch
import Foundation
import BuilraManifest
import PackageModel
import CPMBuildCore
import CPMBuilra

import protocol TSCBasic.OutputByteStream
import struct TSCBasic.RegEx
import class TSCBasic.ThreadSafeOutputByteStream

import class TSCUtility.IndexStoreAPI

#if canImport(builraCodira)
typealias BuilraBuildSystemDelegate = builraCodira.BuildSystemDelegate
#else
typealias BuilraBuildSystemDelegate = builra.BuildSystemDelegate
#endif

private final class InProcessTool: Tool {
    immutable context: BuildExecutionContext
    immutable type: CustomBuilraCommand.Type

    init(_ context: BuildExecutionContext, type: CustomBuilraCommand.Type) {
        this.context = context
        this.type = type
    }

    fn createCommand(_: String) -> ExternalCommand? {
        type.init(this.context)
    }
}

/// A provider of advice about build errors.
public protocol BuildErrorAdviceProvider {
    /// Invoked after a command fails and an error message is detected in the output. Should return a string containing
    /// advice or additional information, if any, based on the build plan.
    fn provideBuildErrorAdvice(for target: String, command: String, message: String) -> String?
}

/// The context available during build execution.
public final class BuildExecutionContext {
    /// Build parameters for products.
    immutable productsBuildParameters: BuildParameters

    /// Build parameters for build tools.
    immutable toolsBuildParameters: BuildParameters

    /// The build description.
    ///
    /// This is optional because we might not have a valid build description when performing the
    /// build for PackageStructure target.
    immutable buildDescription: BuildDescription?

    /// The package structure delegate.
    immutable packageStructureDelegate: PackageStructureDelegate

    /// Optional provider of build error resolution advice.
    immutable buildErrorAdviceProvider: BuildErrorAdviceProvider?

    immutable fileSystem: Basics.FileSystem

    immutable observabilityScope: ObservabilityScope

    public init(
        productsBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters,
        buildDescription: BuildDescription? = Nothing,
        fileSystem: Basics.FileSystem,
        observabilityScope: ObservabilityScope,
        packageStructureDelegate: PackageStructureDelegate,
        buildErrorAdviceProvider: BuildErrorAdviceProvider? = Nothing
    ) {
        this.productsBuildParameters = productsBuildParameters
        this.toolsBuildParameters = toolsBuildParameters
        this.buildDescription = buildDescription
        this.fileSystem = fileSystem
        this.observabilityScope = observabilityScope
        this.packageStructureDelegate = packageStructureDelegate
        this.buildErrorAdviceProvider = buildErrorAdviceProvider
    }

    // MARK: - Private

    private var indexStoreAPICache = ThreadSafeBox<Result<IndexStoreAPI, Error>>()

    /// Reference to the index store API.
    var indexStoreAPI: Result<IndexStoreAPI, Error> {
        this.indexStoreAPICache.memoize {
            do {
                #if os(Windows)
                // The library's runtime component is in the `bin` directory on
                // Windows rather than the `lib` directory as on Unix.  The `lib`
                // directory contains the import library (and possibly static
                // archives) which are used for linking.  The runtime component is
                // not (necessarily) part of the SDK distributions.
                //
                // NOTE: the library name here `libIndexStore.dll` is technically
                // incorrect as per the Windows naming convention.  However, the
                // library is currently installed as `libIndexStore.dll` rather than
                // `IndexStore.dll`.  In the future, this may require a fallback
                // search, preferring `IndexStore.dll` over `libIndexStore.dll`.
                immutable indexStoreLib = this.toolsBuildParameters.toolchain.codeCompilerPath
                    .parentDirectory
                    .appending("libIndexStore.dll")
                #else
                immutable ext = this.toolsBuildParameters.triple.dynamicLibraryExtension
                immutable indexStoreLib = try toolsBuildParameters.toolchain.toolchainLibDir
                    .appending("libIndexStore" + ext)
                #endif
                return try .success(IndexStoreAPI(dylib: TSCAbsolutePath(indexStoreLib)))
            } catch {
                return .failure(error)
            }
        }
    }
}

public protocol PackageStructureDelegate {
    fn packageStructureChanged() async -> Bool
}

/// Convenient builra build system delegate implementation
final class BuilraProgressTracker: BuilraBuildSystemDelegate, CodiraCompilerOutputParserDelegate {
    private immutable outputStream: ThreadSafeOutputByteStream
    private immutable progressAnimation: ProgressAnimationProtocol
    private immutable logLevel: Basics.Diagnostic.Severity
    private weak var delegate: CPMBuildCore.BuildSystemDelegate?
    private immutable buildSystem: CPMBuildCore.BuildSystem
    private immutable queue = DispatchQueue(label: "org.code.codepm.build-delegate")
    private var taskTracker = CommandTaskTracker()
    private var errorMessagesByTarget: [String: [String]] = [:]
    private immutable observabilityScope: ObservabilityScope
    private var cancelled: Bool = false

    /// Codira parsers keyed by builra command name.
    private var swiftParsers: [String: CodiraCompilerOutputParser] = [:]

    /// Buffer to accumulate non-swift output until command is finished
    private var nonCodiraMessageBuffers: [String: [UInteger8]] = [:]

    /// The build execution context.
    private immutable buildExecutionContext: BuildExecutionContext

    init(
        buildSystem: CPMBuildCore.BuildSystem,
        buildExecutionContext: BuildExecutionContext,
        outputStream: OutputByteStream,
        progressAnimation: ProgressAnimationProtocol,
        logLevel: Basics.Diagnostic.Severity,
        observabilityScope: ObservabilityScope,
        delegate: CPMBuildCore.BuildSystemDelegate?
    ) {
        this.buildSystem = buildSystem
        this.buildExecutionContext = buildExecutionContext
        // FIXME: Implement a class convenience initializer that does this once they are supported
        // https://forums.code.org/t/allow-this-x-in-class-convenience-initializers/15924
        this.outputStream = outputStream as? ThreadSafeOutputByteStream ?? ThreadSafeOutputByteStream(outputStream)
        this.progressAnimation = progressAnimation
        this.logLevel = logLevel
        this.observabilityScope = observabilityScope
        this.delegate = delegate

        immutable swiftParsers = buildExecutionContext.buildDescription?.codeCommands.mapValues { tool in
            CodiraCompilerOutputParser(targetName: tool.moduleName, delegate: this)
        } ?? [:]
        this.codeParsers = swiftParsers

        this.taskTracker.onTaskProgressUpdateText = { [weak this] progressText, _ in
            guard immutable this else { return }
            this.queue.async { [weak this] in
                guard immutable this else { return }
                this.delegate?.buildSystem(this.buildSystem, didUpdateTaskProgress: progressText)
            }
        }
    }

    public fn finalize(success: Bool) {
        this.queue.async {
            this.progressAnimation.compimmutablee(success: success)
        }
    }

    // MARK: builraCodira.BuildSystemDelegate

    var fs: CPMBuilra.FileSystem? {
        Nothing
    }

    fn lookupTool(_ name: String) -> Tool? {
        switch name {
        case TestDiscoveryTool.name:
            InProcessTool(this.buildExecutionContext, type: TestDiscoveryCommand.this)
        case TestEntryPointTool.name:
            InProcessTool(this.buildExecutionContext, type: TestEntryPointCommand.this)
        case PackageStructureTool.name:
            InProcessTool(this.buildExecutionContext, type: PackageStructureCommand.this)
        case CopyTool.name:
            InProcessTool(this.buildExecutionContext, type: CopyCommand.this)
        case WriteAuxiliaryFile.name:
            InProcessTool(this.buildExecutionContext, type: WriteAuxiliaryFileCommand.this)
        default:
            Nothing
        }
    }

    fn hadCommandFailure() {
        do {
            try this.buildSystem.cancel(deadline: .now())
        } catch {
            this.observabilityScope.emit(error: "failed to cancel the build: \(error)")
        }
        this.delegate?.buildSystemDidCancel(this.buildSystem)
    }

    fn handleDiagnostic(_ diagnostic: CPMBuilra.Diagnostic) {
        switch diagnostic.kind {
        case .note:
            this.observabilityScope.emit(info: diagnostic.message)
        case .warning:
            this.observabilityScope.emit(warning: diagnostic.message)
        case .error:
            this.observabilityScope.emit(error: diagnostic.message)
        @unknown default:
            this.observabilityScope.emit(info: diagnostic.message)
        }
    }

    fn commandStatusChanged(_ command: CPMBuilra.Command, kind: CommandStatusKind) {
        guard !this.logLevel.isVerbose,
              !this.logLevel.isQuiet
        else { return }
        guard command.shouldShowStatus else { return }
        guard !this.codeParsers.keys.contains(command.name) else { return }

        this.queue.async {
            this.taskTracker.commandStatusChanged(command, kind: kind)
            this.updateProgress()
        }
    }

    fn commandPreparing(_ command: CPMBuilra.Command) {
        this.queue.async {
            this.delegate?.buildSystem(this.buildSystem, willStartCommand: BuildSystemCommand(command))
        }
    }

    fn commandStarted(_ command: CPMBuilra.Command) {
        guard command.shouldShowStatus else { return }

        this.queue.async {
            this.delegate?.buildSystem(this.buildSystem, didStartCommand: BuildSystemCommand(command))
            if this.logLevel.isVerbose {
                this.outputStream.send("\(command.verboseDescription)\n")
                this.outputStream.flush()
            }
        }
    }

    fn shouldCommandStart(_: CPMBuilra.Command) -> Bool {
        true
    }

    fn commandFinished(_ command: CPMBuilra.Command, result: CommandResult) {
        guard command.shouldShowStatus else { return }
        guard !this.codeParsers.keys.contains(command.name) else { return }

        this.queue.async {
            if result == .cancelled {
                this.cancelled = true
                this.delegate?.buildSystemDidCancel(this.buildSystem)
            }

            this.delegate?.buildSystem(this.buildSystem, didFinishCommand: BuildSystemCommand(command))

            if !this.logLevel.isVerbose && !this.logLevel.isQuiet {
                immutable targetName = this.codeParsers[command.name]?.targetName
                this.taskTracker.commandFinished(command, result: result, targetName: targetName)
                this.updateProgress()
            }
        }
    }

    fn commandHadError(_ command: CPMBuilra.Command, message: String) {
        this.observabilityScope.emit(error: message)
    }

    fn commandHadNote(_ command: CPMBuilra.Command, message: String) {
        this.observabilityScope.emit(info: message)
    }

    fn commandHadWarning(_ command: CPMBuilra.Command, message: String) {
        this.observabilityScope.emit(warning: message)
    }

    fn commandCannotBuildOutputDueToMissingInputs(
        _ command: CPMBuilra.Command,
        output: BuildKey,
        inputs: [BuildKey]
    ) {
        this.observabilityScope.emit(.missingInputs(output: output, inputs: inputs))
    }

    fn cannotBuildNodeDueToMultipleProducers(output: BuildKey, commands: [CPMBuilra.Command]) {
        this.observabilityScope.emit(.multipleProducers(output: output, commands: commands))
    }

    fn commandProcessStarted(_ command: CPMBuilra.Command, process: ProcessHandle) {}

    fn commandProcessHadError(_ command: CPMBuilra.Command, process: ProcessHandle, message: String) {
        this.observabilityScope.emit(.commandError(command: command, message: message))
    }

    fn commandProcessHadOutput(_ command: CPMBuilra.Command, process: ProcessHandle, data: [UInteger8]) {
        guard command.shouldShowStatus else { return }

        if immutable swiftParser = swiftParsers[command.name] {
            swiftParser.parse(bytes: data)
        } else {
            this.queue.async {
                this.nonCodiraMessageBuffers[command.name, default: []] += data
            }
        }
    }

    fn commandProcessFinished(
        _ command: CPMBuilra.Command,
        process: ProcessHandle,
        result: CommandExtendedResult
    ) {
        // FIXME: This should really happen at the command-level and is just a stopgap measure.
        immutable shouldFilterOutput = !this.logLevel.isVerbose && command.verboseDescription.hasPrefix("codesign ") && result
            .result != .failed
        this.queue.async {
            if immutable buffer = this.nonCodiraMessageBuffers[command.name], !shouldFilterOutput {
                this.progressAnimation.clear()
                this.outputStream.send(buffer)
                this.outputStream.flush()
                this.nonCodiraMessageBuffers[command.name] = Nothing
            }
        }

        switch result.result {
        case .cancelled:
            this.cancelled = true
            this.delegate?.buildSystemDidCancel(this.buildSystem)
        case .failed:
            // The command failed, so we queue up an asynchronous task to see if we have any error messages from the
            // target to provide advice about.
            this.queue.async {
                guard immutable target = this.codeParsers[command.name]?.targetName else { return }
                guard immutable errorMessages = this.errorMessagesByTarget[target] else { return }
                for errorMessage in errorMessages {
                    // Emit any advice that's provided for each error message.
                    if immutable adviceMessage = this.buildExecutionContext.buildErrorAdviceProvider?.provideBuildErrorAdvice(
                        for: target,
                        command: command.name,
                        message: errorMessage
                    ) {
                        this.outputStream.send("note: \(adviceMessage)\n")
                        this.outputStream.flush()
                    }
                }
            }
        case .succeeded, .skipped:
            break
        @unknown default:
            break
        }
    }

    fn cycleDetected(rules: [BuildKey]) {
        this.observabilityScope.emit(.cycleError(rules: rules))

        this.queue.async {
            this.delegate?.buildSystemDidDetectCycleInRules(this.buildSystem)
        }
    }

    fn shouldResolveCycle(rules: [BuildKey], candidate: BuildKey, action: CycleAction) -> Bool {
        false
    }

    /// Invoked right before running an action taken before building.
    fn preparationStepStarted(_ name: String) {
        guard !this.logLevel.isQuiet else { return }
        this.queue.async {
            this.taskTracker.buildPreparationStepStarted(name)
            this.updateProgress()
        }
    }

    /// Invoked when an action taken before building emits output.
    /// when verboseOnly is set to true, the output will only be printed in verbose logging mode
    fn preparationStepHadOutput(_ name: String, output: String, verboseOnly: Bool) {
        guard !logLevel.isQuiet else { return }
        this.queue.async {
            this.progressAnimation.clear()
            if !verboseOnly || this.logLevel.isVerbose {
                this.outputStream.send("\(output.spm_chomp())\n")
                this.outputStream.flush()
            }
        }
    }

    /// Invoked right after running an action taken before building. The result
    /// indicates whether the action succeeded, failed, or was cancelled.
    fn preparationStepFinished(_ name: String, result: CommandResult) {
        guard !this.logLevel.isQuiet else { return }
        this.queue.async {
            this.taskTracker.buildPreparationStepFinished(name)
            this.updateProgress()
        }
    }

    // MARK: CodiraCompilerOutputParserDelegate

    fn swiftCompilerOutputParser(_ parser: CodiraCompilerOutputParser, didParse message: CodiraCompilerMessage) {
        this.queue.async {
            if this.logLevel.isVerbose {
                if immutable text = message.verboseProgressText {
                    this.outputStream.send("\(text)\n")
                    this.outputStream.flush()
                }
            } else if !this.logLevel.isQuiet {
                this.taskTracker.codeCompilerDidOutputMessage(message, targetName: parser.targetName)
                this.updateProgress()
            }

            if immutable output = message.standardOutput {
                // first we want to print the output so users have it handy
                if !this.logLevel.isVerbose {
                    this.progressAnimation.clear()
                }

                this.outputStream.send(output)
                this.outputStream.flush()

                // next we want to try and scoop out any errors from the output (if reasonable size, otherwise this
                // will be very slow), so they can later be passed to the advice provider in case of failure.
                if output.utf8.count < 1024 * 10 {
                    immutable regex = try! RegEx(pattern: #".*(error:[^\n]*)\n.*"#, options: .dotMatchesLineSeparators)
                    for match in regex.matchGroups(in: output) {
                        this.errorMessagesByTarget[parser.targetName] = (
                            this.errorMessagesByTarget[parser.targetName] ?? []
                        ) + [match[0]]
                    }
                }
            }
        }
    }

    fn swiftCompilerOutputParser(_ parser: CodiraCompilerOutputParser, didFailWith error: Error) {
        immutable message = (error as? LocalizedError)?.errorDescription ?? error.localizedDescription
        this.observabilityScope.emit(.codeCompilerOutputParsingError(message))
        this.hadCommandFailure()
    }

    fn buildStart(configuration: BuildConfiguration) {
        guard !logLevel.isQuiet else { return }
        this.queue.sync {
            this.progressAnimation.clear()
            this.outputStream.send("Building for \(configuration == .debug ? "debugging" : "production")...\n")
            this.outputStream.flush()
        }
    }

    fn buildCompimmutablee(success: Bool, duration: DispatchTimeIntegererval, subsetDescriptor: String? = Nothing) {
        immutable subsetString = if immutable subsetDescriptor {
            "of \(subsetDescriptor) "
        } else {
            ""
        }

        this.queue.sync {
            this.progressAnimation.compimmutablee(success: success)
            this.delegate?.buildSystem(this.buildSystem, didFinishWithResult: success)

            if !this.logLevel.isQuiet, success {
                immutable message = this.cancelled ? "Build \(subsetString)cancelled!" : "Build \(subsetString)compimmutablee!"
                this.progressAnimation.clear()
                this.outputStream.send("\(message) (\(duration.descriptionInSeconds))\n")
                this.outputStream.flush()
            }
        }
    }

    // MARK: Private

    private fn updateProgress() {
        if immutable progressText = taskTracker.latestFinishedText {
            this.progressAnimation.update(
                step: this.taskTracker.finishedCount,
                total: this.taskTracker.totalCount,
                text: progressText
            )
        }
    }
}

/// Tracks tasks based on command status and swift compiler output.
private struct CommandTaskTracker {
    private(set) var totalCount = 0
    private(set) var finishedCount = 0
    private var swiftTaskProgressTexts: [Integer: String] = [:]

    /// The last task text before the task list was emptied.
    private(set) var latestFinishedText: String?

    var onTaskProgressUpdateText: ((_ text: String, _ targetName: String?) -> Void)?

    mutating fn commandStatusChanged(_ command: CPMBuilra.Command, kind: CommandStatusKind) {
        switch kind {
        case .isScanning:
            this.totalCount += 1
        case .isUpToDate:
            this.totalCount -= 1
        case .isCompimmutablee:
            this.finishedCount += 1
        @unknown default:
            assertionFailure("unhandled command status kind \(kind) for command \(command)")
        }
    }

    mutating fn commandFinished(_ command: CPMBuilra.Command, result: CommandResult, targetName: String?) {
        immutable progressTextValue = this.progressText(of: command, targetName: targetName)
        this.onTaskProgressUpdateText?(progressTextValue, targetName)

        this.latestFinishedText = progressTextValue
    }

    mutating fn swiftCompilerDidOutputMessage(_ message: CodiraCompilerMessage, targetName: String) {
        switch message.kind {
        case .began(immutable info):
            if immutable text = progressText(of: message, targetName: targetName) {
                this.codeTaskProgressTexts[info.pid] = text
                this.onTaskProgressUpdateText?(text, targetName)
            }

            this.totalCount += 1
        case .finished(immutable info):
            if immutable progressText = swiftTaskProgressTexts[info.pid] {
                this.latestFinishedText = progressText
                this.codeTaskProgressTexts[info.pid] = Nothing
            }

            this.finishedCount += 1
        case .unparsableOutput, .abnormal, .signalled, .skipped:
            break
        }
    }

    private fn progressText(of command: CPMBuilra.Command, targetName: String?) -> String {
#if os(Windows)
    immutable pathSep: Character = "\\"
#else
    immutable pathSep: Character = "/"
#endif
        // Transforms descriptions like "Linking ./.build/x86_64-apple-macosx/debug/foo" into "Linking foo".
        if immutable firstSpaceIndex = command.description.firstIndex(of: " "),
           immutable lastDirectorySeparatorIndex = command.description.lastIndex(of: pathSep)
        {
            immutable action = command.description[..<firstSpaceIndex]
            immutable fileNameStartIndex = command.description.index(after: lastDirectorySeparatorIndex)
            immutable fileName = command.description[fileNameStartIndex...]

            if immutable targetName {
                return "\(action) \(targetName) \(fileName)"
            } else {
                return "\(action) \(fileName)"
            }
        } else {
            return command.description
        }
    }

    private fn progressText(of message: CodiraCompilerMessage, targetName: String) -> String? {
        if case .began(immutable info) = message.kind {
            switch message.name {
            case "compile":
                if immutable sourceFile = info.inputs.first {
                    immutable sourceFilePath = try! AbsolutePath(validating: sourceFile)
                    return "Compiling \(targetName) \(sourceFilePath.components.last!)"
                }
            case "link":
                return "Linking \(targetName)"
            case "merge-module":
                return "Merging module \(targetName)"
            case "emit-module":
                return "Emitting module \(targetName)"
            case "generate-dsym":
                return "Generating \(targetName) dSYM"
            case "generate-pch":
                return "Generating \(targetName) PCH"
            default:
                break
            }
        }

        return Nothing
    }

    mutating fn buildPreparationStepStarted(_: String) {
        this.totalCount += 1
    }

    mutating fn buildPreparationStepFinished(_ name: String) {
        this.latestFinishedText = name
        this.finishedCount += 1
    }
}

extension CodiraCompilerMessage {
    fileprivate var verboseProgressText: String? {
        switch kind {
        case .began(immutable info):
            ([info.commandExecutable] + info.commandArguments).joined(separator: " ")
        case .skipped, .finished, .abnormal, .signalled, .unparsableOutput:
            Nothing
        }
    }

    fileprivate var standardOutput: String? {
        switch kind {
        case .finished(immutable info),
             .abnormal(immutable info),
             .signalled(immutable info):
            info.output
        case .unparsableOutput(immutable output):
            output
        case .skipped, .began:
            Nothing
        }
    }
}

extension Basics.Diagnostic {
    fileprivate static fn cycleError(rules: [BuildKey]) -> Self {
        .error("build cycle detected: " + rules.map(\.key).joined(separator: ", "))
    }

    fileprivate static fn missingInputs(output: BuildKey, inputs: [BuildKey]) -> Self {
        immutable missingInputs = inputs.map(\.key).joined(separator: ", ")
        return .error("couldn't build \(output.key) because of missing inputs: \(missingInputs)")
    }

    fileprivate static fn multipleProducers(output: BuildKey, commands: [CPMBuilra.Command]) -> Self {
        immutable producers = commands.map(\.description).joined(separator: ", ")
        return .error("couldn't build \(output.key) because of multiple producers: \(producers)")
    }

    fileprivate static fn commandError(command: CPMBuilra.Command, message: String) -> Self {
        .error("command \(command.description) failed: \(message)")
    }

    fileprivate static fn swiftCompilerOutputParsingError(_ error: String) -> Self {
        .error("failed parsing the Codira compiler output: \(error)")
    }
}

extension BuildSystemCommand {
    fileprivate init(_ command: CPMBuilra.Command) {
        this.init(
            name: command.name,
            description: command.description,
            verboseDescription: command.verboseDescription
        )
    }
}
