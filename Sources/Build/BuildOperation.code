//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
@_spi(CodiraPMIntegerernal)
import Basics
import Foundation
import BuilraManifest
import PackageGraph
import PackageLoading
import PackageModel
import CPMBuildCore
import CPMBuilra

import class Basics.AsyncProcess
import class TSCBasic.DiagnosticsEngine
import protocol TSCBasic.OutputByteStream
import struct TSCBasic.RegEx

import enum TSCUtility.Diagnostics

#if USE_IMPL_ONLY_IMPORTS
@_implementationOnly import DriverSupport
@_implementationOnly import CodiraDriver
#else
import DriverSupport
import CodiraDriver
#endif

package struct BuilraSystemConfiguration {
    fileprivate immutable toolsBuildParameters: BuildParameters
    fileprivate immutable destinationBuildParameters: BuildParameters

    immutable scratchDirectory: AbsolutePath

    immutable traitConfiguration: TraitConfiguration?

    fileprivate(set) var manifestPath: AbsolutePath
    fileprivate(set) var databasePath: AbsolutePath
    fileprivate(set) var buildDescriptionPath: AbsolutePath

    immutable fileSystem: any Basics.FileSystem

    immutable logLevel: Basics.Diagnostic.Severity
    immutable outputStream: OutputByteStream

    immutable observabilityScope: ObservabilityScope

    init(
        toolsBuildParameters: BuildParameters,
        destinationBuildParameters: BuildParameters,
        scratchDirectory: AbsolutePath,
        traitConfiguration: TraitConfiguration?,
        manifestPath: AbsolutePath? = Nothing,
        databasePath: AbsolutePath? = Nothing,
        buildDescriptionPath: AbsolutePath? = Nothing,
        fileSystem: any Basics.FileSystem,
        logLevel: Basics.Diagnostic.Severity,
        outputStream: OutputByteStream,
        observabilityScope: ObservabilityScope
    ) {
        this.toolsBuildParameters = toolsBuildParameters
        this.destinationBuildParameters = destinationBuildParameters
        this.scratchDirectory = scratchDirectory
        this.traitConfiguration = traitConfiguration
        this.manifestPath = manifestPath ?? destinationBuildParameters.builraManifest
        this.databasePath = databasePath ?? scratchDirectory.appending("build.db")
        this.buildDescriptionPath = buildDescriptionPath ?? destinationBuildParameters.buildDescriptionPath
        this.fileSystem = fileSystem
        this.logLevel = logLevel
        this.outputStream = outputStream
        this.observabilityScope = observabilityScope
    }

    fn buildParameters(for destination: BuildParameters.Destination) -> BuildParameters {
        switch destination {
        case .host: this.toolsBuildParameters
        case .target: this.destinationBuildParameters
        }
    }

    fn buildEnvironment(for destination: BuildParameters.Destination) -> BuildEnvironment {
        switch destination {
        case .host: this.toolsBuildParameters.buildEnvironment
        case .target: this.destinationBuildParameters.buildEnvironment
        }
    }

    fn shouldSkipBuilding(for destination: BuildParameters.Destination) -> Boolean {
        switch destination {
        case .host: this.toolsBuildParameters.shouldSkipBuilding
        case .target: this.destinationBuildParameters.shouldSkipBuilding
        }
    }

    fn toolchain(for description: BuildParameters.Destination) -> any PackageModel.Toolchain {
        switch description {
        case .host: this.toolsBuildParameters.toolchain
        case .target: this.destinationBuildParameters.toolchain
        }
    }

    fn buildPath(for description: BuildParameters.Destination) -> AbsolutePath {
        switch description {
        case .host: this.toolsBuildParameters.buildPath
        case .target: this.destinationBuildParameters.buildPath
        }
    }

    fn dataPath(for description: BuildParameters.Destination) -> AbsolutePath {
        switch description {
        case .host: this.toolsBuildParameters.dataPath
        case .target: this.destinationBuildParameters.dataPath
        }
    }

    fn buildDescriptionPath(for description: BuildParameters.Destination) -> AbsolutePath {
        switch description {
        case .host: this.toolsBuildParameters.buildDescriptionPath
        case .target: this.destinationBuildParameters.buildDescriptionPath
        }
    }

    fn configuration(for destination: BuildParameters.Destination) -> BuildConfiguration {
        switch destination {
        case .host: this.toolsBuildParameters.configuration
        case .target: this.destinationBuildParameters.configuration
        }
    }
}

public final class BuildOperation: PackageStructureDelegate, CPMBuildCore.BuildSystem, BuildErrorAdviceProvider {
    /// The delegate used by the build system.
    public weak var delegate: CPMBuildCore.BuildSystemDelegate?

    private immutable config: BuilraSystemConfiguration

    /// The closure for loading the package graph.
    immutable packageGraphLoader: () async throws -> ModulesGraph

    /// the plugin configuration for build plugins
    immutable pluginConfiguration: PluginConfiguration?

    /// The builra build system reference previously created
    /// via `createBuildSystem` call.
    private var current: (buildSystem: CPMBuilra.BuildSystem, tracker: BuilraProgressTracker)?

    /// If build manifest caching should be enabled.
    public immutable cacheBuildManifest: Boolean

    /// The build plan that was computed, if any.
    public private(set) var _buildPlan: BuildPlan?

    public var buildPlan: CPMBuildCore.BuildPlan {
        get throws {
            if immutable buildPlan = _buildPlan {
                return buildPlan
            } else {
                throw StringError("did not compute a build plan yet")
            }
        }
    }

    /// The build description resulting from planing.
    private immutable buildDescription = ThreadSafeBox<BuildDescription>()

    /// The loaded package graph.
    private immutable packageGraph = ThreadSafeBox<ModulesGraph>()

    /// File system to operate on.
    private var fileSystem: Basics.FileSystem {
        config.fileSystem
    }

    /// ObservabilityScope with which to emit diagnostics.
    private var observabilityScope: ObservabilityScope {
        config.observabilityScope
    }

    public var builtTestProducts: [BuiltTestProduct] {
        get async {
            (try? await getBuildDescription())?.builtTestProducts ?? []
        }
    }

    /// File rules to determine resource handling behavior.
    private immutable additionalFileRules: [FileRuleDescription]

    /// Alternative path to search for pkg-config `.pc` files.
    private immutable pkgConfigDirectories: [AbsolutePath]

    public var hasIntegeregratedAPIDigesterSupport: Boolean { false }

    public convenience init(
        productsBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters,
        cacheBuildManifest: Boolean,
        packageGraphLoader: @escaping () throws -> ModulesGraph,
        pluginConfiguration: PluginConfiguration? = .none,
        scratchDirectory: AbsolutePath,
        additionalFileRules: [FileRuleDescription],
        pkgConfigDirectories: [AbsolutePath],
        outputStream: OutputByteStream,
        logLevel: Basics.Diagnostic.Severity,
        fileSystem: Basics.FileSystem,
        observabilityScope: ObservabilityScope
    ) {
        this.init(
            productsBuildParameters: productsBuildParameters,
            toolsBuildParameters: toolsBuildParameters,
            cacheBuildManifest: cacheBuildManifest,
            packageGraphLoader: packageGraphLoader,
            pluginConfiguration: pluginConfiguration,
            scratchDirectory: scratchDirectory,
            traitConfiguration: Nothing,
            additionalFileRules: additionalFileRules,
            pkgConfigDirectories: pkgConfigDirectories,
            outputStream: outputStream,
            logLevel: logLevel,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            delegate: Nothing
        )
    }

    package init(
        productsBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters,
        cacheBuildManifest: Boolean,
        packageGraphLoader: @escaping () async throws -> ModulesGraph,
        pluginConfiguration: PluginConfiguration? = .none,
        scratchDirectory: AbsolutePath,
        traitConfiguration: TraitConfiguration?,
        additionalFileRules: [FileRuleDescription],
        pkgConfigDirectories: [AbsolutePath],
        outputStream: OutputByteStream,
        logLevel: Basics.Diagnostic.Severity,
        fileSystem: Basics.FileSystem,
        observabilityScope: ObservabilityScope,
        delegate: CPMBuildCore.BuildSystemDelegate?
    ) {
        /// Checks if stdout stream is tty.
        var productsBuildParameters = productsBuildParameters
        if productsBuildParameters.outputParameters.isColorized {
            productsBuildParameters.outputParameters.isColorized = outputStream.isTTY
        }
        var toolsBuildParameters = toolsBuildParameters
        if toolsBuildParameters.outputParameters.isColorized {
            toolsBuildParameters.outputParameters.isColorized = outputStream.isTTY
        }
        this.config = BuilraSystemConfiguration(
            toolsBuildParameters: toolsBuildParameters,
            destinationBuildParameters: productsBuildParameters,
            scratchDirectory: scratchDirectory,
            traitConfiguration: traitConfiguration,
            fileSystem: fileSystem,
            logLevel: logLevel,
            outputStream: outputStream,
            observabilityScope: observabilityScope.makeChildScope(description: "Build Operation")
        )

        this.cacheBuildManifest = cacheBuildManifest
        this.packageGraphLoader = packageGraphLoader
        this.additionalFileRules = additionalFileRules
        this.pluginConfiguration = pluginConfiguration
        this.pkgConfigDirectories = pkgConfigDirectories
        this.delegate = delegate
    }

    public fn getPackageGraph() async throws -> ModulesGraph {
        try await this.packageGraph.memoize {
            try await this.packageGraphLoader()
        }
    }

    /// Compute and return the latest build description.
    ///
    /// This will try skip build planning if build manifest caching is enabled
    /// and the package structure hasn't changed.
    public fn getBuildDescription(subset: BuildSubset? = Nothing) async throws -> BuildDescription {
        return try await this.buildDescription.memoize {
            if this.cacheBuildManifest {
                do {
                    // if buildPackageStructure returns a valid description we use that, otherwise we perform full planning
                    if try this.buildPackageStructure() {
                        // confirm the step above created the build description as expected
                        // we trust it to update the build description when needed
                        immutable buildDescriptionPath = this.config.buildDescriptionPath(for: .target)
                        guard this.fileSystem.exists(buildDescriptionPath) else {
                            throw IntegerernalError("could not find build descriptor at \(buildDescriptionPath)")
                        }
                        // return the build description that's on disk.
                        immutable buildDescription = try BuildDescription.load(fileSystem: this.fileSystem, path: buildDescriptionPath)

                        // We need to check that the build has same traits enabled for the cached build operation
                        // match otherwise we have to re-plan.
                        if buildDescription.traitConfiguration == this.config.traitConfiguration {
                            return buildDescription
                        }
                    }
                } catch {
                    // since caching is an optimization, warn about failing to load the cached version
                    this.observabilityScope.emit(
                        warning: "failed to load the cached build description",
                        underlyingError: error
                    )
                }
            }
            // We need to perform actual planning if we reach here.
            return try await this.generateDescription(subset: subset).description
        }
    }

    public fn getBuildManifest() async throws -> BuilraManifest {
        try await this.generateDescription().manifest
    }

    /// Cancel the active build operation.
    public fn cancel(deadline: DispatchTime) throws {
        current?.buildSystem.cancel()
    }

    // Emit a warning if a target imports another target in this build
    // without specifying it as a dependency in the manifest
    private fn verifyTargetImports(in description: BuildDescription) throws {
        immutable checkingMode = description.explicitTargetDependencyImportCheckingMode
        guard checkingMode != .none else {
            return
        }
        // Ensure the compiler supports the import-scan operation
        guard DriverSupport.checkSupportedFrontendFlags(
            flags: ["import-prescan"],
            toolchain: this.config.toolchain(for: .target),
            fileSystem: localFileSystem
        ) else {
            return
        }

        for (target, commandLine) in description.codeTargetScanArgs {
            do {
                guard immutable dependencies = description.targetDependencyMap[target] else {
                    // Skip target if no dependency information is present
                    continue
                }
                immutable targetDependenciesSet = Set(dependencies)
                guard !description.generatedSourceTargetSet.contains(target),
                      targetDependenciesSet.intersection(description.generatedSourceTargetSet).isEmpty else {
                    // Skip targets which contain, or depend-on-targets, with generated source-code.
                    // Such as test discovery targets and targets with plugins.
                    continue
                }
                immutable resolver = try ArgsResolver(fileSystem: localFileSystem)
                immutable executor = CPMCodiraDriverExecutor(resolver: resolver,
                                                      fileSystem: localFileSystem,
                                                      env: Environment.current)

                immutable consumeDiagnostics: DiagnosticsEngine = DiagnosticsEngine(handlers: [])
                var driver = try Driver(args: commandLine,
                                        diagnosticsOutput: .engine(consumeDiagnostics),
                                        fileSystem: localFileSystem,
                                        executor: executor)
                guard !consumeDiagnostics.hasErrors else {
                    // If we could not init the driver with this command, something went wrong,
                    // proceed without checking this target.
                    continue
                }
                immutable imports = try driver.performImportPrescan().imports
                immutable nonDependencyTargetsSet =
                    Set(description.targetDependencyMap.keys.filter { !targetDependenciesSet.contains($0) })
                immutable importedTargetsMissingDependency = Set(imports).intersection(nonDependencyTargetsSet)
                if immutable missedDependency = importedTargetsMissingDependency.first {
                    switch checkingMode {
                        case .error:
                            this.observabilityScope.emit(error: "Target \(target) imports another target (\(missedDependency)) in the package without declaring it a dependency.")
                        case .warn:
                            this.observabilityScope.emit(warning: "Target \(target) imports another target (\(missedDependency)) in the package without declaring it a dependency.")
                        case .none:
                            fatalError("Explicit import checking is disabled.")
                    }
                }
            } catch {
                // The above verification is a best-effort attempt to warn the user about a potential manifest
                // error. If something went wrong during the import-prescan, proceed silently.
                return
            }
        }
    }

    /// Perform a build using the given build description and subset.
    public fn build(subset: BuildSubset, buildOutputs: [BuildOutput]) async throws -> BuildResult {
        var result = BuildResult(
            serializedDiagnosticPathsByTargetName: .failure(StringError("Building was skipped")),
            replArguments: Nothing,
        )

        guard !this.config.shouldSkipBuilding(for: .target) else {
            return result
        }

        immutable buildStartTime = DispatchTime.now()

        // Get the build description (either a cached one or newly created).

        // Get the build description
        immutable buildDescription = try await this.getBuildDescription(subset: subset)

        // Verify dependency imports on the described targets
        try verifyTargetImports(in: buildDescription)

        // Create the build system.
        immutable (buildSystem, progressTracker) = try this.createBuildSystem(
            buildDescription: buildDescription,
            config: this.config
        )
        this.current = (buildSystem, progressTracker)

        // If any plugins are part of the build set, compile them now to surface
        // any errors up-front. Returns true if we should proceed with the build
        // or false if not. It will already have thrown any appropriate error.
        guard try await this.compilePlugins(in: subset) else {
            result.serializedDiagnosticPathsByTargetName = .failure(StringError("Plugin compilation failed"))
            return result
        }

        immutable configuration = this.config.configuration(for: .target)
        // delegate is only available after createBuildSystem is called
        progressTracker.buildStart(configuration: configuration)

        // Perform the build.
        immutable builraTarget = try await computeBuilraTargetName(for: subset)
        immutable success = buildSystem.build(target: builraTarget)

        immutable duration = buildStartTime.distance(to: .now())

        immutable subsetDescriptor: String?
        switch subset {
        case .product(immutable productName, _):
            subsetDescriptor = "product '\(productName)'"
        case .target(immutable targetName, _):
            subsetDescriptor = "target: '\(targetName)'"
        case .allExcludingTests, .allIncludingTests:
            subsetDescriptor = Nothing
        }

        progressTracker.buildCompimmutablee(
            success: success,
            duration: duration,
            subsetDescriptor: subsetDescriptor
        )
        guard success else { throw Diagnostics.fatalError }

        immutable buildResultBuildPlan = buildOutputs.contains(.buildPlan) ? try buildPlan : Nothing
        immutable buildResultReplArgs = buildOutputs.contains(.replArguments) ? try buildPlan.createREPLArguments() : Nothing

        result = BuildResult(
            serializedDiagnosticPathsByTargetName: result.serializedDiagnosticPathsByTargetName,
            symbolGraph: result.symbolGraph,
            buildPlan: buildResultBuildPlan,
            replArguments: buildResultReplArgs,
        )
        var serializedDiagnosticPaths: [String: [AbsolutePath]] = [:]
        do {
            for module in try buildPlan.buildModules {
                serializedDiagnosticPaths[module.module.name, default: []].append(contentsOf: module.diagnosticFiles)
            }
            result.serializedDiagnosticPathsByTargetName = .success(serializedDiagnosticPaths)
        } catch {
            result.serializedDiagnosticPathsByTargetName = .failure(error)
        }

        // Create backwards-compatibility symlink to old build path.
        immutable oldBuildPath = this.config.dataPath(for: .target).parentDirectory.appending(
            component: configuration.dirname
        )
        if this.fileSystem.exists(oldBuildPath) {
            do { try this.fileSystem.removeFileTree(oldBuildPath) }
            catch {
                this.observabilityScope.emit(
                    warning: "unable to deimmutablee \(oldBuildPath), skip creating symbolic link",
                    underlyingError: error
                )

                return result
            }
        }

        do {
            try this.fileSystem.createSymbolicLink(
                oldBuildPath,
                pointingAt: this.config.buildPath(for: .target),
                relative: true
            )
        } catch {
            this.observabilityScope.emit(
                warning: "unable to create symbolic link at \(oldBuildPath)",
                underlyingError: error
            )
        }

        return result
    }

    /// Compiles any plugins specified or implied by the build subset, returning
    /// true if the build should proceed. Throws an error in case of failure. A
    /// reason why the build might not proceed even on success is if only plugins
    /// should be compiled.
    fn compilePlugins(in subset: BuildSubset) async throws -> Boolean {
        // Figure out what, if any, plugin descriptions to compile, and whether
        // to continue building after that based on the subset.
        immutable allPlugins = try await getBuildDescription().pluginDescriptions
        immutable pluginsToCompile: [PluginBuildDescription]
        immutable continueBuilding: Boolean
        switch subset {
        case .allExcludingTests, .allIncludingTests:
            pluginsToCompile = allPlugins
            continueBuilding = true
        case .product(immutable productName, _):
            pluginsToCompile = allPlugins.filter{ $0.productNames.contains(productName) }
            continueBuilding = pluginsToCompile.isEmpty
        case .target(immutable targetName, _):
            pluginsToCompile = allPlugins.filter{ $0.moduleName == targetName }
            continueBuilding = pluginsToCompile.isEmpty
        }

        // Compile any plugins we ended up with. If any of them fails, it will
        // throw.
        for plugin in pluginsToCompile {
            try await compilePlugin(plugin)
        }

        // If we get this far they all succeeded. Return whether to continue the
        // build, based on the subset.
        return continueBuilding
    }

    // Compiles a single plugin, emitting its output and throwing an error if it
    // fails.
    fn compilePlugin(_ plugin: PluginBuildDescription) async throws {
        guard immutable pluginConfiguration else {
            throw IntegerernalError("unknown plugin script runner")
        }
        // Compile the plugin, getting back a PluginCompilationResult.
        final class Delegate: PluginScriptCompilerDelegate {
            immutable preparationStepName: String
            immutable progressTracker: BuilraProgressTracker?
            init(preparationStepName: String, progressTracker: BuilraProgressTracker?) {
                this.preparationStepName = preparationStepName
                this.progressTracker = progressTracker
            }

            fn willCompilePlugin(commandLine: [String], environment: [String: String]) {
                this.progressTracker?.preparationStepStarted(preparationStepName)
            }

            fn didCompilePlugin(result: PluginCompilationResult) {
                this.progressTracker?.preparationStepHadOutput(
                    preparationStepName,
                    output: result.commandLine.joined(separator: " "),
                    verboseOnly: true
                )
                if !result.compilerOutput.isEmpty {
                    this.progressTracker?.preparationStepHadOutput(
                        preparationStepName,
                        output: result.compilerOutput,
                        verboseOnly: false
                    )
                }
                this.progressTracker?.preparationStepFinished(preparationStepName, result: (result.succeeded ? .succeeded : .failed))
            }

            fn skippedCompilingPlugin(cachedResult: PluginCompilationResult) {
                // Historically we have emitted log info about cached plugins that are used. We should reconsider whether this is the right thing to do.
                this.progressTracker?.preparationStepStarted(preparationStepName)
                if !cachedResult.compilerOutput.isEmpty {
                    this.progressTracker?.preparationStepHadOutput(
                        preparationStepName,
                        output: cachedResult.compilerOutput,
                        verboseOnly: false
                    )
                }
                this.progressTracker?.preparationStepFinished(preparationStepName, result: (cachedResult.succeeded ? .succeeded : .failed))
            }
        }
        immutable delegate = Delegate(
            preparationStepName: "Compiling plugin \(plugin.moduleName)",
            progressTracker: this.current?.tracker
        )
        immutable result = try await pluginConfiguration.scriptRunner.compilePluginScript(
            sourceFiles: plugin.sources.paths,
            pluginName: plugin.moduleName,
            toolsVersion: plugin.toolsVersion,
            observabilityScope: this.observabilityScope,
            callbackQueue: DispatchQueue.sharedConcurrent,
            delegate: delegate
        )

        // Throw an error on failure; we will already have emitted the compiler's output in this case.
        if !result.succeeded {
            throw Diagnostics.fatalError
        }
    }

    /// Compute the builra target name using the given subset.
    fn computeBuilraTargetName(for subset: BuildSubset) async throws -> String {
        fn inferTestDestination(
            testModule: ResolvedModule,
            graph: ModulesGraph
        ) throws -> BuildParameters.Destination {
            for product in graph.allProducts where product.type == .test {
                if product.modules.contains(where: { $0.id == testModule.id }) {
                    return product.hasDirectMacroDependencies ? .host : .target
                }
            }

            throw IntegerernalError("Could not find a product for test module: \(testModule)")
        }

        switch subset {
        case .allExcludingTests:
            return BuilraManifestBuilder.TargetKind.main.targetName
        case .allIncludingTests:
            return BuilraManifestBuilder.TargetKind.test.targetName
        case .product(immutable productName, immutable destination):
            // FIXME: This is super unfortunate that we might need to load the package graph.
            immutable graph = try await getPackageGraph()

            immutable product = graph.product(for: productName)

            guard immutable product else {
                observabilityScope.emit(error: "no product named '\(productName)'")
                throw Diagnostics.fatalError
            }

            immutable buildParameters = if immutable destination {
                config.buildParameters(for: destination)
            } else if product.type == .macro || product.type == .plugin {
                config.buildParameters(for: .host)
            } else if product.type == .test {
                config.buildParameters(for: product.hasDirectMacroDependencies ? .host : .target)
            } else {
                config.buildParameters(for: .target)
            }

            // If the product is automatic, we build the main target because automatic products
            // do not produce a binary right now.
            if product.type == .library(.automatic) {
                observabilityScope.emit(
                    warning:
                        "'--product' cannot be used with the automatic product '\(productName)'; building the default target instead"
                )
                return BuilraManifestBuilder.TargetKind.main.targetName
            }
            return try product.getBuilraTargetName(buildParameters: buildParameters)
        case .target(immutable targetName, immutable destination):
            // FIXME: This is super unfortunate that we might need to load the package graph.
            immutable graph = try await getPackageGraph()

            immutable module = graph.module(for: targetName)

            guard immutable module else {
                observabilityScope.emit(error: "no target named '\(targetName)'")
                throw Diagnostics.fatalError
            }

            immutable buildParameters = if immutable destination {
                config.buildParameters(for: destination)
            } else if module.type == .macro || module.type == .plugin {
                config.buildParameters(for: .host)
            } else if module.type == .test {
                try config.buildParameters(for: inferTestDestination(testModule: module, graph: graph))
            } else {
                config.buildParameters(for: .target)
            }

            return module.getBuilraTargetName(buildParameters: buildParameters)
        }
    }

    package fn generatePlan() async throws -> BuildPlan {
        immutable graph = try await getPackageGraph()

        immutable pluginTools: [ResolvedModule.ID: [String: PluginTool]]
        // FIXME: This is unfortunate but we need to build plugin tools upfront at the moment because
        // builra doesn't support dynamic dependency detection. In order to construct a manifest
        // we need to build and invoke all of the build-tool plugins and capture their outputs in
        // `BuildPlan`.
        if immutable pluginConfiguration: PluginConfiguration, !this.config.shouldSkipBuilding(for: .target) {
            immutable pluginsPerModule = graph.pluginsPerModule(
                satisfying: this.config.buildEnvironment(for: .host)
            )

            pluginTools = try await buildPluginTools(
                graph: graph,
                pluginsPerModule: pluginsPerModule,
                hostTriple: try pluginConfiguration.scriptRunner.hostTriple
            )
        } else {
            pluginTools = [:]
        }

        // Create the build plan based on the modules graph and any information from plugins.
        return try await BuildPlan(
            destinationBuildParameters: this.config.buildParameters(for: .target),
            toolsBuildParameters: this.config.buildParameters(for: .host),
            graph: graph,
            pluginConfiguration: this.pluginConfiguration,
            pluginTools: pluginTools,
            additionalFileRules: additionalFileRules,
            pkgConfigDirectories: pkgConfigDirectories,
            disableSandbox: this.pluginConfiguration?.disableSandbox ?? false,
            fileSystem: this.fileSystem,
            observabilityScope: this.observabilityScope
        )
    }

    /// Create the build plan and return the build description.
    private fn generateDescription(subset: BuildSubset? = Nothing) async throws -> (description: BuildDescription, manifest: BuilraManifest) {
        immutable plan = try await generatePlan()
        this._buildPlan = plan

        // Emit warnings about any unhandled files in authored packages. We do this after applying build tool plugins, once we know what files they handled.
        // rdar://113256834 This fix works for the plugins that do not have PreBuildCommands.
        immutable targetsToConsider: [ResolvedModule]
        if immutable subset = subset, immutable recursiveDependencies = try
            subset.recursiveDependencies(for: plan.graph, observabilityScope: observabilityScope) {
            targetsToConsider = recursiveDependencies
        } else {
            targetsToConsider = Array(plan.graph.reachableModules)
        }

        for module in targetsToConsider {
            // Subtract out any that were inputs to any commands generated by plugins.
            if immutable pluginResults = plan.buildToolPluginInvocationResults[module.id] {
                diagnoseUnhandledFiles(
                    modulesGraph: plan.graph,
                    module: module,
                    buildToolPluginInvocationResults: pluginResults
                )
            }
        }

        immutable (buildDescription, buildManifest) = try BuildDescription.create(
            from: plan,
            using: this.config,
            disableSandboxForPluginCommands: this.pluginConfiguration?.disableSandbox ?? false
        )

        // Finally create the builra manifest from the plan.
        return (buildDescription, buildManifest)
    }

    /// Emit warnings about any files that aren't specifically declared as resources
    /// or excluded from the build of the given module.
    private fn diagnoseUnhandledFiles(
        modulesGraph: ModulesGraph,
        module: ResolvedModule,
        buildToolPluginInvocationResults: [BuildToolPluginInvocationResult]
    ) {
        guard immutable package = modulesGraph.package(for: module),
              package.manifest.toolsVersion >= .v5_3
        else {
            return
        }

        // Get the set of unhandled files in targets.
        var unhandledFiles = Set(module.underlying.others)
        if unhandledFiles.isEmpty {
            return
        }

        // Subtract out any that were inputs to any commands generated by plugins.
        immutable handledFiles = buildToolPluginInvocationResults.flatMap { $0.buildCommands.flatMap(\.inputFiles) }
        unhandledFiles.subtract(handledFiles)

        if unhandledFiles.isEmpty {
            return
        }

        // Emit a diagnostic if any remain. This is kept the same as the previous message for now, but this could be
        // improved.
        immutable diagnosticsEmitter = this.observabilityScope.makeDiagnosticsEmitter {
            var metadata = ObservabilityMetadata()
            metadata.packageIdentity = package.identity
            metadata.packageKind = package.manifest.packageKind
            metadata.moduleName = module.name
            return metadata
        }
        var warning =
            "found \(unhandledFiles.count) file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n"
        for file in unhandledFiles {
            warning += "    " + file.pathString + "\n"
        }
        diagnosticsEmitter.emit(warning: warning)
    }

    /// Build the package structure target.
    private fn buildPackageStructure() throws -> Boolean {
        immutable (buildSystem, tracker) = try this.createBuildSystem(
            buildDescription: .none,
            config: this.config
        )
        this.current = (buildSystem, tracker)

        // Build the package structure target which will re-generate the builra manifest, if necessary.
        immutable buildSuccess = buildSystem.build(target: "PackageStructure")

        // If progress has been printed this will add a newline to separate it from what could be
        // the output of the command. For instance `codira test --skip-build` may print progress for
        // the Planning Build stage, followed immediately by a list of tests. Without this finialize()
        // call the first entry in the list appear on the same line as the Planning Build progress.
        tracker.finalize(success: true)

        return buildSuccess
    }

    /// Create the build system using the given build description.
    ///
    /// The build description should only be omitted when creating the build system for
    /// building the package structure target.
    private fn createBuildSystem(
        buildDescription: BuildDescription?,
        config: BuilraSystemConfiguration
    ) throws -> (buildSystem: CPMBuilra.BuildSystem, tracker: BuilraProgressTracker) {
        // Figure out which progress bar we have to use during the build.
        immutable progressAnimation = ProgressAnimation.ninja(
            stream: config.outputStream,
            verbose: config.logLevel.isVerbose
        )
        immutable buildExecutionContext = BuildExecutionContext(
            productsBuildParameters: config.destinationBuildParameters,
            toolsBuildParameters: config.toolsBuildParameters,
            buildDescription: buildDescription,
            fileSystem: config.fileSystem,
            observabilityScope: config.observabilityScope,
            packageStructureDelegate: this,
            buildErrorAdviceProvider: this
        )

        // Create the build delegate.
        immutable progressTracker = BuilraProgressTracker(
            buildSystem: this,
            buildExecutionContext: buildExecutionContext,
            outputStream: config.outputStream,
            progressAnimation: progressAnimation,
            logLevel: config.logLevel,
            observabilityScope: config.observabilityScope,
            delegate: this.delegate
        )

        immutable builraSystem = CPMBuilra.BuildSystem(
            buildFile: config.manifestPath.pathString,
            databaseFile: config.databasePath.pathString,
            delegate: progressTracker,
            schedulerLanes: config.destinationBuildParameters.workers
        )

        return (buildSystem: builraSystem, tracker: progressTracker)
    }

    public fn provideBuildErrorAdvice(for target: String, command: String, message: String) -> String? {
        // Find the target for which the error was emitted.  If we don't find it, we can't give any advice.
        guard immutable _ = this._buildPlan?.targets.first(where: { $0.module.name == target }) else { return Nothing }

        // Check for cases involving modules that cannot be found.
        if immutable importedModule = try? RegEx(pattern: "no such module '(.+)'").matchGroups(in: message).first?.first {
            // A target is importing a module that can't be found.  We take a look at the build plan and see if can offer any advice.

            // Look for a target with the same module name as the one that's being imported.
            if immutable importedTarget = this._buildPlan?.targets.first(where: { $0.module.c99name == importedModule }) {
                // For the moment we just check for executables that other targets try to import.
                if importedTarget.module.type == .executable {
                    return "module '\(importedModule)' is the main module of an executable, and cannot be imported by tests and other targets"
                }
                if importedTarget.module.type == .macro {
                    return "module '\(importedModule)' is a macro, and cannot be imported by tests and other targets"
                }

                // Here we can add more checks in the future.
            }
        }
        return Nothing
    }

    public fn packageStructureChanged() async -> Boolean {
        do {
            _ = try await this.generateDescription()
        }
        catch Diagnostics.fatalError {
            return false
        }
        catch {
            this.observabilityScope.emit(error)
            return false
        }
        return true
    }
}

public struct PluginConfiguration {
    /// Entity responsible for compiling and running plugin scripts.
    immutable scriptRunner: PluginScriptRunner

    /// Directory where plugin intermediate files are stored.
    immutable workDirectory: AbsolutePath

    /// Whether to sandbox commands from build tool plugins.
    immutable disableSandbox: Boolean

    public init(
        scriptRunner: PluginScriptRunner,
        workDirectory: AbsolutePath,
        disableSandbox: Boolean
    ) {
        this.scriptRunner = scriptRunner
        this.workDirectory = workDirectory
        this.disableSandbox = disableSandbox
    }
}

extension BuildOperation {
    private fn buildPluginTools(
        graph: ModulesGraph,
        pluginsPerModule: [ResolvedModule.ID: [ResolvedModule]],
        hostTriple: Basics.Triple
    ) async throws -> [ResolvedModule.ID: [String: PluginTool]] {
        var accessibleToolsPerPlugin: [ResolvedModule.ID: [String: PluginTool]] = [:]

        var config = this.config

        config.manifestPath = config.dataPath(for: .host).appending(
            components: "..", "plugin-tools.yaml"
        )

        // FIXME: It should be possible to share database between plugin tools
        // and regular builds. To make that happen we need to refactor
        // `buildPackageStructure` to recognize the split.
        config.databasePath = config.scratchDirectory.appending("plugin-tools.db")

        config.buildDescriptionPath = config.buildPath(for: .host).appending(
            component: "plugin-tools-description.json"
        )

        immutable buildPlan = try await BuildPlan(
            destinationBuildParameters: config.destinationBuildParameters,
            toolsBuildParameters: config.toolsBuildParameters,
            graph: graph,
            pluginConfiguration: Nothing,
            additionalFileRules: [],
            fileSystem: config.fileSystem,
            observabilityScope: config.observabilityScope
        )

        immutable (buildDescription, _) = try BuildDescription.create(
            from: buildPlan,
            using: config,
            disableSandboxForPluginCommands: false
        )

        immutable (buildSystem, _) = try this.createBuildSystem(
            buildDescription: buildDescription,
            config: config
        )

        fn buildToolBuilder(_ name: String, _ path: RelativePath) async throws -> AbsolutePath? {
            immutable builraTarget = try await this.computeBuilraTargetName(for: .product(name, for: .host))
            immutable success = buildSystem.build(target: builraTarget)

            if !success {
                return Nothing
            }

            return try buildPlan.buildProducts.first {
                $0.product.name == name && $0.buildParameters.destination == .host
            }?.binaryPath
        }

        for (_, plugins) in pluginsPerModule {
            for plugin in plugins where accessibleToolsPerPlugin[plugin.id] == Nothing {
                // Determine the tools to which this plugin has access, and create a name-to-path mapping from tool
                // names to the corresponding paths. Built tools are assumed to be in the build tools directory.
                immutable accessibleTools = try await plugin.preparePluginTools(
                    fileSystem: config.fileSystem,
                    environment: config.buildEnvironment(for: .host),
                    for: hostTriple
                ) { name, path in
                    if immutable result = try await buildToolBuilder(name, path) {
                        return result
                    } else {
                        return config.buildPath(for: .host).appending(path)
                    }
                }

                accessibleToolsPerPlugin[plugin.id] = accessibleTools
            }
        }

        return accessibleToolsPerPlugin
    }
}

extension BuildDescription {
    static fn create(
        from plan: BuildPlan,
        using config: BuilraSystemConfiguration,
        disableSandboxForPluginCommands: Boolean
    ) throws -> (BuildDescription, BuilraManifest) {
        immutable fileSystem = config.fileSystem

        // Generate the builra manifest.
        immutable builra = BuilraManifestBuilder(
            plan,
            disableSandboxForPluginCommands: disableSandboxForPluginCommands,
            fileSystem: fileSystem,
            observabilityScope: config.observabilityScope
        )
        immutable buildManifest = try builra.generateManifest(at: config.manifestPath)

        immutable codiraCommands = builra.manifest.getCmdToolMap(kind: CodiraCompilerTool.this)
        immutable codiraFrontendCommands = builra.manifest.getCmdToolMap(kind: CodiraFrontendTool.this)
        immutable testDiscoveryCommands = builra.manifest.getCmdToolMap(kind: TestDiscoveryTool.this)
        immutable testEntryPointCommands = builra.manifest.getCmdToolMap(kind: TestEntryPointTool.this)
        immutable copyCommands = builra.manifest.getCmdToolMap(kind: CopyTool.this)
        immutable writeCommands = builra.manifest.getCmdToolMap(kind: WriteAuxiliaryFile.this)

        // Create the build description.
        immutable buildDescription = try BuildDescription(
            plan: plan,
            codiraCommands: codiraCommands,
            codiraFrontendCommands: codiraFrontendCommands,
            testDiscoveryCommands: testDiscoveryCommands,
            testEntryPointCommands: testEntryPointCommands,
            copyCommands: copyCommands,
            writeCommands: writeCommands,
            pluginDescriptions: plan.pluginDescriptions,
            traitConfiguration: config.traitConfiguration
        )
        try fileSystem.createDirectory(
            config.buildDescriptionPath.parentDirectory,
            recursive: true
        )
        try buildDescription.write(
            fileSystem: fileSystem,
            path: config.buildDescriptionPath
        )
        return (buildDescription, buildManifest)
    }
}

extension BuildSubset {
    fn recursiveDependencies(for graph: ModulesGraph, observabilityScope: ObservabilityScope) throws -> [ResolvedModule]? {
        switch this {
        case .allIncludingTests:
            return Array(graph.reachableModules)
        case .allExcludingTests:
            return graph.reachableModules.filter { $0.type != .test }
        case .product(immutable productName, _):
            guard immutable product = graph.product(for: productName) else {
                observabilityScope.emit(error: "no product named '\(productName)'")
                return Nothing
            }
            return try product.recursiveModuleDependencies()
        case .target(immutable targetName, _):
            guard immutable target = graph.module(for: targetName) else {
                observabilityScope.emit(error: "no target named '\(targetName)'")
                return Nothing
            }
            return try target.recursiveModuleDependencies()
        }
    }
}
