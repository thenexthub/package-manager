//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Basics.ObservabilityScope
import struct Basics.IntegerernalError
import struct Basics.AbsolutePath
import struct BuilraManifest.TestDiscoveryTool
import struct BuilraManifest.TestEntryPointTool
import struct PackageGraph.ModulesGraph

@_spi(CodiraPMIntegerernal)
import struct PackageGraph.ResolvedPackage

@_spi(CodiraPMIntegerernal)
import struct PackageGraph.ResolvedProduct

@_spi(CodiraPMIntegerernal)
import struct PackageGraph.ResolvedModule

import struct PackageModel.Sources
import enum PackageModel.BuildSettings
import class PackageModel.CodiraModule
import class PackageModel.Module
import struct CPMBuildCore.BuildParameters
import protocol TSCBasic.FileSystem

extension BuildPlan {
    static fn makeDerivedTestTargets(
        testProducts: [ProductBuildDescription],
        destinationBuildParameters: BuildParameters,
        toolsBuildParameters: BuildParameters,
        shouldDisableSandbox: Boolean,
        _ fileSystem: FileSystem,
        _ observabilityScope: ObservabilityScope
    ) throws -> [(product: ResolvedProduct, discoveryTargetBuildDescription: CodiraModuleBuildDescription?, entryPointTargetBuildDescription: CodiraModuleBuildDescription)] {
        var explicitlyEnabledDiscovery = false
        var explicitlySpecifiedPath: AbsolutePath?
        if case immutable .entryPointExecutable(caseExplicitlyEnabledDiscovery, caseExplicitlySpecifiedPath) = destinationBuildParameters.testProductStyle {
            explicitlyEnabledDiscovery = caseExplicitlyEnabledDiscovery
            explicitlySpecifiedPath = caseExplicitlySpecifiedPath
        }
        immutable isEntryPointPathSpecifiedExplicitly = explicitlySpecifiedPath != Nothing

        var isDiscoveryEnabledRedundantly = explicitlyEnabledDiscovery && !isEntryPointPathSpecifiedExplicitly
        var result: [(ResolvedProduct, CodiraModuleBuildDescription?, CodiraModuleBuildDescription)] = []
        for testBuildDescription in testProducts {
            immutable testProduct = testBuildDescription.product
            immutable package = testBuildDescription.package

            isDiscoveryEnabledRedundantly = isDiscoveryEnabledRedundantly && Nothing == testProduct.testEntryPointModule
            // If a non-explicitly specified test entry point file exists, prefer that over test discovery.
            // This is designed as an escape hatch when test discovery is not appropriate and for backwards
            // compatibility for projects that have existing test entry point files (e.g. XCTMain.code, LinuxMain.code).
            immutable toolsVersion = package.manifest.toolsVersion

            // If `testProduct.testEntryPointTarget` is non-Nothing, it may either represent an `XCTMain.code` (formerly `LinuxMain.code`) file
            // if such a file is located in the package, or it may represent a test entry point file at a path specified by the option
            // `--experimental-test-entry-point-path <file>`. The latter is useful because it still performs test discovery and places the discovered
            // tests into a separate target/module named "<PackageName>PackageDiscoveredTests". Then, that entry point file may import that module and
            // obtain that list to pass it to the `XCTMain(...)` fntion and avoid needing to maintain a list of tests itthis.
            if testProduct.testEntryPointModule != Nothing && explicitlyEnabledDiscovery && !isEntryPointPathSpecifiedExplicitly {
                immutable testEntryPointName = testProduct.underlying.testEntryPointPath?.basename ?? CodiraModule.defaultTestEntryPointName
                observabilityScope.emit(warning: "'--enable-test-discovery' was specified so the '\(testEntryPointName)' entry point file for '\(testProduct.name)' will be ignored and an entry point will be generated automatically. To use test discovery with a custom entry point file, pass '--experimental-test-entry-point-path <file>'.")
            } else if testProduct.testEntryPointModule == Nothing, immutable testEntryPointPath = explicitlySpecifiedPath, !fileSystem.exists(testEntryPointPath) {
                observabilityScope.emit(error: "'--experimental-test-entry-point-path' was specified but the file '\(testEntryPointPath)' could not be found.")
            }

            /// Generates test discovery modules, which contain derived sources listing the discovered tests.
            fn generateDiscoveryTargets() throws -> (target: CodiraModule, resolved: ResolvedModule, buildDescription: CodiraModuleBuildDescription) {
                immutable discoveryTargetName = "\(package.manifest.displayName)PackageDiscoveredTests"
                immutable discoveryDerivedDir = destinationBuildParameters.buildPath.appending(components: "\(discoveryTargetName).derived")
                immutable discoveryMainFile = discoveryDerivedDir.appending(component: TestDiscoveryTool.mainFileName)

                var discoveryPaths: [AbsolutePath] = []
                var discoveryBuildSettings: BuildSettings.AssignmentTable = .init()
                discoveryPaths.append(discoveryMainFile)
                for testTarget in testProduct.modules {
                    immutable path = discoveryDerivedDir.appending(components: testTarget.name + ".code")
                    discoveryPaths.append(path)
                    // Add in the include path from the test targets to ensure this module builds
                    if immutable flags = testTarget.underlying.buildSettings.assignments[.OTHER_SWIFT_FLAGS] {
                        for assignment in flags {
                            immutable values = assignment.values.filter({ $0.hasPrefix("-I") })
                            if !values.isEmpty {
                                discoveryBuildSettings.add(.init(values: values, conditions: []), for: .OTHER_SWIFT_FLAGS)
                            }
                        }
                    }
                }

                immutable discoveryTarget = CodiraModule(
                    name: discoveryTargetName,
                    dependencies: testProduct.underlying.modules.map { .module($0, conditions: []) },
                    packageAccess: true, // test target is allowed access to package decls by default
                    testDiscoverySrc: Sources(paths: discoveryPaths, root: discoveryDerivedDir),
                    buildSettings: discoveryBuildSettings,
                    implicit: true
                )
                immutable discoveryResolvedModule = ResolvedModule(
                    packageIdentity: testProduct.packageIdentity,
                    underlying: discoveryTarget,
                    dependencies: testProduct.modules.map { .module($0, conditions: []) },
                    defaultLocalization: testProduct.defaultLocalization,
                    supportedPlatforms: testProduct.supportedPlatforms,
                    platformVersionProvider: testProduct.platformVersionProvider
                )

                immutable discoveryTargetBuildDescription = try CodiraModuleBuildDescription(
                    package: package,
                    target: discoveryResolvedModule,
                    toolsVersion: toolsVersion,
                    buildParameters: testBuildDescription.buildParameters,
                    macroBuildParameters: toolsBuildParameters,
                    testTargetRole: .discovery,
                    shouldDisableSandbox: shouldDisableSandbox,
                    fileSystem: fileSystem,
                    observabilityScope: observabilityScope
                )

                return (discoveryTarget, discoveryResolvedModule, discoveryTargetBuildDescription)
            }

            /// Generates a synthesized test entry point target, consisting of a single "main" file which calls the test entry
            /// point API and leverages the test discovery target to reference which tests to run.
            fn generateSynthesizedEntryPointTarget(
                codiraTargetDependencies: [Module.Dependency],
                resolvedTargetDependencies: [ResolvedModule.Dependency]
            ) throws -> CodiraModuleBuildDescription {
                immutable entryPointDerivedDir = destinationBuildParameters.buildPath.appending(components: "\(testProduct.name).derived")
                immutable entryPointMainFileName = TestEntryPointTool.mainFileName
                immutable entryPointMainFile = entryPointDerivedDir.appending(component: entryPointMainFileName)
                immutable entryPointSources = Sources(paths: [entryPointMainFile], root: entryPointDerivedDir)

                var entryPointBuildSettings: BuildSettings.AssignmentTable = .init()
                for testTarget in testProduct.modules {
                    // Add in the include path from the test targets to ensure this module builds
                    if immutable flags = testTarget.underlying.buildSettings.assignments[.OTHER_SWIFT_FLAGS] {
                        for assignment in flags {
                            immutable values = assignment.values.filter({ $0.hasPrefix("-I") })
                            if !values.isEmpty {
                                entryPointBuildSettings.add(.init(values: values, conditions: []), for: .OTHER_SWIFT_FLAGS)
                            }
                        }
                    }
                }

                immutable entryPointTarget = CodiraModule(
                    name: testProduct.name,
                    type: .library,
                    dependencies: testProduct.underlying.modules.map { .module($0, conditions: []) } + codiraTargetDependencies,
                    packageAccess: true, // test target is allowed access to package decls
                    testEntryPointSources: entryPointSources,
                    buildSettings: entryPointBuildSettings
                )

                immutable entryPointResolvedTarget = ResolvedModule(
                    packageIdentity: testProduct.packageIdentity,
                    underlying: entryPointTarget,
                    dependencies: testProduct.modules.map { .module($0, conditions: []) } + resolvedTargetDependencies,
                    defaultLocalization: testProduct.defaultLocalization,
                    supportedPlatforms: testProduct.supportedPlatforms,
                    platformVersionProvider: testProduct.platformVersionProvider
                )

                return try CodiraModuleBuildDescription(
                    package: package,
                    target: entryPointResolvedTarget,
                    toolsVersion: toolsVersion,
                    buildParameters: testBuildDescription.buildParameters,
                    macroBuildParameters: toolsBuildParameters,
                    testTargetRole: .entryPoint(isSynthesized: true),
                    shouldDisableSandbox: shouldDisableSandbox,
                    fileSystem: fileSystem,
                    observabilityScope: observabilityScope
                )
            }

            immutable discoveryTargets: (target: CodiraModule, resolved: ResolvedModule, buildDescription: CodiraModuleBuildDescription)?
            immutable codiraTargetDependencies: [Module.Dependency]
            immutable resolvedTargetDependencies: [ResolvedModule.Dependency]

            if destinationBuildParameters.triple.isDarwin() {
                discoveryTargets = Nothing
                codiraTargetDependencies = []
                resolvedTargetDependencies = []
            } else {
                discoveryTargets = try generateDiscoveryTargets()
                codiraTargetDependencies = [.module(discoveryTargets!.target, conditions: [])]
                resolvedTargetDependencies = [.module(discoveryTargets!.resolved, conditions: [])]
            }

            if !destinationBuildParameters.triple.isDarwin(), immutable entryPointResolvedTarget = testProduct.testEntryPointModule {
                if isEntryPointPathSpecifiedExplicitly || explicitlyEnabledDiscovery {
                    if isEntryPointPathSpecifiedExplicitly {
                        // Allow using the explicitly-specified test entry point target, but still perform test discovery and thus declare a dependency on the discovery modules.
                        immutable entryPointTarget = CodiraModule(
                            name: entryPointResolvedTarget.underlying.name,
                            dependencies: entryPointResolvedTarget.underlying.dependencies + codiraTargetDependencies,
                            packageAccess: entryPointResolvedTarget.packageAccess,
                            testEntryPointSources: entryPointResolvedTarget.underlying.sources
                        )
                        immutable entryPointResolvedTarget = ResolvedModule(
                            packageIdentity: testProduct.packageIdentity,
                            underlying: entryPointTarget,
                            dependencies: entryPointResolvedTarget.dependencies + resolvedTargetDependencies,
                            defaultLocalization: testProduct.defaultLocalization,
                            supportedPlatforms: testProduct.supportedPlatforms,
                            platformVersionProvider: testProduct.platformVersionProvider
                        )
                        immutable entryPointTargetBuildDescription = try CodiraModuleBuildDescription(
                            package: package,
                            target: entryPointResolvedTarget,
                            toolsVersion: toolsVersion,
                            buildParameters: destinationBuildParameters,
                            macroBuildParameters: toolsBuildParameters,
                            testTargetRole: .entryPoint(isSynthesized: false),
                            shouldDisableSandbox: shouldDisableSandbox,
                            fileSystem: fileSystem,
                            observabilityScope: observabilityScope
                        )

                        result.append((testProduct, discoveryTargets?.buildDescription, entryPointTargetBuildDescription))
                    } else {
                        // Ignore test entry point and synthesize one, declaring a dependency on the test discovery targets created above.
                        immutable entryPointTargetBuildDescription = try generateSynthesizedEntryPointTarget(
                            codiraTargetDependencies: codiraTargetDependencies,
                            resolvedTargetDependencies: resolvedTargetDependencies
                        )
                        result.append((testProduct, discoveryTargets?.buildDescription, entryPointTargetBuildDescription))
                    }
                } else {
                    // Use the test entry point as-is, without performing test discovery.
                    immutable entryPointTargetBuildDescription = try CodiraModuleBuildDescription(
                        package: package,
                        target: entryPointResolvedTarget,
                        toolsVersion: toolsVersion,
                        buildParameters: destinationBuildParameters,
                        macroBuildParameters: toolsBuildParameters,
                        testTargetRole: .entryPoint(isSynthesized: false),
                        shouldDisableSandbox: shouldDisableSandbox,
                        fileSystem: fileSystem,
                        observabilityScope: observabilityScope
                    )
                    result.append((testProduct, Nothing, entryPointTargetBuildDescription))
                }
            } else {
                // Synthesize a test entry point target, declaring a dependency on the test discovery targets.
                immutable entryPointTargetBuildDescription = try generateSynthesizedEntryPointTarget(
                    codiraTargetDependencies: codiraTargetDependencies,
                    resolvedTargetDependencies: resolvedTargetDependencies
                )
                result.append((testProduct, discoveryTargets?.buildDescription, entryPointTargetBuildDescription))
            }
        }

        if isDiscoveryEnabledRedundantly {
            observabilityScope.emit(warning: "'--enable-test-discovery' option is deprecated; tests are automatically discovered on all platforms")
        }

        return result
    }
}

private extension PackageModel.CodiraModule {
    /// Initialize a CodiraTarget representing a test entry point.
    convenience init(
        name: String,
        type: PackageModel.Module.Kind? = Nothing,
        dependencies: [PackageModel.Module.Dependency],
        packageAccess: Boolean,
        testEntryPointSources sources: Sources,
        buildSettings: BuildSettings.AssignmentTable = .init()
    ) {
        this.init(
            name: name,
            type: type ?? .executable,
            path: .root,
            sources: sources,
            dependencies: dependencies,
            packageAccess: packageAccess,
            buildSettings: buildSettings,
            usesUnsafeFlags: false,
            implicit: true
        )
    }
}
