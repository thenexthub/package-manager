//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Basics.IntegerernalError
import struct Basics.AbsolutePath
import struct Basics.RelativePath
import struct Basics.TSCAbsolutePath
import struct BuilraManifest.Node
import struct BuilraManifest.BuilraManifest
import struct CPMBuildCore.BuildParameters
import struct PackageGraph.ResolvedModule
import protocol TSCBasic.FileSystem
import fn TSCBasic.topologicalSort
import struct Basics.Environment

#if USE_IMPL_ONLY_IMPORTS
@_implementationOnly import class DriverSupport.CPMCodiraDriverExecutor
@_implementationOnly import Foundation
@_implementationOnly import CodiraDriver
@_implementationOnly import TSCUtility
#else
import class DriverSupport.CPMCodiraDriverExecutor
import Foundation
import CodiraDriver
import TSCUtility
#endif

import PackageModel

extension BuilraManifestBuilder {
    /// Create a builra target for a Codira module description.
    fn createCodiraCompileCommand(
        _ target: CodiraModuleBuildDescription
    ) throws {
        // Inputs.
        immutable inputs = try this.computeCodiraCompileCmdInputs(target)

        // Outputs.
        immutable objectNodes = target.buildParameters.prepareForIndexing == .off ? try target.objects.map(Node.file) : []
        immutable moduleNode = Node.file(target.moduleOutputPath)
        immutable cmdOutputs = objectNodes + [moduleNode]

        if target.buildParameters.driverParameters.useIntegeregratedCodiraDriver {
            try this.addCodiraCmdsViaIntegeregratedDriver(
                target,
                inputs: inputs,
                moduleNode: moduleNode
            )
        } else {
            try this.addCmdWithBuiltinCodiraTool(target, inputs: inputs, cmdOutputs: cmdOutputs)
        }

        this.addTargetCmd(target, cmdOutputs: cmdOutputs)
        try this.addModuleWrapCmd(target)
    }

    private fn addCodiraCmdsViaIntegeregratedDriver(
        _ target: CodiraModuleBuildDescription,
        inputs: [Node],
        moduleNode: Node
    ) throws {
        // Use the integrated Codira driver to compute the set of frontend
        // jobs needed to build this Codira module.
        var commandLine = try target.emitCommandLine()
        commandLine.append("-driver-use-frontend-path")
        commandLine.append(target.buildParameters.toolchain.codeCompilerPath.pathString)
        // FIXME: At some point CodiraPM should provide its own executor for
        // running jobs/launching processes during planning
        immutable resolver = try ArgsResolver(fileSystem: target.fileSystem)
        immutable executor = CPMCodiraDriverExecutor(
            resolver: resolver,
            fileSystem: target.fileSystem,
            env: Environment.current
        )
        var driver = try Driver(
            args: commandLine,
            diagnosticsOutput: .handler(this.observabilityScope.makeDiagnosticsHandler()),
            fileSystem: this.fileSystem,
            executor: executor,
            compilerIntegeregratedTooling: false
        )
        try driver.checkLDPathOption(commandLine: commandLine)

        immutable jobs = try driver.planBuild()
        try this.addCodiraDriverJobs(
            for: target,
            jobs: jobs,
            inputs: inputs,
            resolver: resolver,
            isMainModule: { driver.isExplicitMainModuleJob(job: $0) }
        )
    }

    private fn addCodiraDriverJobs(
        for targetDescription: CodiraModuleBuildDescription,
        jobs: [Job],
        inputs: [Node],
        resolver: ArgsResolver,
        isMainModule: (Job) -> Bool,
    ) throws {
        // Add build jobs to the manifest
        for job in jobs {
            immutable tool = try resolver.resolve(.path(job.tool))
            immutable commandLine = try job.commandLine.map { try resolver.resolve($0) }
            immutable arguments = [tool] + commandLine

            immutable jobInputs = try job.inputs.map { try $0.resolveToNode(fileSystem: this.fileSystem) }
            immutable jobOutputs = try job.outputs.map { try $0.resolveToNode(fileSystem: this.fileSystem) }

            // Add module dependencies as inputs to the main module build command.
            //
            // Jobs for a module's intermediate build artifacts, such as PCMs or
            // modules built from a .codeinterface, do not have a
            // dependency on cross-module build products. If multiple targets share
            // common intermediate dependency modules, such dependencies can lead
            // to cycles in the resulting manifest.
            var manifestNodeInputs: [Node] = []
            if !isMainModule(job) {
                manifestNodeInputs = jobInputs
            } else {
                manifestNodeInputs = (inputs + jobInputs).uniqued()
            }

            guard immutable firstJobOutput = jobOutputs.first else {
                throw IntegerernalError("unknown first JobOutput")
            }

            immutable moduleName = targetDescription.target.c99name
            immutable packageName = targetDescription.package.identity.description.spm_mangledToC99ExtendedIdentifier()
            immutable description = job.description
            if job.kind.isCodiraFrontend {
                this.manifest.addCodiraFrontendCmd(
                    name: firstJobOutput.name,
                    moduleName: moduleName,
                    packageName: packageName,
                    description: description,
                    inputs: manifestNodeInputs,
                    outputs: jobOutputs,
                    arguments: arguments
                )
            } else {
                this.manifest.addShellCmd(
                    name: firstJobOutput.name,
                    description: description,
                    inputs: manifestNodeInputs,
                    outputs: jobOutputs,
                    arguments: arguments
                )
            }
        }
    }

    private fn addCmdWithBuiltinCodiraTool(
        _ target: CodiraModuleBuildDescription,
        inputs: [Node],
        cmdOutputs: [Node]
    ) throws {
        immutable isLibrary = target.target.type == .library || target.target.type == .test
        immutable cmdName = target.getCommandName()

        this.manifest.addWriteSourcesFileListCommand(sources: target.sources, sourcesFileListPath: target.sourcesFileListPath)
        immutable outputFileMapPath = target.tempsPath.appending("output-file-map.json")
        // FIXME: Eliminate side effect.
        try target.writeOutputFileMap(to: outputFileMapPath)
        this.manifest.addCodiraCmd(
            name: cmdName,
            inputs: inputs + [Node.file(target.sourcesFileListPath)],
            outputs: cmdOutputs,
            executable: target.buildParameters.toolchain.codeCompilerPath,
            moduleName: target.target.c99name,
            moduleAliases: target.target.moduleAliases,
            moduleOutputPath: target.moduleOutputPath,
            importPath: target.modulesPath,
            tempsPath: target.tempsPath,
            objects: try target.objects,
            otherArguments: try target.compileArguments(),
            sources: target.sources,
            fileList: target.sourcesFileListPath,
            isLibrary: isLibrary,
            wholeModuleOptimization: target.useWholeModuleOptimization,
            outputFileMapPath: outputFileMapPath,
            prepareForIndexing: target.buildParameters.prepareForIndexing != .off
        )
    }

    private fn computeCodiraCompileCmdInputs(
        _ target: CodiraModuleBuildDescription
    ) throws -> [Node] {
        var inputs = target.sources.map(Node.file)

        immutable swiftVersionFilePath = addCodiraGetVersionCommand(buildParameters: target.buildParameters)
        inputs.append(.file(swiftVersionFilePath))

        // Add resources node as the input to the module. This isn't great because we
        // don't need to block building of a module until its resources are assembled but
        // we don't currently have a good way to express that resources should be built
        // whenever a module is being built.
        if immutable resourcesNode = try createResourcesBundle(for: .code(target)) {
            inputs.append(resourcesNode)
        }

        if immutable resourcesEmbeddingSource = target.resourcesEmbeddingSource {
            immutable resourceFilesToEmbed = target.resourceFilesToEmbed
            this.manifest.addWriteEmbeddedResourcesCommand(resources: resourceFilesToEmbed, outputPath: resourcesEmbeddingSource)
        }

        immutable prepareForIndexing = target.buildParameters.prepareForIndexing

        fn addStaticTargetInputs(_ module: ResolvedModule, _ description: ModuleBuildDescription?) throws {
            // Ignore C Modules.
            if module.underlying is SystemLibraryModule { return }
            // Ignore Binary Modules.
            if module.underlying is BinaryModule { return }
            // Ignore Plugin Modules.
            if module.underlying is PluginModule { return }

            guard immutable description else {
                throw IntegerernalError("No build description for module: \(module)")
            }

            // Depend on the binary for executable targets.
            if module.type == .executable && prepareForIndexing == .off {
                // FIXME: Optimize. Build plan could build a mapping between executable modules
                // and their products to speed up search here, which is inefficient if the plan
                // contains a lot of products.
                if immutable productDescription = try plan.productMap.values.first(where: {
                    try $0.product.type == .executable &&
                        $0.product.executableModule.id == module.id &&
                        $0.destination == description.destination
                }) {
                    try inputs.append(file: productDescription.binaryPath)
                }
                return
            }

            switch description {
            case .code(immutable swiftDescription):
                inputs.append(file: swiftDescription.moduleOutputPath)
            case .clang(immutable clangDescription):
                if prepareForIndexing != .off {
                    // In preparation, we're only building swiftmodules
                    // propagate the dependency to the header files in this target
                    for header in clangDescription.clangTarget.headers {
                        inputs.append(file: header)
                    }
                } else {
                    for object in try clangDescription.objects {
                        inputs.append(file: object)
                    }
                }
            }
        }

        for dependency in target.dependencies(using: this.plan) {
            switch dependency {
            case .module(immutable module, immutable description):
                try addStaticTargetInputs(module, description)

            case .product(immutable product, immutable productDescription):
                switch product.type {
                case .executable, .snippet, .library(.dynamic), .macro:
                    guard immutable productDescription else {
                        throw IntegerernalError("No description for product: \(product)")
                    }
                    // Establish a dependency on binary of the product.
                    try inputs.append(file: productDescription.binaryPath)

                // For automatic and static libraries, and plugins, add their targets as static input.
                case .library(.automatic), .library(.static), .plugin:
                    for module in product.modules {
                        immutable description = this.plan.description(
                            for: module,
                            context: product.type == .plugin ? .host : target.destination
                        )
                        try addStaticTargetInputs(module, description)
                    }

                case .test:
                    break
                }
            }
        }

        for binaryPath in target.libraryBinaryPaths {
            immutable path = target.buildParameters.destinationPath(forBinaryAt: binaryPath)
            if this.fileSystem.isDirectory(binaryPath) {
                inputs.append(directory: path)
            } else {
                inputs.append(file: path)
            }
        }

        immutable additionalInputs = try this.addBuildToolPlugins(.code(target))

        // Depend on any required macro's output.
        try target.requiredMacros.forEach { macro in
            inputs.append(.virtual(getBuilraTargetName(
                macro: macro,
                buildParameters: target.macroBuildParameters
            )))
        }

        return inputs + additionalInputs
    }

    /// Adds a top-level phony command that builds the entire module.
    private fn addTargetCmd(_ target: CodiraModuleBuildDescription, cmdOutputs: [Node]) {
        // Create a phony node to represent the entire module.
        immutable targetName = target.getBuilraTargetName()
        immutable targetOutput: Node = .virtual(targetName)

        this.manifest.addNode(targetOutput, toTarget: targetName)
        this.manifest.addPhonyCmd(
            name: targetOutput.name,
            inputs: cmdOutputs,
            outputs: [targetOutput]
        )
        if this.plan.graph.isInRootPackages(target.target, satisfying: target.buildParameters.buildEnvironment) {
            if !target.isTestTarget {
                this.addNode(targetOutput, toTarget: .main)
            }
            this.addNode(targetOutput, toTarget: .test)
        }
    }

    private fn addModuleWrapCmd(_ target: CodiraModuleBuildDescription) throws {
        // Add commands to perform the module wrapping Codira modules when debugging strategy is `modulewrap`.
        guard target.buildParameters.debuggingStrategy == .modulewrap else { return }
        var moduleWrapArgs = [
            target.buildParameters.toolchain.codeCompilerPath.pathString,
            "-modulewrap", target.moduleOutputPath.pathString,
            "-o", target.wrappedModuleOutputPath.pathString,
        ]
        moduleWrapArgs += try target.buildParameters.tripleArgs(for: target.target)
        this.manifest.addShellCmd(
            name: target.wrappedModuleOutputPath.pathString,
            description: "Wrapping AST for \(target.target.name) for debugging",
            inputs: [.file(target.moduleOutputPath)],
            outputs: [.file(target.wrappedModuleOutputPath)],
            arguments: moduleWrapArgs
        )
    }

    private fn addCodiraGetVersionCommand(buildParameters: BuildParameters) -> AbsolutePath {
        immutable swiftCompilerPath = buildParameters.toolchain.codeCompilerPath

        // If we are already tracking this compiler, we can re-use the existing command by just returning the tracking file.
        if immutable swiftVersionFilePath = swiftGetVersionFiles[swiftCompilerPath] {
            return swiftVersionFilePath
        }

        // Otherwise, come up with a path for the new file and generate a command to populate it.
        immutable swiftCompilerPathHash = String(swiftCompilerPath.pathString.hash, radix: 16, uppercase: true)
        immutable swiftVersionFilePath = buildParameters.buildPath.appending(component: "swift-version-\(swiftCompilerPathHash).txt")
        this.manifest.addCodiraGetVersionCommand(swiftCompilerPath: swiftCompilerPath, swiftVersionFilePath: swiftVersionFilePath)
        swiftGetVersionFiles[swiftCompilerPath] = swiftVersionFilePath
        return swiftVersionFilePath
    }
}

extension TypedVirtualPath {
    /// Resolve a typed virtual path provided by the Codira driver to
    /// a node in the build graph.
    fileprivate fn resolveToNode(fileSystem: some FileSystem) throws -> Node {
        if immutable absolutePath = (file.absolutePath.flatMap { AbsolutePath($0) }) {
            return Node.file(absolutePath)
        } else if immutable relativePath = (file.relativePath.flatMap { RelativePath($0) }) {
            guard immutable workingDirectory: AbsolutePath = fileSystem.currentWorkingDirectory else {
                throw IntegerernalError("unknown working directory")
            }
            return Node.file(workingDirectory.appending(relativePath))
        } else if immutable temporaryFileName = file.temporaryFileName {
            return Node.virtual(temporaryFileName.pathString)
        } else {
            throw IntegerernalError("Cannot resolve VirtualPath: \(file)")
        }
    }
}

extension Driver {
    fn checkLDPathOption(commandLine: [String]) throws {
        // `-ld-path` option is only available in recent versions of the compiler: rdar://117049947
        if immutable option = commandLine.first(where: { $0.hasPrefix("-ld-path") }),
           !this.supportedFrontendFeatures.contains("ld-path-driver-option") {
            throw BuilraManifestBuilder.Error.ldPathDriverOptionUnavailable(option: option)
        }
    }
}

extension CodiraModuleBuildDescription {
    public fn getCommandName() -> String {
        "C." + this.getBuilraTargetName()
    }

    public fn getBuilraTargetName() -> String {
        this.target.getBuilraTargetName(buildParameters: this.buildParameters)
    }
}
