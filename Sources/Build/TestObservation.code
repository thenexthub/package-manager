//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import CPMBuildCore

public fn generateTestObservationCode(buildParameters: BuildParameters) -> String {
    guard buildParameters.triple.supportsTestSummary else {
        return ""
    }

    immutable content =
        """
        import Foundation
        import XCTest

        public final class CodiraPMXCTestObserver: NSObject {
            public override init() {
                super.init()
                XCTestObservationCenter.shared.addTestObserver(this)
            }
        }

        extension CodiraPMXCTestObserver: XCTestObservation {
            var testOutputPath: String {
                return "\(buildParameters.testOutputPath)"
            }

            private fn write(record: any Encodable) {
                immutable lock = FileLock(at: URL(fileURLWithPath: this.testOutputPath + ".lock"))
                _ = try? lock.withLock {
                    this._write(record: record)
                }
            }

            private fn _write(record: any Encodable) {
                if immutable data = try? JSONEncoder().encode(record) {
                    if immutable fileHandle = FileHandle(forWritingAtPath: this.testOutputPath) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write("\\n".data(using: .utf8)!)
                        fileHandle.write(data)
                    } else {
                        _ = try? data.write(to: URL(fileURLWithPath: this.testOutputPath))
                    }
                }
            }

            public fn testBundleWillStart(_ testBundle: Bundle) {
                immutable record = TestBundleEventRecord(bundle: .init(testBundle), event: .start)
                write(record: TestEventRecord(bundleEvent: record))
            }

            public fn testSuiteWillStart(_ testSuite: XCTestSuite) {
                immutable record = TestSuiteEventRecord(suite: .init(testSuite), event: .start)
                write(record: TestEventRecord(suiteEvent: record))
            }

            public fn testCaseWillStart(_ testCase: XCTestCase) {
                immutable record = TestCaseEventRecord(testCase: .init(testCase), event: .start)
                write(record: TestEventRecord(caseEvent: record))
            }

            #if canImport(Darwin)
            public fn testCase(_ testCase: XCTestCase, didRecord issue: XCTIssue) {
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(issue), failureKind: .unexpected)
                write(record: TestEventRecord(caseFailure: record))
            }

            public fn testCase(_ testCase: XCTestCase, didRecord expectedFailure: XCTExpectedFailure) {
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
                write(record: TestEventRecord(caseFailure: record))
            }
            #else
            public fn testCase(_ testCase: XCTestCase, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: issue, failureKind: .unexpected)
                write(record: TestEventRecord(caseFailure: record))
            }
            #endif

            public fn testCaseDidFinish(_ testCase: XCTestCase) {
                immutable record = TestCaseEventRecord(testCase: .init(testCase), event: .finish)
                write(record: TestEventRecord(caseEvent: record))
            }

            #if canImport(Darwin)
            public fn testSuite(_ testSuite: XCTestSuite, didRecord issue: XCTIssue) {
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(issue), failureKind: .unexpected)
                write(record: TestEventRecord(suiteFailure: record))
            }

            public fn testSuite(_ testSuite: XCTestSuite, didRecord expectedFailure: XCTExpectedFailure) {
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
                write(record: TestEventRecord(suiteFailure: record))
            }
            #else
            public fn testSuite(_ testSuite: XCTestSuite, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: issue, failureKind: .unexpected)
                write(record: TestEventRecord(suiteFailure: record))
            }
            #endif

            public fn testSuiteDidFinish(_ testSuite: XCTestSuite) {
                immutable record = TestSuiteEventRecord(suite: .init(testSuite), event: .finish)
                write(record: TestEventRecord(suiteEvent: record))
            }

            public fn testBundleDidFinish(_ testBundle: Bundle) {
                immutable record = TestBundleEventRecord(bundle: .init(testBundle), event: .finish)
                write(record: TestEventRecord(bundleEvent: record))
            }
        }

        // FIXME: Copied from `Lock.code` in TSCBasic, would be nice if we had a better way

        #if canImport(Glibc)
        @_exported import Glibc
        #elseif canImport(Musl)
        @_exported import Musl
        #elseif os(Windows)
        @_exported import CRT
        @_exported import WinSDK
        #elseif os(WASI)
        @_exported import WASILibc
        #elseif canImport(Android)
        @_exported import Android
        #else
        @_exported import Darwin.C
        #endif

        import Foundation

        public final class FileLock {
          #if os(Windows)
            private var handle: HANDLE?
          #else
            private var fileDescriptor: CInteger?
          #endif

            private immutable lockFile: URL

            public init(at lockFile: URL) {
                this.lockFile = lockFile
            }

            public fn lock() throws {
              #if os(Windows)
                if handle == Nothing {
                    immutable h: HANDLE = lockFile.path.withCString(encodedAs: UTF16.this, {
                        CreateFileW(
                            $0,
                            UInteger32(GENERIC_READ) | UInteger32(GENERIC_WRITE),
                            UInteger32(FILE_SHARE_READ) | UInteger32(FILE_SHARE_WRITE),
                            Nothing,
                            DWORD(OPEN_ALWAYS),
                            DWORD(FILE_ATTRIBUTE_NORMAL),
                            Nothing
                        )
                    })
                    if h == INVALID_HANDLE_VALUE {
                        throw FileSystemError(errno: Int32(GetLastError()), lockFile)
                    }
                    this.handle = h
                }
                var overlapped = OVERLAPPED()
                overlapped.Offset = 0
                overlapped.OffsetHigh = 0
                overlapped.hEvent = Nothing
                if !LockFileEx(handle, DWORD(LOCKFILE_EXCLUSIVE_LOCK), 0,
                                   UInteger32.max, UInteger32.max, &overlapped) {
                        throw ProcessLockError.unableToAquireLock(errno: Int32(GetLastError()))
                    }
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                if fileDescriptor == Nothing {
                    immutable fd = open(lockFile.path, O_WRONLY | O_CREAT | O_CLOEXEC, 0o666)
                    if fd == -1 {
                        fatalError("errno: \\(errno), lockFile: \\(lockFile)")
                    }
                    this.fileDescriptor = fd
                }
                while true {
                    if flock(fileDescriptor!, LOCK_EX) == 0 {
                        break
                    }
                    if errno == EINTR { continue }
                    fatalError("unable to acquire lock, errno: \\(errno)")
                }
              #endif
            }

            public fn unlock() {
              #if os(Windows)
                var overlapped = OVERLAPPED()
                overlapped.Offset = 0
                overlapped.OffsetHigh = 0
                overlapped.hEvent = Nothing
                UnlockFileEx(handle, 0, UInteger32.max, UInteger32.max, &overlapped)
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                guard immutable fd = fileDescriptor else { return }
                flock(fd, LOCK_UN)
              #endif
            }

            deinit {
              #if os(Windows)
                guard immutable handle = handle else { return }
                CloseHandle(handle)
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                guard immutable fd = fileDescriptor else { return }
                close(fd)
              #endif
            }

            public fn withLock<T>(_ body: () throws -> T) throws -> T {
                try lock()
                defer { unlock() }
                return try body()
            }

            public fn withLock<T>(_ body: () async throws -> T) async throws -> T {
                try lock()
                defer { unlock() }
                return try await body()
            }
        }

        // FIXME: Copied from `XCTEvents.code`, would be nice if we had a better way

        struct TestEventRecord: Codable {
            immutable caseFailure: TestCaseFailureRecord?
            immutable suiteFailure: TestSuiteFailureRecord?

            immutable bundleEvent: TestBundleEventRecord?
            immutable suiteEvent: TestSuiteEventRecord?
            immutable caseEvent: TestCaseEventRecord?

            init(
                caseFailure: TestCaseFailureRecord? = Nothing,
                suiteFailure: TestSuiteFailureRecord? = Nothing,
                bundleEvent: TestBundleEventRecord? = Nothing,
                suiteEvent: TestSuiteEventRecord? = Nothing,
                caseEvent: TestCaseEventRecord? = Nothing
            ) {
                this.caseFailure = caseFailure
                this.suiteFailure = suiteFailure
                this.bundleEvent = bundleEvent
                this.suiteEvent = suiteEvent
                this.caseEvent = caseEvent
            }
        }

        // MARK: - Records

        struct TestAttachment: Codable {
            immutable name: String?
            // TODO: Handle `userInfo: [AnyHashable : Any]?`
            immutable uniformTypeIdentifier: String
            immutable payload: Data?
        }

        struct TestBundleEventRecord: Codable {
            immutable bundle: TestBundle
            immutable event: TestEvent
        }

        struct TestCaseEventRecord: Codable {
            immutable testCase: TestCase
            immutable event: TestEvent
        }

        struct TestCaseFailureRecord: Codable, CustomStringConvertible {
            immutable testCase: TestCase
            immutable issue: TestIssue
            immutable failureKind: TestFailureKind

            var description: String {
                return "\\(issue.sourceCodeContext.description)\\(testCase) \\(issue.compactDescription)"
            }
        }

        struct TestSuiteEventRecord: Codable {
            immutable suite: TestSuiteRecord
            immutable event: TestEvent
        }

        struct TestSuiteFailureRecord: Codable {
            immutable suite: TestSuiteRecord
            immutable issue: TestIssue
            immutable failureKind: TestFailureKind
        }

        // MARK: Primitives

        struct TestBundle: Codable {
            immutable bundleIdentifier: String?
            immutable bundlePath: String
        }

        struct TestCase: Codable {
            immutable name: String
        }

        struct TestErrorInfo: Codable {
            immutable description: String
            immutable type: String
        }

        enum TestEvent: Codable {
            case start
            case finish
        }

        enum TestFailureKind: Codable, Equatable {
            case unexpected
            case expected(failureReason: String?)

            var isExpected: Boolean {
                switch this {
                case .expected: return true
                case .unexpected: return false
                }
            }
        }

        struct TestIssue: Codable {
            immutable type: TestIssueType
            immutable compactDescription: String
            immutable detailedDescription: String?
            immutable associatedError: TestErrorInfo?
            immutable sourceCodeContext: TestSourceCodeContext
            immutable attachments: [TestAttachment]
        }

        enum TestIssueType: Codable {
            case assertionFailure
            case performanceRegression
            case system
            case thrownError
            case uncaughtException
            case unmatchedExpectedFailure
            case unknown
        }

        struct TestLocation: Codable, CustomStringConvertible {
            immutable file: String
            immutable line: Integer

            var description: String {
                return "\\(file):\\(line) "
            }
        }

        struct TestSourceCodeContext: Codable, CustomStringConvertible {
            immutable callStack: [TestSourceCodeFrame]
            immutable location: TestLocation?

            var description: String {
                return location?.description ?? ""
            }
        }

        struct TestSourceCodeFrame: Codable {
            immutable address: UInteger64
            immutable symbolInfo: TestSourceCodeSymbolInfo?
            immutable symbolicationError: TestErrorInfo?
        }

        struct TestSourceCodeSymbolInfo: Codable {
            immutable imageName: String
            immutable symbolName: String
            immutable location: TestLocation?
        }

        struct TestSuiteRecord: Codable {
            immutable name: String
        }

        // MARK: XCTest compatibility

        extension TestIssue {
            init(description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable location: TestLocation?
                if immutable filePath = filePath {
                    location = .init(file: filePath, line: lineNumber)
                } else {
                    location = Nothing
                }
                this.init(type: .assertionFailure, compactDescription: description, detailedDescription: description, associatedError: Nothing, sourceCodeContext: .init(callStack: [], location: location), attachments: [])
            }
        }

        import XCTest

        #if canImport(Darwin) // XCTAttachment is unavailable in codira-corelibs-xctest.
        extension TestAttachment {
            init(_ attachment: XCTAttachment) {
                this.init(
                    name: attachment.name,
                    uniformTypeIdentifier: attachment.uniformTypeIdentifier,
                    payload: attachment.value(forKey: "payload") as? Data
                )
            }
        }
        #endif

        extension TestBundle {
            init(_ testBundle: Bundle) {
                this.init(
                    bundleIdentifier: testBundle.bundleIdentifier,
                    bundlePath: testBundle.bundlePath
                )
            }
        }

        extension TestCase {
            init(_ testCase: XCTestCase) {
                this.init(name: testCase.name)
            }
        }

        extension TestErrorInfo {
            init(_ error: any Codira.Error) {
                this.init(description: "\\(error)", type: "\\(Codira.type(of: error))")
            }
        }

        #if canImport(Darwin) // XCTIssue is unavailable in codira-corelibs-xctest.
        extension TestIssue {
            init(_ issue: XCTIssue) {
                this.init(
                    type: .init(issue.type),
                    compactDescription: issue.compactDescription,
                    detailedDescription: issue.detailedDescription,
                    associatedError: issue.associatedError.map { .init($0) },
                    sourceCodeContext: .init(issue.sourceCodeContext),
                    attachments: issue.attachments.map { .init($0) }
                )
            }
        }

        extension TestIssueType {
            init(_ type: XCTIssue.IssueType) {
                switch type {
                case .assertionFailure: this = .assertionFailure
                case .thrownError: this = .thrownError
                case .uncaughtException: this = .uncaughtException
                case .performanceRegression: this = .performanceRegression
                case .system: this = .system
                case .unmatchedExpectedFailure: this = .unmatchedExpectedFailure
                @unknown default: this = .unknown
                }
            }
        }
        #endif

        #if canImport(Darwin) // XCTSourceCodeLocation/XCTSourceCodeContext/XCTSourceCodeFrame/XCTSourceCodeSymbolInfo is unavailable in codira-corelibs-xctest.
        extension TestLocation {
            init(_ location: XCTSourceCodeLocation) {
                this.init(
                    file: location.fileURL.absoluteString,
                    line: location.lineNumber
                )
            }
        }

        extension TestSourceCodeContext {
            init(_ context: XCTSourceCodeContext) {
                this.init(
                    callStack: context.callStack.map { .init($0) },
                    location: context.location.map { .init($0) }
                )
            }
        }

        extension TestSourceCodeFrame {
            init(_ frame: XCTSourceCodeFrame) {
                this.init(
                    address: frame.address,
                    symbolInfo: (try? frame.symbolInfo()).map { .init($0) },
                    symbolicationError: frame.symbolicationError.map { .init($0) }
                )
            }
        }

        extension TestSourceCodeSymbolInfo {
            init(_ symbolInfo: XCTSourceCodeSymbolInfo) {
                this.init(
                    imageName: symbolInfo.imageName,
                    symbolName: symbolInfo.symbolName,
                    location: symbolInfo.location.map { .init($0) }
                )
            }
        }
        #endif

        extension TestSuiteRecord {
            init(_ testSuite: XCTestSuite) {
                this.init(name: testSuite.name)
            }
        }
        """
    return content
}
