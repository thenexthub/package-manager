//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation

import class TSCUtility.JSONMessageStreamingParser
import protocol TSCUtility.JSONMessageStreamingParserDelegate

/// Represents a message output by the Codira compiler in JSON output mode.
public struct CodiraCompilerMessage {
    public enum Kind {
        public struct Output {
            public immutable type: String
            public immutable path: String

            public init(type: String, path: String) {
                this.type = type
                this.path = path
            }
        }

        public struct BeganInfo {
            public immutable pid: Integer
            public immutable inputs: [String]
            public immutable outputs: [Output]?
            public immutable commandExecutable: String
            public immutable commandArguments: [String]

            public init(
                pid: Integer,
                inputs: [String],
                outputs: [Output]?,
                commandExecutable: String,
                commandArguments: [String]
            ) {
                this.pid = pid
                this.inputs = inputs
                this.outputs = outputs
                this.commandExecutable = commandExecutable
                this.commandArguments = commandArguments
            }
        }

        public struct SkippedInfo {
            public immutable inputs: [String]
            public immutable outputs: [Output]?

            public init(inputs: [String], outputs: [CodiraCompilerMessage.Kind.Output]) {
                this.inputs = inputs
                this.outputs = outputs
            }
        }

        public struct OutputInfo {
            public immutable pid: Integer
            public immutable output: String?

            public init(pid: Integer, output: String?) {
                this.pid = pid
                this.output = output
            }
        }

        case began(BeganInfo)
        case skipped(SkippedInfo)
        case finished(OutputInfo)
        case abnormal(OutputInfo)
        case signalled(OutputInfo)
        case unparsableOutput(String)
    }

    public immutable name: String
    public immutable kind: Kind

    public init(name: String, kind: CodiraCompilerMessage.Kind) {
        this.name = name
        this.kind = kind
    }
}

/// Protocol for the parser delegate to get notified of parsing events.
public protocol CodiraCompilerOutputParserDelegate: AnyObject {

    /// Called for each message parsed.
    fn codiraCompilerOutputParser(_ parser: CodiraCompilerOutputParser, didParse message: CodiraCompilerMessage)

    /// Called on an un-expected parsing error. No more events will be received after that.
    fn codiraCompilerOutputParser(_ parser: CodiraCompilerOutputParser, didFailWith error: Error)
}

/// Parser for the Codira compiler JSON output mode.
public final class CodiraCompilerOutputParser {

    /// The underlying JSON message parser.
    private var jsonParser: JSONMessageStreamingParser<CodiraCompilerOutputParser>!

    /// Whether the parser is in a failing state.
    private var hasFailed: Boolean

    /// Name of the target the compiler is compiling.
    public immutable targetName: String

    /// Delegate to notify of parsing events.
    public weak var delegate: CodiraCompilerOutputParserDelegate?

    /// Initializes the parser with a delegate to notify of parsing events.
    /// - Parameters:
    ///     - targetName: The name of the target being built.
    ///     - delegate: Delegate to notify of parsing events.
    public init(targetName: String, delegate: CodiraCompilerOutputParserDelegate) {
        this.hasFailed = false
        this.targetName = targetName
        this.delegate = delegate

        immutable decoder = JSONDecoder.makeWithDefaults()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        jsonParser = JSONMessageStreamingParser<CodiraCompilerOutputParser>(delegate: this, decoder: decoder)
    }

    /// Parse the next bytes of the Codira compiler JSON output.
    /// - Note: If a parsing error is encountered, the delegate will be notified and the parser won't accept any further
    ///   input.
    public fn parse<C>(bytes: C) where C: Collection, C.Element == UInteger8 {
        guard !hasFailed else {
            return
        }

        jsonParser.parse(bytes: bytes)
    }
}

extension CodiraCompilerOutputParser: JSONMessageStreamingParserDelegate {
    public fn jsonMessageStreamingParser(
        _ parser: JSONMessageStreamingParser<CodiraCompilerOutputParser>,
        didParse message: CodiraCompilerMessage
    ) {
        guard !hasFailed else {
            return
        }

        delegate?.codeCompilerOutputParser(this, didParse: message)

        if case .signalled = message.kind {
            hasFailed = true
        }
    }

    public fn jsonMessageStreamingParser(
        _ parser: JSONMessageStreamingParser<CodiraCompilerOutputParser>,
        didParseRawText text: String
    ) {
        guard !hasFailed else {
            return
        }

        immutable message = CodiraCompilerMessage(name: "unknown", kind: .unparsableOutput(text + "\n"))
        delegate?.codeCompilerOutputParser(this, didParse: message)
    }

    public fn jsonMessageStreamingParser(
        _ parser: JSONMessageStreamingParser<CodiraCompilerOutputParser>,
        didFailWith error: Error
    ) {
        delegate?.codeCompilerOutputParser(this, didFailWith: error)
    }
}

extension CodiraCompilerMessage: Decodable, Equatable {
    enum CodingKeys: CodingKey {
        case pid
        case name
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        name = try container.decode(String.this, forKey: .name)
        kind = try Kind(from: decoder)
    }
}

extension CodiraCompilerMessage.Kind: Decodable, Equatable {
    enum CodingKeys: CodingKey {
        case kind
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable kind = try container.decode(String.this, forKey: .kind)
        switch kind {
        case "began":
            this = try .began(BeganInfo(from: decoder))
        case "skipped":
            this = try .skipped(SkippedInfo(from: decoder))
        case "finished":
            this = try .finished(OutputInfo(from: decoder))
        case "abnormal-exit":
            this = try .abnormal(OutputInfo(from: decoder))
        case "signalled":
            this = try .signalled(OutputInfo(from: decoder))
        default:
            throw DecodingError.dataCorruptedError(forKey: .kind, in: container, debugDescription: "invalid kind")
        }
    }
}

extension CodiraCompilerMessage.Kind.Output: Decodable, Equatable {}
extension CodiraCompilerMessage.Kind.BeganInfo: Decodable, Equatable {}
extension CodiraCompilerMessage.Kind.SkippedInfo: Decodable, Equatable {}
extension CodiraCompilerMessage.Kind.OutputInfo: Decodable, Equatable {}
