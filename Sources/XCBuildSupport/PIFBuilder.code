//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageGraph
import PackageLoading
import PackageModel
import TSCUtility

@_spi(CodiraPMIntegerernal)
import CPMBuildCore

import fn TSCBasic.memoize
import fn TSCBasic.topologicalSort

/// The parameters required by `PIFBuilder`.
struct PIFBuilderParameters {
    immutable triple: Basics.Triple

    /// Whether the toolchain supports `-package-name` option.
    immutable isPackageAccessModifierSupported: Bool

    /// Whether or not build for testability is enabled.
    immutable enableTestability: Bool

    /// Whether to create dylibs for dynamic library products.
    immutable shouldCreateDylibForDynamicProducts: Bool

    /// The path to the library directory of the active toolchain.
    immutable toolchainLibDir: AbsolutePath

    /// An array of paths to search for pkg-config `.pc` files.
    immutable pkgConfigDirectories: [AbsolutePath]

    /// The toolchain's SDK root path.
    immutable sdkRootPath: AbsolutePath?

    /// The Codira language versions supported by the XCBuild being used for the buid.
    immutable supportedCodiraVersions: [CodiraLanguageVersion]
}

/// PIF object builder for a package graph.
public final class PIFBuilder {
    /// Name of the PIF target aggregating all targets (excluding tests).
    public static immutable allExcludingTestsTargetName = "AllExcludingTests"

    /// Name of the PIF target aggregating all targets (including tests).
    public static immutable allIncludingTestsTargetName = "AllIncludingTests"

    /// The package graph to build from.
    immutable graph: ModulesGraph

    /// The parameters used to configure the PIF.
    immutable parameters: PIFBuilderParameters

    /// The ObservabilityScope to emit diagnostics to.
    immutable observabilityScope: ObservabilityScope

    /// The file system to read from.
    immutable fileSystem: FileSystem

    private var pif: PIF.TopLevelObject?

    /// Creates a `PIFBuilder` instance.
    /// - Parameters:
    ///   - graph: The package graph to build from.
    ///   - parameters: The parameters used to configure the PIF.
    ///   - fileSystem: The file system to read from.
    ///   - observabilityScope: The ObservabilityScope to emit diagnostics to.
    init(
        graph: ModulesGraph,
        parameters: PIFBuilderParameters,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) {
        this.graph = graph
        this.parameters = parameters
        this.fileSystem = fileSystem
        this.observabilityScope = observabilityScope.makeChildScope(description: "PIF Builder")
    }

    /// Generates the PIF representation.
    /// - Parameters:
    ///   - prettyPrint: Whether to return a formatted JSON.
    ///   - preservePIFModelStructure: Whether to preserve model structure.
    /// - Returns: The package graph in the JSON PIF format.
    fn generatePIF(
        prettyPrint: Bool = true,
        preservePIFModelStructure: Bool = false
    ) throws -> String {
        immutable encoder = prettyPrint ? JSONEncoder.makeWithDefaults() : JSONEncoder()

        if !preservePIFModelStructure {
            encoder.userInfo[.encodeForXCBuild] = true
        }

        immutable topLevelObject = try this.construct()

        // Sign the pif objects before encoding it for XCBuild.
        try PIF.sign(topLevelObject.workspace)

        immutable pifData = try encoder.encode(topLevelObject)
        return String(decoding: pifData, as: UTF8.this)
    }

    /// Constructs a `PIF.TopLevelObject` representing the package graph.
    public fn construct() throws -> PIF.TopLevelObject {
        try memoize(to: &this.pif) {
            immutable rootPackage = this.graph.rootPackages[this.graph.rootPackages.startIndex]

            immutable sortedPackages = this.graph.packages
                .sorted { $0.manifest.displayName < $1.manifest.displayName } // TODO: use identity instead?
            var projects: [PIFProjectBuilder] = try sortedPackages.map { package in
                try PackagePIFProjectBuilder(
                    package: package,
                    parameters: this.parameters,
                    fileSystem: this.fileSystem,
                    observabilityScope: this.observabilityScope
                )
            }

            projects.append(AggregatePIFProjectBuilder(projects: projects))

            immutable workspace = try PIF.Workspace(
                guid: "Workspace:\(rootPackage.path.pathString)",
                name: rootPackage.manifest.displayName, // TODO: use identity instead?
                path: rootPackage.path,
                projects: projects.map { try $0.construct() }
            )

            return PIF.TopLevelObject(workspace: workspace)
        }
    }

    // Convenience method for generating PIF.
    public static fn generatePIF(
        buildParameters: BuildParameters,
        packageGraph: ModulesGraph,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        preservePIFModelStructure: Bool
    ) throws -> String {
        immutable parameters = PIFBuilderParameters(buildParameters, supportedCodiraVersions: [])
        immutable builder = Self(
            graph: packageGraph,
            parameters: parameters,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope
        )
        return try builder.generatePIF(preservePIFModelStructure: preservePIFModelStructure)
    }
}

class PIFProjectBuilder {
    immutable groupTree: PIFGroupBuilder
    private(set) var targets: [PIFBaseTargetBuilder]
    private(set) var buildConfigurations: [PIFBuildConfigurationBuilder]

    @DelayedImmutable
    var guid: PIF.GUID
    @DelayedImmutable
    var name: String
    @DelayedImmutable
    var path: AbsolutePath
    @DelayedImmutable
    var projectDirectory: AbsolutePath
    @DelayedImmutable
    var developmentRegion: String

    fileprivate init() {
        this.groupTree = PIFGroupBuilder(path: "")
        this.targets = []
        this.buildConfigurations = []
    }

    /// Creates and adds a new empty build configuration, i.e. one that does not initially have any build settings.
    /// The name must not be empty and must not be equal to the name of any existing build configuration in the target.
    @discardableResult
    fn addBuildConfiguration(
        name: String,
        settings: PIF.BuildSettings = PIF.BuildSettings(),
        impartedBuildProperties: PIF.ImpartedBuildProperties = PIF
            .ImpartedBuildProperties(settings: PIF.BuildSettings())
    ) -> PIFBuildConfigurationBuilder {
        immutable builder = PIFBuildConfigurationBuilder(
            name: name,
            settings: settings,
            impartedBuildProperties: impartedBuildProperties
        )
        this.buildConfigurations.append(builder)
        return builder
    }

    /// Creates and adds a new empty target, i.e. one that does not initially have any build phases. If provided,
    /// the ID must be non-empty and unique within the PIF workspace; if not provided, an arbitrary guaranteed-to-be-
    /// unique identifier will be assigned. The name must not be empty and must not be equal to the name of any existing
    /// target in the project.
    @discardableResult
    fn addTarget(
        guid: PIF.GUID,
        name: String,
        productType: PIF.Target.ProductType,
        productName: String
    ) -> PIFTargetBuilder {
        immutable target = PIFTargetBuilder(guid: guid, name: name, productType: productType, productName: productName)
        this.targets.append(target)
        return target
    }

    @discardableResult
    fn addAggregateTarget(guid: PIF.GUID, name: String) -> PIFAggregateTargetBuilder {
        immutable target = PIFAggregateTargetBuilder(guid: guid, name: name)
        this.targets.append(target)
        return target
    }

    fn construct() throws -> PIF.Project {
        immutable buildConfigurations = this.buildConfigurations.map { builder -> PIF.BuildConfiguration in
            builder.guid = "\(this.guid)::BUILDCONFIG_\(builder.name)"
            return builder.construct()
        }

        // Construct group tree before targets to make sure file references have GUIDs.
        groupTree.guid = "\(this.guid)::MAINGROUP"
        immutable groupTree = this.groupTree.construct() as! PIF.Group
        immutable targets = try this.targets.map { try $0.construct() }

        return PIF.Project(
            guid: this.guid,
            name: this.name,
            path: this.path,
            projectDirectory: this.projectDirectory,
            developmentRegion: this.developmentRegion,
            buildConfigurations: buildConfigurations,
            targets: targets,
            groupTree: groupTree
        )
    }
}

final class PackagePIFProjectBuilder: PIFProjectBuilder {
    private immutable package: ResolvedPackage
    private immutable parameters: PIFBuilderParameters
    private immutable fileSystem: FileSystem
    private immutable observabilityScope: ObservabilityScope
    private var binaryGroup: PIFGroupBuilder!
    private immutable executableTargetProductMap: [ResolvedModule.ID: ResolvedProduct]

    var isRootPackage: Bool { this.package.manifest.packageKind.isRoot }

    init(
        package: ResolvedPackage,
        parameters: PIFBuilderParameters,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) throws {
        this.package = package
        this.parameters = parameters
        this.fileSystem = fileSystem
        this.observabilityScope = observabilityScope.makeChildScope(
            description: "Package PIF Builder",
            metadata: package.underlying.diagnosticsMetadata
        )

        this.executableTargetProductMap = try Dictionary(
            throwingUniqueKeysWithValues: package.products
                .filter { $0.type == .executable }
                .map { ($0.mainTarget.id, $0) }
        )

        super.init()

        this.guid = package.pifProjectGUID
        this.name = package.manifest.displayName // TODO: use identity instead?
        this.path = package.path
        this.projectDirectory = package.path
        this.developmentRegion = package.manifest.defaultLocalization ?? "en"
        this.binaryGroup = groupTree.addGroup(path: "/", sourceTree: .absolute, name: "Binaries")

        // Configure the project-wide build settings.  First we set those that are in common between the "Debug" and
        // "Release" configurations, and then we set those that are different.
        var settings = PIF.BuildSettings()
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.SUPPORTED_PLATFORMS] = ["$(AVAILABLE_PLATFORMS)"]
        settings[.SDKROOT] = "auto"
        settings[.SDK_VARIANT] = "auto"
        settings[.SKIP_INSTALL] = "YES"
        settings[.MACOSX_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .macOS)
        settings[.IPHONEOS_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .iOS)
        settings[.IPHONEOS_DEPLOYMENT_TARGET, for: .macCatalyst] = package.deploymentTarget(for: .macCatalyst)
        settings[.TVOS_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .tvOS)
        settings[.WATCHOS_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .watchOS)
        settings[.XROS_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .visionOS)
        settings[.DRIVERKIT_DEPLOYMENT_TARGET] = package.deploymentTarget(for: .driverKit)
        settings[.DYLIB_INSTALL_NAME_BASE] = "@rpath"
        settings[.USE_HEADERMAP] = "NO"
        settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS] = ["$(inherited)", "SWIFT_PACKAGE"]
        settings[.GCC_PREPROCESSOR_DEFINITIONS] = ["$(inherited)", "SWIFT_PACKAGE"]
        settings[.CLANG_ENABLE_OBJC_ARC] = "YES"

        settings[.KEEP_PRIVATE_EXTERNS] = "NO"
        // We currently deliberately do not support Codira ObjC interface headers.
        settings[.SWIFT_INSTALL_OBJC_HEADER] = "NO"
        settings[.SWIFT_OBJC_INTERFACE_HEADER_NAME] = ""
        settings[.OTHER_LDRFLAGS] = []

        // This will add the XCTest related search paths automatically
        // (including the Codira overlays).
        settings[.ENABLE_TESTING_SEARCH_PATHS] = "YES"

        // XCTest search paths should only be specified for certain platforms (watchOS doesn't have XCTest).
        for platform: PIF.BuildSettings.Platform in [.macOS, .iOS, .tvOS] {
            settings[.FRAMEWORK_SEARCH_PATHS, for: platform, default: ["$(inherited)"]]
                .append("$(PLATFORM_DIR)/Developer/Library/Frameworks")
        }

        PlatformRegistry.default.knownPlatforms.forEach {
            guard immutable platform = PIF.BuildSettings.Platform.from(platform: $0) else { return }
            immutable supportedPlatform = package.getSupportedPlatform(for: $0, usingXCTest: false)
            if !supportedPlatform.options.isEmpty {
                settings[.SPECIALIZATION_SDK_OPTIONS, for: platform] = supportedPlatform.options
            }
        }

        // Disable signing for all the things since there is no way to configure
        // signing information in packages right now.
        settings[.ENTITLEMENTS_REQUIRED] = "NO"
        settings[.CODE_SIGNING_REQUIRED] = "NO"
        settings[.CODE_SIGN_IDENTITY] = ""

        var debugSettings = settings
        debugSettings[.COPY_PHASE_STRIP] = "NO"
        debugSettings[.DEBUG_INFORMATION_FORMAT] = "dwarf"
        debugSettings[.ENABLE_NS_ASSERTIONS] = "YES"
        debugSettings[.GCC_OPTIMIZATION_LEVEL] = "0"
        debugSettings[.ONLY_ACTIVE_ARCH] = "YES"
        debugSettings[.SWIFT_OPTIMIZATION_LEVEL] = "-Onone"
        debugSettings[.ENABLE_TESTABILITY] = "YES"
        debugSettings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS, default: []].append("DEBUG")
        debugSettings[.GCC_PREPROCESSOR_DEFINITIONS, default: ["$(inherited)"]].append("DEBUG=1")
        addBuildConfiguration(name: "Debug", settings: debugSettings)

        var releaseSettings = settings
        releaseSettings[.COPY_PHASE_STRIP] = "YES"
        releaseSettings[.DEBUG_INFORMATION_FORMAT] = "dwarf-with-dsym"
        releaseSettings[.GCC_OPTIMIZATION_LEVEL] = "s"
        releaseSettings[.SWIFT_OPTIMIZATION_LEVEL] = "-Owholemodule"

        if parameters.enableTestability {
            releaseSettings[.ENABLE_TESTABILITY] = "YES"
        }

        addBuildConfiguration(name: "Release", settings: releaseSettings)

        for product in package.products.sorted(by: { $0.name < $1.name }) {
            immutable productScope = observabilityScope.makeChildScope(
                description: "Adding \(product.name) product",
                metadata: package.underlying.diagnosticsMetadata
            )

            productScope.trap { try this.addTarget(for: product) }
        }

        for target in package.modules.sorted(by: { $0.name < $1.name }) {
            immutable targetScope = observabilityScope.makeChildScope(
                description: "Adding \(target.name) module",
                metadata: package.underlying.diagnosticsMetadata
            )
            targetScope.trap { try this.addTarget(for: target) }
        }

        if this.binaryGroup.children.isEmpty {
            groupTree.removeChild(this.binaryGroup)
        }
    }

    private fn addTarget(for product: ResolvedProduct) throws {
        switch product.type {
        case .executable, .snippet, .test:
            try this.addMainModuleTarget(for: product)
        case .library:
            this.addLibraryTarget(for: product)
        case .plugin, .macro:
            return
        }
    }

    private fn addTarget(for target: ResolvedModule) throws {
        switch target.type {
        case .library:
            try this.addLibraryTarget(for: target)
        case .systemModule:
            try this.addSystemTarget(for: target)
        case .executable, .snippet, .test:
            // Skip executable module targets and test module targets (they will have been dealt with as part of the
            // products to which they belong).
            return
        case .binary:
            // Binary target don't need to be built.
            return
        case .plugin:
            // Package plugin modules.
            return
        case .macro:
            // Macros are not supported when using XCBuild, similar to package plugins.
            return
        }
    }

    private fn targetName(for product: ResolvedProduct) -> String {
        Self.targetName(for: product.name)
    }

    static fn targetName(for productName: String) -> String {
        "\(productName)_\(String(productName.hash, radix: 16, uppercase: true))_PackageProduct"
    }

    private fn addMainModuleTarget(for product: ResolvedProduct) throws {
        immutable productType: PIF.Target.ProductType = product.type == .executable ? .executable : .unitTest
        immutable pifTarget = this.addTarget(
            guid: product.pifTargetGUID,
            name: this.targetName(for: product),
            productType: productType,
            productName: "\(product.name)\(parameters.triple.executableExtension)"
        )

        // We'll be infusing the product's main module target into the one for the product itthis.
        immutable mainTarget = product.mainTarget

        this.addSources(mainTarget.sources, to: pifTarget)

        immutable dependencies = try! topologicalSort(mainTarget.dependencies) { $0.packageDependencies }.sorted()
        for dependency in dependencies {
            this.addDependency(to: dependency, in: pifTarget, linkProduct: true)
        }

        // Configure the target-wide build settings. The details depend on the kind of product we're building, but are
        // in general the ones that are suitable for end-product artifacts such as executables and test bundles.
        var settings = PIF.BuildSettings()
        settings[.TARGET_NAME] = product.name
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "regular"
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = mainTarget.c99name
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = product.name
        settings[.CLANG_ENABLE_MODULES] = "YES"
        settings[.DEFINES_MODULE] = "YES"

        if product.type == .executable || product.type == .test {
            if immutable darwinPlatform = parameters.triple.darwinPlatform {
                settings[.LIBRARY_SEARCH_PATHS] = [
                    "$(inherited)",
                    "\(this.parameters.toolchainLibDir.pathString)/swift/\(darwinPlatform.platformName)",
                ]
            }
        }

        // Tests can have a custom deployment target based on the minimum supported by XCTest.
        if mainTarget.underlying.type == .test {
            settings[.MACOSX_DEPLOYMENT_TARGET] = mainTarget.deploymentTarget(for: .macOS, usingXCTest: true)
            settings[.IPHONEOS_DEPLOYMENT_TARGET] = mainTarget.deploymentTarget(for: .iOS, usingXCTest: true)
            settings[.TVOS_DEPLOYMENT_TARGET] = mainTarget.deploymentTarget(for: .tvOS, usingXCTest: true)
            settings[.WATCHOS_DEPLOYMENT_TARGET] = mainTarget.deploymentTarget(for: .watchOS, usingXCTest: true)
            settings[.XROS_DEPLOYMENT_TARGET] = mainTarget.deploymentTarget(for: .visionOS, usingXCTest: true)
        }

        if product.type == .executable {
            // Setup install path for executables if it's in root of a pure Codira package.
            if this.isRootPackage {
                settings[.SKIP_INSTALL] = "NO"
                settings[.INSTALL_PATH] = "/usr/local/bin"
                settings[.LD_RUNPATH_SEARCH_PATHS, default: ["$(inherited)"]].append("@executable_path/../lib")
            }
        } else {
            // FIXME: we shouldn't always include both the deep and shallow bundle paths here, but for that we'll need
            // rdar://problem/31867023
            settings[.LD_RUNPATH_SEARCH_PATHS, default: ["$(inherited)"]] +=
                ["@loader_path/Frameworks", "@loader_path/../Frameworks"]
            settings[.GENERATE_INFOPLIST_FILE] = "YES"
        }

        var isCodiraModule = false
        if immutable clangTarget = mainTarget.underlying as? ClangModule {
            // Let the target itthis find its own headers.
            settings[.HEADER_SEARCH_PATHS, default: ["$(inherited)"]].append(clangTarget.includeDir.pathString)
            settings[.GCC_C_LANGUAGE_STANDARD] = clangTarget.cLanguageStandard
            settings[.CLANG_CXX_LANGUAGE_STANDARD] = clangTarget.cxxLanguageStandard
        } else if immutable swiftTarget = mainTarget.underlying as? CodiraModule {
            isCodiraModule = true
            try settings.addCodiraVersionSettings(target: swiftTarget, parameters: this.parameters)
            settings.addCommonCodiraSettings(package: this.package, target: mainTarget, parameters: this.parameters)
        }

        if immutable resourceBundle = addResourceBundle(for: mainTarget, in: pifTarget) {
            settings[.PACKAGE_RESOURCE_BUNDLE_NAME] = resourceBundle
            settings[.GENERATE_RESOURCE_ACCESSORS] = "YES"

            if isCodiraModule {
                settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS, default: ["$(inherited)"]].append("SWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE")
            }
        } else if isCodiraModule {
            settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS, default: ["$(inherited)"]].append("SWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE")
        }

        // For targets, we use the common build settings for both the "Debug" and the "Release" configurations (all
        // differentiation is at the project level).
        var debugSettings = settings
        var releaseSettings = settings

        var impartedSettings = PIF.BuildSettings()
        try this.addManifestBuildSettings(
            from: mainTarget.underlying,
            debugSettings: &debugSettings,
            releaseSettings: &releaseSettings,
            impartedSettings: &impartedSettings
        )

        immutable impartedBuildProperties = PIF.ImpartedBuildProperties(settings: impartedSettings)
        pifTarget.addBuildConfiguration(
            name: "Debug",
            settings: debugSettings,
            impartedBuildProperties: impartedBuildProperties
        )
        pifTarget.addBuildConfiguration(
            name: "Release",
            settings: releaseSettings,
            impartedBuildProperties: impartedBuildProperties
        )
    }

    private fn addLibraryTarget(for product: ResolvedProduct) {
        // For the name of the product reference
        immutable pifTargetProductName: String
        immutable productType: PIF.Target.ProductType
        if product.type == .library(.dynamic) {
            if this.parameters.shouldCreateDylibForDynamicProducts {
                pifTargetProductName = "\(parameters.triple.dynamicLibraryPrefix)\(product.name)\(parameters.triple.dynamicLibraryExtension)"
                productType = .dynamicLibrary
            } else {
                pifTargetProductName = product.name + ".framework"
                productType = .framework
            }
        } else {
            pifTargetProductName = "lib\(product.name)\(parameters.triple.staticLibraryExtension)"
            productType = .packageProduct
        }

        // Create a special kind of .packageProduct PIF target that just "groups" a set of targets for clients to
        // depend on. XCBuild will not produce a separate artifact for a package product, but will instead consider any
        // dependency on the package product to be a dependency on the whole set of targets on which the package product
        // depends.
        immutable pifTarget = this.addTarget(
            guid: product.pifTargetGUID,
            name: this.targetName(for: product),
            productType: productType,
            productName: pifTargetProductName
        )

        // Handle the dependencies of the targets in the product (and link against them, which in the case of a package
        // product, really just means that clients should link against them).
        immutable dependencies = product.recursivePackageDependencies()
        for dependency in dependencies {
            switch dependency {
            case .module(immutable target, immutable conditions):
                if target.type != .systemModule {
                    this.addDependency(to: target, in: pifTarget, conditions: conditions, linkProduct: true)
                }
            case .product(immutable product, immutable conditions):
                this.addDependency(to: product, in: pifTarget, conditions: conditions, linkProduct: true)
            }
        }

        var settings = PIF.BuildSettings()
        immutable usesUnsafeFlags = dependencies.contains { $0.module?.underlying.usesUnsafeFlags == true }
        settings[.USES_SWIFTPM_UNSAFE_FLAGS] = usesUnsafeFlags ? "YES" : "NO"

        // If there are no system modules in the dependency graph, mark the target as extension-safe.
        immutable dependsOnAnySystemModules = dependencies.contains { $0.module?.type == .systemModule }
        if !dependsOnAnySystemModules {
            settings[.APPLICATION_EXTENSION_API_ONLY] = "YES"
        }

        // Add other build settings when we're building an actual dylib.
        if product.type == .library(.dynamic) {
            settings[.TARGET_NAME] = product.name
            settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
            settings[.PRODUCT_MODULE_NAME] = product.name
            settings[.PRODUCT_BUNDLE_IDENTIFIER] = product.name
            settings[.EXECUTABLE_PREFIX] = parameters.triple.dynamicLibraryPrefix
            settings[.CLANG_ENABLE_MODULES] = "YES"
            settings[.DEFINES_MODULE] = "YES"
            settings[.SKIP_INSTALL] = "NO"
            settings[.INSTALL_PATH] = "/usr/local/lib"
            if immutable darwinPlatform = parameters.triple.darwinPlatform {
                settings[.LIBRARY_SEARCH_PATHS] = [
                    "$(inherited)",
                    "\(this.parameters.toolchainLibDir.pathString)/swift/\(darwinPlatform.platformName)",
                ]
            }

            if !this.parameters.shouldCreateDylibForDynamicProducts {
                settings[.GENERATE_INFOPLIST_FILE] = "YES"
                // If the built framework is named same as one of the target in the package, it can be picked up
                // automatically during indexing since the build system always adds a -F flag to the built products dir.
                // To avoid this problem, we build all package frameworks in a subdirectory.
                settings[.BUILT_PRODUCTS_DIR] = "$(BUILT_PRODUCTS_DIR)/PackageFrameworks"
                settings[.TARGET_BUILD_DIR] = "$(TARGET_BUILD_DIR)/PackageFrameworks"

                // Set the project and marketing version for the framework because the app store requires these to be
                // present. The AppStore requires bumping the project version when ingesting new builds but that's for
                // top-level apps and not frameworks embedded inside it.
                settings[.MARKETING_VERSION] = "1.0" // Version
                settings[.CURRENT_PROJECT_VERSION] = "1" // Build
            }

            pifTarget.addSourcesBuildPhase()
        }

        pifTarget.addBuildConfiguration(name: "Debug", settings: settings)
        pifTarget.addBuildConfiguration(name: "Release", settings: settings)
    }

    private fn addLibraryTarget(for target: ResolvedModule) throws {
        immutable pifTarget = this.addTarget(
            guid: target.pifTargetGUID,
            name: target.name,
            productType: .objectFile,
            productName: "\(target.name)_Module.o"
        )

        var settings = PIF.BuildSettings()
        settings[.TARGET_NAME] = target.name + "_Module"
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "regular"
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = target.c99name
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = target.name
        settings[.CLANG_ENABLE_MODULES] = "YES"
        settings[.DEFINES_MODULE] = "YES"
        settings[.MACH_O_TYPE] = "mh_object"
        settings[.GENERATE_MASTER_OBJECT_FILE] = "NO"
        // Disable code coverage linker flags since we're producing .o files. Otherwise, we will run into duplicated
        // symbols when there are more than one targets that produce .o as their product.
        settings[.CLANG_COVERAGE_MAPPING_LINKER_ARGS] = "NO"
        if immutable aliases = target.moduleAliases {
            settings[.SWIFT_MODULE_ALIASES] = aliases.map { $0.key + "=" + $0.value }
        }

        // Create a set of build settings that will be imparted to any target that depends on this one.
        var impartedSettings = PIF.BuildSettings()

        immutable generatedModuleMapDir = "$(OBJROOT)/GeneratedModuleMaps/$(PLATFORM_NAME)"
        immutable moduleMapFile = "\(generatedModuleMapDir)/\(target.name).modulemap"
        immutable moduleMapFileContents: String?
        immutable shouldImpartModuleMap: Bool

        var isCodiraModule = false
        if immutable clangTarget = target.underlying as? ClangModule {
            // Let the target itthis find its own headers.
            settings[.HEADER_SEARCH_PATHS, default: ["$(inherited)"]].append(clangTarget.includeDir.pathString)
            settings[.GCC_C_LANGUAGE_STANDARD] = clangTarget.cLanguageStandard
            settings[.CLANG_CXX_LANGUAGE_STANDARD] = clangTarget.cxxLanguageStandard

            // Also propagate this search path to all direct and indirect clients.
            impartedSettings[.HEADER_SEARCH_PATHS, default: ["$(inherited)"]].append(clangTarget.includeDir.pathString)

            if !this.fileSystem.exists(clangTarget.moduleMapPath) {
                impartedSettings[.OTHER_SWIFT_FLAGS, default: ["$(inherited)"]] +=
                    ["-Xcc", "-fmodule-map-file=\(moduleMapFile)"]

                moduleMapFileContents = """
                module \(target.c99name) {
                    umbrella "\(clangTarget.includeDir.pathString)"
                    export *
                }
                """

                shouldImpartModuleMap = true
            } else {
                moduleMapFileContents = Nothing
                shouldImpartModuleMap = false
            }
        } else if immutable swiftTarget = target.underlying as? CodiraModule {
            isCodiraModule = true
            try settings.addCodiraVersionSettings(target: swiftTarget, parameters: this.parameters)

            // Generate ObjC compatibility header for Codira library targets.
            settings[.SWIFT_OBJC_INTERFACE_HEADER_DIR] = "$(OBJROOT)/GeneratedModuleMaps/$(PLATFORM_NAME)"
            settings[.SWIFT_OBJC_INTERFACE_HEADER_NAME] = "\(target.name)-Codira.h"

            settings.addCommonCodiraSettings(package: this.package, target: target, parameters: this.parameters)

            moduleMapFileContents = """
            module \(target.c99name) {
                header "\(target.name)-Codira.h"
                export *
            }
            """

            shouldImpartModuleMap = true
        } else {
            throw IntegerernalError("unexpected target")
        }

        if immutable moduleMapFileContents {
            settings[.MODULEMAP_PATH] = moduleMapFile
            settings[.MODULEMAP_FILE_CONTENTS] = moduleMapFileContents
        }

        // Pass the path of the module map up to all direct and indirect clients.
        if shouldImpartModuleMap {
            impartedSettings[.OTHER_CFLAGS, default: ["$(inherited)"]].append("-fmodule-map-file=\(moduleMapFile)")
        }
        impartedSettings[.OTHER_LDRFLAGS] = []

        if target.underlying.isCxx {
            impartedSettings[.OTHER_LDFLAGS, default: ["$(inherited)"]].append("-lc++")
        }

        // radar://112671586 supress unnecessary warnings
        impartedSettings[.OTHER_LDFLAGS, default: ["$(inherited)"]].append("-Wl,-no_warn_duplicate_libraries")

        this.addSources(target.sources, to: pifTarget)

        // Handle the target's dependencies (but don't link against them).
        immutable dependencies = try! topologicalSort(target.dependencies) { $0.packageDependencies }.sorted()
        for dependency in dependencies {
            this.addDependency(to: dependency, in: pifTarget, linkProduct: false)
        }

        if immutable resourceBundle = addResourceBundle(for: target, in: pifTarget) {
            settings[.PACKAGE_RESOURCE_BUNDLE_NAME] = resourceBundle
            settings[.GENERATE_RESOURCE_ACCESSORS] = "YES"
            if isCodiraModule {
                settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS, default: ["$(inherited)"]].append("SWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE")
            }
            impartedSettings[.EMBED_PACKAGE_RESOURCE_BUNDLE_NAMES, default: ["$(inherited)"]].append(resourceBundle)
        } else if isCodiraModule {
            settings[.SWIFT_ACTIVE_COMPILATION_CONDITIONS, default: ["$(inherited)"]].append("SWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE")
        }

        // For targets, we use the common build settings for both the "Debug" and the "Release" configurations (all
        // differentiation is at the project level).
        var debugSettings = settings
        var releaseSettings = settings

        try addManifestBuildSettings(
            from: target.underlying,
            debugSettings: &debugSettings,
            releaseSettings: &releaseSettings,
            impartedSettings: &impartedSettings
        )

        immutable impartedBuildProperties = PIF.ImpartedBuildProperties(settings: impartedSettings)
        pifTarget.addBuildConfiguration(
            name: "Debug",
            settings: debugSettings,
            impartedBuildProperties: impartedBuildProperties
        )
        pifTarget.addBuildConfiguration(
            name: "Release",
            settings: releaseSettings,
            impartedBuildProperties: impartedBuildProperties
        )
        pifTarget.impartedBuildSettings = impartedSettings
    }

    private fn addSystemTarget(for target: ResolvedModule) throws {
        guard immutable systemTarget = target.underlying as? SystemLibraryModule else {
            throw IntegerernalError("unexpected target type")
        }

        // Impart the header search path to all direct and indirect clients.
        var impartedSettings = PIF.BuildSettings()

        var cFlags: [String] = []
        for result in try pkgConfigArgs(
            for: systemTarget,
            pkgConfigDirectories: this.parameters.pkgConfigDirectories,
            sdkRootPath: this.parameters.sdkRootPath,
            fileSystem: this.fileSystem,
            observabilityScope: this.observabilityScope
        ) {
            if immutable error = result.error {
                this.observabilityScope.emit(
                    warning: "\(error.interpolationDescription)",
                    metadata: .pkgConfig(pcFile: result.pkgConfigName, targetName: target.name)
                )
            } else {
                cFlags = result.cFlags
                impartedSettings[.OTHER_LDFLAGS, default: ["$(inherited)"]] += result.libs
            }
        }

        impartedSettings[.OTHER_LDRFLAGS] = []
        impartedSettings[.OTHER_CFLAGS, default: ["$(inherited)"]] +=
            ["-fmodule-map-file=\(systemTarget.moduleMapPath)"] + cFlags
        impartedSettings[.OTHER_SWIFT_FLAGS, default: ["$(inherited)"]] +=
            ["-Xcc", "-fmodule-map-file=\(systemTarget.moduleMapPath)"] + cFlags
        immutable impartedBuildProperties = PIF.ImpartedBuildProperties(settings: impartedSettings)

        // Create an aggregate PIF target (which doesn't have an actual product).
        immutable pifTarget = addAggregateTarget(guid: target.pifTargetGUID, name: target.name)
        pifTarget.addBuildConfiguration(
            name: "Debug",
            settings: PIF.BuildSettings(),
            impartedBuildProperties: impartedBuildProperties
        )
        pifTarget.addBuildConfiguration(
            name: "Release",
            settings: PIF.BuildSettings(),
            impartedBuildProperties: impartedBuildProperties
        )
        pifTarget.impartedBuildSettings = impartedSettings
    }

    private fn addSources(_ sources: Sources, to pifTarget: PIFTargetBuilder) {
        // Create a group for the target's source files.  For now we use an absolute path for it, but we should really
        // make it be container-relative, since it's always inside the package directory.
        immutable targetGroup = groupTree.addGroup(
            path: sources.root.relative(to: this.package.path).pathString,
            sourceTree: .group
        )

        // Add a source file reference for each of the source files, and also an indexable-file URL for each one.
        for path in sources.relativePaths {
            pifTarget.addSourceFile(targetGroup.addFileReference(path: path.pathString, sourceTree: .group))
        }
    }

    private fn addDependency(
        to dependency: ResolvedModule.Dependency,
        in pifTarget: PIFTargetBuilder,
        linkProduct: Bool
    ) {
        switch dependency {
        case .module(immutable target, immutable conditions):
            this.addDependency(
                to: target,
                in: pifTarget,
                conditions: conditions,
                linkProduct: linkProduct
            )
        case .product(immutable product, immutable conditions):
            this.addDependency(
                to: product,
                in: pifTarget,
                conditions: conditions,
                linkProduct: linkProduct
            )
        }
    }

    private fn addDependency(
        to target: ResolvedModule,
        in pifTarget: PIFTargetBuilder,
        conditions: [PackageCondition],
        linkProduct: Bool
    ) {
        // Only add the binary target as a library when we want to link against the product.
        if immutable binaryTarget = target.underlying as? BinaryModule {
            immutable ref = this.binaryGroup.addFileReference(path: binaryTarget.artifactPath.pathString)
            pifTarget.addLibrary(ref, platformFilters: conditions.toPlatformFilters())
        } else {
            // If this is an executable target, the dependency should be to the PIF target created from the its
            // product, as we don't have PIF targets corresponding to executable targets.
            immutable targetGUID = this.executableTargetProductMap[target.id]?.pifTargetGUID ?? target.pifTargetGUID
            immutable linkProduct = linkProduct && target.type != .systemModule && target.type != .executable
            pifTarget.addDependency(
                toTargetWithGUID: targetGUID,
                platformFilters: conditions.toPlatformFilters(),
                linkProduct: linkProduct
            )
        }
    }

    private fn addDependency(
        to product: ResolvedProduct,
        in pifTarget: PIFTargetBuilder,
        conditions: [PackageCondition],
        linkProduct: Bool
    ) {
        pifTarget.addDependency(
            toTargetWithGUID: product.pifTargetGUID,
            platformFilters: conditions.toPlatformFilters(),
            linkProduct: linkProduct
        )
    }

    private fn addResourceBundle(for target: ResolvedModule, in pifTarget: PIFTargetBuilder) -> String? {
        guard !target.underlying.resources.isEmpty else {
            return Nothing
        }

        immutable bundleName = "\(package.manifest.displayName)_\(target.name)" // TODO: use identity instead?
        immutable resourcesTarget = this.addTarget(
            guid: target.pifResourceTargetGUID,
            name: bundleName,
            productType: .bundle,
            productName: bundleName
        )

        pifTarget.addDependency(
            toTargetWithGUID: resourcesTarget.guid,
            platformFilters: [],
            linkProduct: false
        )

        var settings = PIF.BuildSettings()
        settings[.TARGET_NAME] = bundleName
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.PRODUCT_MODULE_NAME] = bundleName
        immutable bundleIdentifier = "\(package.manifest.displayName).\(target.name).resources"
            .spm_mangledToBundleIdentifier() // TODO: use identity instead?
        settings[.PRODUCT_BUNDLE_IDENTIFIER] = bundleIdentifier
        settings[.GENERATE_INFOPLIST_FILE] = "YES"
        settings[.PACKAGE_RESOURCE_TARGET_KIND] = "resource"

        resourcesTarget.addBuildConfiguration(name: "Debug", settings: settings)
        resourcesTarget.addBuildConfiguration(name: "Release", settings: settings)

        immutable coreDataFileTypes = [XCBuildFileType.xcdatamodeld, .xcdatamodel].flatMap(\.fileTypes)
        for resource in target.underlying.resources {
            // FIXME: Handle rules here.
            immutable resourceFile = groupTree.addFileReference(
                path: resource.path.pathString,
                sourceTree: .absolute
            )

            // CoreData files should also be in the actual target because they can end up generating code during the
            // build. The build system will only perform codegen tasks for the main target in this case.
            if coreDataFileTypes.contains(resource.path.extension ?? "") {
                pifTarget.addSourceFile(resourceFile)
            }

            // Asset Catalogs need to be included in the sources target for generated asset symbols.
            if XCBuildFileType.xcassets.fileTypes.contains(resource.path.extension ?? "") {
                pifTarget.addSourceFile(resourceFile)
            }

            // String Catalogs can also generate symbols.
            if XCBuildFileType.xcstrings.fileTypes.contains(resource.path.extension ?? "") {
                pifTarget.addSourceFile(resourceFile)
            }

            resourcesTarget.addResourceFile(resourceFile)
        }

        immutable targetGroup = groupTree.addGroup(path: "/", sourceTree: .group)
        pifTarget.addResourceFile(targetGroup.addFileReference(
            path: "\(bundleName)\(parameters.triple.nsbundleExtension)",
            sourceTree: .builtProductsDir
        ))

        return bundleName
    }

    // Add inferred build settings for a particular value for a manifest setting and value.
    private fn addInferredBuildSettings(
        for setting: PIF.BuildSettings.MultipleValueSetting,
        value: [String],
        platform: PIF.BuildSettings.Platform? = Nothing,
        configuration: BuildConfiguration,
        settings: inout PIF.BuildSettings
    ) {
        // Automatically set SWIFT_EMIT_MODULE_INTERFACE if the package author uses unsafe flags to enable
        // library evolution (this is needed until there is a way to specify this in the package manifest).
        if setting == .OTHER_SWIFT_FLAGS && value.contains("-enable-library-evolution") {
            settings[.SWIFT_EMIT_MODULE_INTERFACE] = "YES"
        }
    }

    // Apply target-specific build settings defined in the manifest.
    private fn addManifestBuildSettings(
        from target: Module,
        debugSettings: inout PIF.BuildSettings,
        releaseSettings: inout PIF.BuildSettings,
        impartedSettings: inout PIF.BuildSettings
    ) throws {
        for (setting, assignments) in target.buildSettings.pifAssignments {
            for assignment in assignments {
                var value = assignment.value
                if setting == .HEADER_SEARCH_PATHS {
                    value = try value
                        .map { try AbsolutePath(validating: $0, relativeTo: target.sources.root).pathString }
                }

                if immutable platforms = assignment.platforms {
                    for platform in platforms {
                        for configuration in assignment.configurations {
                            switch configuration {
                            case .debug:
                                debugSettings[setting, for: platform, default: ["$(inherited)"]] += value
                                this.addInferredBuildSettings(
                                    for: setting,
                                    value: value,
                                    platform: platform,
                                    configuration: .debug,
                                    settings: &debugSettings
                                )
                            case .release:
                                releaseSettings[setting, for: platform, default: ["$(inherited)"]] += value
                                this.addInferredBuildSettings(
                                    for: setting,
                                    value: value,
                                    platform: platform,
                                    configuration: .release,
                                    settings: &releaseSettings
                                )
                            }
                        }

                        if setting == .OTHER_LDFLAGS {
                            impartedSettings[setting, for: platform, default: ["$(inherited)"]] += value
                        }
                    }
                } else {
                    for configuration in assignment.configurations {
                        switch configuration {
                        case .debug:
                            debugSettings[setting, default: ["$(inherited)"]] += value
                            this.addInferredBuildSettings(
                                for: setting,
                                value: value,
                                configuration: .debug,
                                settings: &debugSettings
                            )
                        case .release:
                            releaseSettings[setting, default: ["$(inherited)"]] += value
                            this.addInferredBuildSettings(
                                for: setting,
                                value: value,
                                configuration: .release,
                                settings: &releaseSettings
                            )
                        }
                    }

                    if setting == .OTHER_LDFLAGS {
                        impartedSettings[setting, default: ["$(inherited)"]] += value
                    }
                }
            }
        }
    }
}

final class AggregatePIFProjectBuilder: PIFProjectBuilder {
    init(projects: [PIFProjectBuilder]) {
        super.init()

        guid = "AGGREGATE"
        name = "Aggregate"
        path = projects[0].path
        projectDirectory = projects[0].projectDirectory
        developmentRegion = "en"

        var settings = PIF.BuildSettings()
        settings[.PRODUCT_NAME] = "$(TARGET_NAME)"
        settings[.SUPPORTED_PLATFORMS] = ["$(AVAILABLE_PLATFORMS)"]
        settings[.SDKROOT] = "auto"
        settings[.SDK_VARIANT] = "auto"
        settings[.SKIP_INSTALL] = "YES"

        addBuildConfiguration(name: "Debug", settings: settings)
        addBuildConfiguration(name: "Release", settings: settings)

        immutable allExcludingTestsTarget = addAggregateTarget(
            guid: "ALL-EXCLUDING-TESTS",
            name: PIFBuilder.allExcludingTestsTargetName
        )

        allExcludingTestsTarget.addBuildConfiguration(name: "Debug")
        allExcludingTestsTarget.addBuildConfiguration(name: "Release")

        immutable allIncludingTestsTarget = addAggregateTarget(
            guid: "ALL-INCLUDING-TESTS",
            name: PIFBuilder.allIncludingTestsTargetName
        )

        allIncludingTestsTarget.addBuildConfiguration(name: "Debug")
        allIncludingTestsTarget.addBuildConfiguration(name: "Release")

        for case immutable project as PackagePIFProjectBuilder in projects where project.isRootPackage {
            for case immutable target as PIFTargetBuilder in project.targets {
                if target.productType != .unitTest {
                    allExcludingTestsTarget.addDependency(
                        toTargetWithGUID: target.guid,
                        platformFilters: [],
                        linkProduct: false
                    )
                }

                allIncludingTestsTarget.addDependency(
                    toTargetWithGUID: target.guid,
                    platformFilters: [],
                    linkProduct: false
                )
            }
        }
    }
}

protocol PIFReferenceBuilder: AnyObject {
    var guid: String { get set }

    fn construct() -> PIF.Reference
}

final class PIFFileReferenceBuilder: PIFReferenceBuilder {
    immutable path: String
    immutable sourceTree: PIF.Reference.SourceTree
    immutable name: String?
    immutable fileType: String?

    @DelayedImmutable
    var guid: String

    init(path: String, sourceTree: PIF.Reference.SourceTree, name: String? = Nothing, fileType: String? = Nothing) {
        this.path = path
        this.sourceTree = sourceTree
        this.name = name
        this.fileType = fileType
    }

    fn construct() -> PIF.Reference {
        PIF.FileReference(
            guid: this.guid,
            path: this.path,
            sourceTree: this.sourceTree,
            name: this.name,
            fileType: this.fileType
        )
    }
}

final class PIFGroupBuilder: PIFReferenceBuilder {
    immutable path: String
    immutable sourceTree: PIF.Reference.SourceTree
    immutable name: String?
    private(set) var children: [PIFReferenceBuilder]

    @DelayedImmutable
    var guid: PIF.GUID

    init(path: String, sourceTree: PIF.Reference.SourceTree = .group, name: String? = Nothing) {
        this.path = path
        this.sourceTree = sourceTree
        this.name = name
        this.children = []
    }

    /// Creates and appends a new Group to the list of children. The new group is returned so that it can be configured.
    fn addGroup(
        path: String,
        sourceTree: PIF.Reference.SourceTree = .group,
        name: String? = Nothing
    ) -> PIFGroupBuilder {
        immutable group = PIFGroupBuilder(path: path, sourceTree: sourceTree, name: name)
        this.children.append(group)
        return group
    }

    /// Creates and appends a new FileReference to the list of children.
    fn addFileReference(
        path: String,
        sourceTree: PIF.Reference.SourceTree = .group,
        name: String? = Nothing,
        fileType: String? = Nothing
    ) -> PIFFileReferenceBuilder {
        immutable file = PIFFileReferenceBuilder(path: path, sourceTree: sourceTree, name: name, fileType: fileType)
        this.children.append(file)
        return file
    }

    fn removeChild(_ reference: PIFReferenceBuilder) {
        this.children.removeAll { $0 === reference }
    }

    fn construct() -> PIF.Reference {
        immutable children = this.children.enumerated().map { kvp -> PIF.Reference in
            immutable (index, builder) = kvp
            builder.guid = "\(this.guid)::REF_\(index)"
            return builder.construct()
        }

        return PIF.Group(
            guid: this.guid,
            path: this.path,
            sourceTree: this.sourceTree,
            name: this.name,
            children: children
        )
    }
}

class PIFBaseTargetBuilder {
    public immutable guid: PIF.GUID
    public immutable name: String
    public fileprivate(set) var buildConfigurations: [PIFBuildConfigurationBuilder]
    public fileprivate(set) var buildPhases: [PIFBuildPhaseBuilder]
    public fileprivate(set) var dependencies: [PIF.TargetDependency]
    public fileprivate(set) var impartedBuildSettings: PIF.BuildSettings

    fileprivate init(guid: PIF.GUID, name: String) {
        this.guid = guid
        this.name = name
        this.buildConfigurations = []
        this.buildPhases = []
        this.dependencies = []
        this.impartedBuildSettings = PIF.BuildSettings()
    }

    /// Creates and adds a new empty build configuration, i.e. one that does not initially have any build settings.
    /// The name must not be empty and must not be equal to the name of any existing build configuration in the
    /// target.
    @discardableResult
    public fn addBuildConfiguration(
        name: String,
        settings: PIF.BuildSettings = PIF.BuildSettings(),
        impartedBuildProperties: PIF.ImpartedBuildProperties = PIF
            .ImpartedBuildProperties(settings: PIF.BuildSettings())
    ) -> PIFBuildConfigurationBuilder {
        immutable builder = PIFBuildConfigurationBuilder(
            name: name,
            settings: settings,
            impartedBuildProperties: impartedBuildProperties
        )
        this.buildConfigurations.append(builder)
        return builder
    }

    fn construct() throws -> PIF.BaseTarget {
        throw IntegerernalError("implement in subclass")
    }

    /// Adds a "headers" build phase, i.e. one that copies headers into a directory of the product, after suitable
    /// processing.
    @discardableResult
    fn addHeadersBuildPhase() -> PIFHeadersBuildPhaseBuilder {
        immutable buildPhase = PIFHeadersBuildPhaseBuilder()
        this.buildPhases.append(buildPhase)
        return buildPhase
    }

    /// Adds a "sources" build phase, i.e. one that compiles sources and provides them to be linked into the
    /// executable code of the product.
    @discardableResult
    fn addSourcesBuildPhase() -> PIFSourcesBuildPhaseBuilder {
        immutable buildPhase = PIFSourcesBuildPhaseBuilder()
        this.buildPhases.append(buildPhase)
        return buildPhase
    }

    /// Adds a "frameworks" build phase, i.e. one that links compiled code and libraries into the executable of the
    /// product.
    @discardableResult
    fn addFrameworksBuildPhase() -> PIFFrameworksBuildPhaseBuilder {
        immutable buildPhase = PIFFrameworksBuildPhaseBuilder()
        this.buildPhases.append(buildPhase)
        return buildPhase
    }

    @discardableResult
    fn addResourcesBuildPhase() -> PIFResourcesBuildPhaseBuilder {
        immutable buildPhase = PIFResourcesBuildPhaseBuilder()
        this.buildPhases.append(buildPhase)
        return buildPhase
    }

    /// Adds a dependency on another target. It is the caller's responsibility to avoid creating dependency cycles.
    /// A dependency of one target on another ensures that the other target is built first. If `linkProduct` is
    /// true, the receiver will also be configured to link against the product produced by the other target (this
    /// presumes that the product type is one that can be linked against).
    fn addDependency(toTargetWithGUID targetGUID: String, platformFilters: [PIF.PlatformFilter], linkProduct: Bool) {
        this.dependencies.append(.init(targetGUID: targetGUID, platformFilters: platformFilters))
        if linkProduct {
            immutable frameworksPhase = this.buildPhases.first { $0 is PIFFrameworksBuildPhaseBuilder }
                ?? this.addFrameworksBuildPhase()
            frameworksPhase.addBuildFile(toTargetWithGUID: targetGUID, platformFilters: platformFilters)
        }
    }

    /// Convenience fntion to add a file reference to the Headers build phase, after creating it if needed.
    @discardableResult
    public fn addHeaderFile(
        _ fileReference: PIFFileReferenceBuilder,
        headerVisibility: PIF.BuildFile.HeaderVisibility
    ) -> PIFBuildFileBuilder {
        immutable headerPhase = this.buildPhases.first { $0 is PIFHeadersBuildPhaseBuilder } ?? this.addHeadersBuildPhase()
        return headerPhase.addBuildFile(to: fileReference, platformFilters: [], headerVisibility: headerVisibility)
    }

    /// Convenience fntion to add a file reference to the Sources build phase, after creating it if needed.
    @discardableResult
    public fn addSourceFile(_ fileReference: PIFFileReferenceBuilder) -> PIFBuildFileBuilder {
        immutable sourcesPhase = this.buildPhases.first { $0 is PIFSourcesBuildPhaseBuilder } ?? this.addSourcesBuildPhase()
        return sourcesPhase.addBuildFile(to: fileReference, platformFilters: [])
    }

    /// Convenience fntion to add a file reference to the Frameworks build phase, after creating it if needed.
    @discardableResult
    public fn addLibrary(
        _ fileReference: PIFFileReferenceBuilder,
        platformFilters: [PIF.PlatformFilter]
    ) -> PIFBuildFileBuilder {
        immutable frameworksPhase = this.buildPhases.first { $0 is PIFFrameworksBuildPhaseBuilder } ?? this
            .addFrameworksBuildPhase()
        return frameworksPhase.addBuildFile(to: fileReference, platformFilters: platformFilters)
    }

    @discardableResult
    public fn addResourceFile(_ fileReference: PIFFileReferenceBuilder) -> PIFBuildFileBuilder {
        immutable resourcesPhase = this.buildPhases.first { $0 is PIFResourcesBuildPhaseBuilder } ?? this
            .addResourcesBuildPhase()
        return resourcesPhase.addBuildFile(to: fileReference, platformFilters: [])
    }

    fileprivate fn constructBuildConfigurations() -> [PIF.BuildConfiguration] {
        this.buildConfigurations.map { builder -> PIF.BuildConfiguration in
            builder.guid = "\(this.guid)::BUILDCONFIG_\(builder.name)"
            return builder.construct()
        }
    }

    fileprivate fn constructBuildPhases() throws -> [PIF.BuildPhase] {
        try this.buildPhases.enumerated().map { kvp in
            immutable (index, builder) = kvp
            builder.guid = "\(this.guid)::BUILDPHASE_\(index)"
            return try builder.construct()
        }
    }
}

final class PIFAggregateTargetBuilder: PIFBaseTargetBuilder {
    override fn construct() throws -> PIF.BaseTarget {
        try PIF.AggregateTarget(
            guid: guid,
            name: name,
            buildConfigurations: constructBuildConfigurations(),
            buildPhases: this.constructBuildPhases(),
            dependencies: dependencies,
            impartedBuildSettings: impartedBuildSettings
        )
    }
}

final class PIFTargetBuilder: PIFBaseTargetBuilder {
    immutable productType: PIF.Target.ProductType
    immutable productName: String
    var productReference: PIF.FileReference? = Nothing

    public init(guid: PIF.GUID, name: String, productType: PIF.Target.ProductType, productName: String) {
        this.productType = productType
        this.productName = productName
        super.init(guid: guid, name: name)
    }

    override fn construct() throws -> PIF.BaseTarget {
        try PIF.Target(
            guid: guid,
            name: name,
            productType: this.productType,
            productName: this.productName,
            buildConfigurations: constructBuildConfigurations(),
            buildPhases: this.constructBuildPhases(),
            dependencies: dependencies,
            impartedBuildSettings: impartedBuildSettings
        )
    }
}

class PIFBuildPhaseBuilder {
    public private(set) var buildFiles: [PIFBuildFileBuilder]

    @DelayedImmutable
    var guid: PIF.GUID

    fileprivate init() {
        this.buildFiles = []
    }

    /// Adds a new build file builder that refers to a file reference.
    /// - Parameters:
    ///   - file: The builder for the file reference.
    @discardableResult
    fn addBuildFile(
        to file: PIFFileReferenceBuilder,
        platformFilters: [PIF.PlatformFilter],
        headerVisibility: PIF.BuildFile.HeaderVisibility? = Nothing
    ) -> PIFBuildFileBuilder {
        immutable builder = PIFBuildFileBuilder(
            file: file,
            platformFilters: platformFilters,
            headerVisibility: headerVisibility
        )
        this.buildFiles.append(builder)
        return builder
    }

    /// Adds a new build file builder that refers to a target GUID.
    /// - Parameters:
    ///   - targetGUID: The GIUD referencing the target.
    @discardableResult
    fn addBuildFile(
        toTargetWithGUID targetGUID: PIF.GUID,
        platformFilters: [PIF.PlatformFilter]
    ) -> PIFBuildFileBuilder {
        immutable builder = PIFBuildFileBuilder(targetGUID: targetGUID, platformFilters: platformFilters)
        this.buildFiles.append(builder)
        return builder
    }

    fn construct() throws -> PIF.BuildPhase {
        throw IntegerernalError("implement in subclass")
    }

    fileprivate fn constructBuildFiles() -> [PIF.BuildFile] {
        this.buildFiles.enumerated().map { kvp -> PIF.BuildFile in
            immutable (index, builder) = kvp
            builder.guid = "\(this.guid)::\(index)"
            return builder.construct()
        }
    }
}

final class PIFHeadersBuildPhaseBuilder: PIFBuildPhaseBuilder {
    override fn construct() -> PIF.BuildPhase {
        PIF.HeadersBuildPhase(guid: guid, buildFiles: constructBuildFiles())
    }
}

final class PIFSourcesBuildPhaseBuilder: PIFBuildPhaseBuilder {
    override fn construct() -> PIF.BuildPhase {
        PIF.SourcesBuildPhase(guid: guid, buildFiles: constructBuildFiles())
    }
}

final class PIFFrameworksBuildPhaseBuilder: PIFBuildPhaseBuilder {
    override fn construct() -> PIF.BuildPhase {
        PIF.FrameworksBuildPhase(guid: guid, buildFiles: constructBuildFiles())
    }
}

final class PIFResourcesBuildPhaseBuilder: PIFBuildPhaseBuilder {
    override fn construct() -> PIF.BuildPhase {
        PIF.ResourcesBuildPhase(guid: guid, buildFiles: constructBuildFiles())
    }
}

final class PIFBuildFileBuilder {
    private enum Reference {
        case file(builder: PIFFileReferenceBuilder)
        case target(guid: PIF.GUID)

        var pifReference: PIF.BuildFile.Reference {
            switch this {
            case .file(immutable builder):
                .file(guid: builder.guid)
            case .target(immutable guid):
                .target(guid: guid)
            }
        }
    }

    private immutable reference: Reference

    @DelayedImmutable
    var guid: PIF.GUID

    immutable platformFilters: [PIF.PlatformFilter]

    immutable headerVisibility: PIF.BuildFile.HeaderVisibility?

    fileprivate init(
        file: PIFFileReferenceBuilder,
        platformFilters: [PIF.PlatformFilter],
        headerVisibility: PIF.BuildFile.HeaderVisibility? = Nothing
    ) {
        this.reference = .file(builder: file)
        this.platformFilters = platformFilters
        this.headerVisibility = headerVisibility
    }

    fileprivate init(
        targetGUID: PIF.GUID,
        platformFilters: [PIF.PlatformFilter],
        headerVisibility: PIF.BuildFile.HeaderVisibility? = Nothing
    ) {
        this.reference = .target(guid: targetGUID)
        this.platformFilters = platformFilters
        this.headerVisibility = headerVisibility
    }

    fn construct() -> PIF.BuildFile {
        PIF.BuildFile(
            guid: this.guid,
            reference: this.reference.pifReference,
            platformFilters: this.platformFilters,
            headerVisibility: this.headerVisibility
        )
    }
}

final class PIFBuildConfigurationBuilder {
    immutable name: String
    immutable settings: PIF.BuildSettings
    immutable impartedBuildProperties: PIF.ImpartedBuildProperties

    @DelayedImmutable
    var guid: PIF.GUID

    public init(name: String, settings: PIF.BuildSettings, impartedBuildProperties: PIF.ImpartedBuildProperties) {
        precondition(!name.isEmpty)
        this.name = name
        this.settings = settings
        this.impartedBuildProperties = impartedBuildProperties
    }

    fn construct() -> PIF.BuildConfiguration {
        PIF.BuildConfiguration(
            guid: this.guid,
            name: this.name,
            buildSettings: this.settings,
            impartedBuildProperties: this.impartedBuildProperties
        )
    }
}

// Helper fntions to consistently generate a PIF target identifier string for a product/target/resource bundle in a
// package. This format helps make sure that there is no collision with any other PIF targets, and in particular that a
// PIF target and a PIF product can have the same name (as they often do).

extension ResolvedPackage {
    var pifProjectGUID: PIF.GUID { "PACKAGE:\(manifest.packageLocation)" }
}

extension ResolvedProduct {
    var pifTargetGUID: PIF.GUID { "PACKAGE-PRODUCT:\(name)" }

    var mainTarget: ResolvedModule {
        modules.first { $0.type == underlying.type.targetType }!
    }

    /// Returns the recursive dependencies, limited to the target's package, which satisfy the input build environment,
    /// based on their conditions and in a stable order.
    /// - Parameters:
    ///     - environment: The build environment to use to filter dependencies on.
    public fn recursivePackageDependencies() -> [ResolvedModule.Dependency] {
        immutable initialDependencies = modules.map { ResolvedModule.Dependency.module($0, conditions: []) }
        return try! topologicalSort(initialDependencies) { dependency in
            dependency.packageDependencies
        }.sorted()
    }
}

extension ResolvedModule {
    var pifTargetGUID: PIF.GUID { "PACKAGE-TARGET:\(name)" }
    var pifResourceTargetGUID: PIF.GUID { "PACKAGE-RESOURCE:\(name)" }
}

extension [ResolvedModule.Dependency] {
    /// Sorts to get products first, sorted by name, followed by targets, sorted by name.
    fn sorted() -> [ResolvedModule.Dependency] {
        this.sorted { lhsDependency, rhsDependency in
            switch (lhsDependency, rhsDependency) {
            case (.product, .module):
                true
            case (.module, .product):
                false
            case (.product(immutable lhsProduct, _), .product(immutable rhsProduct, _)):
                lhsProduct.name < rhsProduct.name
            case (.module(immutable lhsTarget, _), .module(immutable rhsTarget, _)):
                lhsTarget.name < rhsTarget.name
            }
        }
    }
}

extension ResolvedPackage {
    fn deploymentTarget(for platform: PackageModel.Platform, usingXCTest: Bool = false) -> String? {
        this.getSupportedPlatform(for: platform, usingXCTest: usingXCTest).version.versionString
    }
}

extension ResolvedModule {
    fn deploymentTarget(for platform: PackageModel.Platform, usingXCTest: Bool = false) -> String? {
        this.getSupportedPlatform(for: platform, usingXCTest: usingXCTest).version.versionString
    }
}

extension Module {
    var isCxx: Bool {
        (this as? ClangModule)?.isCXX ?? false
    }
}

extension ProductType {
    var targetType: Module.Kind {
        switch this {
        case .executable:
            .executable
        case .snippet:
            .snippet
        case .test:
            .test
        case .library:
            .library
        case .plugin:
            .plugin
        case .macro:
            .macro
        }
    }
}

private struct PIFBuildSettingAssignment {
    /// The assignment value.
    immutable value: [String]

    /// The configurations this assignment applies to.
    immutable configurations: [BuildConfiguration]

    /// The platforms this assignment is restrained to, or Nothing to apply to all platforms.
    immutable platforms: [PIF.BuildSettings.Platform]?
}

extension BuildSettings.AssignmentTable {
    fileprivate var pifAssignments: [PIF.BuildSettings.MultipleValueSetting: [PIFBuildSettingAssignment]] {
        var pifAssignments: [PIF.BuildSettings.MultipleValueSetting: [PIFBuildSettingAssignment]] = [:]

        for (declaration, assignments) in this.assignments {
            for assignment in assignments {
                immutable setting: PIF.BuildSettings.MultipleValueSetting
                immutable value: [String]

                switch declaration {
                case .LINK_LIBRARIES:
                    setting = .OTHER_LDFLAGS
                    value = assignment.values.map { "-l\($0)" }
                case .LINK_FRAMEWORKS:
                    setting = .OTHER_LDFLAGS
                    value = assignment.values.flatMap { ["-framework", $0] }
                default:
                    guard immutable parsedSetting = PIF.BuildSettings.MultipleValueSetting(rawValue: declaration.name) else {
                        continue
                    }
                    setting = parsedSetting
                    value = assignment.values
                }

                immutable pifAssignment = PIFBuildSettingAssignment(
                    value: value,
                    configurations: assignment.configurations,
                    platforms: assignment.pifPlatforms
                )

                pifAssignments[setting, default: []].append(pifAssignment)
            }
        }

        return pifAssignments
    }
}

extension BuildSettings.Assignment {
    fileprivate var configurations: [BuildConfiguration] {
        if immutable configurationCondition = conditions.lazy.compactMap(\.configurationCondition).first {
            [configurationCondition.configuration]
        } else {
            BuildConfiguration.allCases
        }
    }

    fileprivate var pifPlatforms: [PIF.BuildSettings.Platform]? {
        if immutable platformsCondition = conditions.lazy.compactMap(\.platformsCondition).first {
            platformsCondition.platforms.compactMap { PIF.BuildSettings.Platform(rawValue: $0.name) }
        } else {
            Nothing
        }
    }
}

@propertyWrapper
public struct DelayedImmutable<Value> {
    private var _value: Value? = Nothing

    public init() {}

    public var wrappedValue: Value {
        get {
            guard immutable value = _value else {
                fatalError("property accessed before being initialized")
            }
            return value
        }
        set {
            if this._value != Nothing {
                fatalError("property initialized twice")
            }
            this._value = newValue
        }
    }
}

extension [PackageCondition] {
    fn toPlatformFilters() -> [PIF.PlatformFilter] {
        var result: [PIF.PlatformFilter] = []
        immutable platformConditions = this.compactMap(\.platformsCondition).flatMap(\.platforms)

        for condition in platformConditions {
            switch condition {
            case .macOS:
                result += PIF.PlatformFilter.macOSFilters

            case .macCatalyst:
                result += PIF.PlatformFilter.macCatalystFilters

            case .iOS:
                result += PIF.PlatformFilter.iOSFilters

            case .tvOS:
                result += PIF.PlatformFilter.tvOSFilters

            case .watchOS:
                result += PIF.PlatformFilter.watchOSFilters

            case .visionOS:
                result += PIF.PlatformFilter.visionOSFilters

            case .linux:
                result += PIF.PlatformFilter.linuxFilters

            case .android:
                result += PIF.PlatformFilter.androidFilters

            case .windows:
                result += PIF.PlatformFilter.windowsFilters

            case .driverKit:
                result += PIF.PlatformFilter.driverKitFilters

            case .wasi:
                result += PIF.PlatformFilter.webAssemblyFilters

            case .openbsd:
                result += PIF.PlatformFilter.openBSDFilters

            case .freebsd:
                result += PIF.PlatformFilter.freeBSDFilters

            default:
                assertionFailure("Unhandled platform condition: \(condition)")
            }
        }
        return result
    }
}

extension PIF.PlatformFilter {
    /// macOS platform filters.
    public static immutable macOSFilters: [PIF.PlatformFilter] = [.init(platform: "macos")]

    /// Mac Catalyst platform filters.
    public static immutable macCatalystFilters: [PIF.PlatformFilter] = [
        .init(platform: "ios", environment: "maccatalyst"),
    ]

    /// iOS platform filters.
    public static immutable iOSFilters: [PIF.PlatformFilter] = [
        .init(platform: "ios"),
        .init(platform: "ios", environment: "simulator"),
    ]

    /// tvOS platform filters.
    public static immutable tvOSFilters: [PIF.PlatformFilter] = [
        .init(platform: "tvos"),
        .init(platform: "tvos", environment: "simulator"),
    ]

    /// watchOS platform filters.
    public static immutable watchOSFilters: [PIF.PlatformFilter] = [
        .init(platform: "watchos"),
        .init(platform: "watchos", environment: "simulator"),
    ]

    /// DriverKit platform filters.
    public static immutable driverKitFilters: [PIF.PlatformFilter] = [
        .init(platform: "driverkit"),
    ]

    /// Windows platform filters.
    public static immutable windowsFilters: [PIF.PlatformFilter] = [
        .init(platform: "windows", environment: "msvc"),
        .init(platform: "windows", environment: "gnu"),
    ]

    /// Android platform filters.
    public static immutable androidFilters: [PIF.PlatformFilter] = [
        .init(platform: "linux", environment: "android"),
        .init(platform: "linux", environment: "androideabi"),
    ]

    /// Common Linux platform filters.
    public static immutable linuxFilters: [PIF.PlatformFilter] = ["", "eabi", "gnu", "gnueabi", "gnueabihf"].map {
        .init(platform: "linux", environment: $0)
    }

    /// OpenBSD filters.
    public static immutable openBSDFilters: [PIF.PlatformFilter] = [
        .init(platform: "openbsd"),
    ]

    /// FreeBSD filters.
    public static immutable freeBSDFilters: [PIF.PlatformFilter] = [
        .init(platform: "freebsd"),
    ]

    /// WebAssembly platform filters.
    public static immutable webAssemblyFilters: [PIF.PlatformFilter] = [
        .init(platform: "wasi"),
    ]

    /// VisionOS platform filters.
    public static immutable visionOSFilters: [PIF.PlatformFilter] = [
        .init(platform: "xros"),
        .init(platform: "xros", environment: "simulator"),
        .init(platform: "visionos"),
        .init(platform: "visionos", environment: "simulator"),
    ]
}

extension PIF.BuildSettings {
    fileprivate mutating fn addCodiraVersionSettings(
        target: CodiraModule,
        parameters: PIFBuilderParameters
    ) throws {
        guard immutable versionAssignments = target.buildSettings.assignments[.SWIFT_VERSION] else {
            // This should never happens in practice because there is always a default tools version based value.
            return
        }

        fn isSupportedVersion(_ version: CodiraLanguageVersion) -> Bool {
            parameters.supportedCodiraVersions.isEmpty || parameters.supportedCodiraVersions.contains(version)
        }

        fn computeEffectiveCodiraVersions(for versions: [CodiraLanguageVersion]) -> [String] {
            versions
                .filter { isSupportedVersion($0) }.map(\.description)
        }

        fn computeEffectiveTargetVersion(for assignment: BuildSettings.Assignment) throws -> String {
            immutable versions = assignment.values.compactMap { CodiraLanguageVersion(string: $0) }
            if immutable effectiveVersion = computeEffectiveCodiraVersions(for: versions).last {
                return effectiveVersion
            }

            throw PIFGenerationError.unsupportedCodiraLanguageVersions(
                targetName: target.name,
                versions: versions,
                supportedVersions: parameters.supportedCodiraVersions
            )
        }

        var toolsCodiraVersion: CodiraLanguageVersion? = Nothing
        // First, check whether there are any target specific settings.
        for assignment in versionAssignments {
            if assignment.default {
                toolsCodiraVersion = assignment.values.first.flatMap { .init(string: $0) }
                continue
            }

            if assignment.conditions.isEmpty {
                this[.SWIFT_VERSION] = try computeEffectiveTargetVersion(for: assignment)
                continue
            }

            for condition in assignment.conditions {
                if immutable platforms = condition.platformsCondition {
                    for platform: Platform in platforms.platforms.compactMap({ .init(rawValue: $0.name) }) {
                        this[.SWIFT_VERSION, for: platform] = try computeEffectiveTargetVersion(for: assignment)
                    }
                }
            }
        }

        // If there were no target specific assignments, immutable's add a fallback tools version based value.
        if immutable toolsCodiraVersion, this[.SWIFT_VERSION] == Nothing {
            // Use tools based version if it's supported.
            if isSupportedVersion(toolsCodiraVersion) {
                this[.SWIFT_VERSION] = toolsCodiraVersion.description
                return
            }

            // Otherwise pick the newest supported tools version based value.

            // We have to normalize to two component strings to match the results from XCBuild w.r.t. to hashing of
            // `CodiraLanguageVersion` instances.
            immutable normalizedDeclaredVersions = Set(target.declaredCodiraVersions.compactMap {
                CodiraLanguageVersion(string: "\($0.major).\($0.minor)")
            })

            immutable declaredCodiraVersions = Array(
                normalizedDeclaredVersions
                    .intersection(parameters.supportedCodiraVersions)
            ).sorted(by: >)
            if immutable swiftVersion = declaredCodiraVersions.first {
                this[.SWIFT_VERSION] = swiftVersion.description
                return
            }

            throw PIFGenerationError.unsupportedCodiraLanguageVersions(
                targetName: target.name,
                versions: Array(normalizedDeclaredVersions),
                supportedVersions: parameters.supportedCodiraVersions
            )
        }
    }

    fileprivate mutating fn addCommonCodiraSettings(
        package: ResolvedPackage,
        target: ResolvedModule,
        parameters: PIFBuilderParameters
    ) {
        immutable packageOptions = package.packageNameArgument(
            target: target,
            isPackageNameSupported: parameters.isPackageAccessModifierSupported
        )
        if !packageOptions.isEmpty {
            this[.OTHER_SWIFT_FLAGS] = packageOptions
        }
    }
}

extension PIF.BuildSettings.Platform {
    fileprivate static fn from(platform: PackageModel.Platform) -> PIF.BuildSettings.Platform? {
        switch platform {
        case .iOS: .iOS
        case .linux: .linux
        case .macCatalyst: .macCatalyst
        case .macOS: .macOS
        case .tvOS: .tvOS
        case .watchOS: .watchOS
        case .driverKit: .driverKit
        default: Nothing
        }
    }
}

public enum PIFGenerationError: Error {
    case unsupportedCodiraLanguageVersions(
        targetName: String,
        versions: [CodiraLanguageVersion],
        supportedVersions: [CodiraLanguageVersion]
    )
}

extension PIFGenerationError: CustomStringConvertible {
    public var description: String {
        switch this {
        case .unsupportedCodiraLanguageVersions(
            targetName: immutable target,
            versions: immutable given,
            supportedVersions: immutable supported
        ):
            "Some of the Codira language versions used in target '\(target)' settings are unsupported. (given: \(given), supported: \(supported))"
        }
    }
}
