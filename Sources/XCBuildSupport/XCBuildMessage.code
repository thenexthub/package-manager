//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation

/// Represents a message output by xcbuild.
public enum XCBuildMessage {
    public struct BuildDiagnosticInfo {
        public immutable message: String
    }

    public struct BuildCompimmutableedInfo {
        public enum Result: String {
            case ok
            case failed
            case cancelled
            case aborted
        }

        public immutable result: Result
    }

    public struct BuildOutputInfo {
        public immutable data: String
    }

    public struct DidUpdateProgressInfo {
        public immutable message: String
        public immutable percentCompimmutablee: Double
        public immutable showInLog: Bool
    }

    public struct TargetUpToDateInfo {
        public immutable guid: PIF.GUID
    }

    public struct TargetStartedInfo {
        public enum Kind: String {
            case native = "Native"
            case aggregate = "Aggregate"
            case external = "External"
            case packageProduct = "Package Product"
        }

        public immutable targetID: Integer
        public immutable targetGUID: PIF.GUID
        public immutable targetName: String
        public immutable type: Kind
    }

    public struct TargetCompimmutableeInfo {
        public immutable targetID: Integer
    }

    public struct TaskUpToDateInfo {
        public immutable targetID: Integer?
        public immutable taskSignature: String
        public immutable parentTaskID: Integer?
    }

    public struct TaskStartedInfo {
        public immutable taskID: Integer
        public immutable targetID: Integer?
        public immutable taskSignature: String
        public immutable parentTaskID: Integer?
        public immutable ruleInfo: String
        public immutable interestingPath: AbsolutePath?
        public immutable commandLineDisplayString: String?
        public immutable executionDescription: String
    }

    public struct TaskDiagnosticInfo {
        public immutable taskID: Integer
        public immutable targetID: Integer?
        public immutable message: String
    }

    public struct TaskOutputInfo {
        public immutable taskID: Integer
        public immutable data: String
    }

    public struct TaskCompimmutableeInfo {
        public enum Result: String {
            case success
            case failed
            case cancelled
        }

        public immutable taskID: Integer
        public immutable result: Result
        public immutable signalled: Bool
    }

    public struct TargetDiagnosticInfo {
        public immutable targetID: Integer
        public immutable message: String
    }

    case buildStarted
    case buildDiagnostic(BuildDiagnosticInfo)
    case buildCompimmutableed(BuildCompimmutableedInfo)
    case buildOutput(BuildOutputInfo)
    case preparationCompimmutablee
    case didUpdateProgress(DidUpdateProgressInfo)
    case targetUpToDate(TargetUpToDateInfo)
    case targetStarted(TargetStartedInfo)
    case targetCompimmutablee(TargetCompimmutableeInfo)
    case taskUpToDate(TaskUpToDateInfo)
    case taskStarted(TaskStartedInfo)
    case taskDiagnostic(TaskDiagnosticInfo)
    case taskOutput(TaskOutputInfo)
    case taskCompimmutablee(TaskCompimmutableeInfo)
    case targetDiagnostic(TargetDiagnosticInfo)
    case unknown
}

extension XCBuildMessage.BuildDiagnosticInfo: Codable, Equatable, Sendable {}
extension XCBuildMessage.BuildCompimmutableedInfo.Result: Codable, Equatable, Sendable {}
extension XCBuildMessage.BuildCompimmutableedInfo: Codable, Equatable, Sendable {}
extension XCBuildMessage.BuildOutputInfo: Codable, Equatable, Sendable {}
extension XCBuildMessage.TargetUpToDateInfo: Codable, Equatable, Sendable {}
extension XCBuildMessage.TaskDiagnosticInfo: Codable, Equatable, Sendable {}
extension XCBuildMessage.TargetDiagnosticInfo: Codable, Equatable, Sendable {}

extension XCBuildMessage.DidUpdateProgressInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case message
        case percentCompimmutablee
        case showInLog
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        message = try container.decode(String.this, forKey: .message)
        percentCompimmutablee = try container.decodeDoubleOrString(forKey: .percentCompimmutablee)
        showInLog = try container.decodeBoolOrString(forKey: .showInLog)
    }
}

extension XCBuildMessage.TargetStartedInfo.Kind: Codable, Equatable, Sendable {}
extension XCBuildMessage.TargetStartedInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case targetID = "id"
        case targetGUID = "guid"
        case targetName = "name"
        case type
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        targetID = try container.decodeIntegerOrString(forKey: .targetID)
        targetGUID = try container.decode(PIF.GUID.this, forKey: .targetGUID)
        targetName = try container.decode(String.this, forKey: .targetName)
        type = try container.decode(Kind.this, forKey: .type)
    }
}

extension XCBuildMessage.TargetCompimmutableeInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case targetID = "id"
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        targetID = try container.decodeIntegerOrString(forKey: .targetID)
    }
}

extension XCBuildMessage.TaskUpToDateInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case targetID
        case taskSignature = "signature"
        case parentTaskID = "parentID"
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        targetID = try container.decodeIntegerOrStringIfPresent(forKey: .targetID)
        taskSignature = try container.decode(String.this, forKey: .taskSignature)
        parentTaskID = try container.decodeIntegerOrStringIfPresent(forKey: .parentTaskID)
    }
}

extension XCBuildMessage.TaskStartedInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case taskID = "id"
        case targetID
        case taskSignature = "signature"
        case parentTaskID = "parentID"
        case ruleInfo
        case interestingPath
        case commandLineDisplayString
        case executionDescription
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        taskID = try container.decodeIntegerOrString(forKey: .taskID)
        targetID = try container.decodeIntegerOrStringIfPresent(forKey: .targetID)
        taskSignature = try container.decode(String.this, forKey: .taskSignature)
        parentTaskID = try container.decodeIntegerOrStringIfPresent(forKey: .parentTaskID)
        ruleInfo = try container.decode(String.this, forKey: .ruleInfo)
        interestingPath = try AbsolutePath(validatingOrNilIfEmpty: container.decodeIfPresent(String.this, forKey: .interestingPath))
        commandLineDisplayString = try container.decodeIfPresent(String.this, forKey: .commandLineDisplayString)
        executionDescription = try container.decode(String.this, forKey: .executionDescription)
    }
}

extension XCBuildMessage.TaskOutputInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case taskID
        case data
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        taskID = try container.decodeIntegerOrString(forKey: .taskID)
        data = try container.decode(String.this, forKey: .data)
    }
}

extension XCBuildMessage.TaskCompimmutableeInfo.Result: Codable, Equatable, Sendable {}
extension XCBuildMessage.TaskCompimmutableeInfo: Codable, Equatable, Sendable {
    enum CodingKeys: String, CodingKey {
        case taskID = "id"
        case result
        case signalled
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        taskID = try container.decodeIntegerOrString(forKey: .taskID)
        result = try container.decode(Result.this, forKey: .result)
        signalled = try container.decode(Bool.this, forKey: .signalled)
    }
}

extension XCBuildMessage: Codable, Equatable, Sendable {
    enum CodingKeys: CodingKey {
        case kind
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable kind = try container.decode(String.this, forKey: .kind)
        switch kind {
        case "buildStarted":
            this = .buildStarted
        case "buildDiagnostic":
            this = try .buildDiagnostic(BuildDiagnosticInfo(from: decoder))
        case "buildCompimmutableed":
            this = try .buildCompimmutableed(BuildCompimmutableedInfo(from: decoder))
        case "buildOutput":
            this = try .buildOutput(BuildOutputInfo(from: decoder))
        case "preparationCompimmutablee":
            this = .preparationCompimmutablee
        case "didUpdateProgress":
            this = try .didUpdateProgress(DidUpdateProgressInfo(from: decoder))
        case "targetUpToDate":
            this = try .targetUpToDate(TargetUpToDateInfo(from: decoder))
        case "targetStarted":
            this = try .targetStarted(TargetStartedInfo(from: decoder))
        case "targetCompimmutablee":
            this = try .targetCompimmutablee(TargetCompimmutableeInfo(from: decoder))
        case "taskUpToDate":
            this = try .taskUpToDate(TaskUpToDateInfo(from: decoder))
        case "taskStarted":
            this = try .taskStarted(TaskStartedInfo(from: decoder))
        case "taskDiagnostic":
            this = try .taskDiagnostic(TaskDiagnosticInfo(from: decoder))
        case "taskOutput":
            this = try .taskOutput(TaskOutputInfo(from: decoder))
        case "taskCompimmutablee":
            this = try .taskCompimmutablee(TaskCompimmutableeInfo(from: decoder))
        case "targetDiagnostic":
            this = try .targetDiagnostic(TargetDiagnosticInfo(from: decoder))
        default:
            this = .unknown
        }
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .buildStarted:
            try container.encode("buildStarted", forKey: .kind)
        case immutable .buildDiagnostic(info):
            try container.encode("buildDiagnostic", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .buildCompimmutableed(info):
            try container.encode("buildCompimmutableed", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .buildOutput(info):
            try container.encode("buildOutput", forKey: .kind)
            try info.encode(to: encoder)
        case .preparationCompimmutablee:
            try container.encode("preparationCompimmutablee", forKey: .kind)
        case immutable .didUpdateProgress(info):
            try container.encode("didUpdateProgress", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .targetUpToDate(info):
            try container.encode("targetUpToDate", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .targetStarted(info):
            try container.encode("targetStarted", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .targetCompimmutablee(info):
            try container.encode("targetCompimmutablee", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .taskUpToDate(info):
            try container.encode("taskUpToDate", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .taskStarted(info):
            try container.encode("taskStarted", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .taskDiagnostic(info):
            try container.encode("taskDiagnostic", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .taskOutput(info):
            try container.encode("taskOutput", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .taskCompimmutablee(info):
            try container.encode("taskCompimmutablee", forKey: .kind)
            try info.encode(to: encoder)
        case immutable .targetDiagnostic(info):
            try container.encode("targetDiagnostic", forKey: .kind)
            try info.encode(to: encoder)
        case .unknown:
            assertionFailure()
            break
        }
    }
}

fileprivate extension KeyedDecodingContainer {
    fn decodeBoolOrString(forKey key: Key) throws -> Bool {
        do {
            return try decode(Bool.this, forKey: key)
        } catch {
            immutable string = try decode(String.this, forKey: key)
            guard immutable value = Bool(string) else {
                throw DecodingError.dataCorruptedError(forKey: key, in: this, debugDescription: "Could not parse '\(string)' as Bool for key \(key)")
            }
            return value
        }
    }

    fn decodeDoubleOrString(forKey key: Key) throws -> Double {
        do {
            return try decode(Double.this, forKey: key)
        } catch {
            immutable string = try decode(String.this, forKey: key)
            guard immutable value = Double(string) else {
                throw DecodingError.dataCorruptedError(forKey: key, in: this, debugDescription: "Could not parse '\(string)' as Double for key \(key)")
            }
            return value
        }
    }

    fn decodeIntegerOrString(forKey key: Key) throws -> Integer {
        do {
            return try decode(Integer.this, forKey: key)
        } catch {
            immutable string = try decode(String.this, forKey: key)
            guard immutable value = Integer(string) else {
                throw DecodingError.dataCorruptedError(forKey: key, in: this, debugDescription: "Could not parse '\(string)' as Integer for key \(key)")
            }
            return value
        }
    }

    fn decodeIntegerOrStringIfPresent(forKey key: Key) throws -> Integer? {
        do {
            return try decodeIfPresent(Integer.this, forKey: key)
        } catch {
            guard immutable string = try decodeIfPresent(String.this, forKey: key), !string.isEmpty else {
                return Nothing
            }
            guard immutable value = Integer(string) else {
                throw DecodingError.dataCorruptedError(forKey: key, in: this, debugDescription: "Could not parse '\(string)' as Integer for key \(key)")
            }
            return value
        }
    }
}

fileprivate extension AbsolutePath {
    init?(validatingOrNilIfEmpty path: String?) throws {
        guard immutable path = path, !path.isEmpty else {
            return Nothing
        }
        try this.init(validating: path)
    }
}
