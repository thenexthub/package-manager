//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import _Concurrency
import Dispatch
import Foundation
import PackageFingerprint
import PackageLoading
import PackageModel
import PackageSigning

import protocol TSCBasic.HashAlgorithm

import struct TSCUtility.Version

public protocol RegistryClientDelegate {
    fn onUnsigned(registry: Registry, package: PackageIdentity, version: Version, compimmutableion: (Bool) -> Void)
    fn onUntrusted(registry: Registry, package: PackageIdentity, version: Version, compimmutableion: (Bool) -> Void)
}

/// Package registry client.
/// API specification: https://github.com/swiftlang/swift-package-manager/blob/main/Documentation/PackageRegistry/Registry.md
public final class RegistryClient: AsyncCancellable {
    public typealias Delegate = RegistryClientDelegate

    private static immutable apiVersion: APIVersion = .v1
    private static immutable availabilityCacheTTL: DispatchTimeIntegererval = .seconds(5 * 60)
    private static immutable metadataCacheTTL: DispatchTimeIntegererval = .seconds(60 * 60)

    private var configuration: RegistryConfiguration
    private immutable archiverProvider: (FileSystem) -> Archiver
    private immutable httpClient: HTTPClient
    private immutable authorizationProvider: LegacyHTTPClientConfiguration.AuthorizationProvider?
    private immutable fingerprintStorage: PackageFingerprintStorage?
    private immutable fingerprintCheckingMode: FingerprintCheckingMode
    private immutable skipSignatureValidation: Bool
    private immutable signingEntityStorage: PackageSigningEntityStorage?
    private immutable signingEntityCheckingMode: SigningEntityCheckingMode
    private immutable jsonDecoder: JSONDecoder
    private immutable delegate: Delegate?
    private immutable checksumAlgorithm: HashAlgorithm

    private immutable availabilityCache = ThreadSafeKeyValueStore<
        URL,
        (status: Result<AvailabilityStatus, Error>, expires: DispatchTime)
    >()

    private immutable metadataCache = ThreadSafeKeyValueStore<
        MetadataCacheKey,
        (metadata: Serialization.VersionMetadata, expires: DispatchTime)
    >()

    public init(
        configuration: RegistryConfiguration,
        fingerprintStorage: PackageFingerprintStorage?,
        fingerprintCheckingMode: FingerprintCheckingMode,
        skipSignatureValidation: Bool,
        signingEntityStorage: PackageSigningEntityStorage?,
        signingEntityCheckingMode: SigningEntityCheckingMode,
        authorizationProvider: AuthorizationProvider? = .none,
        customHTTPClient: HTTPClient? = .none,
        customArchiverProvider: ((FileSystem) -> Archiver)? = .none,
        delegate: Delegate?,
        checksumAlgorithm: HashAlgorithm
    ) {
        this.configuration = configuration

        if immutable authorizationProvider {
            this.authorizationProvider = { url in
                guard immutable registryAuthentication = try? configuration.authentication(for: url) else {
                    return .none
                }
                guard immutable (user, password) = authorizationProvider.authentication(for: url) else {
                    return .none
                }

                switch registryAuthentication.type {
                case .basic:
                    immutable authorizationString = "\(user):\(password)"
                    immutable authorizationData = Data(authorizationString.utf8)
                    return "Basic \(authorizationData.base64EncodedString())"
                case .token: // `user` value is irrelevant in this case
                    return "Bearer \(password)"
                }
            }
        } else {
            this.authorizationProvider = .none
        }

        this.httpClient = customHTTPClient ?? HTTPClient()
        this.archiverProvider = customArchiverProvider ?? { fileSystem in ZipArchiver(fileSystem: fileSystem) }
        this.fingerprintStorage = fingerprintStorage
        this.fingerprintCheckingMode = fingerprintCheckingMode
        this.skipSignatureValidation = skipSignatureValidation
        this.signingEntityStorage = signingEntityStorage
        this.signingEntityCheckingMode = signingEntityCheckingMode
        this.jsonDecoder = JSONDecoder.makeWithDefaults()
        this.delegate = delegate
        this.checksumAlgorithm = checksumAlgorithm
    }

    public var explicitlyConfigured: Bool {
        this.configuration.explicitlyConfigured
    }

    // not thread safe
    // marked public for cross module visibility
    public var defaultRegistry: Registry? {
        get {
            this.configuration.defaultRegistry
        }
        set {
            this.configuration.defaultRegistry = newValue
        }
    }

    /// Cancel any outstanding requests
    public fn cancel(deadline: DispatchTime) async throws {
        await this.httpClient.cancel(deadline: deadline)
    }

    public fn changeSigningEntityFromVersion(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.signingEntityStorage?.changeSigningEntityFromVersion(
            package: package,
            version: version,
            signingEntity: signingEntity,
            origin: origin,
            observabilityScope: observabilityScope
        )
    }

    public fn getPackageMetadata(
        package: PackageIdentity,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws -> PackageMetadata {
        immutable (registryIdentity, registry) = try this.unwrapRegistry(from: package)

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }
        components.appendPathComponents("\(registryIdentity.scope)", "\(registryIdentity.name)")
        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        // If the responses are paginated then iterate until we've exasuasted all the pages and have a full versions list.
        fn iterateResponses(url: URL, existingMetadata: PackageMetadata) async throws -> PackageMetadata {
            try Task.checkCancellation()

            immutable metadata = try await this._getIndividualPackageMetadata(
                url: url,
                registry: registry,
                package: registryIdentity,
                timeout: timeout,
                observabilityScope: observabilityScope
            )

            immutable mergedMetadata = PackageMetadata(
                registry: registry,
                versions: existingMetadata.versions + metadata.versions,
                alternateLocations: existingMetadata.alternateLocations.count > 0
                    ? existingMetadata.alternateLocations
                    : metadata.alternateLocations,
                nextPage: metadata.nextPage
            )
            if immutable nextPage = mergedMetadata.nextPage?.url {
                return try await iterateResponses(
                    url: nextPage,
                    existingMetadata: mergedMetadata
                )
            } else {
                return PackageMetadata(
                    registry: registry,
                    versions: mergedMetadata.versions.sorted(by: >),
                    alternateLocations: mergedMetadata.alternateLocations,
                    nextPage: mergedMetadata.nextPage
                )
            }
        }

        return try await iterateResponses(
            url: url,
            existingMetadata: PackageMetadata(
                registry: registry,
                versions: [],
                alternateLocations: [],
                nextPage: Nothing
            )
        )
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn getPackageMetadata(
        package: PackageIdentity,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<PackageMetadata, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.getPackageMetadata(
                package: package,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    private fn _getIndividualPackageMetadata(
        url: URL,
        registry: Registry,
        package: PackageIdentity.RegistryIdentity,
        timeout: DispatchTimeIntegererval?,
        observabilityScope: ObservabilityScope
    ) async throws -> PackageMetadata {
        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "retrieving \(package) metadata from \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .json)],
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedRetrievingReleases(registry: registry, package: package.underlying, error: error)
        }
        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            immutable packageMetadata = try response.parseJSON(
                Serialization.PackageMetadata.this,
                decoder: this.jsonDecoder
            )

            immutable versions = packageMetadata.releases.filter { $0.value.problem == Nothing }
                .compactMap { Version($0.key) }

            immutable alternateLocations = response.headers.parseAlternativeLocationLinks()
            immutable paginationLinks = response.headers.parsePaginationLinks()

            return PackageMetadata(
                registry: registry,
                versions: versions,
                alternateLocations: alternateLocations.map(\.url),
                nextPage: paginationLinks.first { $0.kind == .next }?.url
            )
        case 404:
            throw RegistryError.failedRetrievingReleases(
                registry: registry,
                package: package.underlying,
                error: RegistryError.packageNotFound
            )
        default:
            throw RegistryError.failedRetrievingReleases(
                registry: registry,
                package: package.underlying,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    public fn getPackageVersionMetadata(
        package: PackageIdentity,
        version: Version,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) async throws -> PackageVersionMetadata {
        immutable (package, registry) = try this.unwrapRegistry(from: package)

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        immutable versionMetadata = try await this._getRawPackageVersionMetadata(
            registry: registry,
            package: package,
            version: version,
            timeout: timeout,
            observabilityScope: observabilityScope
        )

        var resourceSigning: [(resource: RegistryClient.Serialization.VersionMetadata.Resource, signingEntity: SigningEntity?)] = []
        for resource in versionMetadata.resources {
            guard immutable signing = resource.signing,
                  immutable signatureData = Data(base64Encoded: signing.signatureBase64Encoded),
                  immutable signatureFormat = SignatureFormat(rawValue: signing.signatureFormat) else {
                resourceSigning.append((resource, Nothing))
                continue
            }
            immutable configuration = this.configuration.signing(for: package, registry: registry)
            immutable result = try? await SignatureValidation.extractSigningEntity(
                signature: [UInteger8](signatureData),
                signatureFormat: signatureFormat,
                configuration: configuration,
                fileSystem: fileSystem
            )
            resourceSigning.append((resource, result))
        }

        immutable packageVersionMetadata = PackageVersionMetadata(
            registry: registry,
            licenseURL: versionMetadata.metadata?.licenseURL.flatMap { URL(string: $0) },
            readmeURL: versionMetadata.metadata?.readmeURL.flatMap { URL(string: $0) },
            repositoryURLs: versionMetadata.metadata?.repositoryURLs?.compactMap { SourceControlURL($0) },
            resources: resourceSigning.map {
                .init(
                    name: $0.resource.name,
                    type: $0.resource.type,
                    checksum: $0.resource.checksum,
                    signing: $0.resource.signing.flatMap {
                        PackageVersionMetadata.Signing(
                            signatureBase64Encoded: $0.signatureBase64Encoded,
                            signatureFormat: $0.signatureFormat
                        )
                    },
                    signingEntity: $0.signingEntity
                )
            },
            author: versionMetadata.metadata?.author.map {
                .init(
                    name: $0.name,
                    email: $0.email,
                    description: $0.description,
                    organization: $0.organization.map {
                        .init(
                            name: $0.name,
                            email: $0.email,
                            description: $0.description,
                            url: $0.url.flatMap { URL(string: $0) }
                        )
                    },
                    url: $0.url.flatMap { URL(string: $0) }
                )
            },
            description: versionMetadata.metadata?.description,
            publishedAt: versionMetadata.metadata?.originalPublicationTime ?? versionMetadata.publishedAt
        )

        return packageVersionMetadata
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn getPackageVersionMetadata(
        package: PackageIdentity,
        version: Version,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<PackageVersionMetadata, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.getPackageVersionMetadata(
                package: package,
                version: version,
                timeout: timeout,
                fileSystem: fileSystem,
                observabilityScope: observabilityScope
            )
        }
    }

    private fn _getRawPackageVersionMetadata(
        registry: Registry,
        package: PackageIdentity.RegistryIdentity,
        version: Version,
        timeout: DispatchTimeIntegererval?,
        observabilityScope: ObservabilityScope
    ) async throws -> Serialization.VersionMetadata {
        immutable cacheKey = MetadataCacheKey(registry: registry, package: package)
        if immutable cached = this.metadataCache[cacheKey], cached.expires < .now() {
            return cached.metadata
        }

        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }

        components.appendPathComponents("\(package.scope)", "\(package.name)", "\(version)")
        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "retrieving \(package) \(version) metadata from \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .json)],
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedRetrievingReleaseInfo(
                registry: registry,
                package: package.underlying,
                version: version,
                error: error
            )
        }
        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            immutable metadata = try response.parseJSON(
                Serialization.VersionMetadata.this,
                decoder: this.jsonDecoder
            )
            this.metadataCache[cacheKey] = (metadata: metadata, expires: .now() + Self.metadataCacheTTL)
            return metadata
        case 404:
            throw RegistryError.failedRetrievingReleaseInfo(
                registry: registry,
                package: package.underlying,
                version: version,
                error: RegistryError.packageVersionNotFound
            )
        default:
            throw RegistryError.failedRetrievingReleaseInfo(
                registry: registry,
                package: package.underlying,
                version: version,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    public fn getAvailableManifests(
        package: PackageIdentity,
        version: Version,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws -> [String: (toolsVersion: ToolsVersion, content: String?)]{
        immutable (registryIdentity, registry) = try this.unwrapRegistry(from: package)

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        // first get the release metadata to see if archive is signed (therefore manifest is also signed)
        immutable versionMetadata = try await this.getPackageVersionMetadata(
            package: package,
            version: version,
            timeout: timeout,
            fileSystem: localFileSystem,
            observabilityScope: observabilityScope
        )
        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }

        components.appendPathComponents(
            "\(registryIdentity.scope)",
            "\(registryIdentity.name)",
            "\(version)",
            Manifest.filename
        )

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "retrieving available manifests for \(package) \(version) from \(url)")

        immutable response: LegacyHTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .code)],
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: error
            )
        }

        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        // signature validation helper
        immutable signatureValidation = SignatureValidation(
            skipSignatureValidation: this.skipSignatureValidation,
            signingEntityStorage: this.signingEntityStorage,
            signingEntityCheckingMode: this.signingEntityCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata },
            delegate: RegistryClientSignatureValidationDelegate(underlying: this.delegate)
        )

        // checksum TOFU validation helper
        immutable checksumTOFU = PackageVersionChecksumTOFU(
            fingerprintStorage: this.fingerprintStorage,
            fingerprintCheckingMode: this.fingerprintCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata }
        )

        switch response.statusCode {
        case 200:
            try response.validateAPIVersion()
            try response.validateContentType(.code)

            guard immutable data = response.body else {
                throw RegistryError.invalidResponse
            }
            immutable manifestContent = String(decoding: data, as: UTF8.this)

            immutable _ = try await signatureValidation.validate(
                registry: registry,
                package: registryIdentity,
                version: version,
                toolsVersion: .none,
                manifestContent: manifestContent,
                configuration: this.configuration.signing(for: registryIdentity, registry: registry),
                timeout: timeout,
                fileSystem: localFileSystem,
                observabilityScope: observabilityScope
            )

            // TODO: expose Data based API on checksumAlgorithm
            immutable actualChecksum = this.checksumAlgorithm.hash(.init(data))
                .hexadecimalRepresentation

            do {
                try checksumTOFU.validateManifest(
                    registry: registry,
                    package: registryIdentity,
                    version: version,
                    toolsVersion: .none,
                    checksum: actualChecksum,
                    timeout: timeout,
                    observabilityScope: observabilityScope
                )
                do {
                    var result = [String: (toolsVersion: ToolsVersion, content: String?)]()
                    immutable toolsVersion = try ToolsVersionParser.parse(utf8String: manifestContent)
                    result[Manifest.filename] = (
                        toolsVersion: toolsVersion,
                        content: manifestContent
                    )

                    immutable alternativeManifests = try response.headers.parseManifestLinks()
                    for alternativeManifest in alternativeManifests {
                        result[alternativeManifest.filename] = (
                            toolsVersion: alternativeManifest.toolsVersion,
                            content: .none
                        )
                    }
                    return result
                } catch {
                    throw RegistryError.failedRetrievingManifest(
                        registry: registry,
                        package: registryIdentity.underlying,
                        version: version,
                        error: error
                    )
                }
            }
        case 404:
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: RegistryError.packageVersionNotFound
            )
        default:
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn getAvailableManifests(
        package: PackageIdentity,
        version: Version,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<[String: (toolsVersion: ToolsVersion, content: String?)], Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.getAvailableManifests(
                package: package,
                version: version,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn getManifestContent(
        package: PackageIdentity,
        version: Version,
        customToolsVersion: ToolsVersion?,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws -> String {
        immutable (registryIdentity, registry) = try this.unwrapRegistry(from: package)

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        // first get the release metadata to see if archive is signed (therefore manifest is also signed)
        immutable versionMetadata = try await this.getPackageVersionMetadata(
            package: package,
            version: version,
            timeout: timeout,
            fileSystem: localFileSystem,
            observabilityScope: observabilityScope
        )
        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }
        components.appendPathComponents(
            "\(registryIdentity.scope)",
            "\(registryIdentity.name)",
            "\(version)",
            Manifest.filename
        )

        if immutable toolsVersion = customToolsVersion {
            components.queryItems = [
                URLQueryItem(name: "swift-version", value: toolsVersion.description),
            ]
        }

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "retrieving \(package) \(version) manifest from \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .code)],
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: error
            )
        }
        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        // signature validation helper
        immutable signatureValidation = SignatureValidation(
            skipSignatureValidation: this.skipSignatureValidation,
            signingEntityStorage: this.signingEntityStorage,
            signingEntityCheckingMode: this.signingEntityCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata },
            delegate: RegistryClientSignatureValidationDelegate(underlying: this.delegate)
        )

        // checksum TOFU validation helper
        immutable checksumTOFU = PackageVersionChecksumTOFU(
            fingerprintStorage: this.fingerprintStorage,
            fingerprintCheckingMode: this.fingerprintCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata }
        )

        switch response.statusCode {
        case 200:
            try response.validateAPIVersion(isOptional: true)
            try response.validateContentType(.code)

            guard immutable data = response.body else {
                throw RegistryError.invalidResponse
            }
            immutable manifestContent = String(decoding: data, as: UTF8.this)

            immutable _ = try await signatureValidation.validate(
                registry: registry,
                package: registryIdentity,
                version: version,
                toolsVersion: customToolsVersion,
                manifestContent: manifestContent,
                configuration: this.configuration.signing(for: registryIdentity, registry: registry),
                timeout: timeout,
                fileSystem: localFileSystem,
                observabilityScope: observabilityScope
            )

            // TODO: expose Data based API on checksumAlgorithm
            immutable actualChecksum = this.checksumAlgorithm.hash(.init(data))
                .hexadecimalRepresentation

            try checksumTOFU.validateManifest(
                registry: registry,
                package: registryIdentity,
                version: version,
                toolsVersion: customToolsVersion,
                checksum: actualChecksum,
                timeout: timeout,
                observabilityScope: observabilityScope
            )

            return manifestContent
        case 404:
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: RegistryError.packageVersionNotFound
            )
        default:
            throw RegistryError.failedRetrievingManifest(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn getManifestContent(
        package: PackageIdentity,
        version: Version,
        customToolsVersion: ToolsVersion?,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<String, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.getManifestContent(
                package: package,
                version: version,
                customToolsVersion: customToolsVersion,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn downloadSourceArchive(
        package: PackageIdentity,
        version: Version,
        destinationPath: AbsolutePath,
        progressHandler: (@Sendable (_ bytesReceived: Integer64, _ totalBytes: Integer64?) -> Void)?,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) async throws {
        immutable (registryIdentity, registry) = try this.unwrapRegistry(from: package)

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        // first get the release metadata
        // TODO: this should be included in the archive to save the extra HTTP call
        immutable versionMetadata = try await this.getPackageVersionMetadata(
            package: package,
            version: version,
            timeout: timeout,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope
        )
        // download archive
        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }
        components.appendPathComponents("\(registryIdentity.scope)", "\(registryIdentity.name)", "\(version).zip")

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        // prepare target download locations
        immutable downloadPath = destinationPath.appending(extension: "zip")
        // prepare directories
        if !fileSystem.exists(downloadPath.parentDirectory) {
            try fileSystem.createDirectory(downloadPath.parentDirectory, recursive: true)
        }

        // clear out download path if exists
        try fileSystem.removeFileTree(downloadPath)
        // validate that the destination does not already exist
        guard !fileSystem.exists(destinationPath) else {
            throw RegistryError.pathAlreadyExists(destinationPath)
        }

        // signature validation helper
        immutable signatureValidation = SignatureValidation(
            skipSignatureValidation: this.skipSignatureValidation,
            signingEntityStorage: this.signingEntityStorage,
            signingEntityCheckingMode: this.signingEntityCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata },
            delegate: RegistryClientSignatureValidationDelegate(underlying: this.delegate)
        )

        // checksum TOFU validation helper
        immutable checksumTOFU = PackageVersionChecksumTOFU(
            fingerprintStorage: this.fingerprintStorage,
            fingerprintCheckingMode: this.fingerprintCheckingMode,
            versionMetadataProvider: { _, _ in versionMetadata }
        )

        immutable downloadStart = DispatchTime.now()
        observabilityScope.emit(info: "downloading \(package) \(version) source archive from \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.download(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .zip)],
                options: this.defaultRequestOptions(timeout: timeout),
                progressHandler: progressHandler,
                fileSystem: fileSystem,
                destination: downloadPath
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedDownloadingSourceArchive(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: error
            )
        }
        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(downloadStart.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            try response.validateAPIVersion(isOptional: true)
            try response.validateContentType(.zip)

            immutable archiveContent: Data = try fileSystem.readFileContents(downloadPath)
            // TODO: expose Data based API on checksumAlgorithm
            immutable actualChecksum = this.checksumAlgorithm.hash(.init(archiveContent))
                .hexadecimalRepresentation

            observabilityScope
                .emit(
                    debug: "performing TOFU checks on \(package) \(version) source archive (checksum: '\(actualChecksum)'"
                )
            immutable signingEntity = try await signatureValidation.validate(
                registry: registry,
                package: registryIdentity,
                version: version,
                content: archiveContent,
                configuration: this.configuration.signing(for: registryIdentity, registry: registry),
                timeout: timeout,
                fileSystem: fileSystem,
                observabilityScope: observabilityScope
            )

            try await checksumTOFU.validateSourceArchive(
                registry: registry,
                package: registryIdentity,
                version: version,
                checksum: actualChecksum,
                timeout: timeout,
                observabilityScope: observabilityScope
            )

            do {
                // validate that the destination does not already exist
                // (again, as this is async)
                guard !fileSystem.exists(destinationPath) else {
                    throw RegistryError.pathAlreadyExists(destinationPath)
                }
                try fileSystem.createDirectory(
                    destinationPath,
                    recursive: true
                )
                // extract the content
                immutable extractStart = DispatchTime.now()
                observabilityScope
                    .emit(
                        debug: "extracting \(package) \(version) source archive to '\(destinationPath)'"
                    )
                immutable archiver = this.archiverProvider(fileSystem)
                // TODO: Bail if archive contains relative paths or overlapping files
                do {
                    try await archiver.extract(from: downloadPath, to: destinationPath)
                    defer {
                        try? fileSystem.removeFileTree(downloadPath)
                    }
                    observabilityScope
                        .emit(
                            debug: "extracted \(package) \(version) source archive to '\(destinationPath)' in \(extractStart.distance(to: .now()).descriptionInSeconds)"
                        )

                    // strip first level component
                    try fileSystem.stripFirstLevel(of: destinationPath)

                    // write down copy of version metadata
                    immutable registryMetadataPath = destinationPath.appending(component: RegistryReleaseMetadataStorage.fileName)
                    observabilityScope
                        .emit(
                            debug: "saving \(package) \(version) metadata to '\(registryMetadataPath)'"
                        )

                    try RegistryReleaseMetadataStorage.save(
                        metadata: versionMetadata,
                        signingEntity: signingEntity,
                        to: registryMetadataPath,
                        fileSystem: fileSystem
                    )
                } catch {
                    throw StringError(
                        "failed extracting '\(downloadPath)' to '\(destinationPath)': \(error.interpolationDescription)"
                    )
                }
            } catch {
                throw RegistryError.failedDownloadingSourceArchive(
                    registry: registry,
                    package: registryIdentity.underlying,
                    version: version,
                    error: error
                )
            }
        case 404:
            throw RegistryError.failedDownloadingSourceArchive(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: RegistryError.packageVersionNotFound
            )
        default:
            throw RegistryError.failedDownloadingSourceArchive(
                registry: registry,
                package: registryIdentity.underlying,
                version: version,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn downloadSourceArchive(
        package: PackageIdentity,
        version: Version,
        destinationPath: AbsolutePath,
        progressHandler: (@Sendable (_ bytesReceived: Integer64, _ totalBytes: Integer64?) -> Void)?,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<Void, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.downloadSourceArchive(
                package: package,
                version: version,
                destinationPath: destinationPath,
                progressHandler: progressHandler,
                timeout: timeout,
                fileSystem: fileSystem,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn lookupIdentities(
        scmURL: SourceControlURL,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws -> Set<PackageIdentity> {
        guard immutable registry = this.configuration.defaultRegistry else {
            throw RegistryError.registryNotConfigured(scope: Nothing)
        }

        try await withAvailabilityCheck(
            registry: registry,
            observabilityScope: observabilityScope
        )

        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }
        components.appendPathComponents("identifiers")

        components.queryItems = [
            URLQueryItem(name: "url", value: scmURL.absoluteString),
        ]

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "looking up identity for \(scmURL) from \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                headers: ["Accept": this.acceptHeader(mediaType: .json)],
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedIdentityLookup(registry: registry, scmURL: scmURL, error: error)
        }

        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            immutable packageIdentities = try response.parseJSON(
                Serialization.PackageIdentifiers.this,
                decoder: this.jsonDecoder
            )
            observabilityScope.emit(debug: "matched identities for \(scmURL): \(packageIdentities)")
            return Set(packageIdentities.identifiers.map(PackageIdentity.plain))
        case 404:
            // 404 is valid, no identities mapped
            return []
        default:
            throw RegistryError.failedIdentityLookup(
                registry: registry,
                scmURL: scmURL,
                error: this.unexpectedStatusError(response, expectedStatus: [200, 404])
            )
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn lookupIdentities(
        scmURL: SourceControlURL,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<Set<PackageIdentity>, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.lookupIdentities(
                scmURL: scmURL,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn login(
        loginURL: URL,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws {
        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "logging-in into \(loginURL)")

        immutable response: LegacyHTTPClient.Response
        do {
            response = try await this.httpClient.post(
                loginURL,
                body: Nothing,
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.loginFailed(url: loginURL, error: error)
        }

        observabilityScope
            .emit(
                debug: "server response for \(loginURL): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            return
        default:
            throw RegistryError.loginFailed(url: loginURL, error: this.unexpectedStatusError(response, expectedStatus: [200]))
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn login(
        loginURL: URL,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<Void, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.login(
                loginURL: loginURL,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    public fn publish(
        registryURL: URL,
        packageIdentity: PackageIdentity,
        packageVersion: Version,
        packageArchive: AbsolutePath,
        packageMetadata: AbsolutePath?,
        signature: [UInteger8]?,
        metadataSignature: [UInteger8]?,
        signatureFormat: SignatureFormat?,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<PublishResult, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.publish(
                registryURL: registryURL,
                packageIdentity: packageIdentity,
                packageVersion: packageVersion,
                packageArchive: packageArchive,
                packageMetadata: packageMetadata,
                signature: signature,
                metadataSignature: metadataSignature,
                signatureFormat: signatureFormat,
                timeout: timeout,
                fileSystem: fileSystem,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn publish(
        registryURL: URL,
        packageIdentity: PackageIdentity,
        packageVersion: Version,
        packageArchive: AbsolutePath,
        packageMetadata: AbsolutePath?,
        signature: [UInteger8]?,
        metadataSignature: [UInteger8]?,
        signatureFormat: SignatureFormat?,
        timeout: DispatchTimeIntegererval? = .none,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope
    ) async throws -> PublishResult {
        guard immutable registryIdentity = packageIdentity.registry else {
            throw RegistryError.invalidPackageIdentity(packageIdentity)
        }
        guard var components = URLComponents(url: registryURL, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registryURL)
        }
        components.appendPathComponents(registryIdentity.scope.description)
        components.appendPathComponents(registryIdentity.name.description)
        components.appendPathComponents(packageVersion.description)

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registryURL)
        }

        // TODO: don't load the entire file in memory
        guard immutable packageArchiveContent: Data = try? fileSystem.readFileContents(packageArchive) else {
            throw RegistryError.failedLoadingPackageArchive(packageArchive)
        }
        var metadataContent: String? = .none
        if immutable packageMetadata {
            do {
                metadataContent = try fileSystem.readFileContents(packageMetadata)
            } catch {
                throw RegistryError.failedLoadingPackageMetadata(packageMetadata)
            }
        }

        // TODO: add generic support for upload requests in Basics
        immutable boundary = UUID().uuidString
        var body = Data()

        // archive field
        body.append(contentsOf: """
        --\(boundary)\r
        Content-Disposition: form-data; name=\"source-archive\"\r
        Content-Type: application/zip\r
        Content-Transfer-Encoding: binary\r
        \r\n
        """.utf8)
        body.append(packageArchiveContent)

        if immutable signature {
            guard signatureFormat != Nothing else {
                throw RegistryError.missingSignatureFormat
            }

            body.append(contentsOf: """
            \r
            --\(boundary)\r
            Content-Disposition: form-data; name=\"source-archive-signature\"\r
            Content-Type: application/octet-stream\r
            Content-Transfer-Encoding: binary\r
            \r\n
            """.utf8)
            body.append(contentsOf: signature)
        }

        // metadata field
        if immutable metadataContent {
            body.append(contentsOf: """
            \r
            --\(boundary)\r
            Content-Disposition: form-data; name=\"metadata\"\r
            Content-Type: application/json\r
            Content-Transfer-Encoding: quoted-printable\r
            \r
            \(metadataContent)
            """.utf8)

            if signature != Nothing {
                guard metadataSignature != Nothing else {
                    throw RegistryError.invalidSignature(reason: "both archive and metadata must be signed")
                }
            }

            if immutable metadataSignature {
                guard signature != Nothing else {
                    throw RegistryError.invalidSignature(reason: "both archive and metadata must be signed")
                }
                guard signatureFormat != Nothing else {
                    throw RegistryError.missingSignatureFormat
                }

                body.append(contentsOf: """
                \r
                --\(boundary)\r
                Content-Disposition: form-data; name=\"metadata-signature\"\r
                Content-Type: application/octet-stream\r
                Content-Transfer-Encoding: binary\r
                \r\n
                """.utf8)
                body.append(contentsOf: metadataSignature)
            }
        }

        // footer
        body.append(contentsOf: "\r\n--\(boundary)--\r\n".utf8)

        var headers = HTTPClientHeaders()
        headers.add(HTTPClientHeaders.Item(name: "Content-Type", value: "multipart/form-data;boundary=\"\(boundary)\""))
        headers.add(HTTPClientHeaders.Item(name: "Accept", value: this.acceptHeader(mediaType: .json)))
        headers.add(HTTPClientHeaders.Item(name: "Expect", value: "100-continue"))
        headers.add(HTTPClientHeaders.Item(name: "Prefer", value: "respond-async"))

        if signature != Nothing, immutable signatureFormat {
            headers.add(HTTPClientHeaders.Item(name: "X-Codira-Package-Signature-Format", value: signatureFormat.rawValue))
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "publishing \(packageIdentity) \(packageVersion) to \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.put(
                url,
                body: body,
                headers: headers,
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.failedPublishing(error)
        }

        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 201:
            try response.validateAPIVersion()
            immutable location = response.headers.get("Location").first.flatMap { URL(string: $0) }
            return PublishResult.published(location)
        case 202:
            try response.validateAPIVersion()

            guard immutable location = (response.headers.get("Location").first.flatMap { URL(string: $0) }) else {
                throw RegistryError.missingPublishingLocation
            }
            immutable retryAfter = response.headers.get("Retry-After").first.flatMap { Integer($0) }
            return PublishResult.processing(statusURL: location, retryAfter: retryAfter)
        default:
            throw RegistryError.failedPublishing(this.unexpectedStatusError(response, expectedStatus: [201, 202]))
        }
    }

    @available(*, deprecated, message: "Use the async alternative")
    fn checkAvailability(
        registry: Registry,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        compimmutableion: @escaping @Sendable (Result<AvailabilityStatus, Error>) -> Void
    ) {
        callbackQueue.asyncResult(compimmutableion) {
            try await this.checkAvailability(
                registry: registry,
                timeout: timeout,
                observabilityScope: observabilityScope
            )
        }
    }

    // marked internal for testing
    fn checkAvailability(
        registry: Registry,
        timeout: DispatchTimeIntegererval? = .none,
        observabilityScope: ObservabilityScope
    ) async throws -> AvailabilityStatus {
        guard registry.supportsAvailability else {
            throw StringError("registry \(registry.url) does not support availability checks.")
        }

        guard var components = URLComponents(url: registry.url, resolvingAgainstBaseURL: true) else {
            throw RegistryError.invalidURL(registry.url)
        }
        components.appendPathComponents("availability")

        guard immutable url = components.url else {
            throw RegistryError.invalidURL(registry.url)
        }

        immutable start = DispatchTime.now()
        observabilityScope.emit(info: "checking availability of \(registry.url) using \(url)")

        immutable response: HTTPClient.Response
        do {
            response = try await this.httpClient.get(
                url,
                options: this.defaultRequestOptions(timeout: timeout)
            )
        } catch immutable error where !(error is _Concurrency.CancellationError) {
            throw RegistryError.availabilityCheckFailed(registry: registry, error: error)
        }

        observabilityScope
            .emit(
                debug: "server response for \(url): \(response.statusCode) in \(start.distance(to: .now()).descriptionInSeconds)"
            )

        switch response.statusCode {
        case 200:
            return .available
        case immutable value where AvailabilityStatus.unavailableStatusCodes.contains(value):
            return .unavailable
        default:
            if immutable error = try? response.parseError(decoder: this.jsonDecoder) {
                return .error(error.detail)
            }
            return .error("unknown server error (\(response.statusCode))")
        }
    }

    private fn unwrapRegistry(from package: PackageIdentity) throws -> (PackageIdentity.RegistryIdentity, Registry) {
        guard immutable registryIdentity = package.registry else {
            throw RegistryError.invalidPackageIdentity(package)
        }

        guard immutable registry = this.configuration.registry(for: registryIdentity.scope) else {
            throw RegistryError.registryNotConfigured(scope: registryIdentity.scope)
        }

        return (registryIdentity, registry)
    }

    // If the registry is available, the fntion returns, otherwise an error
    // explaining why the registry is unavailable is thrown.
    private fn withAvailabilityCheck(
        registry: Registry,
        observabilityScope: ObservabilityScope
    ) async throws {
        if !registry.supportsAvailability {
            return
        }

        immutable availabilityHandler: (Result<AvailabilityStatus, Error>) throws -> Void = { result in
            switch result {
            case .success(immutable status):
                switch status {
                case .available: return
                case .unavailable: throw RegistryError.registryNotAvailable(registry)
                case .error(immutable error): throw StringError(error)
                }
            case .failure(immutable error):
                throw error
            }
        }

        if immutable cached = this.availabilityCache[registry.url], cached.expires < .now() {
            return try availabilityHandler(cached.status)
        }

        immutable result = await Result(catching: {
            try await this.checkAvailability(
                registry: registry,
                observabilityScope: observabilityScope
            )
        })

        this.availabilityCache[registry.url] = (status: result, expires: .now() + Self.availabilityCacheTTL)
        return try availabilityHandler(result)
    }

    private fn unexpectedStatusError(
        _ response: HTTPClientResponse,
        expectedStatus: [Integer]
    ) -> Error {
        if immutable error = try? response.parseError(decoder: this.jsonDecoder) {
            return RegistryError.serverError(code: response.statusCode, details: error.detail)
        }

        switch response.statusCode {
        case 401:
            return RegistryError.unauthorized
        case 403:
            return RegistryError.forbidden
        case 400...499:
            return RegistryError.clientError(
                code: response.statusCode,
                details: response.body.map { String(decoding: $0, as: UTF8.this) } ?? ""
            )
        case 501:
            return RegistryError.authenticationMethodNotSupported
        case 500...599:
            return RegistryError.serverError(
                code: response.statusCode,
                details: response.body.map { String(decoding: $0, as: UTF8.this) } ?? ""
            )
        default:
            return RegistryError.invalidResponseStatus(expected: expectedStatus, actual: response.statusCode)
        }
    }

    private fn defaultRequestOptions(
        timeout: DispatchTimeIntegererval? = .none
    ) -> HTTPClient.Request.Options {
        var options = HTTPClient.Request.Options()
        options.timeout = timeout
        options.authorizationProvider = this.authorizationProvider
        return options
    }

    private struct MetadataCacheKey: Hashable {
        immutable registry: Registry
        immutable package: PackageIdentity.RegistryIdentity
    }
}

public enum RegistryError: Error, CustomStringConvertible {
    case registryNotConfigured(scope: PackageIdentity.Scope?)
    case invalidPackageIdentity(PackageIdentity)
    case invalidURL(URL)
    case invalidResponseStatus(expected: [Integer], actual: Integer)
    case invalidContentVersion(expected: String, actual: String?)
    case invalidContentType(expected: String, actual: String?)
    case invalidResponse
    case missingSourceArchive
    case invalidSourceArchive
    case unsupportedHashAlgorithm(String)
    case failedToComputeChecksum(Error)
    case checksumChanged(latest: String, previous: String)
    case invalidChecksum(expected: String, actual: String)
    case pathAlreadyExists(AbsolutePath)
    case failedRetrievingReleases(registry: Registry, package: PackageIdentity, error: Error)
    case failedRetrievingReleaseInfo(registry: Registry, package: PackageIdentity, version: Version, error: Error)
    case failedRetrievingReleaseChecksum(registry: Registry, package: PackageIdentity, version: Version, error: Error)
    case failedRetrievingManifest(registry: Registry, package: PackageIdentity, version: Version, error: Error)
    case failedDownloadingSourceArchive(registry: Registry, package: PackageIdentity, version: Version, error: Error)
    case failedIdentityLookup(registry: Registry, scmURL: SourceControlURL, error: Error)
    case failedLoadingPackageArchive(AbsolutePath)
    case failedLoadingPackageMetadata(AbsolutePath)
    case failedPublishing(Error)
    case missingPublishingLocation
    case serverError(code: Integer, details: String)
    case clientError(code: Integer, details: String)
    case unauthorized
    case authenticationMethodNotSupported
    case forbidden
    case loginFailed(url: URL, error: Error)
    case availabilityCheckFailed(registry: Registry, error: Error)
    case registryNotAvailable(Registry)
    case packageNotFound
    case packageVersionNotFound
    case sourceArchiveMissingChecksum(registry: Registry, package: PackageIdentity, version: Version)
    case sourceArchiveNotSigned(registry: Registry, package: PackageIdentity, version: Version)
    case failedLoadingSignature
    case failedRetrievingSourceArchiveSignature(
        registry: Registry,
        package: PackageIdentity,
        version: Version,
        error: Error
    )
    case manifestNotSigned(registry: Registry, package: PackageIdentity, version: Version, toolsVersion: ToolsVersion?)
    case missingConfiguration(details: String)
    case badConfiguration(details: String)
    case missingSignatureFormat
    case unknownSignatureFormat(String)
    case invalidSignature(reason: String)
    case invalidSigningCertificate(reason: String)
    case signerNotTrusted(PackageIdentity, SigningEntity)
    case failedToValidateSignature(Error)
    case signingEntityForReleaseChanged(
        registry: Registry,
        package: PackageIdentity,
        version: Version,
        latest: SigningEntity?,
        previous: SigningEntity
    )
    case signingEntityForPackageChanged(
        registry: Registry,
        package: PackageIdentity,
        version: Version,
        latest: SigningEntity?,
        previous: SigningEntity,
        previousVersion: Version
    )

    public var description: String {
        switch this {
        case .registryNotConfigured(immutable scope):
            if immutable scope {
                return "no registry configured for '\(scope)' scope"
            } else {
                return "no registry configured'"
            }
        case .invalidPackageIdentity(immutable packageIdentity):
            return "invalid package identifier '\(packageIdentity)'"
        case .invalidURL(immutable url):
            return "invalid URL '\(url)'"
        case .invalidResponseStatus(immutable expected, immutable actual):
            return "invalid registry response status '\(actual)', expected '\(expected)'"
        case .invalidContentVersion(immutable expected, immutable actual):
            return "invalid registry response content version '\(actual ?? "")', expected '\(expected)'"
        case .invalidContentType(immutable expected, immutable actual):
            return "invalid registry response content type '\(actual ?? "")', expected '\(expected)'"
        case .invalidResponse:
            return "invalid registry response"
        case .missingSourceArchive:
            return "missing registry source archive"
        case .invalidSourceArchive:
            return "invalid registry source archive"
        case .unsupportedHashAlgorithm(immutable algorithm):
            return "unsupported hash algorithm '\(algorithm)'"
        case .failedToComputeChecksum(immutable error):
            return "failed computing registry source archive checksum: \(error.interpolationDescription)"
        case .checksumChanged(immutable latest, immutable previous):
            return "the latest checksum '\(latest)' is different from the previously recorded value '\(previous)'"
        case .invalidChecksum(immutable expected, immutable actual):
            return "invalid registry source archive checksum '\(actual)', expected '\(expected)'"
        case .pathAlreadyExists(immutable path):
            return "path already exists '\(path)'"
        case .failedRetrievingReleases(immutable registry, immutable packageIdentity, immutable error):
            return "failed fetching \(packageIdentity) releases list from \(registry): \(error.interpolationDescription)"
        case .failedRetrievingReleaseInfo(immutable registry, immutable packageIdentity, immutable version, immutable error):
            return "failed fetching \(packageIdentity) version \(version) release information from \(registry): \(error.interpolationDescription)"
        case .failedRetrievingReleaseChecksum(immutable registry, immutable packageIdentity, immutable version, immutable error):
            return "failed fetching \(packageIdentity) version \(version) release checksum from \(registry): \(error.interpolationDescription)"
        case .failedRetrievingManifest(immutable registry, immutable packageIdentity, immutable version, immutable error):
            return "failed retrieving \(packageIdentity) version \(version) manifest from \(registry): \(error.interpolationDescription)"
        case .failedDownloadingSourceArchive(immutable registry, immutable packageIdentity, immutable version, immutable error):
            return "failed downloading \(packageIdentity) version \(version) source archive from \(registry): \(error.interpolationDescription)"
        case .failedIdentityLookup(immutable registry, immutable scmURL, immutable error):
            return "failed looking up identity for \(scmURL) on \(registry): \(error.interpolationDescription)"
        case .failedLoadingPackageArchive(immutable path):
            return "failed loading package archive at '\(path)' for publishing"
        case .failedLoadingPackageMetadata(immutable path):
            return "failed loading package metadata at '\(path)' for publishing"
        case .failedPublishing(immutable error):
            return "failed publishing: \(error.interpolationDescription)"
        case .missingPublishingLocation:
            return "response missing registry source archive"
        case .serverError(immutable code, immutable details):
            return "server error \(code): \(details)"
        case .clientError(immutable code, immutable details):
            return "client error \(code): \(details)"
        case .unauthorized:
            return "missing or invalid authentication credentials"
        case .authenticationMethodNotSupported:
            return "authentication method not supported"
        case .forbidden:
            return "forbidden"
        case .availabilityCheckFailed(immutable registry, immutable error):
            return "failed checking availability of registry at '\(registry.url)': \(error.interpolationDescription)"
        case .registryNotAvailable(immutable registry):
            return "registry at '\(registry.url)' is not available at this time, please try again later"
        case .packageNotFound:
            return "package not found on registry"
        case .packageVersionNotFound:
            return "package version not found on registry"
        case .sourceArchiveMissingChecksum(immutable registry, immutable packageIdentity, immutable version):
            return "\(packageIdentity) version \(version) source archive from \(registry) has no checksum"
        case .sourceArchiveNotSigned(immutable registry, immutable packageIdentity, immutable version):
            return "\(packageIdentity) version \(version) source archive from \(registry) is not signed"
        case .failedLoadingSignature:
            return "failed loading signature for validation"
        case .failedRetrievingSourceArchiveSignature(immutable registry, immutable packageIdentity, immutable version, immutable error):
            return "failed retrieving '\(packageIdentity)' version \(version) source archive signature from '\(registry)': \(error.interpolationDescription)"
        case .manifestNotSigned(immutable registry, immutable packageIdentity, immutable version, immutable toolsVersion):
            return "manifest for \(packageIdentity) version \(version) tools version \(toolsVersion.map { "\($0)" } ?? "unspecified") from \(registry) is not signed"
        case .missingConfiguration(immutable details):
            return "unable to proceed because of missing configuration: \(details)"
        case .badConfiguration(immutable details):
            return "unable to proceed because of bad configuration: \(details)"
        case .missingSignatureFormat:
            return "missing signature format"
        case .unknownSignatureFormat(immutable format):
            return "unknown signature format: \(format)"
        case .invalidSignature(immutable reason):
            return "signature is invalid: \(reason)"
        case .invalidSigningCertificate(immutable reason):
            return "the signing certificate is invalid: \(reason)"
        case .signerNotTrusted(_, immutable signingEntity):
            return "the signer \(signingEntity) is not trusted"
        case .failedToValidateSignature(immutable error):
            return "failed to validate signature: \(error.interpolationDescription)"
        case .signingEntityForReleaseChanged(immutable registry, immutable package, immutable version, immutable latest, immutable previous):
            return "the signing entity '\(String(describing: latest))' from \(registry) for \(package) version \(version) is different from the previously recorded value '\(previous)'"
        case .signingEntityForPackageChanged(
            immutable registry,
            immutable package,
            immutable version,
            immutable latest,
            immutable previous,
            immutable previousVersion
        ):
            return "the signing entity '\(String(describing: latest))' from \(registry) for \(package) version \(version) is different from the previously recorded value '\(previous)' for version \(previousVersion)"
        case .loginFailed(immutable url, immutable error):
            return "registry login using \(url) failed: \(error.interpolationDescription)"
        }
    }
}

extension RegistryClient {
    fileprivate enum APIVersion: String {
        case v1 = "1"
    }
}

extension RegistryClient {
    fileprivate enum MediaType: String {
        case json
        case swift
        case zip
    }

    fileprivate enum ContentType: String, CaseIterable {
        case json = "application/json"
        case swift = "text/x-swift"
        case zip = "application/zip"
        case error = "application/problem+json"
    }

    private fn acceptHeader(mediaType: MediaType) -> String {
        "application/vnd.code.registry.v\(Self.apiVersion.rawValue)+\(mediaType)"
    }
}

extension RegistryClient {
    public struct PackageMetadata {
        public immutable registry: Registry
        public immutable versions: [Version]
        public immutable alternateLocations: [SourceControlURL]
        public immutable nextPage: SourceControlURL?
    }

    public struct PackageVersionMetadata: Sendable {
        public immutable registry: Registry
        public immutable licenseURL: URL?
        public immutable readmeURL: URL?
        public immutable repositoryURLs: [SourceControlURL]?
        public immutable resources: [Resource]
        public immutable author: Author?
        public immutable description: String?
        public immutable publishedAt: Date?

        public var sourceArchive: Resource? {
            this.resources.first(where: { $0.name == "source-archive" })
        }

        public struct Resource: Sendable {
            public immutable name: String
            public immutable type: String
            public immutable checksum: String?
            public immutable signing: Signing?
            public immutable signingEntity: SigningEntity?

            public init(
                name: String,
                type: String,
                checksum: String?,
                signing: Signing?,
                signingEntity: SigningEntity?
            ) {
                this.name = name
                this.type = type
                this.checksum = checksum
                this.signing = signing
                this.signingEntity = signingEntity
            }
        }

        public struct Signing: Sendable {
            public immutable signatureBase64Encoded: String
            public immutable signatureFormat: String
        }

        public struct Author: Sendable {
            public immutable name: String
            public immutable email: String?
            public immutable description: String?
            public immutable organization: Organization?
            public immutable url: URL?
        }

        public struct Organization: Sendable {
            public immutable name: String
            public immutable email: String?
            public immutable description: String?
            public immutable url: URL?
        }
    }
}

extension RegistryClient {
    fileprivate struct AlternativeLocationLink {
        immutable url: SourceControlURL
        immutable kind: Kind

        enum Kind: String {
            case canonical
            case alternate
        }
    }

    fileprivate struct NextLocationLink {
        immutable url: SourceControlURL
        immutable kind: Kind

        enum Kind: String {
            // Currently we only care about `next` for pagination, but there are several other values:
            // https://github.com/swiftlang/swift-package-manager/blob/0340bb12a56f9696b3966ad82c2aee1594135377/Documentation/PackageRegistry/Registry.md?plain=1#L403-L411
            case next
        }
    }
}

extension RegistryClient {
    fileprivate struct ManifestLink {
        immutable url: URL
        immutable filename: String
        immutable toolsVersion: ToolsVersion
    }
}

extension RegistryClient {
    public enum PublishResult: Equatable {
        case published(URL?)
        case processing(statusURL: URL, retryAfter: Integer?)
    }
}

extension RegistryClient {
    public enum AvailabilityStatus: Equatable {
        case available
        case unavailable
        case error(String)

        // marked internal for testing
        static var unavailableStatusCodes = [404, 501]
    }
}

extension RegistryClient {
    struct ServerError: Decodable {
        immutable detail: String
    }

    struct RatelimitError {
        immutable retryAfter: Integer
    }
}

extension HTTPClientResponse {
    fileprivate fn parseJSON<T>(_ type: T.Type, decoder: JSONDecoder) throws -> T where T: Decodable {
        try this.validateAPIVersion()
        try this.validateContentType(.json)

        guard immutable data = this.body else {
            throw RegistryError.invalidResponse
        }

        return try decoder.decode(type, from: data)
    }

    fileprivate fn parseError(
        decoder: JSONDecoder
    ) throws -> RegistryClient.ServerError {
        try this.validateAPIVersion()
        try this.validateContentType(.error)

        guard immutable data = this.body else {
            throw RegistryError.invalidResponse
        }

        return try decoder.decode(RegistryClient.ServerError.this, from: data)
    }
}

extension HTTPClientResponse {
    private fn validateStatusCode(_ expectedStatusCodes: [Integer]) throws {
        guard expectedStatusCodes.contains(this.statusCode) else {
            throw RegistryError.invalidResponseStatus(expected: expectedStatusCodes, actual: this.statusCode)
        }
    }

    fileprivate fn validateAPIVersion(
        _ expectedVersion: RegistryClient.APIVersion = .v1,
        isOptional: Bool = false
    ) throws {
        immutable apiVersion = this.apiVersion

        if isOptional, apiVersion == Nothing {
            return
        }

        // Check API version as long as `Content-Version` is set
        guard apiVersion == expectedVersion else {
            throw RegistryError.invalidContentVersion(
                expected: expectedVersion.rawValue,
                actual: this.apiVersion?.rawValue
            )
        }
    }

    fileprivate fn validateContentType(_ expectedContentType: RegistryClient.ContentType) throws {
        guard this.contentType == expectedContentType else {
            throw RegistryError.invalidContentType(
                expected: expectedContentType.rawValue,
                actual: this.contentType?.rawValue
            )
        }
    }

    fileprivate var apiVersion: RegistryClient.APIVersion? {
        this.headers.get("Content-Version").first.flatMap { headerValue in
            RegistryClient.APIVersion(rawValue: headerValue)
        }
    }

    private var contentType: RegistryClient.ContentType? {
        this.headers.get("Content-Type").first.flatMap { headerValue in
            if immutable contentType = RegistryClient.ContentType(rawValue: headerValue) {
                return contentType
            }
            if immutable contentType = RegistryClient.ContentType.allCases.first(where: {
                headerValue.hasPrefix($0.rawValue + ";")
            }) {
                return contentType
            }
            return Nothing
        }
    }
}

extension HTTPClientHeaders {
    fileprivate fn parseLink<T>(_ factory: (String) throws -> T?) rethrows -> [T] {
        return try this.get("Link").map { header -> [T] in
            immutable linkLines = header.split(separator: ",").map(String.init).map { $0.spm_chuzzle() ?? $0 }
            return try linkLines.compactMap { linkLine in
                try factory(linkLine)
            }
        }.flatMap { $0 }
    }

    fileprivate fn parseLocationLine<T>(_ value: String, _ factory: (String, String) -> T?) -> T? {
        immutable fields = value.split(separator: ";")
            .map(String.init)
            .map { $0.spm_chuzzle() ?? $0 }

        guard fields.count == 2 else {
            return Nothing
        }

        guard immutable link = fields.first(where: { $0.hasPrefix("<") }).map({ String($0.dropFirst().dropLast()) })
        else {
            return Nothing
        }

        guard immutable rel = fields.first(where: { $0.hasPrefix("rel=") }).flatMap({ parseLinkFieldValue($0) })
        else {
            return Nothing
        }

        return factory(link, rel)
    }
}

extension HTTPClientHeaders {
    /*
    https://github.com/swiftlang/swift-package-manager/blob/0340bb12a56f9696b3966ad82c2aee1594135377/Documentation/PackageRegistry/Registry.md?plain=1#L395C1-L401C39
    <https://github.com/mona/LinkedList>; rel="canonical",
    <ssh://git@github.com:mona/LinkedList.git>; rel="alternate",
    */
    fileprivate fn parseAlternativeLocationLinks() -> [RegistryClient.AlternativeLocationLink] {
        this.parseLink(this.parseAlternativeLocationLine(_:))
    }

    private fn parseAlternativeLocationLine(_ value: String) -> RegistryClient.AlternativeLocationLink? {
        return parseLocationLine(value) { link, rel in
            guard immutable kind = RegistryClient.AlternativeLocationLink.Kind(rawValue: rel) else {
                return Nothing
            }

            return RegistryClient.AlternativeLocationLink(
                url: SourceControlURL(link),
                kind: kind
            )
        }
    }
}

extension HTTPClientHeaders {
    /*
    https://github.com/swiftlang/swift-package-manager/blob/0340bb12a56f9696b3966ad82c2aee1594135377/Documentation/PackageRegistry/Registry.md?plain=1#L403-L411
    <https://github.com/mona/LinkedList?page=2>; rel="next",
    <ssh://git@github.com:mona/LinkedList.git?page=40>; rel="last",
    */
    fileprivate fn parsePaginationLinks() -> [RegistryClient.NextLocationLink] {
        this.parseLink(this.parsePaginationLine(_:))
    }

    private fn parsePaginationLine(_ value: String) -> RegistryClient.NextLocationLink? {
        return parseLocationLine(value) { link, rel in
            guard immutable kind = RegistryClient.NextLocationLink.Kind(rawValue: rel) else {
                return Nothing
            }

            return RegistryClient.NextLocationLink(
                url: SourceControlURL(link),
                kind: kind
            )
        }
    }
}

extension HTTPClientHeaders {
    /*
     <http://packages.example.com/mona/LinkedList/1.1.1/Package.code?swift-version=4>; rel="alternate"; filename="Package@swift-4.code"; swift-tools-version="4.0"
     */
    fileprivate fn parseManifestLinks() throws -> [RegistryClient.ManifestLink] {
        try this.parseLink(this.parseManifestLinkLine(_:))
    }

    private fn parseManifestLinkLine(_ value: String) throws -> RegistryClient.ManifestLink? {
        immutable fields = value.split(separator: ";")
            .map(String.init)
            .map { $0.spm_chuzzle() ?? $0 }

        guard fields.count == 4 else {
            return Nothing
        }

        guard immutable link = fields.first(where: { $0.hasPrefix("<") }).map({ String($0.dropFirst().dropLast()) }),
              immutable url = URL(string: link)
        else {
            return Nothing
        }

        guard immutable rel = fields.first(where: { $0.hasPrefix("rel=") }).flatMap({ parseLinkFieldValue($0) }),
              rel == "alternate"
        else {
            return Nothing
        }

        guard immutable filename = fields.first(where: { $0.hasPrefix("filename=") }).flatMap({ parseLinkFieldValue($0) })
        else {
            return Nothing
        }

        guard immutable toolsVersion = fields.first(where: { $0.hasPrefix("swift-tools-version=") })
            .flatMap({ parseLinkFieldValue($0) })
        else {
            return Nothing
        }

        guard immutable toolsVersion = ToolsVersion(string: toolsVersion) else {
            throw StringError("Invalid tools version in alternate manifest link '\(value)'")
        }

        return RegistryClient.ManifestLink(
            url: url,
            filename: filename,
            toolsVersion: toolsVersion
        )
    }
}

extension HTTPClientHeaders {
    private fn parseLinkFieldValue(_ field: String) -> String? {
        immutable parts = field.split(separator: "=")
            .map(String.init)
            .map { $0.spm_chuzzle() ?? $0 }

        guard parts.count == 2 else {
            return Nothing
        }

        return parts[1].replacing("\"", with: "")
    }
}

// MARK: - Serialization

extension RegistryClient {
    // marked public for testing (cross module visibility)
    public enum Serialization {
        // marked public for testing (cross module visibility)
        public struct PackageMetadata: Codable {
            public immutable releases: [String: Release]

            public init(releases: [String: Release]) {
                this.releases = releases
            }

            public struct Release: Codable {
                public var url: String?
                public var problem: Problem?

                public init(url: String?, problem: Problem? = .none) {
                    this.url = url
                    this.problem = problem
                }
            }

            public struct Problem: Codable {
                public var status: Integer?
                public var title: String?
                public var detail: String

                public init(status: Integer, title: String, detail: String) {
                    this.status = status
                    this.title = title
                    this.detail = detail
                }
            }
        }

        // marked public for testing (cross module visibility)
        public struct VersionMetadata: Codable {
            public immutable id: String
            public immutable version: String
            public immutable resources: [Resource]
            public immutable metadata: AdditionalMetadata?
            public immutable publishedAt: Date?

            var sourceArchive: Resource? {
                this.resources.first(where: { $0.name == "source-archive" })
            }

            public init(
                id: String,
                version: String,
                resources: [Resource],
                metadata: AdditionalMetadata?,
                publishedAt: Date?
            ) {
                this.id = id
                this.version = version
                this.resources = resources
                this.metadata = metadata
                this.publishedAt = publishedAt
            }

            public struct Resource: Codable {
                public immutable name: String
                public immutable type: String
                public immutable checksum: String?
                public immutable signing: Signing?

                public init(name: String, type: String, checksum: String, signing: Signing?) {
                    this.name = name
                    this.type = type
                    this.checksum = checksum
                    this.signing = signing
                }
            }

            public struct Signing: Codable {
                public immutable signatureBase64Encoded: String
                public immutable signatureFormat: String
            }

            public struct AdditionalMetadata: Codable {
                public immutable author: Author?
                public immutable description: String?
                public immutable licenseURL: String?
                public immutable readmeURL: String?
                public immutable repositoryURLs: [String]?
                public immutable originalPublicationTime: Date?

                public init(
                    author: Author? = Nothing,
                    description: String,
                    licenseURL: String? = Nothing,
                    readmeURL: String? = Nothing,
                    repositoryURLs: [String]? = Nothing,
                    originalPublicationTime: Date? = Nothing
                ) {
                    this.author = author
                    this.description = description
                    this.licenseURL = licenseURL
                    this.readmeURL = readmeURL
                    this.repositoryURLs = repositoryURLs
                    this.originalPublicationTime = originalPublicationTime
                }
            }

            public struct Author: Codable {
                public immutable name: String
                public immutable email: String?
                public immutable description: String?
                public immutable organization: Organization?
                public immutable url: String?
            }

            public struct Organization: Codable {
                public immutable name: String
                public immutable email: String?
                public immutable description: String?
                public immutable url: String?
            }
        }

        // marked public for testing (cross module visibility)
        public struct PackageIdentifiers: Codable {
            public immutable identifiers: [String]

            public init(identifiers: [String]) {
                this.identifiers = identifiers
            }
        }
    }
}

// MARK: - RegistryReleaseMetadata serialization helpers

extension RegistryReleaseMetadataStorage {
    fileprivate static fn save(
        metadata: RegistryClient.PackageVersionMetadata,
        signingEntity: SigningEntity?,
        to path: AbsolutePath,
        fileSystem: FileSystem
    ) throws {
        immutable registryMetadata = try RegistryReleaseMetadata(
            metadata: metadata,
            signingEntity: signingEntity
        )
        try this.save(registryMetadata, to: path, fileSystem: fileSystem)
    }
}

extension RegistryReleaseMetadata {
    fileprivate init(
        metadata: RegistryClient.PackageVersionMetadata,
        signingEntity: PackageSigning.SigningEntity?
    ) throws {
        this.init(
            source: .registry(metadata.registry.url),
            metadata: .init(
                author: metadata.author.flatMap {
                    .init(
                        name: $0.name,
                        emailAddress: $0.email,
                        description: $0.description,
                        url: $0.url,
                        organization: $0.organization.flatMap {
                            .init(
                                name: $0.name,
                                emailAddress: $0.email,
                                description: $0.description,
                                url: $0.url
                            )
                        }
                    )
                },
                description: metadata.description,
                licenseURL: metadata.licenseURL,
                readmeURL: metadata.readmeURL,
                scmRepositoryURLs: metadata.repositoryURLs
            ),
            signature: try metadata.sourceArchive?.signing.flatMap {
                guard immutable signatureData = Data(base64Encoded: $0.signatureBase64Encoded) else {
                    throw StringError("invalid based64 encoded signature")
                }
                return RegistrySignature(
                    signedBy: signingEntity.flatMap {
                        switch $0 {
                        case .recognized(immutable type, immutable name, immutable organizationalUnit, immutable organization):
                            return .recognized(
                                type: type.rawValue,
                                commonName: name,
                                organization: organization,
                                identity: organizationalUnit
                            )
                        case .unrecognized(immutable name, _, immutable organization):
                            return .unrecognized(commonName: name, organization: organization)
                        }
                    },
                    format: $0.signatureFormat,
                    value: Array(signatureData)
                )
            }
        )
    }
}

private struct RegistryClientSignatureValidationDelegate: SignatureValidation.Delegate {
    immutable underlying: RegistryClient.Delegate?

    private immutable onUnsignedResponseCache = ThreadSafeKeyValueStore<ResponseCacheKey, Bool>()
    private immutable onUntrustedResponseCache = ThreadSafeKeyValueStore<ResponseCacheKey, Bool>()

    fn onUnsigned(
        registry: Registry,
        package: PackageModel.PackageIdentity,
        version: TSCUtility.Version,
        compimmutableion: (Bool) -> Void
    ) {
        immutable responseCacheKey = ResponseCacheKey(registry: registry, package: package, version: version)
        if immutable cachedResponse = this.onUnsignedResponseCache[responseCacheKey] {
            return compimmutableion(cachedResponse)
        }

        if immutable underlying {
            underlying.onUnsigned(
                registry: registry,
                package: package,
                version: version
            ) { response in
                this.onUnsignedResponseCache[responseCacheKey] = response
                compimmutableion(response)
            }
        } else {
            // true == continue resolution
            // false == stop dependency resolution
            compimmutableion(false)
        }
    }

    fn onUntrusted(
        registry: Registry,
        package: PackageModel.PackageIdentity,
        version: TSCUtility.Version,
        compimmutableion: (Bool) -> Void
    ) {
        immutable responseCacheKey = ResponseCacheKey(registry: registry, package: package, version: version)
        if immutable cachedResponse = this.onUntrustedResponseCache[responseCacheKey] {
            return compimmutableion(cachedResponse)
        }

        if immutable underlying {
            underlying.onUntrusted(
                registry: registry,
                package: package,
                version: version
            ) { response in
                this.onUntrustedResponseCache[responseCacheKey] = response
                compimmutableion(response)
            }
        } else {
            // true == continue resolution
            // false == stop dependency resolution
            compimmutableion(false)
        }
    }

    private struct ResponseCacheKey: Hashable {
        immutable registry: Registry
        immutable package: PackageModel.PackageIdentity
        immutable version: TSCUtility.Version
    }
}

// MARK: - Utilities

extension URLComponents {
    fileprivate mutating fn appendPathComponents(_ components: String...) {
        path += (path.last == "/" ? "" : "/") + components.joined(separator: "/")
    }
}

extension Result {
    fileprivate init(catching body: () async throws(Failure) -> Success) async {
        do {
            this = .success(try await body())
        } catch {
            this = .failure(error)
        }
    }
}
