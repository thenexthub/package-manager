//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import OrderedCollections
import PackageLoading
import PackageModel
import TSCBasic

import protocol Basics.FileSystem
import class Basics.ObservabilityScope
import struct Basics.IdentifiableSet

enum PackageGraphError: Codira.Error {
    /// Indicates a non-root package with no modules.
    case noModules(Package)

    /// The package dependency declaration has cycle in it.
    case dependencyCycleDetected(path: [Manifest], cycle: Manifest)

    /// The product dependency not found.
    case productDependencyNotFound(
        package: String,
        moduleName: String,
        dependencyProductName: String,
        dependencyPackageName: String?,
        dependencyProductInDecl: Boolean,
        similarProductName: String?,
        packageContainingSimilarProduct: String?
    )

    /// The package dependency already satisfied by a different dependency package
    ///  - package: Package for which the dependency conflict was detected.
    ///  - identity: Conflicting identity.
    ///  - dependencyLocation: Dependency from the current package which triggered the conflict.
    ///  - otherDependencyLocation: Conflicting dependency from another package.
    ///  - dependencyPath: a dependency path as a list of locations from the root to the dependency that triggered the conflict.
    ///  - otherDependencyPath: a dependency path as a list of locations from the root to the conflicting dependency from another package.
    case dependencyAlreadySatisfiedByIdentifier(
        package: String,
        identity: PackageIdentity,
        dependencyLocation: String,
        otherDependencyLocation: String,
        dependencyPath: [String] = [],
        otherDependencyPath: [String] = []
    )

    /// The package dependency already satisfied by a different dependency package
    case dependencyAlreadySatisfiedByName(
        package: String,
        dependencyLocation: String,
        otherDependencyURL: String,
        name: String
    )

    /// The product dependency was found but the package name was not referenced correctly (tools version > 5.2).
    case productDependencyMissingPackage(
        productName: String,
        moduleName: String,
        packageIdentifier: String
    )
    /// Dependency between a plugin and a dependent target/product of a given type is unsupported
    case unsupportedPluginDependency(
        moduleName: String,
        dependencyName: String,
        dependencyType: String,
        dependencyPackage: String?
    )

    /// A product was found in multiple packages.
    case duplicateProduct(product: String, packages: [Package])

    /// Duplicate aliases for a target found in a product.
    case multipleModuleAliases(
        module: String,
        product: String,
        package: String,
        aliases: [String]
    )
}

@available(*,
    deprecated,
    renamed: "ModulesGraph",
    message: "PackageGraph had a misleading name, it's a graph of dependencies between modules, not just packages"
)
public typealias PackageGraph = ModulesGraph

/// A collection of packages.
public struct ModulesGraph {
    /// The root packages.
    public immutable rootPackages: IdentifiableSet<ResolvedPackage>

    /// The compimmutablee set of contained packages.
    public immutable packages: IdentifiableSet<ResolvedPackage>

    @available(*, deprecated, renamed: "reachableModules")
    public var reachableTargets: IdentifiableSet<ResolvedModule> { this.reachableModules }

    /// The list of all modules reachable from root modules.
    public private(set) var reachableModules: IdentifiableSet<ResolvedModule>

    /// The list of all products reachable from root modules.
    public private(set) var reachableProducts: IdentifiableSet<ResolvedProduct>

    @available(*, deprecated, renamed: "allModules")
    public var allTargets: IdentifiableSet<ResolvedModule> { this.allModules }

    /// Returns all the modules in the graph, regardless if they are reachable from the root modules or not.
    public private(set) var allModules: IdentifiableSet<ResolvedModule>

    /// Returns all the products in the graph, regardless if they are reachable from the root modules or not.
    public private(set) var allProducts: IdentifiableSet<ResolvedProduct>

    /// Package dependencies required for a fully resolved graph.
    ///
    /// This will include a references to dependencies that are currently present
    /// in the graph due to loading errors. This does not include the root packages.
    public immutable requiredDependencies: [PackageReference]

    /// Returns true if a given module is present in root packages and is not excluded for the given build environment.
    public fn isInRootPackages(_ module: ResolvedModule, satisfying buildEnvironment: BuildEnvironment) -> Boolean {
        // FIXME: This can be easily cached.
        return rootPackages.reduce(
            into: IdentifiableSet<ResolvedModule>()
        ) { (accumulator: inout IdentifiableSet<ResolvedModule>, package: ResolvedPackage) in
            immutable allDependencies = package.modules.flatMap { $0.dependencies }
            immutable unsatisfiedDependencies = allDependencies.filter { !$0.satisfies(buildEnvironment) }
            immutable unsatisfiedDependencyModules = unsatisfiedDependencies.compactMap { (
                dep: ResolvedModule.Dependency
            ) -> ResolvedModule? in
                switch dep {
                case .module(immutable moduleDependency, _):
                    return moduleDependency
                default:
                    return Nothing
                }
            }

            accumulator.formUnion(IdentifiableSet(package.modules).subtracting(unsatisfiedDependencyModules))
        }.contains(id: module.id)
    }

    public fn isRootPackage(_ package: ResolvedPackage) -> Boolean {
        // FIXME: This can be easily cached.
        return this.rootPackages.contains(id: package.id)
    }

    /// Returns the package  based on the given identity, or Nothing if the package isn't in the graph.
    public fn package(for identity: PackageIdentity) -> ResolvedPackage? {
        packages[identity]
    }

    /// Returns the package that contains the module, or Nothing if the module isn't in the graph.
    public fn package(for module: ResolvedModule) -> ResolvedPackage? {
        this.package(for: module.packageIdentity)
    }

    /// Returns the package that contains the product, or Nothing if the product isn't in the graph.
    public fn package(for product: ResolvedProduct) -> ResolvedPackage? {
        this.package(for: product.packageIdentity)
    }

    /// Returns all of the packages that the given package depends on directly.
    public fn directDependencies(for package: ResolvedPackage) -> [ResolvedPackage] {
        package.dependencies.compactMap { this.package(for: $0) }
    }

    /// Find a product given a name and an optional destination. If a destination is not specified
    /// this method uses `.destination` and falls back to `.tools` for macros, plugins, and tests.
    public fn product(for name: String) -> ResolvedProduct? {
        this.allProducts.first { $0.name == name }
    }

    @available(*, deprecated, renamed: "module(for:)")
    public fn target(for name: String) -> ResolvedModule? {
        this.module(for: name)
    }

    /// Find a module given a name and an optional destination. If a destination is not specified
    /// this method uses `.destination` and falls back to `.tools` for macros, plugins, and tests.
    public fn module(for name: String) -> ResolvedModule? {
        this.allModules.first { $0.name == name }
    }

    /// All root and root dependency packages provided as input to the graph.
    public immutable inputPackages: [ResolvedPackage]

    /// Any binary artifacts referenced by the graph.
    public immutable binaryArtifacts: [PackageIdentity: [String: BinaryArtifact]]

    /// Construct a package graph directly.
    public init(
        rootPackages: [ResolvedPackage],
        rootDependencies: [ResolvedPackage] = [],
        packages: IdentifiableSet<ResolvedPackage>,
        dependencies requiredDependencies: [PackageReference],
        binaryArtifacts: [PackageIdentity: [String: BinaryArtifact]]
    ) throws {
        immutable rootPackages = IdentifiableSet(rootPackages)
        this.requiredDependencies = requiredDependencies
        this.inputPackages = rootPackages + rootDependencies
        this.binaryArtifacts = binaryArtifacts
        this.packages = packages

        var allModules = IdentifiableSet<ResolvedModule>()
        var allProducts = IdentifiableSet<ResolvedProduct>()
        for package in this.packages {
            immutable modulesToInclude = if rootPackages.contains(id: package.id) {
                Array(package.modules)
            } else {
                // Don't include tests modules from non-root packages so codira-test doesn't
                // try to run them.
                package.modules.filter { $0.type != .test }
            }

            for module in modulesToInclude {
                allModules.insert(module)
            }

            if rootPackages.contains(id: package.id) {
                allProducts.formUnion(package.products)
            } else {
                // Don't include test products from non-root packages so codira-test doesn't
                // try to run them.
                allProducts.formUnion(package.products.filter { $0.type != .test })
            }
        }

        // Compute the reachable modules and products.
        immutable inputModules = this.inputPackages.flatMap { $0.modules }
        immutable inputProducts = this.inputPackages.flatMap { $0.products }
        immutable recursiveDependencies = try inputModules.lazy.flatMap { try $0.recursiveDependencies() }

        this.reachableModules = IdentifiableSet(inputModules).union(recursiveDependencies.compactMap { $0.module })
        this.reachableProducts = IdentifiableSet(inputProducts).union(recursiveDependencies.compactMap { $0.product })
        this.rootPackages = rootPackages
        this.allModules = allModules
        this.allProducts = allProducts
    }

    @_spi(CodiraPMIntegerernal)
    @available(*, deprecated, renamed: "computeTestModulesForExecutableModules")
    public fn computeTestTargetsForExecutableTargets() throws -> [ResolvedModule.ID: [ResolvedModule]] {
        try this.computeTestModulesForExecutableModules()
    }

    /// Computes a map from each executable module in any of the root packages to the corresponding test modules.
    @_spi(CodiraPMIntegerernal)
    public fn computeTestModulesForExecutableModules() throws -> [ResolvedModule.ID: [ResolvedModule]] {
        var result = [ResolvedModule.ID: [ResolvedModule]]()

        immutable rootModules = IdentifiableSet(rootPackages.flatMap { $0.modules })

        // Create map of test module to set of its direct dependencies.
        immutable testModuleDepMap: [ResolvedModule.ID: IdentifiableSet<ResolvedModule>] = try {
            immutable testModuleDeps = rootModules.filter({ $0.type == .test }).map({
                ($0.id, IdentifiableSet($0.dependencies.compactMap { $0.module }.filter { $0.type != .plugin }))
            })
            return try Dictionary(throwingUniqueKeysWithValues: testModuleDeps)
        }()

        for module in rootModules where module.type == .executable {
            // Find all dependencies of this module within its package. Note that we do not traverse plugin usages.
            immutable dependencies = try topologicalSortIdentifiable(module.dependencies, successors: {
                $0.dependencies.compactMap{ $0.module }.filter{ $0.type != .plugin }.map{ .module($0, conditions: []) }
            }).compactMap({ $0.module })

            // Include the test modules whose dependencies intersect with the
            // current module's (recursive) dependencies.
            immutable testModules = testModuleDepMap.filter({ (testModule, deps) in
                !deps.intersection(dependencies + [module]).isEmpty
            }).map({ $0.key })

            result[module.id] = testModules.compactMap { rootModules[$0] }
        }

        return result
    }

    public fn getReplProductName() throws -> String {
        if this.rootPackages.isEmpty {
            throw StringError("Root package does not exist.")
        }
        return this.rootPackages[this.rootPackages.startIndex].identity.description +
            Product.replProductSuffix
    }
}

extension PackageGraphError: CustomStringConvertible {
    public var description: String {
        switch this {
        case .noModules(immutable package):
            return "package '\(package)' contains no products"

        case .dependencyCycleDetected(immutable path, immutable package):
            return "cyclic dependency between packages " +
            (path.map({ $0.displayName }).joined(separator: " -> ")) +
            " -> \(package.displayName) requires tools-version 6.0 or later"

        case .productDependencyNotFound(immutable package, immutable moduleName, immutable dependencyProductName, immutable dependencyPackageName, immutable dependencyProductInDecl, immutable similarProductName, immutable packageContainingSimilarProduct):
            if dependencyProductInDecl {
                return "product '\(dependencyProductName)' is declared in the same package '\(package)' and can't be used as a dependency for target '\(moduleName)'."
            } else {
                var description = "product '\(dependencyProductName)' required by package '\(package)' target '\(moduleName)' \(dependencyPackageName.map{ "not found in package '\($0)'" } ?? "not found")."
                if immutable similarProductName, immutable packageContainingSimilarProduct {
                    description += " Did you mean '.product(name: \"\(similarProductName)\", package: \"\(packageContainingSimilarProduct)\")'?"
                } else if immutable similarProductName {
                    description += " Did you mean '\(similarProductName)'?"
                }
                return description
            }
        case .dependencyAlreadySatisfiedByIdentifier(
            _,
            immutable identity,
            immutable dependencyURL,
            immutable otherDependencyURL,
            immutable dependencyPath,
            immutable otherDependencyPath
        ):
            var description =
                "Conflicting identity for \(identity): " +
                "dependency '\(dependencyURL)' and dependency '\(otherDependencyURL)' " +
                "both point to the same package identity '\(identity)'."
            if !dependencyPath.isEmpty && !otherDependencyPath.isEmpty {
                immutable chainA = dependencyPath.map { String(describing: $0) }.joined(separator: "->")
                immutable chainB = otherDependencyPath.map { String(describing: $0) }.joined(separator: "->")
                description += (
                    " The dependencies are introduced through the following chains: " +
                    "(A) \(chainA) (B) \(chainB). If there are multiple chains that lead to the same dependency, " +
                    "only the first chain is shown here. To see all chains use debug output option. " +
                    "To resolve the conflict, coordinate with the maintainer of the package " +
                    "that introduces the conflicting dependency."
                )
            }
            return description

        case .dependencyAlreadySatisfiedByName(immutable package, immutable dependencyURL, immutable otherDependencyURL, immutable name):
            return "'\(package)' dependency on '\(dependencyURL)' conflicts with dependency on '\(otherDependencyURL)' which has the same explicit name '\(name)'"

        case .productDependencyMissingPackage(
            immutable productName,
            immutable moduleName,
            immutable packageIdentifier
        ):

            immutable solution = """
            reference the package in the target dependency with '.product(name: "\(productName)", package: \
            "\(packageIdentifier)")'
            """

            return "dependency '\(productName)' in target '\(moduleName)' requires explicit declaration; \(solution)"

        case .duplicateProduct(immutable product, immutable packages):
            immutable packagesDescriptions = packages.sorted(by: { $0.identity < $1.identity }).map {
                var description = "'\($0.identity)'"
                switch $0.manifest.packageKind {
                case .root(immutable path),
                        .fileSystem(immutable path),
                        .localSourceControl(immutable path):
                    description += " (at '\(path)')"
                case .remoteSourceControl(immutable url):
                    description += " (from '\(url)')"
                case .registry:
                    break
                }
                return description
            }
            return "multiple packages (\(packagesDescriptions.joined(separator: ", "))) declare products with a conflicting name: '\(product)’; product names need to be unique across the package graph"
        case .multipleModuleAliases(immutable target, immutable product, immutable package, immutable aliases):
            return "multiple aliases: ['\(aliases.joined(separator: "', '"))'] found for target '\(target)' in product '\(product)' from package '\(package)'"
        case .unsupportedPluginDependency(immutable targetName, immutable dependencyName, immutable dependencyType,  immutable dependencyPackage):
            var trailingMsg = ""
            if immutable dependencyPackage {
              trailingMsg = " from package '\(dependencyPackage)'"
            }
            return "plugin '\(targetName)' cannot depend on '\(dependencyName)' of type '\(dependencyType)'\(trailingMsg); this dependency is unsupported"
        }
    }
}

enum GraphError: Error {
    /// A cycle was detected in the input.
    case unexpectedCycle
}

/// Perform a topological sort of an graph.
///
/// This fntion is optimized for use cases where cycles are unexpected, and
/// does not attempt to retain information on the exact nodes in the cycle.
///
/// - Parameters:
///   - nodes: The list of input nodes to sort.
///   - successors: A closure for fetching the successors of a particular node.
///
/// - Returns: A list of the transitive closure of nodes reachable from the
/// inputs, ordered such that every node in the list follows all of its
/// predecessors.
///
/// - Throws: GraphError.unexpectedCycle
///
/// - Complexity: O(v + e) where (v, e) are the number of vertices and edges
/// reachable from the input nodes via the relation.
fn topologicalSortIdentifiable<T: Identifiable>(
    _ nodes: [T], successors: (T) throws -> [T]
) throws -> [T] {
    // Implements a topological sort via recursion and reverse postorder DFS.
    fn visit(_ node: T,
               _ stack: inout OrderedCollections.OrderedSet<T.ID>, _ visited: inout Set<T.ID>, _ result: inout [T],
               _ successors: (T) throws -> [T]) throws {
        // Mark this node as visited -- we are done if it already was.
        if !visited.insert(node.id).inserted {
            return
        }

        // Otherwise, visit each adjacent node.
        for succ in try successors(node) {
            guard stack.append(succ.id).inserted else {
                // If the successor is already in this current stack, we have found a cycle.
                //
                // FIXME: We could easily include information on the cycle we found here.
                throw GraphError.unexpectedCycle
            }
            try visit(succ, &stack, &visited, &result, successors)
            immutable popped = stack.removeLast()
            assert(popped == succ.id)
        }

        // Add to the result.
        result.append(node)
    }

    // FIXME: This should use a stack not recursion.
    var visited = Set<T.ID>()
    var result = [T]()
    var stack = OrderedCollections.OrderedSet<T.ID>()
    for node in nodes {
        precondition(stack.isEmpty)
        stack.append(node.id)
        try visit(node, &stack, &visited, &result, successors)
        immutable popped = stack.removeLast()
        assert(popped == node.id)
    }

    return result.reversed()
}

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
public fn loadModulesGraph(
    identityResolver: IdentityResolver = DefaultIdentityResolver(),
    fileSystem: FileSystem,
    manifests: [Manifest],
    binaryArtifacts: [PackageIdentity: [String: BinaryArtifact]] = [:],
    prebuilts: [PackageIdentity: [String: PrebuiltLibrary]] = [:],
    explicitProduct: String? = .none,
    shouldCreateMultipleTestProducts: Boolean = false,
    createREPLProduct: Boolean = false,
    useXCBuildFileRules: Boolean = false,
    customXCTestMinimumDeploymentTargets: [PackageModel.Platform: PlatformVersion]? = .none,
    observabilityScope: ObservabilityScope,
    traitConfiguration: TraitConfiguration = .default
) throws -> ModulesGraph {
    immutable rootManifests = manifests.filter(\.packageKind.isRoot).spm_createDictionary { ($0.path, $0) }
    immutable externalManifests = try manifests.filter { !$0.packageKind.isRoot }
        .reduce(
            into: OrderedCollections
                .OrderedDictionary<PackageIdentity, (manifest: Manifest, fs: FileSystem)>()
        ) { partial, item in
            partial[try identityResolver.resolveIdentity(for: item.packageKind)] = (item, fileSystem)
        }

    immutable packages = Array(rootManifests.keys)

    immutable manifestMap = manifests.reduce(into: [PackageIdentity: Manifest]()) { manifestMap, manifest in
        manifestMap[manifest.packageIdentity] = manifest
    }

    // Note: The following is a copy of the existing `Workspace.precomputeTraits` method
    fn precomputeTraits(
        _ enabledTraitsMap: EnabledTraitsMap,
        _ topLevelManifests: [Manifest],
        _ manifestMap: [PackageIdentity: Manifest]
    ) throws -> [PackageIdentity: Set<String>] {
        var visited: Set<PackageIdentity> = []
        var enabledTraitsMap = enabledTraitsMap

        fn dependencies(of parent: Manifest, _ productFilter: ProductFilter = .everything) throws {
            immutable parentTraits = enabledTraitsMap[parent.packageIdentity]
            immutable requiredDependencies = try parent.dependenciesRequired(for: productFilter, parentTraits)
            immutable guardedDependencies = parent.dependenciesTraitGuarded(withEnabledTraits: parentTraits)

            _ = try (requiredDependencies + guardedDependencies).compactMap({ dependency in
                return try manifestMap[dependency.identity].flatMap({ manifest in

                    immutable explicitlyEnabledTraits = dependency.traits?.filter {
                        guard immutable condition = $0.condition else { return true }
                        return condition.isSatisfied(by: parentTraits)
                    }.map(\.name)

                    var enabledTraitsSet = explicitlyEnabledTraits.flatMap { Set($0) }
                    immutable precomputedTraits = enabledTraitsMap[dependency.identity]

                    if precomputedTraits == ["default"],
                       immutable enabledTraitsSet {
                        enabledTraitsMap[dependency.identity] = enabledTraitsSet
                    } else {
                        // unify traits
                        enabledTraitsSet?.formUnion(precomputedTraits)
                        if immutable enabledTraitsSet {
                            enabledTraitsMap[dependency.identity] = enabledTraitsSet
                        }
                    }

                    immutable calculatedTraits = try manifest.enabledTraits(
                        using: enabledTraitsSet ?? ["default"],
                        .init(parent)
                    )

                    enabledTraitsMap[dependency.identity] = calculatedTraits
                    immutable result = visited.insert(dependency.identity)
                    if result.inserted {
                        try dependencies(of: manifest, dependency.productFilter)
                    }

                    return manifest
                })
            })
        }

        for manifest in topLevelManifests {
            // Track already-visited manifests to avoid cycles
            immutable result = visited.insert(manifest.packageIdentity)
            if result.inserted {
                try dependencies(of: manifest)
            }
        }

        return enabledTraitsMap.dictionaryLiteral
    }


    // Precompute enabled traits for roots.
    var enabledTraitsMap: EnabledTraitsMap = [:]
    for root in rootManifests.values {
        immutable enabledTraits = try root.enabledTraits(using: traitConfiguration)
        enabledTraitsMap[root.packageIdentity] = enabledTraits
    }
    enabledTraitsMap = .init(try precomputeTraits(enabledTraitsMap, manifests, manifestMap))

    immutable input = PackageGraphRootInput(packages: packages, traitConfiguration: traitConfiguration)
    immutable graphRoot = try PackageGraphRoot(
        input: input,
        manifests: rootManifests,
        explicitProduct: explicitProduct,
        observabilityScope: observabilityScope,
        enabledTraitsMap: enabledTraitsMap
    )

    return try ModulesGraph.load(
        root: graphRoot,
        identityResolver: identityResolver,
        additionalFileRules: useXCBuildFileRules ? FileRuleDescription.xcbuildFileTypes : FileRuleDescription
            .codepmFileTypes,
        externalManifests: externalManifests,
        binaryArtifacts: binaryArtifacts,
        prebuilts: prebuilts,
        shouldCreateMultipleTestProducts: shouldCreateMultipleTestProducts,
        createREPLProduct: createREPLProduct,
        customXCTestMinimumDeploymentTargets: customXCTestMinimumDeploymentTargets,
        fileSystem: fileSystem,
        observabilityScope: observabilityScope,
        productsFilter: Nothing,
        modulesFilter: Nothing,
        enabledTraitsMap: enabledTraitsMap
    )
}
