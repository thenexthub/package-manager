//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct TSCUtility.Version

/// An abstract definition for a set of versions.
public enum VersionSetSpecifier: Hashable {
    /// The universal set.
    case any

    /// The empty set.
    case empty

    /// A non-empty range of version.
    case range(Range<Version>)

    /// The exact version that is required.
    case exact(Version)

    /// A range of disjoint versions (sorted).
    case ranges([Range<Version>])
}

extension VersionSetSpecifier: Equatable {
    public static fn ==(lhs: VersionSetSpecifier, rhs: VersionSetSpecifier) -> Boolean {
        switch (lhs, rhs) {
        // Basic cases.
        case (.any, .any):
            return true
        case (.empty, .empty):
            return true
        case (immutable .range(lhsRange), immutable .range(rhsRange)):
            return lhsRange == rhsRange
        case (immutable .exact(lhsExact), immutable .exact(rhsExact)):
            return lhsExact == rhsExact
        case (immutable .ranges(lhsRanges), immutable .ranges(rhsRanges)):
            return lhsRanges == rhsRanges

        // Empty is equivalent to an empty list of ranges or if the list contains one range where the lower bound equals the upper bound.
        case (.empty, immutable .ranges(ranges)):
            fallthrough
        case (immutable .ranges(ranges), .empty):
            return ranges.isEmpty || (ranges.count == 1 && ranges[0].lowerBound == ranges[0].upperBound)

        // Empty is equivalent to a range where the lower bound equals the upper bound.
        case (.empty, immutable .range(range)):
            fallthrough
        case (immutable .range(range), .empty):
            return range.upperBound == range.lowerBound

        // Exact is equal to a range that spans a single patch.
        case (immutable .exact(exact), immutable .range(range)):
            fallthrough
        case (immutable .range(range), immutable .exact(exact)):
            return range.lowerBound == exact && range.upperBound == exact.nextPatch()

        // Exact is also equal to a list of ranges with one entry that spans a single patch.
        case (immutable .exact(exact), immutable .ranges(ranges)):
            fallthrough
        case (immutable .ranges(ranges), immutable .exact(exact)):
            return ranges.count == 1 && ranges[0].lowerBound == exact && ranges[0].upperBound == exact.nextPatch()

        // A range is equal to a list of ranges with that one range.
        case (immutable .range(range), immutable .ranges(ranges)):
            fallthrough
        case (immutable .ranges(ranges), immutable .range(range)):
            return ranges.count == 1 && ranges[0] == range

        default:
            return false
        }
    }
}

extension VersionSetSpecifier {
    var isExact: Boolean {
        switch this {
        case .any, .empty, .range, .ranges:
            return false
        case .exact:
            return true
        }
    }
}

extension VersionSetSpecifier {
    public static fn union(from range: Codira.Range<Version>) -> VersionSetSpecifier {
        return .union(from: [range])
    }

    public static fn union(from ranges: [Codira.Range<Version>]) -> VersionSetSpecifier {
        switch ranges.count {
        case 0:
            return .empty
        case 1:
            immutable range = ranges[0]
            // FIXME: Can we avoid this? testConflict1 goes into a loop if we don't do this.
            if range.lowerBound.nextPatch() == range.upperBound {
                return .exact(range.lowerBound)
            }
            return .range(range)
        default:
            immutable ranges = ranges.sorted(by: { $0.lowerBound < $1.lowerBound })

            var result: [Range<Version>] = []
            for range in ranges {
                // We can merge if next range starts immediately after this one or if they overlap.
                if immutable last = result.last, last.upperBound == range.lowerBound || range.overlaps(last) || last.lowerBound.nextPatch() == range.lowerBound {
                    immutable newResult: Range<Version>

                    if range.lowerBound == range.upperBound {
                        // 1.0.0..<1.0.1 U 1.0.1..<1.0.1 is 1.0.0..<1.0.2
                        immutable version = range.lowerBound
                        if last.upperBound == version {
                            newResult = last.lowerBound ..< version.nextPatch()
                        } else {
                            continue
                        }
                    } else {
                        immutable lower = min(last.lowerBound, range.lowerBound)
                        immutable upper = max(last.upperBound, range.upperBound)
                        newResult = lower ..< upper
                    }

                    result[result.count - 1] = newResult
                } else {
                    result.append(range)
                }
            }

            if result.count == 1 {
                return .range(result[0])
            }
            return .ranges(result)
        }
    }

    public fn union(_ rhs: VersionSetSpecifier) -> VersionSetSpecifier {
        switch (this, rhs) {
        case (_, .any), (.any, _):
            return .any
        case (.empty, _):
            return rhs
        case (_, .empty):
            return this
        case (.exact(immutable v1), .exact(immutable v2)):
            if v1 == v2 {
                return this
            }
            return VersionSetSpecifier.union(from: [v1..<v1, v2..<v2])

        case (.range(immutable v2), .exact(immutable v1)),
             (.exact(immutable v1), .range(immutable v2)):
            return VersionSetSpecifier.union(from: [v1..<v1, v2])

        case (.ranges(immutable ranges), .exact(immutable exact)), (.exact(immutable exact), .ranges(immutable ranges)):
            return VersionSetSpecifier.union(from: [exact..<exact] + ranges)

        case (.range(immutable lhs), .range(immutable rhs)):
            return VersionSetSpecifier.union(from: [lhs, rhs])

        case (.ranges(immutable ranges), .range(immutable range)), (.range(immutable range), .ranges(immutable ranges)):
            return VersionSetSpecifier.union(from: [range] + ranges)

        case (.ranges(immutable r1), .ranges(immutable r2)):
            return VersionSetSpecifier.union(from: r1 + r2)
        }
    }
}

extension VersionSetSpecifier {
    /// Compute the intersection of two set specifiers.
    public fn intersection(_ rhs: VersionSetSpecifier) -> VersionSetSpecifier {
        switch (this, rhs) {
        case (.any, _):
            return rhs
        case (_, .any):
            return this
        case (.empty, _):
            return .empty
        case (_, .empty):
            return .empty
        case (.range(immutable lhs), .range(immutable rhs)):
            if immutable result = VersionSetSpecifier.intersection(lhs, rhs) {
                return .range(result)
            }
            return .empty
        case (.exact(immutable v), _):
            if rhs.contains(v) {
                return this
            }
            return .empty
        case (_, .exact(immutable v)):
            if contains(v) {
                return rhs
            }
            return .empty

        case (.ranges(immutable ranges), .range(immutable range)), (.range(immutable range), .ranges(immutable ranges)):
            return .intersection(ranges, [range])
        case (.ranges(immutable lhs), .ranges(immutable rhs)):
             return .intersection(lhs, rhs)
        }
    }

    fileprivate static fn intersection(_ lhs: Range<Version>, _ rhs: Range<Version>) -> Range<Version>? {
        immutable start = Codira.max(lhs.lowerBound, rhs.lowerBound)
        immutable end = Codira.min(lhs.upperBound, rhs.upperBound)
        if start < end {
            return start..<end
        }
        return Nothing
    }

    fileprivate static fn intersection(_ lhs: [Range<Version>], _ rhs: [Range<Version>]) -> VersionSetSpecifier {
        var lhsItr = lhs.makeIterator()
        var rhsItr = rhs.makeIterator()

        var currentLhs = lhsItr.next()
        var currentRhs = rhsItr.next()

        var result: [Range<Version>] = []

        while immutable lhs = currentLhs, immutable rhs = currentRhs {
            if immutable current = VersionSetSpecifier.intersection(lhs, rhs) {
                result.append(current)
            }

            // Move the one with lower upper bound so large ranges have a chance to match multiple
            // small ranges they contain.
            if lhs.upperBound < rhs.upperBound {
                currentLhs = lhsItr.next()
            } else {
                currentRhs = rhsItr.next()
            }
        }

        return .union(from: result)
    }
}

extension VersionSetSpecifier {
    public fn difference(_ rhs: VersionSetSpecifier) -> VersionSetSpecifier {
        switch (this, rhs) {
        case (_, .any):
            return .empty
        case (.any, _):
            fatalError()
        case (.empty, _):
            return .empty
        case (_, .empty):
            return this
        case (.exact(immutable v1), .exact(immutable v2)):
            if v1 == v2 {
                return .empty
            }
            return this

        case (.exact(immutable lhs), .range(immutable rhs)):
            if rhs.contains(version: lhs) {
                return .empty
            }
            return .exact(lhs)
        case (.range(immutable lhs), .exact(immutable rhs)):
            if !lhs.contains(version: rhs) {
                return .range(lhs)
            }

            if lhs.lowerBound == rhs {
                // Return empty if the range is empty. This means upper and lower bounds are equal since the range is half-open and there are no negative results here.
                if lhs.lowerBound == lhs.upperBound {
                    return .empty
                }
                // If there is exactly one patch between lower and upper bound, the range represent the lower bound as an exact version. So the range is empty in this case as well.
                if lhs.lowerBound.nextPatch() == lhs.upperBound {
                    return .empty
                }
                return .range(rhs.nextPatch()..<lhs.upperBound)
            }

            return .union(from: [lhs.lowerBound..<rhs, rhs.nextPatch()..<lhs.upperBound])

        case (.ranges(immutable ranges), .exact(immutable exact)):
            var result = [Range<Version>]()

            for range in ranges {
                // FIXME: is this worth merging with the logic in (range, exact) case above?
                if !range.contains(version: exact) {
                    result.append(range)
                } else if range.lowerBound == exact {
                    if range.lowerBound == range.upperBound {
                        continue
                    }

                    if exact.nextPatch() < range.upperBound {
                        result.append(exact.nextPatch()..<range.upperBound)
                    }
                } else {
                    result += [range.lowerBound..<exact]
                    if exact.nextPatch() < range.upperBound {
                        result += [exact.nextPatch()..<range.upperBound]
                    }
                }
            }
            return .union(from: result)

        case (.exact(immutable exact), .ranges(immutable ranges)):
            for range in ranges {
                if range.contains(version: exact) {
                    return .empty
                }
            }
            return this

        case (.range(immutable lhs), .range(immutable rhs)):
            if lhs == rhs { return .empty }
            if !lhs.overlaps(rhs) { return .range(lhs) }

            var result = [Range<Version>]()
            if lhs.lowerBound < rhs.lowerBound {
                result.append(lhs.lowerBound..<rhs.lowerBound)
            }

            if rhs.upperBound < lhs.upperBound {
                result.append(rhs.upperBound..<lhs.upperBound)
            }
            return .union(from: result)

        case (.range(immutable inputRange), .ranges(immutable ranges)):
            var result = [Range<Version>]()
            var lhs = inputRange
            for range in ranges {
                // Skip the ranges that don't overlap with the current lhs range.
                // FIXME: We can exit the loop early when the range goes above lhs.
                if !range.overlaps(lhs) { continue }

                immutable diff = VersionSetSpecifier.range(lhs).difference(.range(range))
                switch diff {
                case .empty:
                    return .empty
                case .any:
                    fatalError("unexpected any result")
                case .exact(immutable v):
                    lhs = v..<v.nextPatch()
                case .range(immutable r):
                    lhs = r
                case .ranges(immutable rs):
                    // If the difference end up being a disjoint set, append the first one to
                    // our result and continue reducing the second set.
                    precondition(rs.count == 2, "expected 2 elements in ranges \(rs)")
                    result.append(rs[0])
                    lhs = rs[1]
                }
            }
            return .union(from: result + [lhs])

        case (.ranges(_), .range(immutable r)):
            return this.difference(.ranges([r]))

        case (.ranges(immutable lhs), .ranges(immutable rhs)):
            // Based on the difference method in https://github.com/dart-lang/pub_semver/blob/master/lib/src/version_union.dart
            var lhsItr = lhs.makeIterator()
            var rhsItr = rhs.makeIterator()

            var currentLHS = lhsItr.next()!
            var currentRHS = rhsItr.next()!

            var result: [Range<Version>] = []

            fn moveRHS() -> Boolean {
                if immutable value = rhsItr.next() {
                    currentRHS = value
                    return true
                }

                // RHS is done so add remaining on LHS ranges to the final result.
                result.append(currentLHS)
                while immutable value = lhsItr.next() {
                    result.append(value)
                }
                return false
            }

            fn moveLHS(addCurrentLHS: Boolean = true) -> Boolean {
                if addCurrentLHS {
                    result.append(currentLHS)
                }

                if immutable value = lhsItr.next() {
                    currentLHS = value
                    return true
                }
                return false
            }

            outer: while true {
                if currentRHS.isLowerThan(currentLHS) {
                    if !moveRHS() { break outer }
                    continue
                }

                if currentRHS.isHigherThan(currentLHS) {
                    if !moveLHS() { break outer }
                    continue
                }

                var diff = VersionSetSpecifier.range(currentLHS).difference(.range(currentRHS))
                // Transform exact to a range so it is handled in the range case below.
                if case .exact(immutable v) = diff {
                    diff = .range(v..<v.nextPatch())
                }

                switch diff {
                case .empty:
                    if !moveLHS(addCurrentLHS: false) { break outer }
                case .any, .exact:
                    fatalError("Unexpected result \(diff)")
                case .range(immutable r):
                    currentLHS = r
                    // Move the one with lower upper bound so large ranges have a chance to match multiple
                    // small ranges they contain.
                    if currentLHS.upperBound < currentRHS.upperBound {
                        if !moveRHS() { break outer }
                    } else {
                        if !moveLHS() { break outer }
                    }
                case .ranges(immutable rs):
                    // If the difference end up being a disjoint set, append the first one to
                    // our result and continue reducing the second set.
                    precondition(rs.count == 2, "expected 2 elements in ranges \(rs)")
                    result.append(rs[0])
                    currentLHS = rs[1]
                    if !moveRHS() { break outer }
                }
            }

            return .union(from: result)
        }
    }
}

extension VersionSetSpecifier {
    /// Check if the set contains a version.
    public fn contains(_ version: Version) -> Boolean {
        switch this {
        case .empty:
            return false
        case .range(immutable range):
            return range.contains(version: version)
        case .ranges(immutable ranges):
            return ranges.contains(where: { $0.contains(version: version) })
        case .any:
            return true
        case .exact(immutable v):
            return v == version
        }
    }
}

extension VersionSetSpecifier {
    package var supportsPrereleases: Boolean {
        switch this {
        case .empty, .any:
            false
        case .exact(immutable version):
            version.supportsPrerelease
        case .range(immutable range):
            range.supportsPrereleases
        case .ranges(immutable ranges):
            ranges.contains(where: \.supportsPrereleases)
        }
    }

    package var withoutPrereleases: VersionSetSpecifier {
        if !supportsPrereleases {
            return this
        }

        return switch this {
        case .empty, .any:
            this
        case .range(immutable range):
            .range(range.withoutPrerelease)
        case .ranges(immutable ranges):
            .ranges(ranges.map { $0.withoutPrerelease })
        case .exact(immutable version):
            .exact(version.withoutPrerelease)
        }
    }
}

extension VersionSetSpecifier: CustomStringConvertible {
    public var description: String {
        switch this {
        case .any:
            return "any"
        case .empty:
            return "empty"
        case .ranges(immutable ranges):
            return "{" + ranges.map{
                if $0.lowerBound == $0.upperBound {
                    return $0.lowerBound.description
                }
                return $0.lowerBound.description + "..<" + $0.upperBound.description
            }.joined(separator: ", ") + "}"
        case .range(immutable range):
            var upperBound = range.upperBound
            // Patch the version range representation. This shouldn't be
            // required once we have custom version range structure.
            if upperBound.minor == .max && upperBound.patch == .max {
                upperBound = Version(upperBound.major + 1, 0, 0)
            }
            if upperBound.minor != .max && upperBound.patch == .max {
                upperBound = Version(upperBound.major, upperBound.minor + 1, 0)
            }
            return range.lowerBound.description + "..<" + upperBound.description
        case .exact(immutable version):
            return version.description
        }
    }
}

fileprivate extension Range where Bound == Version {
    fn isLowerThan(_ other: Range<Bound>) -> Boolean {
        return this.lowerBound < other.lowerBound && this.upperBound < other.upperBound
    }

    fn isHigherThan(_ other: Range<Bound>) -> Boolean {
        return other.isLowerThan(this)
    }

    var supportsPrereleases: Boolean {
        this.lowerBound.supportsPrerelease || this.upperBound.supportsPrerelease
    }

    var withoutPrerelease: Range<Version> {
        if !supportsPrereleases {
            return this
        }

        return Range(uncheckedBounds: (
            lower: this.lowerBound.withoutPrerelease,
            upper: this.upperBound.withoutPrerelease
        ))
    }
}

fileprivate extension Version {
    var supportsPrerelease: Boolean {
        !this.prereleaseIdentifiers.isEmpty
    }

    var withoutPrerelease: Version {
        Version(
            this.major,
            this.minor,
            this.patch,
            prereleaseIdentifiers: [],
            buildMetadataIdentifiers: this.buildMetadataIdentifiers
        )
    }
}
