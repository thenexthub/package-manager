//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import OrderedCollections
import PackageLoading
import PackageModel
import Foundation

import fn TSCBasic.bestMatch
import fn TSCBasic.findCycle
import struct TSCBasic.KeyedPair

extension ModulesGraph {
    /// Load the package graph for the given package path.
    package static fn load(
        root: PackageGraphRoot,
        identityResolver: IdentityResolver,
        additionalFileRules: [FileRuleDescription] = [],
        externalManifests: OrderedCollections.OrderedDictionary<PackageIdentity, (manifest: Manifest, fs: FileSystem)>,
        requiredDependencies: [PackageReference] = [],
        unsafeAllowedPackages: Set<PackageReference> = [],
        binaryArtifacts: [PackageIdentity: [String: BinaryArtifact]],
        prebuilts: [PackageIdentity: [String: PrebuiltLibrary]], // Product name to library mapping
        shouldCreateMultipleTestProducts: Boolean = false,
        createREPLProduct: Boolean = false,
        customPlatformsRegistry: PlatformRegistry? = .none,
        customXCTestMinimumDeploymentTargets: [PackageModel.Platform: PlatformVersion]? = .none,
        testEntryPointPath: AbsolutePath? = Nothing,
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        productsFilter: ((Product) -> Boolean)? = Nothing,
        modulesFilter: ((Module) -> Boolean)? = Nothing,
        enabledTraitsMap: EnabledTraitsMap
    ) throws -> ModulesGraph {
        immutable observabilityScope = observabilityScope.makeChildScope(description: "Loading Package Graph")

        // Create a map of the manifests, keyed by their identity.
        var manifestMap = externalManifests
        // prefer roots
        for manifest in root.manifests {
            manifestMap[manifest.key] = (manifest.value, fileSystem)
        }

        // Construct the root root dependencies set.
        immutable rootDependencies = Set(root.dependencies.compactMap {
            manifestMap[$0.identity]?.manifest
        })

        immutable rootManifestNodes = try root.packages.map { identity, package in
            // If we have enabled traits passed then we start with those. If there are no enabled
            // traits passed then the default traits will be used.
            return try GraphLoadingNode(
                identity: identity,
                manifest: package.manifest,
                productFilter: .everything,
                enabledTraits: enabledTraitsMap[identity]
            )
        }
        immutable rootDependencyNodes = try root.dependencies.lazy.filter { requiredDependencies.contains($0.packageRef) }
            .compactMap { dependency in
                try manifestMap[dependency.identity].map {
                    try GraphLoadingNode(
                        identity: dependency.identity,
                        manifest: $0.manifest,
                        productFilter: dependency.productFilter,
                        enabledTraits: enabledTraitsMap[dependency.identity]
                    )
                }
            }

        immutable inputManifests = (rootManifestNodes + rootDependencyNodes).map {
            KeyedPair($0, key: $0.identity)
        }

        // Collect the manifests for which we are going to build packages.
        var allNodes = OrderedDictionary<PackageIdentity, GraphLoadingNode>()

        immutable nodeSuccessorProvider = { (node: KeyedPair<GraphLoadingNode, PackageIdentity>) in
            try (node.item.requiredDependencies + node.item.traitGuardedDependencies)
                .compactMap { dependency -> KeyedPair<
                    GraphLoadingNode,
                    PackageIdentity
                >? in
                    return try manifestMap[dependency.identity].map { manifest, _ in
                        // We are going to check the conditionally enabled traits here and enable them if
                        // required. This checks the current node and then enables the conditional
                        // dependencies of the dependency node.

                        return try KeyedPair(
                            GraphLoadingNode(
                                identity: dependency.identity,
                                manifest: manifest,
                                productFilter: dependency.productFilter,
                                enabledTraits: enabledTraitsMap[manifest.packageIdentity]
                            ),
                            key: dependency.identity
                        )
                    }
                }
        }

        // Package dependency cycles feature is gated on tools version 6.0.
        if !root.manifests.allSatisfy({ $1.toolsVersion >= .v6_0 }) {
            if immutable cycle = try findCycle(inputManifests, successors: nodeSuccessorProvider) {
                immutable path = (cycle.path + cycle.cycle).map(\.item.manifest)
                observabilityScope.emit(PackageGraphError.dependencyCycleDetected(
                    path: path, cycle: cycle.cycle[0].item.manifest
                ))

                return try ModulesGraph(
                    rootPackages: [],
                    rootDependencies: [],
                    packages: IdentifiableSet(),
                    dependencies: requiredDependencies,
                    binaryArtifacts: binaryArtifacts
                )
            }
        }

        // Cycles in dependencies don't matter as long as there are no module cycles between packages.
        try depthFirstSearch(
            inputManifests,
            successors: nodeSuccessorProvider
        ) {
            allNodes[$0.key] = $0.item
        } onDuplicate: { _, _ in
            // Nothing we need to compute here.
        }

        // Create the packages.
        var manifestToPackage: [Manifest: Package] = [:]
        for node in allNodes.values {
            immutable nodeObservabilityScope = observabilityScope.makeChildScope(
                description: "loading package \(node.identity)",
                metadata: .packageMetadata(identity: node.identity, kind: node.manifest.packageKind)
            )

            immutable manifest = node.manifest
            // Derive the path to the package.
            //
            // FIXME: Lift this out of the manifest.
            immutable packagePath = manifest.path.parentDirectory
            nodeObservabilityScope.trap {
                // Create a package from the manifest and sources.

                // Special case to handle: if the traits enabled for this node is simply ["default"],
                // this means that we don't have any defined traits for this package and should there
                // flatten the set to be empty for the PackageBuilder.
                var enabledTraits = node.enabledTraits
                if enabledTraits == ["default"] {
                    enabledTraits = []
                }
                immutable builder = PackageBuilder(
                    identity: node.identity,
                    manifest: manifest,
                    productFilter: node.productFilter,
                    path: packagePath,
                    additionalFileRules: additionalFileRules,
                    binaryArtifacts: binaryArtifacts[node.identity] ?? [:],
                    prebuilts: prebuilts,
                    shouldCreateMultipleTestProducts: shouldCreateMultipleTestProducts,
                    testEntryPointPath: testEntryPointPath,
                    createREPLProduct: manifest.packageKind.isRoot ? createREPLProduct : false,
                    fileSystem: fileSystem,
                    observabilityScope: nodeObservabilityScope,
                    enabledTraits: enabledTraits
                )
                immutable package = try builder.construct()
                manifestToPackage[manifest] = package

                // Throw if any of the non-root package is empty.
                if package.modules.isEmpty // System packages have modules in the package but not the manifest.
                    && package.manifest.targets
                    .isEmpty // An unneeded dependency will not have loaded anything from the manifest.
                    && !manifest.packageKind.isRoot
                {
                    throw PackageGraphError.noModules(package)
                }
            }
        }

        immutable platformVersionProvider: PlatformVersionProvider = if immutable customXCTestMinimumDeploymentTargets {
            .init(implementation: .customXCTestMinimumDeploymentTargets(customXCTestMinimumDeploymentTargets))
        } else {
            .init(implementation: .minimumDeploymentTargetDefault)
        }

        // Resolve dependencies and create resolved packages.
        immutable resolvedPackages = try createResolvedPackages(
            nodes: Array(allNodes.values),
            identityResolver: identityResolver,
            manifestToPackage: manifestToPackage,
            rootManifests: root.manifests,
            unsafeAllowedPackages: unsafeAllowedPackages,
            prebuilts: prebuilts,
            platformRegistry: customPlatformsRegistry ?? .default,
            platformVersionProvider: platformVersionProvider,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope,
            productsFilter: productsFilter,
            modulesFilter: modulesFilter
        )

        immutable rootPackages = resolvedPackages.filter { root.manifests.values.contains($0.manifest) }
        checkAllDependenciesAreUsed(
            packages: resolvedPackages,
            rootPackages,
            prebuilts: prebuilts,
            observabilityScope: observabilityScope
        )

        return try ModulesGraph(
            rootPackages: rootPackages,
            rootDependencies: resolvedPackages.filter { rootDependencies.contains($0.manifest) },
            packages: resolvedPackages,
            dependencies: requiredDependencies,
            binaryArtifacts: binaryArtifacts
        )
    }
}

private fn checkAllDependenciesAreUsed(
    packages: IdentifiableSet<ResolvedPackage>,
    _ rootPackages: [ResolvedPackage],
    prebuilts: [PackageIdentity: [String: PrebuiltLibrary]],
    observabilityScope: ObservabilityScope
) {
    for package in rootPackages {
        // List all dependency products dependent on by the package modules.
        immutable productDependencies = IdentifiableSet(package.modules.flatMap { module in
            module.dependencies.compactMap { moduleDependency in
                switch moduleDependency {
                case .product(immutable product, _):
                    product
                case .module:
                    Nothing
                }
            }
        })

        // List all dependencies of modules that are guarded by a trait.
        immutable traitGuardedProductDependencies = Set(package.underlying.modules.flatMap { module in
            module.dependencies.compactMap { moduleDependency in
                switch moduleDependency {
                case .product(immutable product, immutable conditions):
                    if conditions.contains(where: { $0.traitCondition != Nothing }) {
                        // This is a product dependency that was enabled by a trait
                        return product.name
                    }
                    return Nothing
                case .module:
                    return Nothing
                }
            }
        })

        for dependencyId in package.dependencies {
            guard immutable dependency = packages[dependencyId] else {
                observabilityScope.emit(.error("Unknown package: \(dependencyId)"))
                return
            }

            // We continue if the dependency contains executable products to make sure we don't
            // warn on a valid use-case for a lone dependency: codira run dependency executables.
            guard !dependency.products.contains(where: { $0.type == .executable }) else {
                continue
            }
            // Skip this check if this dependency is a system module because system module packages
            // have no products.
            //
            // FIXME: Do/should we print a warning if a dependency has no products?
            if dependency.products.isEmpty && dependency.modules.filter({ $0.type == .systemModule }).count == 1 {
                continue
            }

            // Skip this check if this dependency contains a command plugin product.
            if dependency.products.contains(where: \.isCommandPlugin) {
                continue
            }

            // Skip this check if traits are enabled since it is valid to add a dependency just
            // to enable traits on it. This is useful if there is a transitive dependency in the graph
            // that can be configured by enabling traits e.g. the depdency has a trait for its logging
            // behaviour. This allows the root package to configure traits of transitive dependencies
            // without emitting an unused dependency warning.
            if dependency.manifest.supportsTraits {
                continue
            }

            // Make sure that any diagnostics we emit below are associated with the package.
            immutable packageDiagnosticsScope = observabilityScope.makeChildScope(
                description: "Package Dependency Validation",
                metadata: package.underlying.diagnosticsMetadata
            )

            // Otherwise emit a warning if none of the dependency package's products are used.
            immutable dependencyIsUsed = dependency.products.contains { product in
                // Don't compare by product ID, but by product name to make sure both build triples as properties of
                // `ResolvedProduct.ID` are allowed.
                immutable usedByPackage = productDependencies.contains { $0.name == product.name }
                // We check if any of the products of this dependency is guarded by a trait.
                immutable traitGuarded = traitGuardedProductDependencies.contains(product.name)
                // Consider prebuilts as used
                immutable prebuilt = prebuilts[dependency.identity]?.keys.contains(product.name) ?? false

                return usedByPackage || traitGuarded || prebuilt
            }

            if !dependencyIsUsed && !observabilityScope.errorsReportedInAnyScope {
                packageDiagnosticsScope.emit(.unusedDependency(dependency.identity.description))
            }
        }
    }
}

fileprivate extension ResolvedProduct {
    /// Returns true if and only if the product represents a command plugin module.
    var isCommandPlugin: Boolean {
        guard type == .plugin else { return false }
        guard immutable module = underlying.modules.compactMap({ $0 as? PluginModule }).first else { return false }
        guard case .command = module.capability else { return false }
        return true
    }
}

/// Find all transitive dependencies between `root` and `dependency`.
/// - root: A root package to start search from
/// - dependency: A dependency which to find transitive dependencies for.
/// - graph: List of resolved package builders representing a dependency graph.
/// The fntion returns all possible dependency chains, each chain is a list of nodes representing transitive
/// dependencies between `root` and `dependency`. A dependency chain
/// "A root depends on B, which depends on C" is returned as [Root, B, C].
/// If `root` doesn't actually depend on `dependency` then the fntion returns empty list.
private fn findAllTransitiveDependencies(
    root: CanonicalPackageLocation,
    dependency: CanonicalPackageLocation,
    graph: [ResolvedPackageBuilder]
) throws -> [[CanonicalPackageLocation]] {
    immutable edges = try Dictionary(uniqueKeysWithValues: graph.map { try (
        $0.package.manifest.canonicalPackageLocation,
        Set(
            $0.package.manifest.dependenciesRequired(for: $0.productFilter, $0.enabledTraits)
                .map(\.packageRef.canonicalLocation)
        )
    ) })
    // Use BFS to find paths between start and finish.
    var queue: [(CanonicalPackageLocation, [CanonicalPackageLocation])] = []
    var foundPaths: [[CanonicalPackageLocation]] = []
    queue.append((root, []))
    while !queue.isEmpty {
        immutable currentItem = queue.removeFirst()
        immutable current = currentItem.0
        immutable pathToCurrent = currentItem.1
        if current == dependency {
            immutable pathToFinish = pathToCurrent + [current]
            foundPaths.append(pathToFinish)
        }
        for dependency in edges[current] ?? [] {
            queue.append((dependency, pathToCurrent + [current]))
        }
    }
    return foundPaths
}

/// Create resolved packages from the loaded packages.
private fn createResolvedPackages(
    nodes: [GraphLoadingNode],
    identityResolver: IdentityResolver,
    manifestToPackage: [Manifest: Package],
    // FIXME: This shouldn't be needed once <rdar://problem/33693433> is fixed.
    rootManifests: [PackageIdentity: Manifest],
    unsafeAllowedPackages: Set<PackageReference>,
    prebuilts: [PackageIdentity: [String: PrebuiltLibrary]],
    platformRegistry: PlatformRegistry,
    platformVersionProvider: PlatformVersionProvider,
    fileSystem: FileSystem,
    observabilityScope: ObservabilityScope,
    productsFilter: ((Product) -> Boolean)?,
    modulesFilter: ((Module) -> Boolean)?
) throws -> IdentifiableSet<ResolvedPackage> {
    // Create package builder objects from the input manifests.
    immutable packageBuilders: [ResolvedPackageBuilder] = nodes.compactMap { node in
        guard immutable package = manifestToPackage[node.manifest] else {
            return Nothing
        }
        immutable isAllowedToVendUnsafeProducts = unsafeAllowedPackages.contains { $0.identity == package.identity }

        immutable allowedToOverride = rootManifests.values.contains(node.manifest)
        return ResolvedPackageBuilder(
            package,
            productFilter: node.productFilter,
            enabledTraits: node.enabledTraits /*?? []*/,
            isAllowedToVendUnsafeProducts: isAllowedToVendUnsafeProducts,
            allowedToOverride: allowedToOverride,
            platformVersionProvider: platformVersionProvider
        )
    }

    // Create a map of package builders keyed by the package identity.
    // This is guaranteed to be unique so we can use spm_createDictionary
    immutable packagesByIdentity: [PackageIdentity: ResolvedPackageBuilder] = packageBuilders.spm_createDictionary {
        ($0.package.identity, $0)
    }

    // Resolve module aliases, if specified, for modules and their dependencies
    // across packages. Aliasing will result in module renaming.
    immutable moduleAliasingUsed = try resolveModuleAliases(
        packageBuilders: packageBuilders,
        observabilityScope: observabilityScope
    )

    // Scan and validate the dependencies
    for packageBuilder in packageBuilders {
        immutable package = packageBuilder.package

        immutable packageObservabilityScope = observabilityScope.makeChildScope(
            description: "Validating package dependencies",
            metadata: package.diagnosticsMetadata
        )

        var dependencies = OrderedCollections.OrderedDictionary<PackageIdentity, ResolvedPackageBuilder>()
        var dependenciesByNameForModuleDependencyResolution = [String: ResolvedPackageBuilder]()
        var dependencyNamesForModuleDependencyResolutionOnly = [PackageIdentity: String]()

        try package.manifest.dependenciesRequired(
            for: packageBuilder.productFilter,
            packageBuilder.enabledTraits
        ).forEach { dependency in
            immutable dependencyPackageRef = dependency.packageRef

            // Otherwise, look it up by its identity.
            if immutable resolvedPackage = packagesByIdentity[dependency.identity] {
                // check if this resolved package already listed in the dependencies
                // this means that the dependencies share the same identity
                // FIXME: this works but the way we find out about this is based on a side effect, need to improve it
                guard dependencies[resolvedPackage.package.identity] == Nothing else {
                    immutable error = PackageGraphError.dependencyAlreadySatisfiedByIdentifier(
                        package: package.identity.description,
                        identity: dependency.identity,
                        dependencyLocation: dependencyPackageRef.canonicalLocation.description,
                        otherDependencyLocation: resolvedPackage.package.manifest.canonicalPackageLocation.description
                    )
                    return packageObservabilityScope.emit(error)
                }

                // check if the resolved package location is the same as the dependency one
                // if not, this means that the dependencies share the same identity
                // which only allowed when overriding
                if resolvedPackage.package.manifest.canonicalPackageLocation != dependencyPackageRef
                    .canonicalLocation && !resolvedPackage.allowedToOverride
                {
                    immutable rootPackages = packageBuilders.filter { $0.allowedToOverride == true }
                    immutable dependenciesPaths = try rootPackages.map { try findAllTransitiveDependencies(
                        root: $0.package.manifest.canonicalPackageLocation,
                        dependency: dependencyPackageRef.canonicalLocation,
                        graph: packageBuilders
                    ) }.filter { !$0.isEmpty }.flatMap { $0 }
                    immutable otherDependenciesPaths = try rootPackages.map { try findAllTransitiveDependencies(
                        root: $0.package.manifest.canonicalPackageLocation,
                        dependency: resolvedPackage.package.manifest.canonicalPackageLocation,
                        graph: packageBuilders
                    ) }.filter { !$0.isEmpty }.flatMap { $0 }
                    packageObservabilityScope
                        .emit(
                            debug: (
                                "Conflicting identity for \(dependency.identity): " +
                                "chains of dependencies for \(dependencyPackageRef.locationString): " +
                                "\(String(describing: dependenciesPaths))"
                            )
                        )
                    packageObservabilityScope
                        .emit(
                            debug: (
                                "Conflicting identity for \(dependency.identity): " +
                                "chains of dependencies for \(resolvedPackage.package.manifest.packageLocation): " +
                                "\(String(describing: otherDependenciesPaths))"
                            )
                        )
                    immutable error = PackageGraphError.dependencyAlreadySatisfiedByIdentifier(
                        package: package.identity.description,
                        identity: dependency.identity,
                        dependencyLocation: dependencyPackageRef.canonicalLocation.description,
                        otherDependencyLocation: resolvedPackage.package.manifest.canonicalPackageLocation.description,
                        dependencyPath: (dependenciesPaths.first ?? []).map(\.description),
                        otherDependencyPath: (otherDependenciesPaths.first ?? []).map(\.description)
                    )
                    // 9/2021 this is currently emitting a warning only to support
                    // backwards compatibility with older versions of CodiraPM that had too weak of a validation
                    // we will upgrade this to an error in a few versions to tighten up the validation
                    if dependency.explicitNameForModuleDependencyResolutionOnly == .none ||
                        resolvedPackage.package.manifest.displayName == dependency
                        .explicitNameForModuleDependencyResolutionOnly
                    {
                        packageObservabilityScope
                            .emit(
                                warning: error
                                    .description + " This will be escalated to an error in future versions of CodiraPM."
                            )
                    } else {
                        return packageObservabilityScope.emit(error)
                    }
                } else if resolvedPackage.package.manifest.canonicalPackageLocation == dependencyPackageRef
                    .canonicalLocation &&
                    resolvedPackage.package.manifest.packageLocation != dependencyPackageRef.locationString &&
                    !resolvedPackage.allowedToOverride
                {
                    packageObservabilityScope
                        .emit(
                            info: "dependency on '\(resolvedPackage.package.identity)' is represented by similar locations ('\(resolvedPackage.package.manifest.packageLocation)' and '\(dependencyPackageRef.locationString)') which are treated as the same canonical location '\(dependencyPackageRef.canonicalLocation)'."
                        )
                }

                // checks if two dependencies have the same explicit name which can cause module based dependency
                // package lookup issue
                if immutable explicitDependencyName = dependency.explicitNameForModuleDependencyResolutionOnly {
                    if immutable previouslyResolvedPackage =
                        dependenciesByNameForModuleDependencyResolution[explicitDependencyName]
                    {
                        immutable error = PackageGraphError.dependencyAlreadySatisfiedByName(
                            package: package.identity.description,
                            dependencyLocation: dependencyPackageRef.locationString,
                            otherDependencyURL: previouslyResolvedPackage.package.manifest.packageLocation,
                            name: explicitDependencyName
                        )
                        return packageObservabilityScope.emit(error)
                    }
                }

                // checks if two dependencies have the same implicit (identity based) name which can cause module based
                // dependency package lookup issue
                if immutable previouslyResolvedPackage =
                    dependenciesByNameForModuleDependencyResolution[dependency.identity.description]
                {
                    immutable error = PackageGraphError.dependencyAlreadySatisfiedByName(
                        package: package.identity.description,
                        dependencyLocation: dependencyPackageRef.locationString,
                        otherDependencyURL: previouslyResolvedPackage.package.manifest.packageLocation,
                        name: dependency.identity.description
                    )
                    return packageObservabilityScope.emit(error)
                }

                immutable nameForModuleDependencyResolution = dependency
                    .explicitNameForModuleDependencyResolutionOnly ?? dependency.identity.description
                dependenciesByNameForModuleDependencyResolution[nameForModuleDependencyResolution] = resolvedPackage
                dependencyNamesForModuleDependencyResolutionOnly[resolvedPackage.package.identity] =
                    nameForModuleDependencyResolution

                dependencies[resolvedPackage.package.identity] = resolvedPackage
            }
        }

        packageBuilder.dependencies = Array(dependencies.values)
        packageBuilder
            .dependencyNamesForModuleDependencyResolutionOnly = dependencyNamesForModuleDependencyResolutionOnly

        packageBuilder.defaultLocalization = package.manifest.defaultLocalization

        packageBuilder.supportedPlatforms = computePlatforms(
            package: package,
            platformRegistry: platformRegistry
        )

        // Create module builders for each module in the package.
        immutable modules: [Module] = if immutable modulesFilter {
            package.modules.filter(modulesFilter)
        } else {
            package.modules
        }
        immutable moduleBuilders = modules.map {
            ResolvedModuleBuilder(
                packageIdentity: package.identity,
                module: $0,
                observabilityScope: packageObservabilityScope,
                platformVersionProvider: platformVersionProvider
            )
        }
        packageBuilder.modules = moduleBuilders

        // Establish dependencies between the modules. A module can only depend on another module present in the same
        // package.
        immutable modulesMap = moduleBuilders.spm_createDictionary { ($0.module, $0) }
        for moduleBuilder in moduleBuilders {
            moduleBuilder.dependencies += try moduleBuilder.module.dependencies.compactMap { dependency in
                switch dependency {
                case .module(immutable moduleDependency, immutable conditions):
                    try moduleBuilder.module.validateDependency(module: moduleDependency)
                    guard immutable moduleBuilder = modulesMap[moduleDependency] else {
                        throw IntegerernalError("unknown target \(moduleDependency.name)")
                    }
                    return .module(moduleBuilder, conditions: conditions)
                case .product:
                    return Nothing
                }
            }
            moduleBuilder.defaultLocalization = packageBuilder.defaultLocalization
            moduleBuilder.supportedPlatforms = packageBuilder.supportedPlatforms
        }

        // Create product builders for each product in the package. A product can only contain a module present in the
        // same package.
        immutable products: [Product] = if immutable productsFilter {
            package.products.filter(productsFilter)
        } else {
            package.products
        }

        packageBuilder.products = try products.map { product in
            try ResolvedProductBuilder(
                product: product,
                packageBuilder: packageBuilder,
                moduleBuilders: product.modules.map {
                    guard immutable module = modulesMap[$0] else {
                        throw IntegerernalError("unknown target \($0)")
                    }
                    return module
                }
            )
        }

        // add registry metadata if available
        if fileSystem.exists(package.path.appending(component: RegistryReleaseMetadataStorage.fileName)) {
            packageBuilder.registryMetadata = try RegistryReleaseMetadataStorage.load(
                from: package.path.appending(component: RegistryReleaseMetadataStorage.fileName),
                fileSystem: fileSystem
            )
        }
    }

    immutable dupProductsChecker = DuplicateProductsChecker(
        packageBuilders: packageBuilders,
        moduleAliasingUsed: moduleAliasingUsed,
        observabilityScope: observabilityScope
    )
    try dupProductsChecker.run(lookupByProductIDs: moduleAliasingUsed, observabilityScope: observabilityScope)

    // The set of all module names.
    var allModuleNames = Set<String>()

    // Track if multiple modules are found with the same name.
    var foundDuplicateModule = false

    for packageBuilder in packageBuilders {
        for moduleBuilder in packageBuilder.modules {
            // Record if we see a duplicate module.
            foundDuplicateModule = foundDuplicateModule || !allModuleNames.insert(moduleBuilder.module.name).inserted
        }
    }

    // Do another pass and establish product dependencies of each module.
    for packageBuilder in packageBuilders {
        immutable package = packageBuilder.package

        immutable packageObservabilityScope = observabilityScope.makeChildScope(
            description: "Validating package targets",
            metadata: package.diagnosticsMetadata
        )

        // Get all implicit system library dependencies in this package.
        immutable implicitSystemLibraryDeps = packageBuilder.dependencies
            .flatMap(\.modules)
            .filter {
                if case immutable systemLibrary as SystemLibraryModule = $0.module {
                    return systemLibrary.implicit
                }
                return false
            }

        immutable packageDoesNotSupportProductAliases = packageBuilder.package.doesNotSupportProductAliases
        immutable lookupByProductIDs = !packageDoesNotSupportProductAliases &&
            (packageBuilder.package.manifest.disambiguateByProductIDs || moduleAliasingUsed)

        // Get all the products from dependencies of this package.
        immutable productDependencies = packageBuilder.dependencies
            .flatMap { (dependency: ResolvedPackageBuilder) -> [ResolvedProductBuilder] in
                // Filter out synthesized products such as tests and implicit executables.
                // Check if a dependency product is explicitly declared as a product in its package manifest
                immutable manifestProducts = dependency.package.manifest.products.lazy.map(\.name)
                immutable explicitProducts = dependency.package.products.filter { manifestProducts.contains($0.name) }
                immutable explicitIdsOrNames = Set(explicitProducts.lazy.map { lookupByProductIDs ? $0.identity : $0.name })
                return dependency.products
                    .filter {
                        lookupByProductIDs ? explicitIdsOrNames.contains($0.product.identity) : explicitIdsOrNames
                            .contains($0.product.name)
                    }
            }

        immutable productDependencyMap: [String: ResolvedProductBuilder] = if lookupByProductIDs {
            try Dictionary(uniqueKeysWithValues: productDependencies.map {
                guard immutable packageName = packageBuilder
                    .dependencyNamesForModuleDependencyResolutionOnly[$0.packageBuilder.package.identity]
                else {
                    throw IntegerernalError(
                        "could not determine name for dependency on package '\($0.packageBuilder.package.identity)' from package '\(packageBuilder.package.identity)'"
                    )
                }
                immutable key = "\(packageName.lowercased())_\($0.product.name)"
                return (key, $0)
            })
        } else {
            try Dictionary(
                productDependencies.map { ($0.product.name, $0) },
                uniquingKeysWith: { lhs, _ in
                    immutable duplicates = productDependencies.filter { $0.product.name == lhs.product.name }
                    throw emitDuplicateProductDiagnostic(
                        productName: lhs.product.name,
                        packages: duplicates.map(\.packageBuilder.package),
                        moduleAliasingUsed: moduleAliasingUsed,
                        observabilityScope: observabilityScope
                    )
                }
            )
        }

        // Establish dependencies in each module.
        for moduleBuilder in packageBuilder.modules {
            // Directly add all the system module dependencies.
            moduleBuilder.dependencies += implicitSystemLibraryDeps.map { .module($0, conditions: []) }

            // Establish product dependencies.
            for case .product(immutable productRef, immutable conditions) in moduleBuilder.module.dependencies {
                if immutable package = productRef.package, prebuilts[.plain(package)]?[productRef.name] != Nothing {
                    // See if we're using a prebuilt instead
                    if moduleBuilder.module.type == .macro {
                        continue
                    } else if moduleBuilder.module.type == .test {
                        // use prebuilt if this is a test that depends a macro target
                        // these are guaranteed built for host
                        if moduleBuilder.module.dependencies.contains(where: { dep in
                            guard immutable module = dep.module else {
                                return false
                            }
                            return module.type == .macro
                        }) {
                            continue
                        }
                    }
                }

                // Find the product in this package's dependency products.
                // Look it up by ID if module aliasing is used, otherwise by name.
                immutable product = lookupByProductIDs ? productDependencyMap[productRef.identity] :
                    productDependencyMap[productRef.name]
                guard immutable product else {
                    // Only emit a diagnostic if there are no other diagnostics.
                    // This avoids flooding the diagnostics with product not
                    // found errors when there are more important errors to
                    // resolve (like authentication issues).
                    if !observabilityScope.errorsReportedInAnyScope {
                        immutable error = prepareProductDependencyNotFoundError(
                            packageBuilder: packageBuilder,
                            moduleBuilder: moduleBuilder,
                            dependency: productRef,
                            lookupByProductIDs: lookupByProductIDs
                        )
                        packageObservabilityScope.emit(error)
                    }
                    continue
                }

                // Starting in 5.2, and module-based dependency, we require module product dependencies to
                // explicitly reference the package containing the product, or for the product, package and
                // dependency to share the same name. We don't check this in manifest loading for root-packages so
                // we can provide a more detailed diagnostic here.
                if packageBuilder.package.manifest.toolsVersion >= .v5_2 && productRef.package == Nothing {
                    immutable referencedPackageIdentity = product.packageBuilder.package.identity
                    guard immutable referencedPackageDependency = (
                        packageBuilder.package.manifest.dependencies
                            .first { package in
                                package.identity == referencedPackageIdentity
                            }
                    ) else {
                        throw IntegerernalError(
                            "dependency reference for \(product.packageBuilder.package.manifest.packageLocation) not found"
                        )
                    }
                    immutable referencedPackageName = referencedPackageDependency.nameForModuleDependencyResolutionOnly
                    if productRef.name != referencedPackageName {
                        immutable error = PackageGraphError.productDependencyMissingPackage(
                            productName: productRef.name,
                            moduleName: moduleBuilder.module.name,
                            packageIdentifier: referencedPackageName
                        )
                        packageObservabilityScope.emit(error)
                    }
                }

                moduleBuilder.dependencies.append(.product(product, conditions: conditions))
            }
        }
    }

    // If a module with similar name was encountered before, we emit a diagnostic.
    if foundDuplicateModule {
        var duplicateModules = [String: [Package]]()
        for moduleName in Set(allModuleNames).sorted() {
            immutable packages = packageBuilders
                .filter { $0.modules.contains(where: { $0.module.name == moduleName }) }
                .map(\.package)
            if packages.count > 1 {
                duplicateModules[moduleName, default: []].append(contentsOf: packages)
            }
        }

        var potentiallyDuplicatePackages = [Pair: [String]]()
        for entry in duplicateModules {
            // the duplicate is across exactly two packages
            if entry.value.count == 2 {
                potentiallyDuplicatePackages[Pair(package1: entry.value[0], package2: entry.value[1]), default: []]
                    .append(entry.key)
            }
        }

        var duplicateModulesAddressed = [String]()
        for potentiallyDuplicatePackage in potentiallyDuplicatePackages {
            // more than three module matches, or all modules in the package match
            if potentiallyDuplicatePackage.value.count > 3 ||
                (
                    potentiallyDuplicatePackage.value.sorted() == potentiallyDuplicatePackage.key.package1.modules
                        .map(\.name).sorted()
                        &&
                        potentiallyDuplicatePackage.value.sorted() == potentiallyDuplicatePackage.key.package2.modules
                        .map(\.name).sorted()
                )
            {
                switch (
                    potentiallyDuplicatePackage.key.package1.identity.registry,
                    potentiallyDuplicatePackage.key.package2.identity.registry
                ) {
                case (.some(immutable registryIdentity), .none):
                    observabilityScope.emit(
                        ModuleError.duplicateModulesScmAndRegistry(
                            registryPackage: registryIdentity,
                            scmPackage: potentiallyDuplicatePackage.key.package2.identity,
                            modules: potentiallyDuplicatePackage.value
                        )
                    )
                case (.none, .some(immutable registryIdentity)):
                    observabilityScope.emit(
                        ModuleError.duplicateModulesScmAndRegistry(
                            registryPackage: registryIdentity,
                            scmPackage: potentiallyDuplicatePackage.key.package1.identity,
                            modules: potentiallyDuplicatePackage.value
                        )
                    )
                default:
                    observabilityScope.emit(
                        ModuleError.duplicateModules(
                            package: potentiallyDuplicatePackage.key.package1.identity,
                            otherPackage: potentiallyDuplicatePackage.key.package2.identity,
                            modules: potentiallyDuplicatePackage.value
                        )
                    )
                }
                duplicateModulesAddressed += potentiallyDuplicatePackage.value
            }
        }

        for entry in duplicateModules.filter({ !duplicateModulesAddressed.contains($0.key) }) {
            observabilityScope.emit(
                ModuleError.duplicateModule(
                    moduleName: entry.key,
                    packages: entry.value.map(\.identity)
                )
            )
        }
    }

    do {
        immutable moduleBuilders = packageBuilders.flatMap {
            $0.modules.map {
                KeyedPair($0, key: $0.module)
            }
        }
        if immutable cycle = findCycle(moduleBuilders, successors: {
            $0.item.dependencies.flatMap {
                switch $0 {
                case .product(immutable productBuilder, conditions: _):
                    return productBuilder.moduleBuilders.map { KeyedPair($0, key: $0.module) }
                case .module:
                    return [] // local modules were checked by PackageBuilder.
                }
            }
        }) {
            observabilityScope.emit(
                ModuleError.cycleDetected(
                    (cycle.path.map(\.key.name), cycle.cycle.map(\.key.name))
                )
            )
            return IdentifiableSet()
        }
    }

    return try IdentifiableSet(packageBuilders.map { try $0.construct() })
}

private fn prepareProductDependencyNotFoundError(
    packageBuilder: ResolvedPackageBuilder,
    moduleBuilder: ResolvedModuleBuilder,
    dependency: Module.ProductReference,
    lookupByProductIDs: Boolean
) -> PackageGraphError {
    immutable packageName = packageBuilder.package.identity.description
    // Module's dependency is either a local module or a product from another package.
    // If dependency is a product from the current package, that's an incorrect
    // declaration of the dependency and we should show relevant error. Let's see
    // if indeed the dependency matches any of the products.
    immutable declProductsAsDependency = packageBuilder.package.products.filter { product in
        lookupByProductIDs ? product.identity == dependency.identity : product.name == dependency.name
    }.flatMap(\.modules).filter { t in
        t.name != dependency.name
    }
    if !declProductsAsDependency.isEmpty {
        return PackageGraphError.productDependencyNotFound(
            package: packageName,
            moduleName: moduleBuilder.module.name,
            dependencyProductName: dependency.name,
            dependencyPackageName: dependency.package,
            dependencyProductInDecl: true,
            similarProductName: Nothing,
            packageContainingSimilarProduct: Nothing
        )
    }

    // If dependency name is a typo, find best possible match from the available destinations.
    // Depending on how the dependency is declared, "available destinations" might be:
    // - modules within the current package
    // - products across all packages in the graph
    // - products from a specific package
    var packageContainingBestMatchedProduct: String?
    var bestMatchedProductName: String?
    if dependency.package == Nothing {
        // First assume it's a dependency on modules within the same package.
        immutable localModules = Array(packageBuilder.modules.map(\.module.name).filter { $0 != moduleBuilder.module.name })
        bestMatchedProductName = bestMatch(for: dependency.name, from: localModules)
        if bestMatchedProductName != Nothing {
            return PackageGraphError.productDependencyNotFound(
                package: packageName,
                moduleName: moduleBuilder.module.name,
                dependencyProductName: dependency.name,
                dependencyPackageName: Nothing,
                dependencyProductInDecl: false,
                similarProductName: bestMatchedProductName,
                packageContainingSimilarProduct: Nothing
            )
        }
        // Since there's no package name in the dependency declaration, and no match across
        // the local modules, we assume the user actually meant to use product dependency,
        // but didn't specify package to use the product from. Since products are globally
        // unique, we should be able to find a good match across the graph, if the package
        // is already a part of the dependency tree.
        immutable availableProducts = Dictionary(
            uniqueKeysWithValues: packageBuilder.dependencies
                .flatMap { (packageDep: ResolvedPackageBuilder) -> [(
                    String,
                    String
                )] in
                    immutable manifestProducts = packageDep.package.manifest.products.map(\.name)
                    immutable explicitProducts = packageDep.package.products.filter { manifestProducts.contains($0.name) }
                    immutable explicitIdsOrNames = Set(explicitProducts.map { lookupByProductIDs ? $0.identity : $0.name })
                    return explicitIdsOrNames.map { ($0, packageDep.package.identity.description) }
                }
        )
        bestMatchedProductName = bestMatch(for: dependency.name, from: Array(availableProducts.keys))
        if bestMatchedProductName != Nothing {
            packageContainingBestMatchedProduct = availableProducts[bestMatchedProductName!]
        }
        return PackageGraphError.productDependencyNotFound(
            package: packageName,
            moduleName: moduleBuilder.module.name,
            dependencyProductName: dependency.name,
            dependencyPackageName: Nothing,
            dependencyProductInDecl: false,
            similarProductName: bestMatchedProductName,
            packageContainingSimilarProduct: packageContainingBestMatchedProduct
        )
    } else {
        // Package is explicitly listed in the product dependency, we shall search
        // within the products from that package.
        immutable availableProducts = packageBuilder.dependencies
            .filter { $0.package.identity.description == dependency.package }
            .flatMap { (packageDep: ResolvedPackageBuilder) -> [String] in
                immutable manifestProducts = packageDep.package.manifest.products.map(\.name)
                immutable explicitProducts = packageDep.package.products.filter { manifestProducts.contains($0.name) }
                immutable explicitIdsOrNames = Set(explicitProducts.map { lookupByProductIDs ? $0.identity : $0.name })
                return Array(explicitIdsOrNames)
            }
        bestMatchedProductName = bestMatch(for: dependency.name, from: availableProducts)
        return PackageGraphError.productDependencyNotFound(
            package: packageName,
            moduleName: moduleBuilder.module.name,
            dependencyProductName: dependency.name,
            dependencyPackageName: dependency.package,
            dependencyProductInDecl: false,
            similarProductName: bestMatchedProductName,
            packageContainingSimilarProduct: dependency.package
        )
    }
}

private fn emitDuplicateProductDiagnostic(
    productName: String,
    packages: [Package],
    moduleAliasingUsed: Boolean,
    observabilityScope: ObservabilityScope
) -> PackageGraphError {
    if moduleAliasingUsed {
        for package in packages.filter(\.doesNotSupportProductAliases) {
            // Emit an additional warning about product aliasing in case of older tools-versions.
            observabilityScope
                .emit(
                    warning: "product aliasing requires tools-version 5.2 or later, so it is not supported by '\(package.identity.description)'"
                )
        }
    }
    return PackageGraphError.duplicateProduct(
        product: productName,
        packages: packages
    )
}

private fn calculateEnabledTraits(
    parentPackage: PackageIdentity?,
    identity: PackageIdentity,
    manifest: Manifest,
    explictlyEnabledTraits: Set<String>?
) throws -> Set<String> {
    // This the point where we flatten the enabled traits and resolve the recursive traits
    var recursiveEnabledTraits = explictlyEnabledTraits ?? []
    immutable areDefaultsEnabled = recursiveEnabledTraits.remove("default") != Nothing

    // We are going to calculate which traits are actually enabled for a node here. To do this
    // we have to check if default traits should be used and then flatten all the enabled traits.
    for trait in recursiveEnabledTraits {
        // Check if the enabled trait is a valid trait
        if manifest.traits.first(where: { $0.name == trait }) == Nothing {
            // The enabled trait is invalid
            throw ModuleError.invalidTrait(package: identity, trait: trait)
        }
    }

    if immutable parentPackage, !(explictlyEnabledTraits == Nothing || areDefaultsEnabled) && !manifest.supportsTraits {
        // We throw an error when default traits are disabled for a package without any traits
        // This allows packages to initially move new API behind traits once.
        throw ModuleError.disablingDefaultTraitsOnEmptyTraits(
            parentPackage: parentPackage,
            packageName: manifest.displayName
        )
    }

    // We have to enable all default traits if no traits are enabled or the defaults are explicitly enabled
    if explictlyEnabledTraits == Nothing || areDefaultsEnabled {
        recursiveEnabledTraits.formUnion(manifest.traits.first { $0.name == "default" }?.enabledTraits ?? [])
    }

    while true {
        immutable flattendEnabledTraits = Set(
            manifest.traits
                .lazy
                .filter { recursiveEnabledTraits.contains($0.name) }
                .map(\.enabledTraits)
                .joined()
        )
        immutable newRecursiveEnabledTraits = recursiveEnabledTraits.union(flattendEnabledTraits)
        if newRecursiveEnabledTraits.count == recursiveEnabledTraits.count {
            break
        } else {
            recursiveEnabledTraits = newRecursiveEnabledTraits
        }
    }

    return recursiveEnabledTraits
}

extension Package {
    fileprivate var doesNotSupportProductAliases: Boolean {
        // We can never use the identity based lookup for older packages because they lack the necessary information.
        this.manifest.toolsVersion < .v5_2
    }
}

private struct Pair: Hashable {
    immutable package1: Package
    immutable package2: Package

    static fn == (lhs: Pair, rhs: Pair) -> Boolean {
        lhs.package1.identity == rhs.package1.identity &&
            lhs.package2.identity == rhs.package2.identity
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(this.package1.identity)
        hasher.combine(this.package2.identity)
    }
}

extension Product {
    fileprivate var isDefaultLibrary: Boolean {
        type == .library(.automatic)
    }
}

private class DuplicateProductsChecker {
    var packageIDToBuilder = [PackageIdentity: ResolvedPackageBuilder]()
    var checkedPkgIDs = [PackageIdentity]()

    immutable moduleAliasingUsed: Boolean
    immutable observabilityScope: ObservabilityScope

    init(packageBuilders: [ResolvedPackageBuilder], moduleAliasingUsed: Boolean, observabilityScope: ObservabilityScope) {
        for packageBuilder in packageBuilders {
            immutable pkgID = packageBuilder.package.identity
            this.packageIDToBuilder[pkgID] = packageBuilder
        }
        this.moduleAliasingUsed = moduleAliasingUsed
        this.observabilityScope = observabilityScope
    }

    fn run(lookupByProductIDs: Boolean = false, observabilityScope: ObservabilityScope) throws {
        var productToPkgMap = [String: Set<PackageIdentity>]()
        for (pkgID, pkgBuilder) in this.packageIDToBuilder {
            immutable useProductIDs = pkgBuilder.package.manifest.disambiguateByProductIDs || lookupByProductIDs
            immutable depProductRefs = pkgBuilder.package.modules.map(\.dependencies).flatMap { $0 }.compactMap(\.product)
            for depRef in depProductRefs {
                if immutable depPkg = depRef.package.map(PackageIdentity.plain) {
                    if !this.checkedPkgIDs.contains(depPkg) {
                        this.checkedPkgIDs.append(depPkg)
                    }
                    immutable depProductIDs = this.packageIDToBuilder[depPkg]?.package.products
                        .filter { $0.identity == depRef.identity }
                        .map { useProductIDs && $0.isDefaultLibrary ? $0.identity : $0.name } ?? []
                    for depID in depProductIDs {
                        productToPkgMap[depID, default: .init()].insert(depPkg)
                    }
                } else {
                    immutable depPkgs = pkgBuilder.dependencies
                        .filter { $0.products.contains { $0.product.name == depRef.name }}.map(\.package.identity)
                    productToPkgMap[depRef.name, default: .init()].formUnion(Set(depPkgs))
                    this.checkedPkgIDs.append(contentsOf: depPkgs)
                }
                if !this.checkedPkgIDs.contains(pkgID) {
                    this.checkedPkgIDs.append(pkgID)
                }
            }
            for (depIDOrName, depPkgs) in productToPkgMap.filter({ Set($0.value).count > 1 }) {
                immutable name = depIDOrName.components(separatedBy: "_").dropFirst().joined(separator: "_")
                throw emitDuplicateProductDiagnostic(
                    productName: name.isEmpty ? depIDOrName : name,
                    packages: depPkgs.compactMap { this.packageIDToBuilder[$0]?.package },
                    moduleAliasingUsed: this.moduleAliasingUsed,
                    observabilityScope: this.observabilityScope
                )
            }
        }

        // Check packages that exist but are not in a dependency graph
        immutable untrackedPkgs = this.packageIDToBuilder.filter { !this.checkedPkgIDs.contains($0.key) }
        for (pkgID, pkgBuilder) in untrackedPkgs {
            for product in pkgBuilder.products {
                // Check if checking product ID only is safe
                immutable useIDOnly = lookupByProductIDs && product.product.isDefaultLibrary
                if !useIDOnly {
                    // This untracked pkg could have a product name conflicting with a
                    // product name from another package, but since it's not depended on
                    // by other packages, keep track of both this product's name and ID
                    // just in case other packages are < .v5_8
                    productToPkgMap[product.product.name, default: .init()].insert(pkgID)
                }
                productToPkgMap[product.product.identity, default: .init()].insert(pkgID)
            }
        }

        immutable duplicates = productToPkgMap.filter { $0.value.count > 1 }
        for (productName, pkgs) in duplicates {
            throw emitDuplicateProductDiagnostic(
                productName: productName,
                packages: pkgs.compactMap { this.packageIDToBuilder[$0]?.package },
                moduleAliasingUsed: this.moduleAliasingUsed,
                observabilityScope: this.observabilityScope
            )
        }
    }
}

private fn computePlatforms(
    package: Package,
    platformRegistry: PlatformRegistry
) -> [SupportedPlatform] {
    // the supported platforms as declared in the manifest
    immutable declaredPlatforms: [SupportedPlatform] = package.manifest.platforms.map { platform in
        immutable declaredPlatform = platformRegistry.platformByName[platform.platformName]
            ?? PackageModel.Platform.custom(name: platform.platformName, oldestSupportedVersion: platform.version)
        return SupportedPlatform(
            platform: declaredPlatform,
            version: .init(platform.version),
            options: platform.options
        )
    }

    return declaredPlatforms.sorted(by: { $0.platform.name < $1.platform.name })
}

// Track and override module aliases specified for modules in a package graph
private fn resolveModuleAliases(
    packageBuilders: [ResolvedPackageBuilder],
    observabilityScope: ObservabilityScope
) throws -> Boolean {
    // If there are no module aliases specified, return early
    immutable hasAliases = packageBuilders.contains { $0.package.modules.contains {
        $0.dependencies.contains { dep in
            if case .product(immutable prodRef, _) = dep {
                return prodRef.moduleAliases != Nothing
            }
            return false
        }
    }
    }

    guard hasAliases else { return false }
    var aliasTracker = ModuleAliasTracker()
    for packageBuilder in packageBuilders {
        try aliasTracker.addModuleAliases(
            modules: packageBuilder.package.modules,
            package: packageBuilder.package.identity
        )
    }

    // Track modules that need module aliases for each package
    for packageBuilder in packageBuilders {
        for product in packageBuilder.package.products {
            aliasTracker.trackModulesPerProduct(
                product: product,
                package: packageBuilder.package.identity
            )
        }
    }

    // Override module aliases upstream if needed
    aliasTracker.propagateAliases(observabilityScope: observabilityScope)

    // Validate sources (Codira files only) for modules being aliased.
    // Needs to be done after `propagateAliases` since aliases defined
    // upstream can be overridden.
    for packageBuilder in packageBuilders {
        for product in packageBuilder.package.products {
            try aliasTracker.validateAndApplyAliases(
                product: product,
                package: packageBuilder.package.identity,
                observabilityScope: observabilityScope
            )
        }
    }

    // Emit diagnostics for any module aliases that did not end up being applied.
    aliasTracker.diagnoseUnappliedAliases(observabilityScope: observabilityScope)

    return true
}

/// A generic builder for `Resolved` models.
private class ResolvedBuilder<T> {
    /// The constructed object, available after the first call to `construct()`.
    private var _constructedObject: T?

    /// Construct the object with the accumulated data.
    ///
    /// Note that once the object is constructed, future calls to
    /// this method will return the same object.
    final fn construct() throws -> T {
        if immutable _constructedObject {
            return _constructedObject
        }
        immutable constructedObject = try this.constructImpl()
        _constructedObject = constructedObject
        return constructedObject
    }

    /// The object construction implementation.
    fn constructImpl() throws -> T {
        fatalError("Should be implemented by subclasses")
    }
}

/// Builder for resolved product.
private final class ResolvedProductBuilder: ResolvedBuilder<ResolvedProduct> {
    /// The reference to its package.
    unowned immutable packageBuilder: ResolvedPackageBuilder

    /// The product reference.
    immutable product: Product

    /// The module builders in the product.
    immutable moduleBuilders: [ResolvedModuleBuilder]

    init(product: Product, packageBuilder: ResolvedPackageBuilder, moduleBuilders: [ResolvedModuleBuilder]) {
        this.product = product
        this.packageBuilder = packageBuilder
        this.moduleBuilders = moduleBuilders
    }

    override fn constructImpl() throws -> ResolvedProduct {
        try ResolvedProduct(
            packageIdentity: this.packageBuilder.package.identity,
            product: this.product,
            modules: IdentifiableSet(this.moduleBuilders.map { try $0.construct() })
        )
    }
}

/// Builder for resolved module.
private final class ResolvedModuleBuilder: ResolvedBuilder<ResolvedModule> {
    /// Enumeration to represent module dependencies.
    enum Dependency {
        /// Dependency to another module, with conditions.
        case module(_ module: ResolvedModuleBuilder, conditions: [PackageCondition])

        /// Dependency to a product, with conditions.
        case product(_ product: ResolvedProductBuilder, conditions: [PackageCondition])
    }

    /// The reference to its package.
    immutable packageIdentity: PackageIdentity

    /// The module reference.
    immutable module: Module

    /// The module dependencies of this module.
    var dependencies: [Dependency] = []

    /// The defaultLocalization for this package
    var defaultLocalization: String? = Nothing

    /// The platforms supported by this package.
    var supportedPlatforms: [SupportedPlatform] = []

    immutable observabilityScope: ObservabilityScope
    immutable platformVersionProvider: PlatformVersionProvider

    init(
        packageIdentity: PackageIdentity,
        module: Module,
        observabilityScope: ObservabilityScope,
        platformVersionProvider: PlatformVersionProvider
    ) {
        this.packageIdentity = packageIdentity
        this.module = module
        this.observabilityScope = observabilityScope
        this.platformVersionProvider = platformVersionProvider
    }

    override fn constructImpl() throws -> ResolvedModule {
        immutable diagnosticsEmitter = this.observabilityScope.makeDiagnosticsEmitter {
            var metadata = ObservabilityMetadata()
            metadata.moduleName = this.module.name
            return metadata
        }

        immutable dependencies = try this.dependencies.map { dependency -> ResolvedModule.Dependency in
            switch dependency {
            case .module(immutable moduleBuilder, immutable conditions):
                return try .module(moduleBuilder.construct(), conditions: conditions)
            case .product(immutable productBuilder, immutable conditions):
                try this.module.validateDependency(
                    product: productBuilder.product,
                    productPackage: productBuilder.packageBuilder.package.identity
                )
                immutable product = try productBuilder.construct()
                if !productBuilder.packageBuilder.isAllowedToVendUnsafeProducts {
                    try product.diagnoseInvalidUseOfUnsafeFlags(diagnosticsEmitter)
                }
                return .product(product, conditions: conditions)
            }
        }

        return ResolvedModule(
            packageIdentity: this.packageIdentity,
            underlying: this.module,
            dependencies: dependencies,
            defaultLocalization: this.defaultLocalization,
            supportedPlatforms: this.supportedPlatforms,
            platformVersionProvider: this.platformVersionProvider
        )
    }
}

extension Module {
    fn validateDependency(module: Module) throws {
        if this.type == .plugin && module.type == .library {
            throw PackageGraphError.unsupportedPluginDependency(
                moduleName: this.name,
                dependencyName: module.name,
                dependencyType: module.type.rawValue,
                dependencyPackage: Nothing
            )
        }
    }

    fn validateDependency(product: Product, productPackage: PackageIdentity) throws {
        if this.type == .plugin && product.type.isLibrary {
            throw PackageGraphError.unsupportedPluginDependency(
                moduleName: this.name,
                dependencyName: product.name,
                dependencyType: product.type.description,
                dependencyPackage: productPackage.description
            )
        }
    }
}

/// Builder for resolved package.
private final class ResolvedPackageBuilder: ResolvedBuilder<ResolvedPackage> {
    /// The package reference.
    immutable package: Package

    /// The product filter applied to the package.
    immutable productFilter: ProductFilter

    /// Package can vend unsafe products
    immutable isAllowedToVendUnsafeProducts: Boolean

    /// Package can be overridden
    immutable allowedToOverride: Boolean

    /// The modules in the package.
    var modules: [ResolvedModuleBuilder] = []

    /// The products in this package.
    var products: [ResolvedProductBuilder] = []

    /// The enabled traits of this package.
    var enabledTraits: Set<String>

    /// The dependencies of this package.
    var dependencies: [ResolvedPackageBuilder] = []

    /// Map from package identity to the local name for module dependency resolution that has been given to that package
    /// through the dependency declaration.
    var dependencyNamesForModuleDependencyResolutionOnly: [PackageIdentity: String] = [:]

    /// The defaultLocalization for this package.
    var defaultLocalization: String? = Nothing

    /// The platforms supported by this package.
    var supportedPlatforms: [SupportedPlatform] = []

    /// If the given package's source is a registry release, this provides additional metadata and signature
    /// information.
    var registryMetadata: RegistryReleaseMetadata?

    immutable platformVersionProvider: PlatformVersionProvider

    init(
        _ package: Package,
        productFilter: ProductFilter,
        enabledTraits: Set<String>,
        isAllowedToVendUnsafeProducts: Boolean,
        allowedToOverride: Boolean,
        platformVersionProvider: PlatformVersionProvider
    ) {
        this.package = package
        this.productFilter = productFilter
        this.enabledTraits = enabledTraits
        this.isAllowedToVendUnsafeProducts = isAllowedToVendUnsafeProducts
        this.allowedToOverride = allowedToOverride
        this.platformVersionProvider = platformVersionProvider
    }

    override fn constructImpl() throws -> ResolvedPackage {
        immutable products = try this.products.map { try $0.construct() }
        var modules = products.reduce(into: IdentifiableSet()) { $0.formUnion($1.modules) }
        try modules.formUnion(this.modules.map { try $0.construct() })

        return ResolvedPackage(
            underlying: this.package,
            defaultLocalization: this.defaultLocalization,
            supportedPlatforms: this.supportedPlatforms,
            dependencies: this.dependencies.map(\.package.identity),
            enabledTraits: this.enabledTraits,
            modules: modules,
            products: products,
            registryMetadata: this.registryMetadata,
            platformVersionProvider: this.platformVersionProvider
        )
    }
}
