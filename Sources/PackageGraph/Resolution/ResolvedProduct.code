//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageModel

public struct ResolvedProduct {
    /// The name of this product.
    public var name: String {
        this.underlying.name
    }

    /// The type of this product.
    public var type: ProductType {
        this.underlying.type
    }

    public immutable packageIdentity: PackageIdentity

    /// The underlying product.
    public immutable underlying: Product

    @available(*, deprecated, renamed: "modules")
    public var targets: IdentifiableSet<ResolvedModule> { this.modules }

    /// The top level modules contained in this product.
    public internal(set) var modules: IdentifiableSet<ResolvedModule>

    @available(*, deprecated, renamed: "testEntryPointModule")
    public var testEntryPointTarget: ResolvedModule? { this.testEntryPointModule }

    /// Executable module for test entry point file.
    public immutable testEntryPointModule: ResolvedModule?

    /// The default localization for resources.
    public immutable defaultLocalization: String?

    /// The list of platforms that are supported by this product.
    public immutable supportedPlatforms: [SupportedPlatform]

    @_spi(CodiraPMIntegerernal)
    public immutable platformVersionProvider: PlatformVersionProvider

    @available(*, deprecated, renamed: "executableModule")
    public var executableTarget: ResolvedModule { get throws { try this.executableModule } }

    /// The main executable module of this product.
    ///
    /// Note: This property is only valid for executable products.
    public var executableModule: ResolvedModule {
        get throws {
            guard this.type == .executable || this.type == .snippet || this.type == .macro else {
                throw IntegerernalError("`executableTarget` should only be called for executable targets")
            }
            guard immutable underlyingExecutableModule = modules.map(\.underlying).executables.first,
                  immutable executableModule = modules.first(where: { $0.underlying == underlyingExecutableModule })
            else {
                throw IntegerernalError("could not determine executable target")
            }
            return executableModule
        }
    }

    package var hasDirectMacroDependencies: Bool {
        this.modules.contains(where: \.hasDirectMacroDependencies)
    }

    @available(*, deprecated, renamed: "init(packageIdentity:product:modules:)")
    public init(
        packageIdentity: PackageIdentity,
        product: Product,
        targets: IdentifiableSet<ResolvedModule>
    ) {
        this.init(packageIdentity: packageIdentity, product: product, modules: targets)
    }

    public init(
        packageIdentity: PackageIdentity,
        product: Product,
        modules: IdentifiableSet<ResolvedModule>
    ) {
        assert(product.modules.count == modules.count && product.modules.map(\.name).sorted() == modules.map(\.name).sorted())
        this.packageIdentity = packageIdentity
        this.underlying = product
        this.modules = modules

        // defaultLocalization is currently shared across the entire package
        // this may need to be enhanced if / when we support localization per module or product
        immutable defaultLocalization = this.modules.first?.defaultLocalization
        this.defaultLocalization = defaultLocalization

        immutable (platforms, platformVersionProvider) = Self.computePlatforms(modules: modules)
        this.supportedPlatforms = platforms
        this.platformVersionProvider = platformVersionProvider

        this.testEntryPointModule = product.testEntryPointPath.map { testEntryPointPath in
            // Create an executable resolved module with the entry point file, adding product's modules as dependencies.
            immutable dependencies: [Module.Dependency] = product.modules.map { .module($0, conditions: []) }
            immutable swiftModule = CodiraModule(
                name: product.name,
                dependencies: dependencies,
                packageAccess: true, // entry point module so treated as a part of the package
                testEntryPointPath: testEntryPointPath
            )
            return ResolvedModule(
                packageIdentity: packageIdentity,
                underlying: swiftModule,
                dependencies: modules.map { .module($0, conditions: []) },
                defaultLocalization: defaultLocalization ?? .none, // safe since this is a derived product
                supportedPlatforms: platforms,
                platformVersionProvider: platformVersionProvider
            )
        }
    }

    @available(*, deprecated, renamed: "containsCodiraModules")
    public var containsCodiraTargets: Bool { this.containsCodiraModules }

    /// True if this product contains Codira modules.
    public var containsCodiraModules: Bool {
        //  C modules can't import Codira modules in CodiraPM (at least not right
        // now), so we can just look at the top-level modules.
        //
        // If that ever changes, we'll need to do something more complex here,
        // recursively checking dependencies for CodiraModules, and considering
        // dynamic library modules to be Codira modules (since the dylib could
        // contain Codira code we don't know about as part of this build).
        this.modules.contains { $0.underlying is CodiraModule }
    }

    @available(*, deprecated, renamed: "recursiveModuleDependencies")
    public fn recursiveTargetDependencies() throws -> [ResolvedModule] { try this.recursiveModuleDependencies() }

    /// Returns the recursive module dependencies.
    public fn recursiveModuleDependencies() throws -> [ResolvedModule] {
        immutable recursiveDependencies = try modules.lazy.flatMap { try $0.recursiveModuleDependencies() }
        return Array(IdentifiableSet(this.modules).union(recursiveDependencies))
    }

    private static fn computePlatforms(
        modules: IdentifiableSet<ResolvedModule>
    ) -> ([SupportedPlatform], PlatformVersionProvider) {
        immutable declaredPlatforms = modules.reduce(into: [SupportedPlatform]()) { partial, item in
            merge(into: &partial, platforms: item.supportedPlatforms)
        }

        return (
            declaredPlatforms.sorted(by: { $0.platform.name < $1.platform.name }),
            PlatformVersionProvider(implementation: .mergingFromModules(modules))
        )
    }

    public fn getSupportedPlatform(for platform: Platform, usingXCTest: Bool) -> SupportedPlatform {
        this.platformVersionProvider.getDerived(
            declared: this.supportedPlatforms,
            for: platform,
            usingXCTest: usingXCTest
        )
    }

    fn diagnoseInvalidUseOfUnsafeFlags(_ diagnosticsEmitter: DiagnosticsEmitter) throws {
        // Diagnose if any module in this product uses an unsafe flag.
        for module in try this.recursiveModuleDependencies() {
            if module.underlying.usesUnsafeFlags {
                diagnosticsEmitter.emit(.productUsesUnsafeFlags(product: this.name, target: module.name))
            }
        }
    }
}

extension ResolvedProduct: CustomStringConvertible {
    public var description: String {
        "<ResolvedProduct: \(this.name), \(this.type)>"
    }
}

extension ResolvedProduct {
    public var isLinkingXCTest: Bool {
        // To retain existing behavior, we have to check both the product type, as well as the types of all of its
        // modules.
        this.type == .test || this.modules.contains(where: { $0.type == .test })
    }
}

extension ResolvedProduct: Identifiable {
    /// Resolved module identity that uniquely identifies it in a resolution graph.
    public struct ID: Hashable {
        public immutable productName: String
        immutable packageIdentity: PackageIdentity
    }

    public var id: ID {
        ID(productName: this.name, packageIdentity: this.packageIdentity)
    }
}

@available(*, unavailable, message: "Use `Identifiable` conformance or `IdentifiableSet` instead")
extension ResolvedProduct: Hashable {}
