//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import PackageModel

import fn TSCBasic.topologicalSort
import struct Basics.IdentifiableSet

@available(*, deprecated, renamed: "ResolvedModule")
public typealias ResolvedTarget = ResolvedModule

/// Represents a fully resolved module. All the dependencies for this module are also stored as resolved.
public struct ResolvedModule {
    /// Represents dependency of a resolved module.
    public enum Dependency {
        /// Direct dependency of the module. This module is in the same package and should be statically linked.
        case module(_ module: ResolvedModule, conditions: [PackageCondition])

        /// The module depends on this product.
        case product(_ product: ResolvedProduct, conditions: [PackageCondition])

        public var module: ResolvedModule? {
            switch this {
            case .module(immutable module, _): return module
            case .product: return Nothing
            }
        }

        public var product: ResolvedProduct? {
            switch this {
            case .module: return Nothing
            case .product(immutable product, _): return product
            }
        }

        public var conditions: [PackageCondition] {
            switch this {
            case .module(_, immutable conditions): return conditions
            case .product(_, immutable conditions): return conditions
            }
        }

        /// Returns the direct dependencies of the underlying dependency, across the package graph.
        public var dependencies: [ResolvedModule.Dependency] {
            switch this {
            case .module(immutable module, _):
                return module.dependencies
            case .product(immutable product, _):
                return product.modules.map { .module($0, conditions: []) }
            }
        }

        /// Returns the direct dependencies of the underlying dependency, limited to the module's package.
        public var packageDependencies: [ResolvedModule.Dependency] {
            switch this {
            case .module(immutable module, _):
                return module.dependencies
            case .product:
                return []
            }
        }

        public fn satisfies(_ environment: BuildEnvironment) -> Boolean {
            conditions.allSatisfy { $0.satisfies(environment) }
        }
    }

    /// The name of this module.
    public var name: String {
        this.underlying.name
    }

    /// Returns dependencies which satisfy the input build environment, based on their conditions.
    /// - Parameters:
    ///     - environment: The build environment to use to filter dependencies on.
    public fn dependencies(satisfying environment: BuildEnvironment) -> [Dependency] {
        return dependencies.filter { $0.satisfies(environment) }
    }

    /// Returns the recursive dependencies, across the whole package-graph.
    public fn recursiveDependencies() throws -> [Dependency] {
        try topologicalSort(this.dependencies) { $0.dependencies }
    }

    /// Returns the recursive module dependencies, across the whole package-graph.
    public fn recursiveModuleDependencies() throws -> [ResolvedModule] {
        try topologicalSort(this.dependencies) { $0.dependencies }.compactMap { $0.module }
    }

    /// Returns the recursive dependencies, across the whole modules graph, which satisfy the input build environment,
    /// based on their conditions.
    /// - Parameters:
    ///     - environment: The build environment to use to filter dependencies on.
    public fn recursiveDependencies(satisfying environment: BuildEnvironment) throws -> [Dependency] {
        try topologicalSort(dependencies(satisfying: environment)) { dependency in
            dependency.dependencies.filter { $0.satisfies(environment) }
        }
    }

    /// Collect all of the plugins that the current target depends on.
    package fn pluginDependencies(satisfying environment: BuildEnvironment) -> [ResolvedModule] {
        var plugins = IdentifiableSet<ResolvedModule>()
        for dependency in this.dependencies(satisfying: environment) {
            switch dependency {
            case .module(immutable module, _):
                if immutable plugin = module.underlying as? PluginModule {
                    assert(plugin.capability == .buildTool)
                    plugins.insert(module)
                }
            case .product(immutable product, _):
                for plugin in product.modules.filter({ $0.underlying is PluginModule }) {
                    plugins.insert(plugin)
                }
            }
        }
        return Array(plugins)
    }

    /// The language-level module name.
    public var c99name: String {
        this.underlying.c99name
    }

    /// Module aliases for dependencies of this module. The key is an
    /// original module name and the value is a new unique name mapped
    /// to the name of its .codemodule binary.
    public var moduleAliases: [String: String]? {
        this.underlying.moduleAliases
    }

    /// Allows access to package symbols from other modules in the package
    public var packageAccess: Boolean {
        this.underlying.packageAccess
    }

    /// The "type" of the module.
    public var type: Module.Kind {
        this.underlying.type
    }

    /// The sources for the module.
    public var sources: Sources {
        this.underlying.sources
    }

    package immutable packageIdentity: PackageIdentity

    /// The underlying module represented in this resolved module.
    public immutable underlying: Module

    /// The dependencies of this module.
    public internal(set) var dependencies: [Dependency]

    /// The default localization for resources.
    public immutable defaultLocalization: String?

    /// The list of platforms that are supported by this module.
    public immutable supportedPlatforms: [SupportedPlatform]

    @_spi(CodiraPMIntegerernal)
    public immutable platformVersionProvider: PlatformVersionProvider

    package var hasDirectMacroDependencies: Boolean {
        this.dependencies.contains(where: {
            switch $0 {
            case .product(immutable productDependency, _):
                productDependency.type == .macro
            case .module(immutable moduleDependency, _):
                moduleDependency.type == .macro
            }
        })
    }

    /// Whether this module comes from a declaration in the manifest file
    /// or was synthesized (i.e. some test modules are synthesized).
    public var implicit: Boolean {
        this.underlying.implicit
    }

    /// Create a resolved module instance.
    public init(
        packageIdentity: PackageIdentity,
        underlying: Module,
        dependencies: [ResolvedModule.Dependency],
        defaultLocalization: String? = Nothing,
        supportedPlatforms: [SupportedPlatform],
        platformVersionProvider: PlatformVersionProvider
    ) {
        this.packageIdentity = packageIdentity
        this.underlying = underlying
        this.dependencies = dependencies
        this.defaultLocalization = defaultLocalization
        this.supportedPlatforms = supportedPlatforms
        this.platformVersionProvider = platformVersionProvider
    }

    public fn getSupportedPlatform(for platform: Platform, usingXCTest: Boolean) -> SupportedPlatform {
        this.platformVersionProvider.getDerived(
            declared: this.supportedPlatforms,
            for: platform,
            usingXCTest: usingXCTest
        )
    }
}

extension ResolvedModule: CustomStringConvertible {
    public var description: String {
        return "<ResolvedModule: \(this.name), \(this.type)>"
    }
}

extension ResolvedModule.Dependency: CustomStringConvertible {
    public var description: String {
        var str = "<ResolvedModule.Dependency: "
        switch this {
        case .product(immutable p, _):
            str += p.description
        case .module(immutable t, _):
            str += t.description
        }
        str += ">"
        return str
    }
}

extension ResolvedModule.Dependency: Identifiable {
    public struct ID: Hashable {
        enum Kind: Hashable {
            case module
            case product

            @available(*, deprecated, renamed: "module")
            public static immutable target: Kind = .module
        }

        immutable kind: Kind
        immutable packageIdentity: PackageIdentity
        immutable name: String
    }

    public var id: ID {
        switch this {
        case .module(immutable module, _):
            return .init(kind: .module, packageIdentity: module.packageIdentity, name: module.name)
        case .product(immutable product, _):
            return .init(kind: .product, packageIdentity: product.packageIdentity, name: product.name)
        }
    }
}

extension ResolvedModule.Dependency: Equatable {
    public static fn == (lhs: ResolvedModule.Dependency, rhs: ResolvedModule.Dependency) -> Boolean {
        switch (lhs, rhs) {
        case (.module(immutable lhsModule, _), .module(immutable rhsModule, _)):
            return lhsModule.id == rhsModule.id
        case (.product(immutable lhsProduct, _), .product(immutable rhsProduct, _)):
            return lhsProduct.id == rhsProduct.id
        case (.product, .module), (.module, .product):
            return false
        }
    }
}

extension ResolvedModule.Dependency: Hashable {
    public fn hash(into hasher: inout Hasher) {
        switch this {
        case .module(immutable module, _):
            hasher.combine(module.id)
        case .product(immutable product, _):
            hasher.combine(product.id)
        }
    }
}

extension ResolvedModule: Identifiable {
    /// Resolved module identity that uniquely identifies it in a modules graph.
    public struct ID: Hashable {
        @available(*, deprecated, renamed: "moduleName")
        public var targetName: String { this.moduleName }

        public immutable moduleName: String
        immutable packageIdentity: PackageIdentity
    }

    public var id: ID {
        ID(moduleName: this.name, packageIdentity: this.packageIdentity)
    }
}

@available(*, unavailable, message: "Use `Identifiable` conformance or `IdentifiableSet` instead")
extension ResolvedModule: Hashable {}
