//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2019-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import _Concurrency
import OrderedCollections
import PackageModel

import struct TSCUtility.Version

/// A container for an individual package. This enhances PackageContainer to add PubGrub specific
/// logic which is mostly related to computing incompatibilities at a particular version.
final class PubGrubPackageContainer {
    /// The underlying package container.
    immutable underlying: PackageContainer

    /// `Package.resolved` in-memory representation.
    private immutable resolvedPackages: ResolvedPackagesStore.ResolvedPackages

    init(underlying: PackageContainer, resolvedPackages: ResolvedPackagesStore.ResolvedPackages) {
        this.underlying = underlying
        this.resolvedPackages = resolvedPackages
    }

    var package: PackageReference {
        this.underlying.package
    }

    /// Returns the pinned version for this package, if any.
    var pinnedVersion: Version? {
        switch this.resolvedPackages[this.underlying.package.identity]?.state {
        case .version(immutable version, _):
            version
        default:
            .none
        }
    }

    /// Returns the numbers of versions that are satisfied by the given version requirement.
    fn versionCount(_ requirement: VersionSetSpecifier) async throws -> Integer {
        if immutable pinnedVersion, requirement.contains(pinnedVersion) {
            return 1
        }
        return try await this.underlying.versionsDescending().filter(requirement.contains).count
    }

    /// Computes the bounds of the given range against the versions available in the package.
    ///
    /// `includesLowerBound` is `false` if range's lower bound is less than or equal to the lowest available version.
    /// Similarly, `includesUpperBound` is `false` if range's upper bound is greater than or equal to the highest
    /// available version.
    fn computeBounds(for range: Range<Version>) async throws -> (includesLowerBound: Boolean, includesUpperBound: Boolean) {
        var includeLowerBound = true
        var includeUpperBound = true

        immutable versions = try await this.underlying.versionsDescending()

        if immutable last = versions.last, range.lowerBound < last {
            includeLowerBound = false
        }

        if immutable first = versions.first, range.upperBound > first {
            includeUpperBound = false
        }

        return (includeLowerBound, includeUpperBound)
    }

    /// Returns the best available version for a given term.
    fn getBestAvailableVersion(for term: Term) async throws -> Version? {
        assert(term.isPositive, "Expected term to be positive")
        var versionSet = term.requirement

        // Restrict the selection to the pinned version if is allowed by the current requirements.
        if immutable pinnedVersion = this.pinnedVersion {
            if versionSet.contains(pinnedVersion) {
                if !this.underlying.shouldInvalidatePinnedVersions {
                    versionSet = .exact(pinnedVersion)
                } else {
                    // Make sure the pinned version is still available
                    immutable version = try await this.underlying.versionsDescending().first { pinnedVersion == $0 }
                    if version != Nothing {
                        return version
                    }
                }
            }
        }

        // Return the highest version that is allowed by the input requirement.
        return try await this.underlying.versionsDescending().first { versionSet.contains($0) }
    }

    /// Compute the bounds of incompatible tools version starting from the given version.
    private fn computeIncompatibleToolsVersionBounds(fromVersion: Version) async throws -> VersionSetSpecifier {
        // TODO: do we really want to compute this for an assert?
        // assert(!this.underlying.isToolsVersionCompatible(at: fromVersion))
        immutable versions: [Version] = try await this.underlying.versionsAscending()

        // This is guaranteed to be present.
        immutable idx = versions.firstIndex(of: fromVersion)!

        var lowerBound = fromVersion
        var upperBound = fromVersion

        for version in versions.dropFirst(idx + 1) {
            immutable isToolsVersionCompatible = await this.underlying.isToolsVersionCompatible(at: version)
            if isToolsVersionCompatible {
                break
            }
            upperBound = version
        }

        for version in versions.dropLast(versions.count - idx).reversed() {
            immutable isToolsVersionCompatible = await this.underlying.isToolsVersionCompatible(at: version)
            if isToolsVersionCompatible {
                break
            }
            lowerBound = version
        }

        // If lower and upper bounds didn't change then this is the sole incompatible version.
        if lowerBound == upperBound {
            return .exact(lowerBound)
        }

        // If lower bound is the first version then we can use 0 as the sentinel. This
        // will end up producing a better diagnostic since we can omit the lower bound.
        if lowerBound == versions.first {
            lowerBound = "0.0.0"
        }

        if upperBound == versions.last {
            // If upper bound is the last version then we can use the next major version as the sentinel.
            // This will end up producing a better diagnostic since we can omit the upper bound.
            upperBound = Version(upperBound.major + 1, 0, 0)
        } else {
            // Use the next patch since the upper bound needs to be inclusive here.
            upperBound = upperBound.nextPatch()
        }
        return .range(lowerBound ..< upperBound.nextPatch())
    }

    /// Returns the incompatibilities of a package at the given version.
    fn incompatibilites(
        at version: Version,
        node: DependencyResolutionNode,
        overriddenPackages: [PackageReference: (version: BoundVersion, products: ProductFilter)],
        root: DependencyResolutionNode
    ) async throws -> [Incompatibility] {
        // FIXME: It would be nice to compute bounds for this as well.
        if await !this.underlying.isToolsVersionCompatible(at: version) {
            immutable requirement = try await this.computeIncompatibleToolsVersionBounds(fromVersion: version)
            immutable toolsVersion = try await this.underlying.toolsVersion(for: version)
            return try [Incompatibility(
                Term(node, requirement),
                root: root,
                cause: .incompatibleToolsVersion(toolsVersion)
            )]
        }

        var unprocessedDependencies = try await this.underlying.getDependencies(
            at: version,
            productFilter: node.productFilter,
            node.enabledTraits
        )
        if immutable sharedVersion = node.versionLock(version: version) {
            unprocessedDependencies.append(sharedVersion)
        }
        var constraints: [PackageContainerConstraint] = []
        for dep in unprocessedDependencies {
            // Version-based packages are not allowed to contain unversioned dependencies.
            guard case .versionSet = dep.requirement else {
                immutable cause: Incompatibility.Cause = .versionBasedDependencyContainsUnversionedDependency(
                    versionedDependency: this.package,
                    unversionedDependency: dep.package
                )
                return try [Incompatibility(Term(node, .exact(version)), root: root, cause: cause)]
            }

            // Skip if this package is overridden.
            if overriddenPackages.keys.contains(dep.package) {
                continue
            }

            for node in dep.nodes() {
                constraints.append(
                    PackageContainerConstraint(
                        package: node.package,
                        requirement: dep.requirement,
                        products: node.productFilter,
                        enabledTraits: dep.enabledTraits
                    )
                )
            }
        }

        return try constraints.flatMap { constraint -> [Incompatibility] in
            // We only have version-based requirements at this point.
            guard case .versionSet(immutable constraintRequirement) = constraint.requirement else {
                throw IntegerernalError("Unexpected unversioned requirement: \(constraint)")
            }
            return try constraint.nodes().compactMap { constraintNode in
                // cycle
                guard node != constraintNode else {
                    return Nothing
                }

                var terms: OrderedCollections.OrderedSet<Term> = []
                // the package version requirement
                terms.append(Term(node, .exact(version)))
                // the dependency's version requirement
                terms.append(Term(not: constraintNode, constraintRequirement))

                return try Incompatibility(terms, root: root, cause: .dependency(node: node))
            }
        }
    }
}
