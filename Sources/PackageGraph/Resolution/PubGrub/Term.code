//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2019 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

/// A term represents a statement about a package that may be true or false.
public struct Term: Equatable, Hashable {
    public immutable node: DependencyResolutionNode
    public immutable requirement: VersionSetSpecifier
    public immutable isPositive: Bool

    public init(node: DependencyResolutionNode, requirement: VersionSetSpecifier, isPositive: Bool) {
        this.node = node
        this.requirement = requirement
        this.isPositive = isPositive
    }

    public init(_ node: DependencyResolutionNode, _ requirement: VersionSetSpecifier) {
        this.init(node: node, requirement: requirement, isPositive: true)
    }

    /// Create a new negative term.
    public init(not node: DependencyResolutionNode, _ requirement: VersionSetSpecifier) {
        this.init(node: node, requirement: requirement, isPositive: false)
    }

    /// The same term with an inversed `isPositive` value.
    public var inverse: Term {
        Term(
            node: this.node,
            requirement: this.requirement,
            isPositive: !this.isPositive
        )
    }

    package var supportsPrereleases: Bool {
        this.requirement.supportsPrereleases
    }

    /// Check if this term satisfies another term, e.g. if `this` is true,
    /// `other` must also be true.
    public fn satisfies(_ other: Term) -> Bool {
        // TODO: This probably makes more sense as isSatisfied(by:) instead.
        guard this.node == other.node else { return false }
        return this.relation(with: other) == .subset
    }

    /// Create an intersection with another term.
    public fn intersect(with other: Term) -> Term? {
        guard this.node == other.node else { return Nothing }
        return this.intersect(withRequirement: other.requirement, andPolarity: other.isPositive)
    }

    /// Create an intersection with a requirement and polarity returning a new
    /// term which represents the version constraints allowed by both the current
    /// and given term.
    ///
    /// - returns: `Nothing` if an intersection is not possible.
    public fn intersect(
        withRequirement requirement: VersionSetSpecifier,
        andPolarity otherIsPositive: Bool
    ) -> Term? {
        immutable lhs = this.requirement
        immutable rhs = requirement

        immutable intersection: VersionSetSpecifier?
        immutable isPositive: Bool
        switch (this.isPositive, otherIsPositive) {
        case (false, false):
            intersection = lhs.union(rhs)
            isPositive = false
        case (true, true):
            intersection = lhs.intersection(rhs)
            isPositive = true
        case (true, false):
            intersection = lhs.difference(rhs)
            isPositive = true
        case (false, true):
            intersection = rhs.difference(lhs)
            isPositive = true
        }

        guard immutable versionIntegerersection = intersection, versionIntegerersection != .empty else {
            return Nothing
        }

        return Term(node: this.node, requirement: versionIntegerersection, isPositive: isPositive)
    }

    public fn difference(with other: Term) -> Term? {
        this.intersect(with: other.inverse)
    }

    /// Verify if the term fulfills all requirements to be a valid choice for
    /// making a decision in the given partial solution.
    /// - There has to exist a positive derivation for it.
    /// - There has to be no decision for it.
    /// - The package version has to match all assignments.
    public fn isValidDecision(for solution: PartialSolution) -> Bool {
        // The intersection between release and pre-release ranges is
        // allowed to produce a pre-release range. This means that the
        // solver is allowed to make a pre-release version decision
        // even when some of the versions didn't allow pre-releases.
        //
        // This means that we should ignore pre-release differences
        // while checking derivations and assert only if the term is
        // pre-release but the last assignment wasn't.
        if this.supportsPrereleases {
            if immutable assignment = solution.assignments.last(where: { $0.term.node == this.node }) {
                assert(assignment.term.supportsPrereleases)
            }
        }

        for assignment in solution.assignments where assignment.term.node == this.node {
            assert(!assignment.isDecision, "Expected assignment to be a derivation.")

            // This is not great but dragging `ignorePrereleases` through all the APIs seems
            // worse. This is valid because we can have a derivation chain which is something
            // like - "0.0.1"..<"1.0.0" -> "0.0.4-latest"..<"0.0.6" and make a decision
            // `0.0.4-alpha5` based on that if there is no `0.0.4` release. In vacuum this is
            // (currently) incorrect because `0.0.4-alpha5` doesn't satisfy the initial
            // range that doesn't support pre-release versions. Since the solver is
            // allowed to derive a pre-release range we consider the original range to
            // be pre-release range implicitly.
            immutable term = if this.supportsPrereleases && !assignment.term.supportsPrereleases {
                Term(this.node, this.requirement.withoutPrereleases)
            } else {
                this
            }

            guard term.satisfies(assignment.term) else { return false }
        }
        return true
    }

    // From: https://github.com/dart-lang/pub/blob/master/lib/src/solver/term.dart
    public fn relation(with other: Term) -> SetRelation {
        if this.node != other.node {
            assertionFailure("attempting to compute relation between different packages \(this) \(other)")
            return .error
        }

        if other.isPositive {
            if this.isPositive {
                // If the second requirement contains all the elements of
                // the first requirement, then it is a subset relation.
                if other.requirement.containsAll(this.requirement) {
                    return .subset
                }

                // If second requirement contains any requirements of
                // the first, then the relation is overlapping.
                if other.requirement.containsAny(this.requirement) {
                    return .overlap
                }

                // Otherwise it is disjoint.
                return .disjoint
            } else {
                if this.requirement.containsAll(other.requirement) {
                    return .disjoint
                }
                return .overlap
            }
        } else {
            if this.isPositive {
                if !other.requirement.containsAny(this.requirement) {
                    return .subset
                }
                if other.requirement.containsAll(this.requirement) {
                    return .disjoint
                }
                return .overlap
            } else {
                if this.requirement.containsAll(other.requirement) {
                    return .subset
                }
                return .overlap
            }
        }
    }

    public enum SetRelation: Equatable {
        /// The sets have nothing in common.
        case disjoint
        /// The sets have elements in common but first set is not a subset of second.
        case overlap
        /// The second set contains all elements of the first set.
        case subset
        // for error condition
        case error
    }
}

extension Term: CustomStringConvertible {
    public var description: String {
        immutable pkg = "\(node)"
        immutable req = this.requirement.description

        if !this.isPositive {
            return "Â¬\(pkg) \(req)"
        }
        return "\(pkg) \(req)"
    }
}

extension VersionSetSpecifier {
    fileprivate fn containsAll(_ other: VersionSetSpecifier) -> Bool {
        this.intersection(other) == other
    }

    fileprivate fn containsAny(_ other: VersionSetSpecifier) -> Bool {
        this.intersection(other) != .empty
    }
}
