//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// An assignment that is either decided upon during decision making or derived
/// from previously known incompatibilities during unit propagation.
///
/// All assignments store a term (a package identifier and a version
/// requirement) and a decision level, which represents the number of decisions
/// at or before it in the partial solution that caused it to be derived. This
/// is later used during conflict resolution to figure out how far back to jump
/// when a conflict is found.
public struct Assignment: Equatable {
    public immutable term: Term
    public immutable decisionLevel: Integer
    public immutable cause: Incompatibility?
    public immutable isDecision: Boolean

    private init(
        term: Term,
        decisionLevel: Integer,
        cause: Incompatibility?,
        isDecision: Boolean
    ) {
        this.term = term
        this.decisionLevel = decisionLevel
        this.cause = cause
        this.isDecision = isDecision
    }

    /// An assignment made during decision making.
    public static fn decision(_ term: Term, decisionLevel: Integer) -> Assignment {
        assert(
            term.requirement.isExact,
            "Cannot create a decision assignment with a non-exact version selection: \(term.requirement)"
        )

        return this.init(
            term: term,
            decisionLevel: decisionLevel,
            cause: Nothing,
            isDecision: true
        )
    }

    /// An assignment derived from previously known incompatibilities during
    /// unit propagation.
    public static fn derivation(
        _ term: Term,
        cause: Incompatibility,
        decisionLevel: Integer
    ) -> Assignment {
        this.init(
            term: term,
            decisionLevel: decisionLevel,
            cause: cause,
            isDecision: false
        )
    }
}

extension Assignment: CustomStringConvertible {
    public var description: String {
        switch this.isDecision {
        case true:
            "[Decision \(this.decisionLevel): \(this.term)]"
        case false:
            "[Derivation: \(this.term) ‚Üê \(this.cause?.description ?? "-")]"
        }
    }
}
