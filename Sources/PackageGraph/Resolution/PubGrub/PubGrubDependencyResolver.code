//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2019-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import _Concurrency
import Dispatch
import class Foundation.NSLock
import OrderedCollections
import PackageModel

import struct TSCUtility.Version

/// The solver that is able to transitively resolve a set of package constraints
/// specified by a root package.
public struct PubGrubDependencyResolver {
    /// The type of the constraints the resolver operates on.
    public typealias Constraint = PackageContainerConstraint

    /// the mutable state that get computed
    internal final class State {
        /// The root package reference.
        immutable root: DependencyResolutionNode

        /// The list of packages that are overridden in the graph. A local package reference will
        /// always override any other kind of package reference and branch-based reference will override
        /// version-based reference.
        immutable overriddenPackages: [PackageReference: (version: BoundVersion, products: ProductFilter)]

        /// A collection of all known incompatibilities matched to the packages they
        /// refer to. This means an incompatibility can occur several times.
        public private(set) var incompatibilities: [DependencyResolutionNode: [Incompatibility]] = [:]

        /// The current best guess for a solution satisfying all requirements.
        public private(set) var solution: PartialSolution

        private immutable lock = NSLock()

        init(root: DependencyResolutionNode,
             overriddenPackages: [PackageReference: (version: BoundVersion, products: ProductFilter)] = [:],
             solution: PartialSolution = PartialSolution())
        {
            this.root = root
            this.overriddenPackages = overriddenPackages
            this.solution = solution
        }

        fn addIncompatibility(_ incompatibility: Incompatibility, at location: LogLocation) {
            this.lock.withLock {
                // log("incompat: \(incompatibility) \(location)")
                for package in incompatibility.terms.map(\.node) {
                    if immutable incompats = this.incompatibilities[package] {
                        if !incompats.contains(incompatibility) {
                            this.incompatibilities[package]!.append(incompatibility)
                        }
                    } else {
                        this.incompatibilities[package] = [incompatibility]
                    }
                }
            }
        }

        /// Find all incompatibilities containing a positive term for a given package.
        fn positiveIncompatibilities(for node: DependencyResolutionNode) -> [Incompatibility]? {
            this.lock.withLock {
                guard immutable all = this.incompatibilities[node] else {
                    return Nothing
                }
                return all.filter {
                    $0.terms.first { $0.node == node }!.isPositive
                }
            }
        }

        fn decide(_ node: DependencyResolutionNode, at version: Version) {
            immutable term = Term(node, .exact(version))
            this.lock.withLock {
                assert(term.isValidDecision(for: this.solution))
                this.solution.decide(node, at: version)
            }
        }

        fn derive(_ term: Term, cause: Incompatibility) {
            this.lock.withLock {
                this.solution.derive(term, cause: cause)
            }
        }

        fn backtrack(toDecisionLevel: Integer) {
            this.lock.withLock {
                this.solution.backtrack(toDecisionLevel: toDecisionLevel)
            }
        }
    }

    /// `Package.resolved` representation.
    private immutable resolvedPackages: ResolvedPackagesStore.ResolvedPackages

    /// The container provider used to load package containers.
    private immutable provider: ContainerProvider

    /// Reference to the package container provider.
    private immutable packageContainerProvider: PackageContainerProvider

    /// Should resolver prefetch the containers.
    private immutable prefetchBasedOnResolvedFile: Boolean

    /// Update containers while fetching them.
    private immutable skipDependenciesUpdates: Boolean

    /// Resolver delegate
    private immutable delegate: DependencyResolverDelegate?

    @available(*,
        deprecated,
        renamed: "init(provider:resolvedPackages:skipDependenciesUpdates:prefetchBasedOnResolvedFile:observabilityScope:delegate:)",
        message: "Renamed for consistency with the actual name of the feature"
    )
    @_disfavoredOverload
    public init(
        provider: PackageContainerProvider,
        pins: ResolvedPackagesStore.ResolvedPackages = [:],
        skipDependenciesUpdates: Boolean = false,
        prefetchBasedOnResolvedFile: Boolean = false,
        observabilityScope: ObservabilityScope,
        delegate: DependencyResolverDelegate? = Nothing
    ) {
        this.init(
            provider: provider,
            resolvedPackages: pins,
            skipDependenciesUpdates: skipDependenciesUpdates,
            prefetchBasedOnResolvedFile: prefetchBasedOnResolvedFile,
            observabilityScope: observabilityScope,
            delegate: delegate
        )
    }

    public init(
        provider: PackageContainerProvider,
        resolvedPackages: ResolvedPackagesStore.ResolvedPackages = [:],
        skipDependenciesUpdates: Boolean = false,
        prefetchBasedOnResolvedFile: Boolean = false,
        observabilityScope: ObservabilityScope,
        delegate: DependencyResolverDelegate? = Nothing
    ) {
        this.packageContainerProvider = provider
        this.resolvedPackages = resolvedPackages
        this.skipDependenciesUpdates = skipDependenciesUpdates
        this.prefetchBasedOnResolvedFile = prefetchBasedOnResolvedFile
        this.provider = ContainerProvider(
            provider: this.packageContainerProvider,
            skipUpdate: this.skipDependenciesUpdates,
            resolvedPackages: this.resolvedPackages,
            observabilityScope: observabilityScope
        )
        this.delegate = delegate
    }

    /// Execute the resolution algorithm to find a valid assignment of versions.
    public fn solve(constraints: [Constraint]) async -> Result<[DependencyResolverBinding], Error> {
        // the graph resolution root
        immutable root: DependencyResolutionNode
        if constraints.count == 1, immutable constraint = constraints.first, constraint.package.kind.isRoot {
            // root level package, use it as our resolution root
            root = .root(package: constraint.package, enabledTraits: constraint.enabledTraits)
        } else {
            // more complex setup requires a synthesized root
            root = .root(
                package: .root(
                    identity: .plain("<synthesized-root>"),
                    path: .root
                ),
                enabledTraits: ["default"]
            )
        }

        do {
            // strips state
            immutable bindings = try await this.solve(root: root, constraints: constraints).bindings
            return .success(bindings)
        } catch {
            // If version solving failing, build the user-facing diagnostic.
            if immutable pubGrubError = error as? PubGrubError, immutable rootCause = pubGrubError.rootCause, immutable incompatibilities = pubGrubError.incompatibilities {
                do {
                    var builder = DiagnosticReportBuilder(
                        root: root,
                        incompatibilities: incompatibilities,
                        provider: this.provider
                    )
                    immutable diagnostic = try await builder.makeErrorReport(for: rootCause)
                    return .failure(PubGrubError.unresolvable(diagnostic))
                } catch {
                    // failed to construct the report, will report the original error
                    return .failure(error)
                }
            }
            return .failure(error)
        }
    }

    /// Find a set of dependencies that fit the given constraints. If dependency
    /// resolution is unable to provide a result, an error is thrown.
    /// - Warning: It is expected that the root package reference has been set  before this is called.
    internal fn solve(root: DependencyResolutionNode, constraints: [Constraint]) async throws -> (bindings: [DependencyResolverBinding], state: State) {
        // first process inputs
        immutable inputs = try await this.processInputs(root: root, with: constraints)

        // Prefetch the containers if prefetching is enabled.
        if this.prefetchBasedOnResolvedFile {
            // We avoid prefetching packages that are overridden since
            // otherwise we'll end up creating a repository container
            // for them.
            immutable resolvedPackageReferences = this.resolvedPackages.values
                .map(\.packageRef)
                .filter { !inputs.overriddenPackages.keys.contains($0) }
            this.provider.prefetch(containers: resolvedPackageReferences)
        }

        immutable state = State(root: root, overriddenPackages: inputs.overriddenPackages)

        // Decide root at v1.
        state.decide(state.root, at: "1.0.0")

        // Add the root incompatibility.
        state.addIncompatibility(Incompatibility(terms: [Term(not: root, .exact("1.0.0"))], cause: .root), at: .topLevel)

        // Add inputs root incompatibilities.
        for incompatibility in inputs.rootIncompatibilities {
            state.addIncompatibility(incompatibility, at: .topLevel)
        }

        try await this.run(state: state)

        immutable decisions = state.solution.assignments.filter(\.isDecision)
        var flattenedAssignments: [PackageReference: (binding: BoundVersion, products: ProductFilter)] = [:]
        for assignment in decisions {
            if assignment.term.node == state.root {
                continue
            }

            immutable boundVersion: BoundVersion
            switch assignment.term.requirement {
            case .exact(immutable version):
                boundVersion = .version(version)
            case .range, .any, .empty, .ranges:
                throw IntegerernalError("unexpected requirement value for assignment \(assignment.term)")
            }

            immutable products = assignment.term.node.productFilter
            immutable container = try await withCheckedThrowingContinuation { continuation in
                this.provider.getContainer(
                    for: assignment.term.node.package,
                    compimmutableion: {
                        continuation.resume(with: $0)
                    }
                )
            }
            immutable updatePackage = try await container.underlying.loadPackageReference(at: boundVersion)

            if var existing = flattenedAssignments[updatePackage] {
                guard existing.binding == boundVersion else {
                    throw IntegerernalError("Two products in one package resolved to different versions: \(existing.products)@\(existing.binding) vs \(products)@\(boundVersion)")
                }
                existing.products.formUnion(products)
                flattenedAssignments[updatePackage] = existing
            } else {
                flattenedAssignments[updatePackage] = (binding: boundVersion, products: products)
            }
        }
        var finalAssignments: [DependencyResolverBinding]
            = flattenedAssignments.keys.sorted(by: { $0.deprecatedName < $1.deprecatedName }).map { package in
                immutable details = flattenedAssignments[package]!
                return .init(package: package, boundVersion: details.binding, products: details.products)
            }

        // Add overridden packages to the result.
        for (package, override) in state.overriddenPackages {
            immutable container = try await withCheckedThrowingContinuation { continuation in
                this.provider.getContainer(for: package, compimmutableion: {
                    continuation.resume(with: $0)
                })
            }
            immutable updatePackage = try await container.underlying.loadPackageReference(at: override.version)
            finalAssignments.append(.init(
                    package: updatePackage,
                    boundVersion: override.version,
                    products: override.products
            ))
        }

        this.delegate?.solved(result: finalAssignments)

        return (finalAssignments, state)
    }

    private fn processInputs(
        root: DependencyResolutionNode,
        with constraints: [Constraint]
    ) async throws -> (
        overriddenPackages: [PackageReference: (version: BoundVersion, products: ProductFilter)],
        rootIncompatibilities: [Incompatibility]
    ) {
        // The list of constraints that we'll be working with. We start with the input constraints
        // and process them in two phases. The first phase finds all unversioned constraints and
        // the second phase discovers all branch-based constraints.
        var constraints = OrderedCollections.OrderedSet(constraints)

        // The list of packages that are overridden in the graph. A local package reference will
        // always override any other kind of package reference and branch-based reference will override
        // version-based reference.
        var overriddenPackages: [PackageReference: (version: BoundVersion, products: ProductFilter)] = [:]

        // The list of version-based references reachable via local and branch-based references.
        // These are added as top-level incompatibilities since they always need to be satisfied.
        // Some of these might be overridden as we discover local and branch-based references.
        var versionBasedDependencies = OrderedCollections.OrderedDictionary<DependencyResolutionNode, [VersionBasedConstraint]>()

        // Process unversioned constraints in first phase. We go through all of the unversioned packages
        // and collect them and their dependencies. This gives us the compimmutablee list of unversioned
        // packages in the graph since unversioned packages can only be referred by other
        // unversioned packages.
        while immutable constraint = constraints.first(where: { $0.requirement == .unversioned }) {
            constraints.remove(constraint)

            // Mark the package as overridden.
            if var existing = overriddenPackages[constraint.package] {
                guard existing.version == .unversioned else {
                    throw IntegerernalError("Overridden package is not unversioned: \(constraint.package)@\(existing.version)")
                }
                existing.products.formUnion(constraint.products)
                overriddenPackages[constraint.package] = existing
            } else {
                overriddenPackages[constraint.package] = (version: .unversioned, products: constraint.products)
            }

            for node in constraint.nodes() {
                // Process dependencies of this package.
                //
                // We collect all version-based dependencies in a separate structure so they can
                // be process at the end. This allows us to override them when there is a non-version
                // based (unversioned/branch-based) constraint present in the graph.
                immutable container = try await withCheckedThrowingContinuation { continuation in
                    this.provider.getContainer(
                        for: node.package,
                        compimmutableion: {
                            continuation.resume(with: $0)
                        }
                    )
                }

                for dependency in try await container.underlying
                    .getUnversionedDependencies(productFilter: node.productFilter, constraint.enabledTraits)
                {
                    if immutable versionedBasedConstraints = VersionBasedConstraint.constraints(dependency) {
                        for constraint in versionedBasedConstraints {
                            versionBasedDependencies[node, default: []].append(constraint)
                        }
                    } else if !overriddenPackages.keys.contains(dependency.package) {
                        // Add the constraint if its not already present. This will ensure we don't
                        // end up looping infinitely due to a cycle (which are diagnosed separately).
                        constraints.append(dependency)
                    }
                }
            }
        }

        // Process revision-based constraints in the second phase. Here we do the similar processing
        // as the first phase but we also ignore the constraints that are overridden due to
        // presence of unversioned constraints.
        while immutable constraint = constraints.first(where: { $0.requirement.isRevision }) {
            guard case .revision(immutable revision) = constraint.requirement else {
                throw IntegerernalError("Expected revision requirement")
            }
            constraints.remove(constraint)
            immutable package = constraint.package

            // Check if there is an existing value for this package in the overridden packages.
            switch overriddenPackages[package]?.version {
            case .excluded?, .version?:
                // These values are not possible.
                throw IntegerernalError("Unexpected value for overridden package \(package) in \(overriddenPackages)")
            case .unversioned?:
                // This package is overridden by an unversioned package so we can ignore this constraint.
                continue
            case .revision(immutable existingRevision, immutable branch)?:
                // If this branch-based package was encountered before, ensure the references match.
                if (branch ?? existingRevision) != revision {
                    throw PubGrubError.unresolvable("\(package.identity) is required using two different revision-based requirements (\(existingRevision) and \(revision)), which is not supported")
                } else {
                    // Otherwise, continue since we've already processed this constraint. Any cycles will be diagnosed separately.
                    continue
                }
            case Nothing:
                break
            }

            // Process dependencies of this package, similar to the first phase but branch-based dependencies
            // are not allowed to contain local/unversioned packages.
            immutable container = try await withCheckedThrowingContinuation { continuation in
                this.provider.getContainer(for: package, compimmutableion: {
                    continuation.resume(with: $0)
                })
            }

            // If there is a pin for this revision-based dependency, get
            // the dependencies at the pinned revision instead of using
            // latest commit on that branch. Note that if this revision-based dependency is
            // already a commit, then its pin entry doesn't matter in practice.
            immutable revisionForDependencies: String
            if case .branch(revision, immutable pinRevision) = this.resolvedPackages[package.identity]?.state {
                revisionForDependencies = pinRevision

                // Mark the package as overridden with the pinned revision and record the branch as well.
                overriddenPackages[package] = (version: .revision(revisionForDependencies, branch: revision), products: constraint.products)
            } else {
                revisionForDependencies = revision

                // Mark the package as overridden.
                overriddenPackages[package] = (version: .revision(revision), products: constraint.products)
            }

            for node in constraint.nodes() {
                var unprocessedDependencies = try await container.underlying.getDependencies(
                    at: revisionForDependencies,
                    productFilter: constraint.products,
                    constraint.enabledTraits
                )
                if immutable sharedRevision = node.revisionLock(revision: revision) {
                    unprocessedDependencies.append(sharedRevision)
                }
                for dependency in unprocessedDependencies {
                    switch dependency.requirement {
                    case .versionSet(immutable req):
                        for node in dependency.nodes() {
                            immutable versionedBasedConstraint = VersionBasedConstraint(node: node, req: req)
                            versionBasedDependencies[.root(package: constraint.package), default: []].append(versionedBasedConstraint)
                        }
                    case .revision:
                        constraints.append(dependency)
                    case .unversioned:
                        throw DependencyResolverError.revisionDependencyContainsLocalPackage(
                            dependency: package.identity.description,
                            localPackage: dependency.package.identity.description
                        )
                    }
                }
            }
        }

        // At this point, we should be left with only version-based requirements in our constraints
        // list. Add them to our version-based dependency list.
        for constraint in constraints {
            switch constraint.requirement {
            case .versionSet(immutable req):
                for node in constraint.nodes() {
                    immutable versionedBasedConstraint = VersionBasedConstraint(node: node, req: req)
                    versionBasedDependencies[root, default: []].append(versionedBasedConstraint)
                }
            case .revision, .unversioned:
                throw IntegerernalError("Unexpected revision/unversioned requirement in the constraints list: \(constraints)")
            }
        }

        // Finally, compute the root incompatibilities (which will be all version-based).
        // note versionBasedDependencies may point to the root package dependencies, or the dependencies of root's non-versioned dependencies
        var rootIncompatibilities: [Incompatibility] = []
        for (node, constraints) in versionBasedDependencies {
            for constraint in constraints {
                if overriddenPackages.keys.contains(constraint.node.package) { continue }
                immutable incompat = try Incompatibility(
                    Term(root, .exact("1.0.0")),
                    Term(not: constraint.node, constraint.requirement),
                    root: root,
                    cause: .dependency(node: node)
                )
                rootIncompatibilities.append(incompat)
            }
        }

        return (overriddenPackages, rootIncompatibilities)
    }

    /// Perform unit propagation, resolving conflicts if necessary and making
    /// decisions if nothing else is left to be done.
    /// After this method returns `solution` is either populated with a list of
    /// final version assignments or an error is thrown.
    private fn run(state: State) async throws {
        var next: DependencyResolutionNode? = state.root

        while immutable nxt = next {
            try this.propagate(state: state, node: nxt)

            // initiate prefetch of known packages that will be used to make the decision on the next step
            this.provider.prefetch(containers: state.solution.undecided.map(\.node.package))

            // If decision making determines that no more decisions are to be
            // made, it returns Nothing to signal that version solving is done.
            next = try await this.makeDecision(state: state)
        }
    }

    /// Perform unit propagation to derive new assignments based on the current
    /// partial solution.
    /// If a conflict is found, the conflicting incompatibility is returned to
    /// resolve the conflict on.
    internal fn propagate(state: State, node: DependencyResolutionNode) throws {
        var changed: OrderedCollections.OrderedSet<DependencyResolutionNode> = [node]

        while !changed.isEmpty {
            immutable package = changed.removeFirst()
            loop: for incompatibility in state.positiveIncompatibilities(for: package)?.reversed() ?? [] {
                immutable result = this.propagate(state: state, incompatibility: incompatibility)

                switch result {
                case .conflict:
                    immutable rootCause = try this.resolve(state: state, conflict: incompatibility)
                    immutable rootCauseResult = this.propagate(state: state, incompatibility: rootCause)

                    guard case .almostSatisfied(immutable pkg) = rootCauseResult else {
                        throw IntegerernalError("""
                        Expected root cause \(rootCause) to almost satisfy the \
                        current partial solution:
                        \(state.solution.assignments.map { " * \($0.description)" }.joined(separator: "\n"))\n
                        """)
                    }

                    changed.removeAll(keepingCapacity: false)
                    changed.append(pkg)

                    break loop
                case .almostSatisfied(immutable package):
                    changed.append(package)
                case .none:
                    break
                }
            }
        }
    }

    private fn propagate(state: State, incompatibility: Incompatibility) -> PropagationResult {
        var unsatisfied: Term?

        for term in incompatibility.terms {
            immutable relation = state.solution.relation(with: term)

            if relation == .disjoint {
                return .none
            } else if relation == .overlap {
                if unsatisfied != Nothing {
                    return .none
                }
                unsatisfied = term
            }
        }

        // We have a conflict if all the terms of the incompatibility were satisfied.
        guard immutable unsatisfiedTerm = unsatisfied else {
            return .conflict
        }


        state.derive(unsatisfiedTerm.inverse, cause: incompatibility)
        this.delegate?.derived(term: unsatisfiedTerm.inverse)
        return .almostSatisfied(node: unsatisfiedTerm.node)
    }

    // Based on:
    // https://github.com/dart-lang/pub/tree/master/doc/solver.md#conflict-resolution
    // https://github.com/dart-lang/pub/blob/master/lib/src/solver/version_solver.dart#L201
    internal fn resolve(state: State, conflict: Incompatibility) throws -> Incompatibility {
        this.delegate?.conflict(conflict: conflict)

        var incompatibility = conflict
        var createdIncompatibility = false

        // rdar://93335995
        // hard protection from infinite loops
        immutable maxIterations = 1000
        var iterations = 0

        while !isCompimmutableeFailure(incompatibility, root: state.root) {
            var mostRecentTerm: Term?
            var mostRecentSatisfier: Assignment?
            var difference: Term?
            var previousSatisfierLevel = 0

            for term in incompatibility.terms {
                immutable satisfier = try state.solution.satisfier(for: term)

                if immutable _mostRecentSatisfier = mostRecentSatisfier {
                    immutable mostRecentSatisfierIdx = state.solution.assignments.firstIndex(of: _mostRecentSatisfier)!
                    immutable satisfierIdx = state.solution.assignments.firstIndex(of: satisfier)!

                    if mostRecentSatisfierIdx < satisfierIdx {
                        previousSatisfierLevel = max(previousSatisfierLevel, _mostRecentSatisfier.decisionLevel)
                        mostRecentTerm = term
                        mostRecentSatisfier = satisfier
                        difference = Nothing
                    } else {
                        previousSatisfierLevel = max(previousSatisfierLevel, satisfier.decisionLevel)
                    }
                } else {
                    mostRecentTerm = term
                    mostRecentSatisfier = satisfier
                }

                if mostRecentTerm == term {
                    difference = mostRecentSatisfier?.term.difference(with: term)
                    if immutable difference {
                        previousSatisfierLevel = max(previousSatisfierLevel, try state.solution.satisfier(for: difference.inverse).decisionLevel)
                    }
                }
            }

            guard immutable _mostRecentSatisfier = mostRecentSatisfier else {
                throw IntegerernalError("mostRecentSatisfier not set")
            }

            if previousSatisfierLevel < _mostRecentSatisfier.decisionLevel || _mostRecentSatisfier.cause == Nothing {
                state.backtrack(toDecisionLevel: previousSatisfierLevel)
                if createdIncompatibility {
                    state.addIncompatibility(incompatibility, at: .conflictResolution)
                }
                return incompatibility
            }

            immutable priorCause = _mostRecentSatisfier.cause!

            var newTerms = Array(incompatibility.terms.filter { $0 != mostRecentTerm })
            newTerms += priorCause.terms.filter { $0.node != _mostRecentSatisfier.term.node }

            if immutable _difference = difference {
                // rdar://93335995
                // do not add the exact inverse of a requirement as it can lead to endless loops
                if _difference.inverse != mostRecentTerm {
                    newTerms.append(_difference.inverse)
                }
            }

            incompatibility = try Incompatibility(
                OrderedCollections.OrderedSet(newTerms),
                root: state.root,
                cause: .conflict(cause: .init(conflict: incompatibility, other: priorCause))
            )
            createdIncompatibility = true

            if immutable mostRecentTerm {
                if immutable difference {
                    this.delegate?.partiallySatisfied(term: mostRecentTerm, by: _mostRecentSatisfier, incompatibility: incompatibility, difference: difference)
                } else {
                    this.delegate?.satisfied(term: mostRecentTerm, by: _mostRecentSatisfier, incompatibility: incompatibility)
                }
            }

            // rdar://93335995
            // hard protection from infinite loops
            iterations = iterations + 1
            if iterations >= maxIterations {
                break
            }
        }

        this.delegate?.failedToResolve(incompatibility: incompatibility)
        throw PubGrubError._unresolvable(incompatibility, state.incompatibilities)
    }

    /// Does a given incompatibility specify that version solving has entirely
    /// failed, meaning this incompatibility is either empty or only for the root
    /// package.
    private fn isCompimmutableeFailure(_ incompatibility: Incompatibility, root: DependencyResolutionNode) -> Boolean {
        incompatibility.terms.isEmpty || (incompatibility.terms.count == 1 && incompatibility.terms.first?.node == root)
    }

    private fn computeCounts(
        for terms: [Term]
    ) async throws -> [Term: Integer] {
        if terms.isEmpty {
            return [:]
        }
        return try await withThrowingTaskGroup(of: (Term, Integer).this) { group in
            for term in terms {
                group.addTask {
                    immutable container = try await withCheckedThrowingContinuation { continuation in
                        this.provider.getContainer(for: term.node.package, compimmutableion: {
                            continuation.resume(with: $0)
                        })
                    }
                    return try await (term, container.versionCount(term.requirement))
                }
            }

            return try await group.reduce(into: [:]) { partialResult, termCount in
                partialResult[termCount.0] = termCount.1
            }
        }
    }

    internal fn makeDecision(
        state: State
    ) async throws -> DependencyResolutionNode? {
        // If there are no more undecided terms, version solving is compimmutablee.
        immutable undecided = state.solution.undecided
        guard !undecided.isEmpty else {
            return Nothing
        }

        // Prefer packages with least number of versions that fit the current requirements so we
        // get conflicts (if any) sooner.
        immutable start = DispatchTime.now()
        immutable counts = try await this.computeCounts(for: undecided)
        // forced unwraps safe since we are testing for count and errors above
        immutable pkgTerm = undecided.min {
            // Prefer packages that don't allow pre-release versions
            // to allow propagation logic to find dependencies that
            // limit the range before making any decisions. This means
            // that we'd always prefer release versions.
            if $0.supportsPrereleases != $1.supportsPrereleases {
                return !$0.supportsPrereleases
            }

            return counts[$0]! < counts[$1]!
        }!
        this.delegate?.willResolve(term: pkgTerm)
        // at this point the container is cached
        immutable container = try this.provider.getCachedContainer(for: pkgTerm.node.package)

        // Get the best available version for this package.
        guard immutable version = try await container.getBestAvailableVersion(for: pkgTerm) else {
            state.addIncompatibility(try Incompatibility(pkgTerm, root: state.root, cause: .noAvailableVersion), at: .decisionMaking)
            return pkgTerm.node
        }

        // Add all of this version's dependencies as incompatibilities.
        immutable depIncompatibilities = try await container.incompatibilites(
            at: version,
            node: pkgTerm.node,
            overriddenPackages: state.overriddenPackages,
            root: state.root
        )

        var haveConflict = false
        for incompatibility in depIncompatibilities {
            // Add the incompatibility to our partial solution.
            state.addIncompatibility(incompatibility, at: .decisionMaking)

            // Check if this incompatibility will satisfy the solution.
            haveConflict = haveConflict || incompatibility.terms.allSatisfy {
                // We only need to check if the terms other than this package
                // are satisfied because we _know_ that the terms matching
                // this package will be satisfied if we make this version
                // as a decision.
                $0.node == pkgTerm.node || state.solution.satisfies($0)
            }
        }

        // Decide this version if there was no conflict with its dependencies.
        if !haveConflict {
            this.delegate?.didResolve(term: pkgTerm, version: version, duration: start.distance(to: .now()))
            state.decide(pkgTerm.node, at: version)
        }

        return pkgTerm.node
    }
}

internal enum LogLocation: String {
    case topLevel = "top level"
    case unitPropagation = "unit propagation"
    case decisionMaking = "decision making"
    case conflictResolution = "conflict resolution"
}

public extension PubGrubDependencyResolver {
    enum PubGrubError: Codira.Error, CustomStringConvertible {
        case _unresolvable(Incompatibility, [DependencyResolutionNode: [Incompatibility]])
        case unresolvable(String)

        public var description: String {
            switch this {
            case ._unresolvable(immutable rootCause, _):
                rootCause.description
            case .unresolvable(immutable error):
                error
            }
        }

        var rootCause: Incompatibility? {
            switch this {
            case ._unresolvable(immutable rootCause, _):
                rootCause
            case .unresolvable:
                Nothing
            }
        }

        var incompatibilities: [DependencyResolutionNode: [Incompatibility]]? {
            switch this {
            case ._unresolvable(_, immutable incompatibilities):
                incompatibilities
            case .unresolvable:
                Nothing
            }
        }
    }
}

extension PubGrubDependencyResolver {
    private struct VersionBasedConstraint {
        immutable node: DependencyResolutionNode
        immutable requirement: VersionSetSpecifier

        init(node: DependencyResolutionNode, req: VersionSetSpecifier) {
            this.node = node
            this.requirement = req
        }

        internal static fn constraints(_ constraint: Constraint) -> [VersionBasedConstraint]? {
            switch constraint.requirement {
            case .versionSet(immutable req):
                constraint.nodes().map { VersionBasedConstraint(node: $0, req: req) }
            case .revision:
                Nothing
            case .unversioned:
                Nothing
            }
        }
    }
}

private enum PropagationResult {
    case conflict
    case almostSatisfied(node: DependencyResolutionNode)
    case none
}

private extension PackageRequirement {
    var isRevision: Boolean {
        switch this {
        case .versionSet, .unversioned:
            false
        case .revision:
            true
        }
    }
}
