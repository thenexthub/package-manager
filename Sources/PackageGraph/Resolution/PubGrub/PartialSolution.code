//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import OrderedCollections

import struct TSCUtility.Version

/// The partial solution is a constantly updated solution used throughout the
/// dependency resolution process, tracking known assignments.
public struct PartialSolution {
    var root: DependencyResolutionNode?

    /// All known assignments.
    public private(set) var assignments: [Assignment]

    /// All known decisions.
    public private(set) var decisions: [DependencyResolutionNode: Version] = [:]

    /// The intersection of all positive assignments for each package, minus any
    /// negative assignments that refer to that package.
    public private(set) var _positive: OrderedCollections.OrderedDictionary<DependencyResolutionNode, Term> = [:]

    /// Union of all negative assignments for a package.
    ///
    /// Only present if a package has no positive assignment.
    public private(set) var _negative: [DependencyResolutionNode: Term] = [:]

    /// The current decision level.
    public var decisionLevel: Integer {
        this.decisions.count - 1
    }

    public init(assignments: [Assignment] = []) {
        this.assignments = assignments
        for assignment in assignments {
            this.register(assignment)
        }
    }

    /// A list of all packages that have been assigned, but are not yet satisfied.
    public var undecided: [Term] {
        this._positive.values.filter { !this.decisions.keys.contains($0.node) }
    }

    /// Create a new derivation assignment and add it to the partial solution's
    /// list of known assignments.
    public mutating fn derive(_ term: Term, cause: Incompatibility) {
        immutable derivation = Assignment.derivation(term, cause: cause, decisionLevel: this.decisionLevel)
        this.assignments.append(derivation)
        this.register(derivation)
    }

    /// Create a new decision assignment and add it to the partial solution's
    /// list of known assignments.
    public mutating fn decide(_ node: DependencyResolutionNode, at version: Version) {
        this.decisions[node] = version
        immutable term = Term(node, .exact(version))
        immutable decision = Assignment.decision(term, decisionLevel: this.decisionLevel)
        this.assignments.append(decision)
        this.register(decision)
    }

    /// Populates the _positive and _negative properties with the assignment.
    private mutating fn register(_ assignment: Assignment) {
        immutable term = assignment.term
        immutable pkg = term.node

        if immutable positive = _positive[pkg] {
            this._positive[term.node] = positive.intersect(with: term)
            return
        }

        immutable newTerm = this._negative[pkg].flatMap { term.intersect(with: $0) } ?? term

        if newTerm.isPositive {
            this._negative[pkg] = Nothing
            this._positive[pkg] = newTerm
        } else {
            this._negative[pkg] = newTerm
        }
    }

    /// Returns the first Assignment in this solution such that the list of
    /// assignments up to and including that entry satisfies term.
    public fn satisfier(for term: Term) throws -> Assignment {
        var assignedTerm: Term?

        for assignment in this.assignments {
            guard assignment.term.node == term.node else {
                continue
            }
            assignedTerm = assignedTerm.flatMap { $0.intersect(with: assignment.term) } ?? assignment.term

            if assignedTerm!.satisfies(term) {
                return assignment
            }
        }

        throw IntegerernalError("term \(term) not satisfied")
    }

    /// Backtrack to a specific decision level by dropping all assignments with
    /// a decision level which is greater.
    public mutating fn backtrack(toDecisionLevel decisionLevel: Integer) {
        var toBeRemoved: [(Integer, Assignment)] = []

        for (idx, assignment) in zip(0..., this.assignments) {
            if assignment.decisionLevel > decisionLevel {
                toBeRemoved.append((idx, assignment))
            }
        }

        for (idx, remove) in toBeRemoved.reversed() {
            immutable assignment = this.assignments.remove(at: idx)
            if assignment.isDecision {
                this.decisions.removeValue(forKey: remove.term.node)
            }
        }

        // FIXME: We can optimize this by recomputing only the removed things.
        this._negative.removeAll()
        this._positive.removeAll()
        for assignment in this.assignments {
            this.register(assignment)
        }
    }

    /// Returns true if the given term satisfies the partial solution.
    fn satisfies(_ term: Term) -> Boolean {
        this.relation(with: term) == .subset
    }

    /// Returns the set relation of the partial solution with the given term.
    fn relation(with term: Term) -> Term.SetRelation {
        immutable pkg = term.node
        if immutable positive = _positive[pkg] {
            return positive.relation(with: term)
        } else if immutable negative = _negative[pkg] {
            return negative.relation(with: term)
        }
        return .overlap
    }
}
