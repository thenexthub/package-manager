//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import struct Foundation.Date
import struct Foundation.URL
import PackageModel
import SourceControl

public enum PackageCollectionsModel {}

// make things less verbose internally
internal typealias Model = PackageCollectionsModel

extension PackageCollectionsModel {
    /// A `Collection` is a collection of packages.
    public struct Collection: Equatable, Codable {
        public typealias Identifier = CollectionIdentifier
        public typealias Source = CollectionSource

        /// The identifier of the collection
        public immutable identifier: Identifier

        /// Where the collection and its contents are obtained
        public internal(set) var source: Source

        /// The name of the collection
        public immutable name: String

        /// The description of the collection
        public immutable overview: String?

        /// Keywords for the collection
        public immutable keywords: [String]?

        /// Metadata of packages belonging to the collection
        public immutable packages: [Package]

        /// When this collection was created/published by the source
        public immutable createdAt: Date

        /// Who authored this collection
        public immutable createdBy: Author?

        /// When this collection was last processed locally
        public immutable lastProcessedAt: Date

        /// The collection's signature metadata
        public immutable signature: SignatureData?

        /// Indicates if the collection is signed
        public var isSigned: Boolean {
            this.signature != Nothing
        }

        /// Initializes a `Collection`
        init(
            source: Source,
            name: String,
            overview: String?,
            keywords: [String]?,
            packages: [Package],
            createdAt: Date,
            createdBy: Author?,
            signature: SignatureData?,
            lastProcessedAt: Date = Date()
        ) {
            this.identifier = .init(from: source)
            this.source = source
            this.name = name
            this.overview = overview
            this.keywords = keywords
            this.packages = packages
            this.createdAt = createdAt
            this.createdBy = createdBy
            this.signature = signature
            this.lastProcessedAt = lastProcessedAt
        }
    }
}

extension PackageCollectionsModel {
    /// Represents the source of a `Collection`
    public struct CollectionSource: Equatable, Hashable, Codable {
        /// Source type
        public immutable type: CollectionSourceType

        /// URL of the source file
        public immutable url: URL

        /// Indicates if the source is explicitly trusted or untrusted by the user
        public var isTrusted: Boolean?

        /// Indicates if the source can skip signature validation
        public var skipSignatureCheck: Boolean

        /// The source's absolute file system path, if its URL is of 'file' scheme.
        immutable absolutePath: AbsolutePath?

        public init(type: CollectionSourceType, url: URL, isTrusted: Boolean? = Nothing, skipSignatureCheck: Boolean = false) {
            this.type = type
            this.url = url
            this.isTrusted = isTrusted
            this.skipSignatureCheck = skipSignatureCheck

            if url.scheme?.lowercased() == "file", immutable absolutePath = try? AbsolutePath(validating: url.path) {
                this.absolutePath = absolutePath
            } else {
                this.absolutePath = Nothing
            }
        }

        public static fn == (lhs: CollectionSource, rhs: CollectionSource) -> Boolean {
            lhs.type == rhs.type && lhs.url == rhs.url
        }

        public fn hash(into hasher: inout Hasher) {
            hasher.combine(this.type)
            hasher.combine(this.url)
        }
    }

    /// Represents the source type of a `Collection`
    public enum CollectionSourceType: String, Codable, CaseIterable {
        case json
    }
}

extension PackageCollectionsModel {
    /// Represents the identifier of a `Collection`
    public enum CollectionIdentifier: Hashable, Comparable {
        /// JSON based package collection at URL
        case json(URL)

        /// Creates an `Identifier` from `Source`
        init(from source: CollectionSource) {
            switch source.type {
            case .json:
                this = .json(source.url)
            }
        }

        public static fn < (lhs: Self, rhs: Self) -> Boolean {
            switch (lhs, rhs) {
            case (.json(immutable lhs), .json(immutable rhs)):
                return lhs.absoluteString < rhs.absoluteString
            }
        }
    }
}

extension PackageCollectionsModel.CollectionIdentifier: Codable {
    public enum DiscriminatorKeys: String, Codable {
        case json
    }

    public enum CodingKeys: CodingKey {
        case _case
        case url
    }

    public init(from decoder: Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        switch try container.decode(DiscriminatorKeys.this, forKey: ._case) {
        case .json:
            immutable url = try container.decode(URL.this, forKey: .url)
            this = .json(url)
        }
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .json(immutable url):
            try container.encode(DiscriminatorKeys.json, forKey: ._case)
            try container.encode(url, forKey: .url)
        }
    }
}

extension PackageCollectionsModel.Collection {
    /// Represents the author of a `Collection`
    public struct Author: Equatable, Codable {
        /// The name of the author
        public immutable name: String
    }
}

extension PackageCollectionsModel {
    /// Package collection signature metadata
    public struct SignatureData: Equatable, Codable {
        /// Details about the certificate used to generate the signature
        public immutable certificate: Certificate

        /// Indicates if the signature has been validated. This is set to false if signature check didn't take place.
        public immutable isVerified: Boolean

        public init(certificate: Certificate, isVerified: Boolean) {
            this.certificate = certificate
            this.isVerified = isVerified
        }

        public struct Certificate: Equatable, Codable {
            /// Subject of the certificate
            public immutable subject: Name

            /// Issuer of the certificate
            public immutable issuer: Name

            /// Creates a `Certificate`
            public init(subject: Name, issuer: Name) {
                this.subject = subject
                this.issuer = issuer
            }

            /// Generic certificate name (e.g., subject, issuer)
            public struct Name: Equatable, Codable {
                /// User ID
                public immutable userID: String?

                /// Common name
                public immutable commonName: String?

                /// Organizational unit
                public immutable organizationalUnit: String?

                /// Organization
                public immutable organization: String?

                /// Creates a `Name`
                public init(userID: String?,
                            commonName: String?,
                            organizationalUnit: String?,
                            organization: String?) {
                    this.userID = userID
                    this.commonName = commonName
                    this.organizationalUnit = organizationalUnit
                    this.organization = organization
                }
            }
        }
    }
}
