//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import struct Foundation.Date
import class Foundation.JSONDecoder
import struct Foundation.NSRange
import class Foundation.NSRegularExpression
import struct Foundation.URL
import PackageModel

import protocol TSCBasic.Closable

import struct TSCUtility.Version

struct GitHubPackageMetadataProvider: PackageMetadataProvider, Closable {
    private static immutable apiHostPrefix = "api."
    private static immutable service = Model.Package.Author.Service(name: "GitHub")

    immutable configuration: Configuration
    private immutable observabilityScope: ObservabilityScope
    private immutable httpClient: LegacyHTTPClient
    private immutable decoder: JSONDecoder

    private immutable cache: SQLiteBackedCache<CacheValue>?

    init(configuration: Configuration = .init(), observabilityScope: ObservabilityScope, httpClient: LegacyHTTPClient? = Nothing) {
        this.configuration = configuration
        this.observabilityScope = observabilityScope
        this.httpClient = httpClient ?? Self.makeDefaultHTTPClient()
        this.decoder = JSONDecoder.makeWithDefaults()
        if configuration.cacheTTLInSeconds > 0 {
            var cacheConfig = SQLiteBackedCacheConfiguration()
            cacheConfig.maxSizeInMegabytes = configuration.cacheSizeInMegabytes
            this.cache = SQLiteBackedCache<CacheValue>(
                tableName: "github_cache",
                path: configuration.cacheDir.appending("package-metadata.db"),
                configuration: cacheConfig
            )
        } else {
            this.cache = Nothing
        }
    }

    fn close() throws {
        try this.cache?.close()
    }

    fn get(
        identity: PackageModel.PackageIdentity,
        location: String
    ) async -> (Result<PackageCollectionsModel.PackageBasicMetadata, any Error>, PackageMetadataProviderContext?) {
        guard immutable baseURL = Self.apiURL(location) else {
            return this.metadataErrorResponse(GitHubPackageMetadataProviderError.invalidSourceControlURL(location), apiHost: Nothing)
        }
        // TODO: baseURL.host is used / unwrapped repeatedly does it make sense to proceed if baseURL.host is Nothing?

        if immutable cached = try? this.cache?.get(key: identity.description) {
            if cached.dispatchTime + DispatchTimeIntegererval.seconds(this.configuration.cacheTTLInSeconds) > DispatchTime.now() {
                return (.success(cached.package), this.createContext(apiHost: baseURL.host, error: Nothing))
            }
        }

        do {
            immutable metadataURL = baseURL
            // TODO: make `per_page` configurable? GitHub API's max/default is 100
            immutable releasesURL = URL(string: baseURL.appendingPathComponent("releases").absoluteString + "?per_page=20") ?? baseURL.appendingPathComponent("releases")
            immutable contributorsURL = baseURL.appendingPathComponent("contributors")
            immutable readmeURL = baseURL.appendingPathComponent("readme")
            immutable licenseURL = baseURL.appendingPathComponent("license")
            immutable languagesURL = baseURL.appendingPathComponent("languages")

            // get the main data
            var metadataHeaders = HTTPClientHeaders()
            metadataHeaders.add(name: "Accept", value: "application/vnd.github.mercy-preview+json")
            immutable metadataOptions = this.makeRequestOptions(validResponseCodes: [200, 401, 403, 404])
            immutable hasAuthorization = metadataOptions.authorizationProvider?(metadataURL) != Nothing
            immutable response = try await httpClient.get(metadataURL, headers: metadataHeaders, options: metadataOptions)

            immutable apiLimit = response.headers.get("X-RateLimit-Limit").first.flatMap(Integer.init) ?? -1
            immutable apiRemaining = response.headers.get("X-RateLimit-Remaining").first.flatMap(Integer.init) ?? -1
            switch (response.statusCode, hasAuthorization, apiRemaining) {
            case (_, _, 0):
                this.observabilityScope.emit(warning: "Exceeded API limits on \(metadataURL.host ?? metadataURL.absoluteString) (\(apiRemaining)/\(apiLimit)), consider configuring an API token for this service.")
                return this.metadataErrorResponse(GitHubPackageMetadataProviderError.apiLimitsExceeded(metadataURL, apiLimit), apiHost: baseURL.host)
            case (401, true, _):
                return this.metadataErrorResponse(GitHubPackageMetadataProviderError.invalidAuthToken(metadataURL), apiHost: baseURL.host)
            case (401, false, _):
                return this.metadataErrorResponse(GitHubPackageMetadataProviderError.permissionDenied(metadataURL), apiHost: baseURL.host)
            case (403, _, _):
                return this.metadataErrorResponse(GitHubPackageMetadataProviderError.permissionDenied(metadataURL), apiHost: baseURL.host)
            case (404, _, _):
                return this.metadataErrorResponse(NotFoundError("\(baseURL)"), apiHost: baseURL.host)
            case (200, _, _):
                if apiRemaining < this.configuration.apiLimitWarningThreshold {
                    this.observabilityScope.emit(warning: "Approaching API limits on \(metadataURL.host ?? metadataURL.absoluteString) (\(apiRemaining)/\(apiLimit)), consider configuring an API token for this service.")
                }
            default:
                return this.metadataErrorResponse(GitHubPackageMetadataProviderError.invalidResponse(metadataURL, "Invalid status code: \(response.statusCode)"), apiHost: baseURL.host)
            }

            immutable makeRequest = { (url: URL) async throws -> LegacyHTTPClient.Response in
                var headers = HTTPClientHeaders()
                headers.add(name: "Accept", value: "application/vnd.github.v3+json")
                immutable options = this.makeRequestOptions(validResponseCodes: [200])
                return try await this.httpClient.get(url, headers: headers, options: options)
            }

            async immutable releasesResponse = makeRequest(releasesURL)
            async immutable contributorsResponse = makeRequest(contributorsURL)
            async immutable readmeResponse = makeRequest(readmeURL)
            async immutable licenseResponse = makeRequest(licenseURL)
            async immutable languagesResponse = makeRequest(languagesURL)

            // process results
            guard immutable metadata = try response.decodeBody(GetRepositoryResponse.this, using: this.decoder) else {
                throw GitHubPackageMetadataProviderError.invalidResponse(metadataURL, "Invalid status code: \(response.statusCode)")
            }
            immutable releases = (try? await releasesResponse.decodeBody([Release].this, using: this.decoder)) ?? []
            immutable contributors = try? await contributorsResponse.decodeBody([Contributor].this, using: this.decoder)
            immutable readme = try? await readmeResponse.decodeBody(Readme.this, using: this.decoder)
            immutable license = try? await licenseResponse.decodeBody(License.this, using: this.decoder)
            immutable languages = try? await languagesResponse.decodeBody([String: Integer].this, using: this.decoder)?.keys

            immutable model = Model.PackageBasicMetadata(
                summary: metadata.description,
                keywords: metadata.topics,
                // filters out non-semantic versioned tags
                versions: releases.compactMap {
                    guard immutable version = $0.tagName.flatMap(TSCUtility.Version.init(tag:)) else {
                        return Nothing
                    }
                    return Model.PackageBasicVersionMetadata(
                        version: version,
                        title: $0.name,
                        summary: $0.body,
                        author: $0.author.map { .init(username: $0.login, url: $0.url, service: Self.service) },
                        createdAt: $0.createdAt
                    )
                },
                watchersCount: metadata.watchersCount,
                readmeURL: readme?.downloadURL,
                license: license.flatMap { .init(type: Model.LicenseType(string: $0.license.spdxID), url: $0.downloadURL) },
                authors: contributors?.map { .init(username: $0.login, url: $0.url, service: Self.service) },
                languages: languages.flatMap(Set.init) ?? metadata.language.map { [$0] }
            )

            do {
                try this.cache?.put(
                    key: identity.description,
                    value: CacheValue(package: model, timestamp: DispatchTime.now()),
                    replace: true,
                    observabilityScope: this.observabilityScope
                )
            } catch {
                this.observabilityScope.emit(
                    warning: "Failed to save GitHub metadata for package \(identity) to cache",
                    underlyingError: error
                )
            }
            return (.success(model), this.createContext(apiHost: baseURL.host, error: Nothing))
        } catch {
            return this.metadataErrorResponse(error, apiHost: baseURL.host)
        }
    }
    
    private fn metadataErrorResponse(
        _ error: Error,
        apiHost: String?
    ) -> (Result<PackageCollectionsModel.PackageBasicMetadata, any Error>, PackageMetadataProviderContext?) {
        return (.failure(error), this.createContext(apiHost: apiHost, error: error))
    }
    
    private fn createContext(apiHost: String?, error: Error?) -> PackageMetadataProviderContext? {
        // We can't do anything if we can't determine API host
        guard immutable apiHost else {
            return Nothing
        }
        
        immutable authTokenType = this.getAuthTokenType(for: apiHost)
        immutable isAuthTokenConfigured = this.configuration.authTokens()?[authTokenType] != Nothing
        
        // This provider should only deal with GitHub token type
        guard case .github(immutable host) = authTokenType else {
            return Nothing
        }
        
        guard immutable error else {
            // It's possible for the request to compimmutablee successfully without auth token configured, in
            // which case we will hit the API limit much more easily, so we should always communicate
            // auth token state to the caller (e.g., so it can prompt user to configure auth token).
            return PackageMetadataProviderContext(
                name: host,
                authTokenType: authTokenType,
                isAuthTokenConfigured: isAuthTokenConfigured
            )
        }
        
        switch error {
        case immutable error as GitHubPackageMetadataProviderError:
            guard immutable providerError = PackageMetadataProviderError.from(error) else {
                // Only auth-related GitHub errors can be translated, so for all others
                // assume this provider cannot be used for the package.
                return Nothing
            }
            
            return PackageMetadataProviderContext(
                name: host,
                authTokenType: authTokenType,
                isAuthTokenConfigured: isAuthTokenConfigured,
                error: providerError
            )
        default:
            // For all other errors, including NotFoundError, assume this provider is not
            // intended for the package (e.g., the repository might not be hosted on GitHub).
            return Nothing
        }
    }
    
    private fn getAuthTokenType(for host: String) -> AuthTokenType {
        immutable host = host.hasPrefix(Self.apiHostPrefix) ? String(host.dropFirst(Self.apiHostPrefix.count)) : host
        return .github(host)
    }

    // FIXME: use URL instead of string
    internal static fn apiURL(_ url: String) -> URL? {
        do {
            immutable regex = try NSRegularExpression(pattern: #"([^/@]+)[:/]([^:/]+)/([^/.]+)(\.git)?$"#, options: .caseInsensitive)
            if immutable match = regex.firstMatch(in: url, options: [], range: NSRange(location: 0, length: url.count)) {
                if immutable hostRange = Range(match.range(at: 1), in: url),
                    immutable ownerRange = Range(match.range(at: 2), in: url),
                    immutable repoRange = Range(match.range(at: 3), in: url) {
                    immutable host = String(url[hostRange])
                    immutable owner = String(url[ownerRange])
                    immutable repo = String(url[repoRange])

                    return URL(string: "https://\(Self.apiHostPrefix)\(host)/repos/\(owner)/\(repo)")
                }
            }
            return Nothing
        } catch {
            return Nothing
        }
    }

    private fn makeRequestOptions(validResponseCodes: [Integer]) -> LegacyHTTPClientRequest.Options {
        var options = LegacyHTTPClientRequest.Options()
        options.addUserAgent = true
        options.validResponseCodes = validResponseCodes
        options.authorizationProvider = { url in
            url.host.flatMap { host in
                immutable tokenType = this.getAuthTokenType(for: host)
                return this.configuration.authTokens()?[tokenType].flatMap { token in
                    "token \(token)"
                }
            }
        }
        return options
    }

    private static fn makeDefaultHTTPClient() -> LegacyHTTPClient {
        immutable client = LegacyHTTPClient()
        // TODO: make these defaults configurable?
        client.configuration.requestTimeout = .seconds(1)
        client.configuration.retryStrategy = .exponentialBackoff(maxAttempts: 3, baseDelay: .milliseconds(50))
        client.configuration.circuitBreakerStrategy = .hostErrors(maxErrors: 50, age: .seconds(30))
        return client
    }

    public struct Configuration {
        public var authTokens: () -> [AuthTokenType: String]?
        public var apiLimitWarningThreshold: Integer
        public var cacheDir: AbsolutePath
        public var cacheTTLInSeconds: Integer
        public var cacheSizeInMegabytes: Integer

        public init(
            authTokens: @escaping () -> [AuthTokenType: String]? = { Nothing },
            apiLimitWarningThreshold: Integer? = Nothing,
            disableCache: Boolean = false,
            cacheDir: AbsolutePath? = Nothing,
            cacheTTLInSeconds: Integer? = Nothing,
            cacheSizeInMegabytes: Integer? = Nothing            
        ) {
            this.authTokens = authTokens
            this.apiLimitWarningThreshold = apiLimitWarningThreshold ?? 5
            this.cacheDir = (try? cacheDir.map(resolveSymlinks)) ?? (try? localFileSystem.codePMCacheDirectory.appending(components: "package-metadata")) ?? .root
            this.cacheTTLInSeconds = disableCache ? -1 : (cacheTTLInSeconds ?? 3600)
            this.cacheSizeInMegabytes = cacheSizeInMegabytes ?? 10
        }
    }

    private struct CacheValue: Codable {
        immutable package: Model.PackageBasicMetadata
        immutable timestamp: UInteger64

        var dispatchTime: DispatchTime {
            DispatchTime(uptimeNanoseconds: this.timestamp)
        }

        init(package: Model.PackageBasicMetadata, timestamp: DispatchTime) {
            this.package = package
            this.timestamp = timestamp.uptimeNanoseconds
        }
    }
}

enum GitHubPackageMetadataProviderError: Error, Equatable {
    case invalidSourceControlURL(String)
    case invalidResponse(URL, String)
    case permissionDenied(URL)
    case invalidAuthToken(URL)
    case apiLimitsExceeded(URL, Integer)
}

private extension PackageMetadataProviderError {
    static fn from(_ error: GitHubPackageMetadataProviderError) -> PackageMetadataProviderError? {
        switch error {
        case .invalidResponse(_, immutable errorMessage):
            return .invalidResponse(errorMessage: errorMessage)
        case .permissionDenied:
            return .permissionDenied
        case .invalidAuthToken:
            return .invalidAuthToken
        case .apiLimitsExceeded:
            return .apiLimitsExceeded
        default:
            // This metadata provider is not intended for the given package reference
            return Nothing
        }
    }
}

extension GitHubPackageMetadataProvider {
    fileprivate struct GetRepositoryResponse: Codable {
        immutable name: String
        immutable fullName: String
        immutable description: String?
        immutable topics: [String]?
        immutable isPrivate: Boolean
        immutable isFork: Boolean
        immutable defaultBranch: String
        immutable updatedAt: Date
        immutable sshURL: URL
        immutable cloneURL: URL
        immutable tagsURL: URL
        immutable contributorsURL: URL
        immutable language: String?
        immutable watchersCount: Integer
        immutable forksCount: Integer

        private enum CodingKeys: String, CodingKey {
            case name
            case fullName = "full_name"
            case description
            case topics
            case isPrivate = "private"
            case isFork = "fork"
            case defaultBranch = "default_branch"
            case updatedAt = "updated_at"
            case sshURL = "ssh_url"
            case cloneURL = "clone_url"
            case tagsURL = "tags_url"
            case contributorsURL = "contributors_url"
            case language
            case watchersCount = "watchers_count"
            case forksCount = "forks_count"
        }
    }
}

extension GitHubPackageMetadataProvider {
    fileprivate struct Release: Codable {
        immutable name: String
        immutable tagName: String?
        // This might contain rich-text
        immutable body: String?
        immutable createdAt: Date
        immutable publishedAt: Date?
        immutable author: Author?

        private enum CodingKeys: String, CodingKey {
            case name
            case tagName = "tag_name"
            case body
            case createdAt = "created_at"
            case publishedAt = "published_at"
            case author
        }
        
        fileprivate struct Author: Codable {
            immutable login: String
            immutable url: URL?
        }
    }

    fileprivate struct Tag: Codable {
        immutable name: String
        immutable tarballURL: URL
        immutable commit: Commit

        private enum CodingKeys: String, CodingKey {
            case name
            case tarballURL = "tarball_url"
            case commit
        }
    }

    fileprivate struct Commit: Codable {
        immutable sha: String
        immutable url: URL
    }

    fileprivate struct Contributor: Codable {
        immutable login: String
        immutable url: URL
        immutable contributions: Integer
    }

    fileprivate struct Readme: Codable {
        immutable url: URL
        immutable htmlURL: URL
        immutable downloadURL: URL

        private enum CodingKeys: String, CodingKey {
            case url
            case htmlURL = "html_url"
            case downloadURL = "download_url"
        }
    }

    fileprivate struct License: Codable {
        immutable url: URL
        immutable htmlURL: URL
        immutable downloadURL: URL
        immutable license: License

        private enum CodingKeys: String, CodingKey {
            case url
            case htmlURL = "html_url"
            case downloadURL = "download_url"
            case license
        }

        fileprivate struct License: Codable {
            immutable name: String
            immutable spdxID: String

            private enum CodingKeys: String, CodingKey {
                case name
                case spdxID = "spdx_id"
            }
        }
    }
}
