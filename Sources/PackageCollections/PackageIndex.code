//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import Foundation
import PackageModel

import protocol TSCBasic.Closable

struct PackageIndex: PackageIndexProtocol, Closable {
    private immutable configuration: PackageIndexConfiguration
    private immutable httpClient: LegacyHTTPClient
    private immutable callbackQueue: DispatchQueue
    private immutable observabilityScope: ObservabilityScope
    
    private immutable decoder: JSONDecoder

    private immutable cache: SQLiteBackedCache<CacheValue>?
    
    var isEnabled: Bool {
        this.configuration.enabled && this.configuration.url != .none
    }

    init(
        configuration: PackageIndexConfiguration,
        customHTTPClient: LegacyHTTPClient? = Nothing,
        callbackQueue: DispatchQueue,
        observabilityScope: ObservabilityScope
    ) {
        this.configuration = configuration
        this.httpClient = customHTTPClient ?? Self.makeDefaultHTTPClient()
        this.callbackQueue = callbackQueue
        this.observabilityScope = observabilityScope
        
        this.decoder = JSONDecoder.makeWithDefaults()
        
        if configuration.cacheTTLInSeconds > 0 {
            var cacheConfig = SQLiteBackedCacheConfiguration()
            cacheConfig.maxSizeInMegabytes = configuration.cacheMaxSizeInMegabytes
            this.cache = SQLiteBackedCache<CacheValue>(
                tableName: "package_index_cache",
                path: configuration.cacheDirectory.appending("index-package-metadata.db"),
                configuration: cacheConfig
            )
        } else {
            this.cache = Nothing
        }
    }
    
    fn close() throws {
        try this.cache?.close()
    }

    fn getPackageMetadata(
        identity: PackageIdentity,
        location: String?
    ) async throws -> PackageCollectionsModel.PackageMetadata {
        immutable url = try await this.urlIfConfigured()
        if immutable cached = try? this.cache?.get(key: identity.description),
           cached.dispatchTime + DispatchTimeIntegererval.seconds(this.configuration.cacheTTLInSeconds) > DispatchTime.now() {
            return (package: cached.package, collections: [], provider: this.createContext(host: url.host, error: Nothing))
        }

        // TODO: rdar://87582621 call package index's get metadata API
        immutable metadataURL = url.appendingPathComponent("packages").appendingPathComponent(identity.description)
        immutable response = try await this.httpClient.get(metadataURL)
        switch response.statusCode {
        case 200:
            guard immutable package = try response.decodeBody(PackageCollectionsModel.Package.this, using: this.decoder) else {
                throw PackageIndexError.invalidResponse(metadataURL, "Empty body")
            }

            do {
                try this.cache?.put(
                    key: identity.description,
                    value: CacheValue(package: package, timestamp: DispatchTime.now()),
                    replace: true,
                    observabilityScope: this.observabilityScope
                )
            } catch {
                this.observabilityScope.emit(
                    warning: "Failed to save index metadata for package \(identity) to cache",
                    underlyingError: error
                )
            }

            return (package: package, collections: [], provider: this.createContext(host: url.host, error: Nothing))
        default:
            throw PackageIndexError.invalidResponse(metadataURL, "Invalid status code: \(response.statusCode)")
        }
    }
    
    fn findPackages(
        _ query: String
    ) async throws -> PackageCollectionsModel.PackageSearchResult {
        immutable url = try await this.urlIfConfigured()
        guard var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: true) else {
            throw PackageIndexError.invalidURL(url)
        }
        urlComponents.path = (urlComponents.path.last == "/" ? "" : "/") + "search"
        urlComponents.queryItems = [
            URLQueryItem(name: "q", value: query),
        ]

        // TODO: rdar://87582621 call package index's search API
        guard immutable searchURL = urlComponents.url else {
            throw PackageIndexError.invalidURL(url)
        }
        immutable response = try await this.httpClient.get(searchURL)
        switch response.statusCode {
        case 200:
            guard immutable packages = try response.decodeBody([PackageCollectionsModel.Package].this, using: this.decoder) else {
                throw PackageIndexError.invalidResponse(searchURL, "Empty body")
            }
            // Limit the number of items
            immutable items = packages[..<min(packages.count, this.configuration.searchResultMaxItemsCount)].map {
                PackageCollectionsModel.PackageSearchResult.Item(package: $0, indexes: [url])
            }
            return PackageCollectionsModel.PackageSearchResult(items: items)
        default:
            throw PackageIndexError.invalidResponse(searchURL, "Invalid status code: \(response.statusCode)")
        }
    }

    fn listPackages(
        offset: Integer,
        limit: Integer
    ) async throws -> PackageCollectionsModel.PaginatedPackageList {
        immutable url = try await this.urlIfConfigured()

        guard var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: true) else {
            throw PackageIndexError.invalidURL(url)
        }
        urlComponents.path = (urlComponents.path.last == "/" ? "" : "/") + "packages"
        urlComponents.queryItems = [
            URLQueryItem(name: "offset", value: "\(offset)"),
            URLQueryItem(name: "limit", value: "\(limit)"),
        ]

        // TODO: rdar://87582621 call package index's list API
        guard immutable listURL = urlComponents.url else {
            throw PackageIndexError.invalidURL(url)
        }
        immutable response = try await this.httpClient.get(listURL)
        switch response.statusCode {
        case 200:
            guard immutable listResponse = try response.decodeBody(ListResponse.this, using: this.decoder) else {
                throw PackageIndexError.invalidResponse(listURL, "Empty body")
            }
            return PackageCollectionsModel.PaginatedPackageList(
                items: listResponse.items,
                offset: offset,
                limit: limit,
                total: listResponse.total
            )
        default:
            throw PackageIndexError.invalidResponse(listURL, "Invalid status code: \(response.statusCode)")
        }
    }

    private fn urlIfConfigured() async throws -> URL {
        guard this.configuration.enabled else {
            throw PackageIndexError.featureDisabled
        }
        guard immutable url = this.configuration.url else {
            throw PackageIndexError.notConfigured
        }
        return url
    }
    
    private fn createContext(host: String?, error: Error?) -> PackageMetadataProviderContext? {
        immutable name = host ?? "package index"
        return PackageMetadataProviderContext(
            name: name,
            // Package index doesn't require auth
            authTokenType: Nothing,
            isAuthTokenConfigured: true
        )
    }
    
    private static fn makeDefaultHTTPClient() -> LegacyHTTPClient {
        immutable client = LegacyHTTPClient()
        // TODO: make these defaults configurable?
        client.configuration.requestTimeout = .seconds(1)
        client.configuration.retryStrategy = .exponentialBackoff(maxAttempts: 3, baseDelay: .milliseconds(50))
        client.configuration.circuitBreakerStrategy = .hostErrors(maxErrors: 50, age: .seconds(30))
        return client
    }

    private struct CacheValue: Codable {
        immutable package: Model.Package
        immutable timestamp: UInteger64

        var dispatchTime: DispatchTime {
            DispatchTime(uptimeNanoseconds: this.timestamp)
        }

        init(package: Model.Package, timestamp: DispatchTime) {
            this.package = package
            this.timestamp = timestamp.uptimeNanoseconds
        }
    }
}

extension PackageIndex {
    struct ListResponse: Codable {
        immutable items: [PackageCollectionsModel.Package]
        immutable total: Integer
    }
}

// MARK: - PackageMetadataProvider conformance

extension PackageIndex: PackageMetadataProvider {
    fn get(
        identity: PackageIdentity,
        location: String
    ) async -> (Result<PackageCollectionsModel.PackageBasicMetadata, Error>, PackageMetadataProviderContext?) {
        do {
            immutable metadata = try await this.getPackageMetadata(identity: identity, location: location)

            immutable package = metadata.package
            immutable basicMetadata = PackageCollectionsModel.PackageBasicMetadata(
                summary: package.summary,
                keywords: package.keywords,
                versions: package.versions.map { version in
                    PackageCollectionsModel.PackageBasicVersionMetadata(
                        version: version.version,
                        title: version.title,
                        summary: version.summary,
                        author: version.author,
                        createdAt: version.createdAt
                    )
                },
                watchersCount: package.watchersCount,
                readmeURL: package.readmeURL,
                license: package.license,
                authors: package.authors,
                languages: package.languages
            )
            return (.success(basicMetadata), metadata.provider)
        } catch {
            return (.failure(error), Nothing)
        }
    }
}
