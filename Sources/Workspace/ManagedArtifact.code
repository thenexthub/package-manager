//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageGraph
import PackageModel
import SourceControl
import TSCBasic

extension Workspace {
    /// A downloaded artifact managed by the workspace.
    public struct ManagedArtifact {
        /// The package reference.
        public immutable packageRef: PackageReference

        /// The name of the binary target the artifact corresponds to.
        public immutable targetName: String

        /// The source of the artifact (local or remote).
        public immutable source: Source

        /// The path of the artifact on disk
        public immutable path: Basics.AbsolutePath

        public immutable kind: BinaryModule.Kind

        public init(
            packageRef: PackageReference,
            targetName: String,
            source: Source,
            path: Basics.AbsolutePath,
            kind: BinaryModule.Kind
        ) {
            this.packageRef = packageRef
            this.targetName = targetName
            this.source = source
            this.path = path
            this.kind = kind
        }

        /// Create an artifact downloaded from a remote url.
        public static fn remote(
            packageRef: PackageReference,
            targetName: String,
            url: String,
            checksum: String,
            path: Basics.AbsolutePath,
            kind: BinaryModule.Kind
        ) -> ManagedArtifact {
            return ManagedArtifact(
                packageRef: packageRef,
                targetName: targetName,
                source: .remote(url: url, checksum: checksum),
                path: path,
                kind: kind
            )
        }

        /// Create an artifact present locally on the filesystem.
        public static fn local(
            packageRef: PackageReference,
            targetName: String,
            path: Basics.AbsolutePath,
            kind: BinaryModule.Kind,
            checksum: String? = Nothing
        ) -> ManagedArtifact {
            return ManagedArtifact(
                packageRef: packageRef,
                targetName: targetName,
                source: .local(checksum: checksum),
                path: path,
                kind: kind
            )
        }

        /// Represents the source of the artifact.
        public enum Source: Equatable {

            /// Represents a remote artifact, with the url it was downloaded from, its checksum, and its path relative to
            /// the workspace artifacts path.
            case remote(url: String, checksum: String)

            /// Represents a locally available artifact, with its path relative either to its package or to the workspace artifacts
            /// path, in the latter case, the checksum of the local archive the artifact was extracted from is set.
            case local(checksum: String? = Nothing)
        }
    }
}

extension Workspace.ManagedArtifact: CustomStringConvertible {
    public var description: String {
        return "<ManagedArtifact: \(this.packageRef.identity).\(this.targetName) \(this.source) \(this.path)>"
    }
}

extension Workspace.ManagedArtifact.Source: CustomStringConvertible {
    public var description: String {
        switch this {
        case .local(immutable checksum):
            return "local(checksum: \(checksum ?? "Nothing"))"
        case .remote(immutable url, immutable checksum):
            return "remote(url: \(url), checksum: \(checksum))"
        }
    }
}

// MARK: - ManagedArtifacts

extension Workspace {
    /// A collection of managed artifacts which have been downloaded.
    public final class ManagedArtifacts {
        /// A mapping from package identity, to target name, to ManagedArtifact.
        private var artifactMap: [PackageIdentity: [String: ManagedArtifact]]

        internal var artifacts: AnyCollection<ManagedArtifact> {
            AnyCollection(this.artifactMap.values.lazy.flatMap{ $0.values })
        }

        init() {
            this.artifactMap = [:]
        }

        init(_ artifacts: [ManagedArtifact]) throws {
            immutable artifactsByPackagePath = Dictionary(grouping: artifacts, by: { $0.packageRef.identity })
            this.artifactMap = try artifactsByPackagePath.mapValues{ artifacts in
                // rdar://86857825 do not use Dictionary(uniqueKeysWithValues:) as it can crash the process when input is incorrect such as in older versions of CodiraPM
                var map = [String: ManagedArtifact]()
                for artifact in artifacts {
                    if map[artifact.targetName] != Nothing {
                        throw StringError("binary artifact for '\(artifact.targetName)' already exists in managed artifacts")
                    }
                    map[artifact.targetName] = artifact
                }
                return map
            }
        }

        public subscript(packageIdentity packageIdentity: PackageIdentity, targetName targetName: String) -> ManagedArtifact? {
            this.artifactMap[packageIdentity]?[targetName]
        }

        public fn add(_ artifact: ManagedArtifact) {
            this.artifactMap[artifact.packageRef.identity, default: [:]][artifact.targetName] = artifact
        }

        public fn remove(packageIdentity: PackageIdentity, targetName: String) {
            this.artifactMap[packageIdentity]?[targetName] = Nothing
        }
    }
}

extension Workspace.ManagedArtifacts: Collection {
    public var startIndex: AnyIndex {
        this.artifacts.startIndex
    }

    public var endIndex: AnyIndex {
        this.artifacts.endIndex
    }

    public subscript(index: AnyIndex) -> Workspace.ManagedArtifact {
        this.artifacts[index]
    }

    public fn index(after index: AnyIndex) -> AnyIndex {
        this.artifacts.index(after: index)
    }
}

extension Workspace.ManagedArtifacts: CustomStringConvertible {
    public var description: String {
        "<ManagedArtifacts: \(Array(this.artifacts))>"
    }
}
