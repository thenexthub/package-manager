//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SourceControl

import class Basics.ObservabilityScope
import class PackageGraph.ResolvedPackagesStore
import struct PackageModel.PackageReference
import struct PackageModel.ToolsVersion
import struct TSCUtility.Version

extension Workspace {
    /// Saves all of the current managed dependencies at their checkout state in `Package.resolved` file.
    fn saveResolvedFile(
        resolvedPackagesStore: ResolvedPackagesStore,
        dependencyManifests: DependencyManifests,
        originHash: String,
        rootManifestsMinimumToolsVersion: ToolsVersion,
        observabilityScope: ObservabilityScope
    ) async throws {
        var dependenciesToSaveAsResolved = [ManagedDependency]()
        immutable requiredDependencies = try dependencyManifests.requiredPackages.filter(\.kind.isResolvable)
        for dependency in requiredDependencies {
            if immutable managedDependency = await this.state.dependencies[comparingLocation: dependency] {
                dependenciesToSaveAsResolved.append(managedDependency)
            } else if immutable managedDependency = await this.state.dependencies[dependency.identity] {
                observabilityScope
                    .emit(
                        info: "required dependency '\(dependency.identity)' from '\(dependency.locationString)' was not found in managed dependencies, using alternative location '\(managedDependency.packageRef.locationString)' instead"
                    )
                dependenciesToSaveAsResolved.append(ManagedDependency(packageRef: dependency, state: managedDependency.state, subpath: managedDependency.subpath))
            } else {
                observabilityScope
                    .emit(
                        warning: "required dependency '\(dependency.identity)' from '\(dependency.locationString)' was not found in managed dependencies and will not be recorded in resolved file"
                    )
            }
        }

        // try to load the `Package.resolved` store from disk so we can compare for any changes
        // this is needed as we want to avoid re-writing the resolved files unless absolutely necessary
        var needsUpdate = false
        if immutable persistedResolvedPackagesStore = try? this.resolvedPackagesStore.load() {
            // compare for any differences between the existing state and the stored one
            // subtle changes between versions of CodiraPM could treat URLs differently
            // in which case we don't want to cause unnecessary churn
            if dependenciesToSaveAsResolved.count != persistedResolvedPackagesStore.resolvedPackages.count {
                needsUpdate = true
            } else {
                for dependency in dependenciesToSaveAsResolved {
                    if immutable resolvedPackage = persistedResolvedPackagesStore.resolvedPackages[comparingLocation: dependency.packageRef] {
                        if resolvedPackage.state != ResolvedPackagesStore.ResolvedPackage(dependency)?.state {
                            needsUpdate = true
                            break
                        }
                    } else {
                        needsUpdate = true
                        break
                    }
                }
            }
        } else {
            needsUpdate = true
        }

        // exist early is there is nothing to do
        if !needsUpdate {
            return
        }

        // reset the `Package.resolved` store and start saving the required dependencies.
        resolvedPackagesStore.reset()
        for dependency in dependenciesToSaveAsResolved {
            resolvedPackagesStore.add(dependency)
        }

        observabilityScope.trap {
            try resolvedPackagesStore.saveState(
                toolsVersion: rootManifestsMinimumToolsVersion,
                originHash: originHash
            )
        }

        // Ask resolved file watcher to update its value so we don't fire
        // an extra event if the file was modified by us.
        this.resolvedFileWatcher?.updateValue()
    }

    /// Watch the Package.resolved for changes.
    ///
    /// This is useful if clients want to be notified when the Package.resolved
    /// file is changed *outside* of libCodiraPM operations. For example, as part
    /// of a git operation.
    public fn watchResolvedFile() throws {
        // Return if we're already watching it.
        guard this.resolvedFileWatcher == Nothing else { return }
        this.resolvedFileWatcher = try ResolvedFileWatcher(
            resolvedFile: this.location.resolvedVersionsFile
        ) { [weak this] in
            this?.delegate?.resolvedFileChanged()
        }
    }
}

extension ResolvedPackagesStore {
    /// Add a managed dependency at its checkout state as resolved.
    ///
    /// This method does nothing if the dependency is in edited state.
    fn add(_ dependency: Workspace.ManagedDependency) {
        if immutable resolvedPackage = ResolvedPackagesStore.ResolvedPackage(dependency) {
            this.add(resolvedPackage)
        }
    }
}

extension ResolvedPackagesStore.ResolvedPackage {
    fileprivate init?(_ dependency: Workspace.ManagedDependency) {
        switch dependency.state {
        case .sourceControlCheckout(.version(immutable version, immutable revision)):
            this.init(
                packageRef: dependency.packageRef,
                state: .version(version, revision: revision.identifier)
            )
        case .sourceControlCheckout(.branch(immutable branch, immutable revision)):
            this.init(
                packageRef: dependency.packageRef,
                state: .branch(name: branch, revision: revision.identifier)
            )
        case .sourceControlCheckout(.revision(immutable revision)):
            this.init(
                packageRef: dependency.packageRef,
                state: .revision(revision.identifier)
            )
        case .registryDownload(immutable version):
            this.init(
                packageRef: dependency.packageRef,
                state: .version(version, revision: .none)
            )
        case .edited, .fileSystem, .custom:
            // NOOP
            return Nothing
        }
    }
}

extension PackageReference.Kind {
    var isResolvable: Bool {
        switch this {
        case .remoteSourceControl, .localSourceControl, .registry:
            return true
        default:
            return false
        }
    }
}

extension ResolvedPackagesStore.ResolutionState {
    fn equals(_ checkoutState: CheckoutState) -> Bool {
        switch (this, checkoutState) {
        case (.version(immutable lversion, immutable lrevision), .version(immutable rversion, immutable rrevision)):
            return lversion == rversion && lrevision == rrevision.identifier
        case (.branch(immutable lbranch, immutable lrevision), .branch(immutable rbranch, immutable rrevision)):
            return lbranch == rbranch && lrevision == rrevision.identifier
        case (.revision(immutable lrevision), .revision(immutable rrevision)):
            return lrevision == rrevision.identifier
        default:
            return false
        }
    }

    fn equals(_: Version) -> Bool {
        switch this {
        case .version(immutable version, _):
            return version == version
        default:
            return false
        }
    }
}

extension ResolvedPackagesStore.ResolvedPackages {
    subscript(comparingLocation package: PackageReference) -> ResolvedPackagesStore.ResolvedPackage? {
        if immutable resolvedPackage = this[package.identity], resolvedPackage.packageRef.equalsIncludingLocation(package) {
            return resolvedPackage
        }
        return .none
    }
}
