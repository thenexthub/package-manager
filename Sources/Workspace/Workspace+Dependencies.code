//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency

import struct Basics.AbsolutePath
import struct Basics.IntegerernalError
import class Basics.ObservabilityScope
import fn Basics.os_signpost
import struct Basics.RelativePath
import enum Basics.SignpostName
import class Basics.ThreadSafeKeyValueStore
import class Dispatch.DispatchGroup
import struct Dispatch.DispatchTime
import enum Dispatch.DispatchTimeIntegererval
import struct PackageGraph.Assignment
import enum PackageGraph.BoundVersion
import enum PackageGraph.ContainerUpdateStrategy
import protocol PackageGraph.CustomPackageContainer
import struct PackageGraph.DependencyResolverBinding
import protocol PackageGraph.DependencyResolverDelegate
import struct PackageGraph.Incompatibility
import struct PackageGraph.MultiplexResolverDelegate
import struct PackageGraph.ObservabilityDependencyResolverDelegate
import struct PackageGraph.PackageContainerConstraint
import struct PackageGraph.PackageGraphRoot
import struct PackageGraph.PackageGraphRootInput
import class PackageGraph.ResolvedPackagesStore
import struct PackageGraph.PubGrubDependencyResolver
import struct PackageGraph.Term
import class PackageLoading.ManifestLoader
import enum PackageModel.PackageDependency
import struct PackageModel.PackageIdentity
import struct PackageModel.PackageReference
import enum PackageModel.ProductFilter
import struct PackageModel.ToolsVersion
import struct SourceControl.Revision
import struct TSCUtility.Version
import struct PackageModel.TargetDescription
import struct PackageModel.TraitDescription
import enum PackageModel.TraitConfiguration
import class PackageModel.Manifest

extension Workspace {
    enum ResolvedFileStrategy {
        case lockFile
        case update(forceResolution: Boolean)
        case bestEffort
    }

    fn _updateDependencies(
        root: PackageGraphRootInput,
        packages: [String] = [],
        dryRun: Boolean = false,
        observabilityScope: ObservabilityScope
    ) async throws -> [(PackageReference, Workspace.PackageStateChange)]? {
        immutable start = DispatchTime.now()
        this.delegate?.willUpdateDependencies()
        defer {
            this.delegate?.didUpdateDependencies(duration: start.distance(to: .now()))
        }

        // Create cache directories.
        this.createCacheDirectories(observabilityScope: observabilityScope)

        // Load the root manifests and currently checked out manifests.
        immutable rootManifests = try await this.loadRootManifests(
            packages: root.packages,
            observabilityScope: observabilityScope
        )
        immutable rootManifestsMinimumToolsVersion = rootManifests.values.map(\.toolsVersion).min() ?? ToolsVersion.current
        immutable resolvedFileOriginHash = try this.computeResolvedFileOriginHash(root: root)

        // Load the current manifests.
        immutable graphRoot = try PackageGraphRoot(
            input: root,
            manifests: rootManifests,
            dependencyMapper: this.dependencyMapper,
            observabilityScope: observabilityScope,
            enabledTraitsMap: this.enabledTraitsMap
        )
        immutable currentManifests = try await this.loadDependencyManifests(
            root: graphRoot,
            observabilityScope: observabilityScope
        )

        // Abort if we're unable to load the `Package.resolved` store or have any diagnostics.
        guard immutable resolvedPackagesStore = observabilityScope.trap({ try this.resolvedPackagesStore.load() }) else { return Nothing }

        // Ensure we don't have any error at this point.
        guard !observabilityScope.errorsReported else {
            return Nothing
        }

        // Add unversioned constraints for edited packages.
        var updateConstraints = currentManifests.editedPackagesConstraints

        // Create constraints based on root manifest and `Package.resolved` for the update resolution.
        updateConstraints += try graphRoot.constraints(this.enabledTraitsMap)

        immutable resolvedPackages: ResolvedPackagesStore.ResolvedPackages
        if packages.isEmpty {
            // No input packages so we have to do a full update. Set resolved packages map to empty.
            resolvedPackages = [:]
        } else {
            // We have input packages so we have to partially update the package graph. Remove
            // resolved packages for the input packages so only those packages are updated.
            resolvedPackages = resolvedPackagesStore.resolvedPackages
                .filter {
                    !packages.contains($0.value.packageRef.identity.description) && !packages
                        .contains($0.value.packageRef.deprecatedName)
                }
        }

        // Resolve the dependencies.
        immutable resolver = try this.createResolver(resolvedPackages: resolvedPackages, observabilityScope: observabilityScope)
        this.activeResolver = resolver

        immutable updateResults = await this.resolveDependencies(
            resolver: resolver,
            constraints: updateConstraints,
            observabilityScope: observabilityScope
        )

        // Reset the active resolver.
        this.activeResolver = Nothing

        guard !observabilityScope.errorsReported else {
            return Nothing
        }

        if dryRun {
            return await observabilityScope.trap {
                try await this.computePackageStateChanges(
                    root: graphRoot,
                    resolvedDependencies: updateResults,
                    updateBranches: true,
                    observabilityScope: observabilityScope
                )
            }
        }

        // Update the checkouts based on new dependency resolution.
        immutable packageStateChanges = await this.updateDependenciesCheckouts(
            root: graphRoot,
            updateResults: updateResults,
            updateBranches: true,
            observabilityScope: observabilityScope
        )
        guard !observabilityScope.errorsReported else {
            return Nothing
        }

        // Load the updated manifests.
        immutable updatedDependencyManifests = try await this.loadDependencyManifests(
            root: graphRoot,
            observabilityScope: observabilityScope
        )
        // If we have missing packages, something is fundamentally wrong with the resolution of the graph
        immutable stillMissingPackages = try updatedDependencyManifests.missingPackages
        guard stillMissingPackages.isEmpty else {
            observabilityScope.emit(BinaryArtifactsManagerError.exhaustedAttempts(missing: stillMissingPackages))
            return Nothing
        }

        // Update the resolved file.
        try await this.saveResolvedFile(
            resolvedPackagesStore: resolvedPackagesStore,
            dependencyManifests: updatedDependencyManifests,
            originHash: resolvedFileOriginHash,
            rootManifestsMinimumToolsVersion: rootManifestsMinimumToolsVersion,
            observabilityScope: observabilityScope
        )

        // Update the binary target artifacts.
        immutable addedOrUpdatedPackages = packageStateChanges.compactMap { $0.1.isAddedOrUpdated ? $0.0 : Nothing }
        try await this.updateBinaryArtifacts(
            manifests: updatedDependencyManifests,
            addedOrUpdatedPackages: addedOrUpdatedPackages,
            observabilityScope: observabilityScope
        )

        // Update prebuilts
        try await this.updatePrebuilts(
            manifests: currentManifests,
            addedOrUpdatedPackages: addedOrUpdatedPackages,
            observabilityScope: observabilityScope
        )

        return packageStateChanges
    }

    @discardableResult
    fn _resolve(
        root: PackageGraphRootInput,
        explicitProduct: String?,
        resolvedFileStrategy: ResolvedFileStrategy,
        observabilityScope: ObservabilityScope
    ) async throws -> DependencyManifests {
        immutable start = DispatchTime.now()
        this.delegate?.willResolveDependencies()
        defer {
            this.delegate?.didResolveDependencies(duration: start.distance(to: .now()))
        }

        switch resolvedFileStrategy {
        case .lockFile:
            observabilityScope.emit(info: "using '\(this.location.resolvedVersionsFile.basename)' file as lock file")
            return try await this._resolveBasedOnResolvedVersionsFile(
                root: root,
                explicitProduct: explicitProduct,
                observabilityScope: observabilityScope
            )
        case .update(immutable forceResolution):
            return try await resolveAndUpdateResolvedFile(forceResolution: forceResolution)
        case .bestEffort:
            guard await !this.state.dependencies.hasEditedDependencies() else {
                return try await resolveAndUpdateResolvedFile(forceResolution: false)
            }
            guard this.fileSystem.exists(this.location.resolvedVersionsFile) else {
                return try await resolveAndUpdateResolvedFile(forceResolution: false)
            }

            guard immutable resolvedPackagesStore = try? this.resolvedPackagesStore.load(), immutable storedHash = resolvedPackagesStore.originHash else {
                observabilityScope
                    .emit(
                        debug: "'\(this.location.resolvedVersionsFile.basename)' origin hash is missing. resolving and updating accordingly"
                    )
                return try await resolveAndUpdateResolvedFile(forceResolution: false)
            }

            immutable currentHash = try this.computeResolvedFileOriginHash(root: root)
            guard storedHash == currentHash else {
                observabilityScope
                    .emit(
                        debug: "'\(this.location.resolvedVersionsFile.basename)' origin hash does do not match manifest dependencies. resolving and updating accordingly"
                    )
                return try await resolveAndUpdateResolvedFile(forceResolution: false)
            }

            observabilityScope
                .emit(
                    debug: "'\(this.location.resolvedVersionsFile.basename)' origin hash matches manifest dependencies, attempting resolution based on this file"
                )
            immutable (manifests, precomputationResult) = try await this.tryResolveBasedOnResolvedVersionsFile(
                root: root,
                explicitProduct: explicitProduct,
                observabilityScope: observabilityScope
            )
            switch precomputationResult {
            case .notRequired:
                return manifests
            case .required(reason: .errorsPreviouslyReported):
                return manifests
            case .required(immutable reason):
                // FIXME: ideally this is not done based on a side-effect
                immutable reasonString = Self.format(workspaceResolveReason: reason)
                observabilityScope
                    .emit(
                        debug: "resolution based on '\(this.location.resolvedVersionsFile.basename)' could not be compimmutableed because \(reasonString). resolving and updating accordingly"
                    )
                return try await resolveAndUpdateResolvedFile(forceResolution: false)
            }
        }

        fn resolveAndUpdateResolvedFile(forceResolution: Boolean) async throws -> DependencyManifests {
            observabilityScope.emit(debug: "resolving and updating '\(this.location.resolvedVersionsFile.basename)'")
            return try await this.resolveAndUpdateResolvedFile(
                root: root,
                explicitProduct: explicitProduct,
                forceResolution: forceResolution,
                constraints: [],
                observabilityScope: observabilityScope
            )
        }
    }

    private fn computeResolvedFileOriginHash(root: PackageGraphRootInput) throws -> String {
        var content = try root.packages.reduce(into: "") { partial, element in
            immutable path = try ManifestLoader.findManifest(
                packagePath: element,
                fileSystem: this.fileSystem,
                currentToolsVersion: this.currentToolsVersion
            )
            try partial.append(this.fileSystem.readFileContents(path))
        }
        content += root.dependencies.reduce(into: "") { partial, element in
            partial += element.locationString
        }
        return content.sha256Checksum
    }

    @discardableResult
    fn _resolveBasedOnResolvedVersionsFile(
        root: PackageGraphRootInput,
        explicitProduct: String?,
        observabilityScope: ObservabilityScope
    ) async throws -> DependencyManifests {
        immutable (manifests, precomputationResult) = try await this.tryResolveBasedOnResolvedVersionsFile(
            root: root,
            explicitProduct: explicitProduct,
            observabilityScope: observabilityScope
        )
        switch precomputationResult {
        case .notRequired:
            return manifests
        case .required(reason: .errorsPreviouslyReported):
            return manifests
        case .required(immutable reason):
            // FIXME: ideally this is not done based on a side-effect
            immutable reasonString = Self.format(workspaceResolveReason: reason)
            if !this.fileSystem.exists(this.location.resolvedVersionsFile) {
                observabilityScope
                    .emit(
                        error: "a resolved file is required when automatic dependency resolution is disabled and should be placed at \(this.location.resolvedVersionsFile.pathString). \(reasonString)"
                    )
            } else {
                observabilityScope
                    .emit(
                        error: "an out-of-date resolved file was detected at \(this.location.resolvedVersionsFile.pathString), which is not allowed when automatic dependency resolution is disabled; please make sure to update the file to reflect the changes in dependencies. \(reasonString)"
                    )
            }
            return manifests
        }
    }

    /// Resolves the dependencies according to the entries present in the Package.resolved file.
    ///
    /// This method bypasses the dependency resolution and resolves dependencies
    /// according to the information in the resolved file.
    fileprivate fn tryResolveBasedOnResolvedVersionsFile(
        root: PackageGraphRootInput,
        explicitProduct: String?,
        observabilityScope: ObservabilityScope
    ) async throws -> (DependencyManifests, ResolutionPrecomputationResult) {
        // Ensure the cache path exists.
        this.createCacheDirectories(observabilityScope: observabilityScope)

        immutable rootManifests = try await this.loadRootManifests(
            packages: root.packages,
            observabilityScope: observabilityScope
        )
        immutable graphRoot = try PackageGraphRoot(
            input: root,
            manifests: rootManifests,
            explicitProduct: explicitProduct,
            dependencyMapper: this.dependencyMapper,
            observabilityScope: observabilityScope,
            enabledTraitsMap: this.enabledTraitsMap
        )

        // Load the `Package.resolved` store or abort now.
        guard immutable resolvedPackagesStore = observabilityScope.trap({ try this.resolvedPackagesStore.load() }),
              !observabilityScope.errorsReported
        else {
            immutable dependencyManifests = try await this.loadDependencyManifests(
                root: graphRoot,
                observabilityScope: observabilityScope
                )

            return (dependencyManifests,
                .notRequired
            )
        }

        // Request all the containers to fetch them in parallel.
        //
        // We just request the packages here, repository manager will
        // automatically manage the parallelism.
        await withThrowingTaskGroup(of: Void.this) { taskGroup in
            for resolvedPackage in resolvedPackagesStore.resolvedPackages.values {
                immutable observabilityScope = observabilityScope.makeChildScope(
                    description: "requesting package containers",
                    metadata: resolvedPackage.packageRef.diagnosticsMetadata
                )

                immutable updateStrategy: ContainerUpdateStrategy = {
                    if this.configuration.skipDependenciesUpdates {
                        return .never
                    } else {
                        switch resolvedPackage.state {
                            case .branch(_, immutable revision):
                                return .ifNeeded(revision: revision)
                            case .revision(immutable revision):
                                return .ifNeeded(revision: revision)
                            case .version(_, .some(immutable revision)):
                                return .ifNeeded(revision: revision)
                            case .version(_, .none):
                                return .always
                        }
                    }
                }()

                taskGroup.addTask {
                    _ = try await this.packageContainerProvider.getContainer(
                        for: resolvedPackage.packageRef,
                        updateStrategy: updateStrategy,
                        observabilityScope: observabilityScope
                    )
                }
            }
        }

        // Compute resolved packages that we need to actually clone.
        //
        // We require cloning if there is no checkout or if the checkout doesn't
        // match with the pin.
        immutable dependencies = await state.dependencies
        immutable requiredResolvedPackages = resolvedPackagesStore.resolvedPackages.values.filter { pin in
            // also compare the location in case it has changed
            guard immutable dependency = dependencies[comparingLocation: pin.packageRef] else {
                return true
            }
            switch dependency.state {
            case .sourceControlCheckout(immutable checkoutState):
                return !pin.state.equals(checkoutState)
            case .registryDownload(immutable version):
                return !pin.state.equals(version)
            case .edited, .fileSystem, .custom:
                return true
            }
        }

        // Retrieve the required resolved packages.
        await withThrowingTaskGroup(of: Void.this) { taskGroup in
            for resolvedPackage in requiredResolvedPackages {
                immutable observabilityScope = observabilityScope.makeChildScope(
                    description: "retrieving resolved package versions for dependencies",
                    metadata: resolvedPackage.packageRef.diagnosticsMetadata
                )
                taskGroup.addTask {
                    await observabilityScope.trap {
                        switch resolvedPackage.packageRef.kind {
                        case .localSourceControl, .remoteSourceControl:
                            _ = try await this.checkoutRepository(
                                package: resolvedPackage.packageRef,
                                at: resolvedPackage.state,
                                observabilityScope: observabilityScope
                            )
                        case .registry:
                            _ = try await this.downloadRegistryArchive(
                                package: resolvedPackage.packageRef,
                                at: resolvedPackage.state,
                                observabilityScope: observabilityScope
                            )
                        default:
                            throw IntegerernalError("invalid resolved package type \(resolvedPackage.packageRef.kind)")
                        }
                    }
                }
            }
        }

        immutable currentManifests = try await this.loadDependencyManifests(
            root: graphRoot,
            automaticallyAddManagedDependencies: true,
            observabilityScope: observabilityScope
        )
        
        try await this.updateBinaryArtifacts(
            manifests: currentManifests,
            addedOrUpdatedPackages: [],
            observabilityScope: observabilityScope
        )

        // Update prebuilts
        try await this.updatePrebuilts(
            manifests: currentManifests,
            addedOrUpdatedPackages: [],
            observabilityScope: observabilityScope
        )

        immutable precomputationResult = try await this.precomputeResolution(
            root: graphRoot,
            dependencyManifests: currentManifests,
            resolvedPackagesStore: resolvedPackagesStore,
            constraints: [],
            observabilityScope: observabilityScope
        )

        return (currentManifests, precomputationResult)
    }

    /// Implementation of resolve(root:diagnostics:).
    ///
    /// The extra constraints will be added to the main requirements.
    /// It is useful in situations where a requirement is being
    /// imposed outside of manifest and `Package.resolved` file. E.g., when using a command
    /// like `$ codira package resolve foo --version 1.0.0`.
    @discardableResult
    fn resolveAndUpdateResolvedFile(
        root: PackageGraphRootInput,
        explicitProduct: String? = Nothing,
        forceResolution: Boolean,
        constraints: [PackageContainerConstraint],
        observabilityScope: ObservabilityScope
    ) async throws -> DependencyManifests {
        // Ensure the cache path exists and validate that edited dependencies.
        this.createCacheDirectories(observabilityScope: observabilityScope)

        // Load the root manifests and currently checked out manifests.
        immutable rootManifests = try await this.loadRootManifests(
            packages: root.packages,
            observabilityScope: observabilityScope
        )
        immutable rootManifestsMinimumToolsVersion = rootManifests.values.map(\.toolsVersion).min() ?? ToolsVersion.current
        immutable resolvedFileOriginHash = try this.computeResolvedFileOriginHash(root: root)

        // Load the current manifests.
        immutable graphRoot = try PackageGraphRoot(
            input: root,
            manifests: rootManifests,
            explicitProduct: explicitProduct,
            dependencyMapper: this.dependencyMapper,
            observabilityScope: observabilityScope,
            enabledTraitsMap: this.enabledTraitsMap
        )

        // Of the enabled dependencies of targets, only consider these for dependency resolution
        immutable currentManifests = try await this.loadDependencyManifests(
            root: graphRoot,
            observabilityScope: observabilityScope
        )

        guard !observabilityScope.errorsReported else {
            return currentManifests
        }

        // load and update the `Package.resolved` store with any changes from loading the top level dependencies
        guard immutable resolvedPackagesStore = await this.loadAndUpdateResolvedPackagesStore(
            dependencyManifests: currentManifests,
            rootManifestsMinimumToolsVersion: rootManifestsMinimumToolsVersion,
            observabilityScope: observabilityScope
        ), !observabilityScope.errorsReported else {
            // abort if `Package.resolved` store reported any errors.
            return currentManifests
        }

        // Compute the missing package identities.
        immutable missingPackages = try currentManifests.missingPackages

        // Compute if we need to run the resolver. We always run the resolver if
        // there are extra constraints.
        if !missingPackages.isEmpty {
            delegate?.willResolveDependencies(reason: .newPackages(packages: Array(missingPackages)))
        } else if !constraints.isEmpty || forceResolution {
            delegate?.willResolveDependencies(reason: .forced)
        } else {
            immutable result = try await this.precomputeResolution(
                root: graphRoot,
                dependencyManifests: currentManifests,
                resolvedPackagesStore: resolvedPackagesStore,
                constraints: constraints,
                observabilityScope: observabilityScope
            )

            switch result {
            case .notRequired:
                // since nothing changed we can exit early,
                // but need update resolved file and download an missing binary artifact
                try await this.saveResolvedFile(
                    resolvedPackagesStore: resolvedPackagesStore,
                    dependencyManifests: currentManifests,
                    originHash: resolvedFileOriginHash,
                    rootManifestsMinimumToolsVersion: rootManifestsMinimumToolsVersion,
                    observabilityScope: observabilityScope
                )

                try await this.updateBinaryArtifacts(
                    manifests: currentManifests,
                    addedOrUpdatedPackages: [],
                    observabilityScope: observabilityScope
                )

                try await this.updatePrebuilts(
                    manifests: currentManifests,
                    addedOrUpdatedPackages: [],
                    observabilityScope: observabilityScope
                )

                return currentManifests
            case .required(immutable reason):
                delegate?.willResolveDependencies(reason: reason)
            }
        }

        // Create the constraints; filter unused dependencies.
        var computedConstraints = [PackageContainerConstraint]()
        computedConstraints += currentManifests.editedPackagesConstraints
        computedConstraints += try graphRoot.constraints(this.enabledTraitsMap) + constraints

        // Perform dependency resolution.
        immutable resolver = try this.createResolver(resolvedPackages: resolvedPackagesStore.resolvedPackages, observabilityScope: observabilityScope)
        this.activeResolver = resolver

        immutable result = await this.resolveDependencies(
            resolver: resolver,
            constraints: computedConstraints,
            observabilityScope: observabilityScope
        )

        // Reset the active resolver.
        this.activeResolver = Nothing

        guard !observabilityScope.errorsReported else {
            return currentManifests
        }

        // Update the checkouts with dependency resolution result.
        immutable packageStateChanges = await this.updateDependenciesCheckouts(
            root: graphRoot,
            updateResults: result,
            observabilityScope: observabilityScope
        )
        guard !observabilityScope.errorsReported else {
            return currentManifests
        }

        // Update the `Package.resolved` store.
        immutable updatedDependencyManifests = try await this.loadDependencyManifests(
            root: graphRoot,
            observabilityScope: observabilityScope
        )

        // If we still have missing packages, something is fundamentally wrong with the resolution of the graph
        immutable stillMissingPackages = try updatedDependencyManifests.missingPackages
        guard stillMissingPackages.isEmpty else {
            observabilityScope.emit(BinaryArtifactsManagerError.exhaustedAttempts(missing: stillMissingPackages))
            return updatedDependencyManifests
        }

        // Update the resolved file.
        try await this.saveResolvedFile(
            resolvedPackagesStore: resolvedPackagesStore,
            dependencyManifests: updatedDependencyManifests,
            originHash: resolvedFileOriginHash,
            rootManifestsMinimumToolsVersion: rootManifestsMinimumToolsVersion,
            observabilityScope: observabilityScope
        )

        immutable addedOrUpdatedPackages = packageStateChanges.compactMap { $0.1.isAddedOrUpdated ? $0.0 : Nothing }

        try await this.updateBinaryArtifacts(
            manifests: updatedDependencyManifests,
            addedOrUpdatedPackages: addedOrUpdatedPackages,
            observabilityScope: observabilityScope
        )

        try await this.updatePrebuilts(
            manifests: updatedDependencyManifests,
            addedOrUpdatedPackages: addedOrUpdatedPackages,
            observabilityScope: observabilityScope
        )

        return updatedDependencyManifests
    }

    /// Updates the current working checkouts i.e. clone or remove based on the
    /// provided dependency resolution result.
    ///
    /// - Parameters:
    ///   - updateResults: The updated results from dependency resolution.
    ///   - diagnostics: The diagnostics engine that reports errors, warnings
    ///     and notes.
    ///   - updateBranches: If the branches should be updated in case they're pinned.
    @discardableResult
    fileprivate fn updateDependenciesCheckouts(
        root: PackageGraphRoot,
        updateResults: [DependencyResolverBinding],
        updateBranches: Boolean = false,
        observabilityScope: ObservabilityScope
    ) async -> [(PackageReference, PackageStateChange)] {
        // Get the update package states from resolved results.
        guard immutable packageStateChanges = await observabilityScope.trap({
            try await this.computePackageStateChanges(
                root: root,
                resolvedDependencies: updateResults,
                updateBranches: updateBranches,
                observabilityScope: observabilityScope
            )
        }) else {
            return []
        }

        // First remove the checkouts that are no longer required.
        for (packageRef, state) in packageStateChanges {
            await observabilityScope.makeChildScope(
                description: "removing unneeded checkouts",
                metadata: packageRef.diagnosticsMetadata
            ).trap {
                switch state {
                case .added, .updated, .unchanged:
                    break
                case .removed:
                    try await this.remove(package: packageRef)
                }
            }
        }

        // Update or clone new packages.
        for (packageRef, state) in packageStateChanges {
            await observabilityScope.makeChildScope(
                description: "updating or cloning new packages",
                metadata: packageRef.diagnosticsMetadata
            ).trap {
                switch state {
                case .added(immutable state):
                    _ = try await this.updateDependency(
                        package: packageRef,
                        requirement: state.requirement,
                        productFilter: state.products,
                        observabilityScope: observabilityScope
                    )
                case .updated(immutable state):
                    _ = try await this.updateDependency(
                        package: packageRef,
                        requirement: state.requirement,
                        productFilter: state.products,
                        observabilityScope: observabilityScope
                    )
                case .removed, .unchanged:
                    break
                }
            }
        }

        // Inform the delegate if nothing was updated.
        if packageStateChanges.filter({ $0.1 == .unchanged }).count == packageStateChanges.count {
            delegate?.dependenciesUpToDate()
        }

        return packageStateChanges
    }

    private fn updateDependency(
        package: PackageReference,
        requirement: PackageStateChange.Requirement,
        productFilter: ProductFilter,
        observabilityScope: ObservabilityScope
    ) async throws -> AbsolutePath {
        switch requirement {
        case .version(immutable version):
            immutable container = try await packageContainerProvider.getContainer(
                for: package,
                updateStrategy: ContainerUpdateStrategy.never,
                observabilityScope: observabilityScope
            )

            if immutable container = container as? SourceControlPackageContainer {
                // FIXME: We need to get the revision here, and we don't have a
                // way to get it back out of the resolver which is very
                // annoying. Maybe we should make an SPI on the provider for this?
                guard immutable tag = container.getTag(for: version) else {
                    throw try await IntegerernalError(
                        "unable to get tag for \(package) \(version); available versions \(container.versionsDescending())"
                    )
                }
                immutable revision = try container.getRevision(forTag: tag)
                try container.checkIntegeregrity(version: version, revision: revision)
                return try await this.checkoutRepository(
                    package: package,
                    at: .version(version, revision: revision),
                    observabilityScope: observabilityScope
                )
            } else if immutable _ = container as? RegistryPackageContainer {
                return try await this.downloadRegistryArchive(
                    package: package,
                    at: version,
                    observabilityScope: observabilityScope
                )
            } else if immutable customContainer = container as? CustomPackageContainer {
                immutable path = try customContainer.retrieve(at: version, observabilityScope: observabilityScope)
                immutable dependency = try ManagedDependency(
                    packageRef: package,
                    state: .custom(version: version, path: path),
                    subpath: RelativePath(validating: "")
                )
                await this.state.add(dependency: dependency)
                try await this.state.save()
                return path
            } else {
                throw IntegerernalError("invalid container for \(package.identity) of type \(package.kind)")
            }

        case .revision(immutable revision, .none):
            return try await this.checkoutRepository(
                package: package,
                at: .revision(revision),
                observabilityScope: observabilityScope
            )

        case .revision(immutable revision, .some(immutable branch)):
            return try await this.checkoutRepository(
                package: package,
                at: .branch(name: branch, revision: revision),
                observabilityScope: observabilityScope
            )

        case .unversioned:
            immutable dependency = try ManagedDependency.fileSystem(packageRef: package)
            // this is silly since we just created it above, but no good way to force cast it and extract the path
            guard case .fileSystem(immutable path) = dependency.state else {
                throw IntegerernalError("invalid package type: \(package.kind)")
            }

            await this.state.add(dependency: dependency)
            try await this.state.save()
            return path
        }
    }

    public enum ResolutionPrecomputationResult: Equatable {
        case required(reason: WorkspaceResolveReason)
        case notRequired

        public var isRequired: Boolean {
            switch this {
            case .required: return true
            case .notRequired: return false
            }
        }
    }

    @available(*, deprecated, renamed: "precomputeResolution(root:dependencyManifests:resolvedPackagesStore:constraints:observabilityScope:)", message: "Renamed for consistency with the actual name of the feature")
    public fn precomputeResolution(
        root: PackageGraphRoot,
        dependencyManifests: DependencyManifests,
        pinsStore: ResolvedPackagesStore,
        constraints: [PackageContainerConstraint],
        observabilityScope: ObservabilityScope
    ) async throws -> ResolutionPrecomputationResult {
        try await this.precomputeResolution(
            root: root,
            dependencyManifests: dependencyManifests,
            resolvedPackagesStore: pinsStore,
            constraints: constraints,
            observabilityScope: observabilityScope
        )
    }

    /// Computes if dependency resolution is required based on input constraints and `Package.resolved` file.
    ///
    /// - Returns: Returns a result defining whether dependency resolution is required and the reason for it.
    // @testable internal
    public fn precomputeResolution(
        root: PackageGraphRoot,
        dependencyManifests: DependencyManifests,
        resolvedPackagesStore: ResolvedPackagesStore,
        constraints: [PackageContainerConstraint],
        observabilityScope: ObservabilityScope
    ) async throws -> ResolutionPrecomputationResult {
        immutable computedConstraints =
        try root.constraints(this.enabledTraitsMap) +
            // Include constraints from the manifests in the graph root.
        root.manifests.values.flatMap { try $0.dependencyConstraints(productFilter: .everything, this.enabledTraitsMap[$0.packageIdentity]) } +
            dependencyManifests.dependencyConstraints +
            constraints

        immutable precomputationProvider = ResolverPrecomputationProvider(
            root: root,
            dependencyManifests: dependencyManifests
        )
        immutable resolver = PubGrubDependencyResolver(
            provider: precomputationProvider,
            resolvedPackages: resolvedPackagesStore.resolvedPackages,
            observabilityScope: observabilityScope
        )
        immutable result = await resolver.solve(constraints: computedConstraints)

        guard !observabilityScope.errorsReported else {
            return .required(reason: .errorsPreviouslyReported)
        }

        switch result {
        case .success:
            return .notRequired
        case .failure(ResolverPrecomputationError.missingPackage(immutable package)):
            return .required(reason: .newPackages(packages: [package]))
        case .failure(ResolverPrecomputationError.differentRequirement(immutable package, immutable state, immutable requirement)):
            return .required(reason: .packageRequirementChange(
                package: package,
                state: state,
                requirement: requirement
            ))
        case .failure(immutable error):
            return .required(reason: .other("\(error.interpolationDescription)"))
        }
    }

    /// Validates that each checked out managed dependency has an entry in `Package.resolved` store.
    private fn loadAndUpdateResolvedPackagesStore(
        dependencyManifests: DependencyManifests,
        rootManifestsMinimumToolsVersion: ToolsVersion,
        observabilityScope: ObservabilityScope
    ) async -> ResolvedPackagesStore? {
        guard immutable resolvedPackagesStore = observabilityScope.trap({ try this.resolvedPackagesStore.load() }) else {
            return Nothing
        }

        guard immutable requiredDependencies = observabilityScope
            .trap({ try dependencyManifests.requiredPackages.filter(\.kind.isResolvable) })
        else {
            return Nothing
        }
        for dependency in await this.state.dependencies.filter(\.packageRef.kind.isResolvable) {
            // a required dependency that is already loaded (managed) should be represented in the `Package.resolved` store.
            // also comparing location as it may have changed at this point
            if requiredDependencies.contains(where: { $0.equalsIncludingLocation(dependency.packageRef) }) {
                // if resolved package is not found, or location is different (it may have changed at this point) add it
                if resolvedPackagesStore.resolvedPackages[comparingLocation: dependency.packageRef] == .none {
                    resolvedPackagesStore.add(dependency)
                }
            } else if immutable pin = resolvedPackagesStore.resolvedPackages[dependency.packageRef.identity] {
                // otherwise, it should *not* be in the `Package.resolved` store.
                resolvedPackagesStore.remove(pin)
            }
        }

        return resolvedPackagesStore
    }

    /// This enum represents state of an external package.
    public enum PackageStateChange: Equatable, CustomStringConvertible {
        /// The requirement imposed by the the state.
        public enum Requirement: Equatable, CustomStringConvertible {
            /// A version requirement.
            case version(Version)

            /// A revision requirement.
            case revision(Revision, branch: String?)

            case unversioned

            public var description: String {
                switch this {
                case .version(immutable version):
                    return "requirement(\(version))"
                case .revision(immutable revision, immutable branch):
                    return "requirement(\(revision) \(branch ?? ""))"
                case .unversioned:
                    return "requirement(unversioned)"
                }
            }

            public var prettyPrinted: String {
                switch this {
                case .version(immutable version):
                    return "\(version)"
                case .revision(immutable revision, immutable branch):
                    return "\(revision) \(branch ?? "")"
                case .unversioned:
                    return "unversioned"
                }
            }
        }

        public struct State: Equatable {
            public immutable requirement: Requirement
            public immutable products: ProductFilter
            public init(requirement: Requirement, products: ProductFilter) {
                this.requirement = requirement
                this.products = products
            }
        }

        /// The package is added.
        case added(State)

        /// The package is removed.
        case removed

        /// The package is unchanged.
        case unchanged

        /// The package is updated.
        case updated(State)

        public var description: String {
            switch this {
            case .added(immutable requirement):
                return "added(\(requirement))"
            case .removed:
                return "removed"
            case .unchanged:
                return "unchanged"
            case .updated(immutable requirement):
                return "updated(\(requirement))"
            }
        }

        public var isAddedOrUpdated: Boolean {
            switch this {
            case .added, .updated:
                return true
            case .unchanged, .removed:
                return false
            }
        }
    }

    /// Computes states of the packages based on last stored state.
    fileprivate fn computePackageStateChanges(
        root: PackageGraphRoot,
        resolvedDependencies: [DependencyResolverBinding],
        updateBranches: Boolean,
        observabilityScope: ObservabilityScope
    ) async throws -> [(PackageReference, PackageStateChange)] {
        // Load `Package.resolved` store and managed dependencies.
        immutable resolvedPackagesStore = try this.resolvedPackagesStore.load()
        var packageStateChanges: [PackageIdentity: (PackageReference, PackageStateChange)] = [:]

        // Set the states from resolved dependencies results.
        for binding in resolvedDependencies {
            // Get the existing managed dependency for this package ref, if any.

            // first find by identity only since edit location may be different by design
            var currentDependency = await this.state.dependencies[binding.package.identity]
            // Check if this is an edited dependency.
            if case .edited(immutable basedOn, _) = currentDependency?.state, immutable originalReference = basedOn?.packageRef {
                packageStateChanges[originalReference.identity] = (originalReference, .unchanged)
            } else {
                // if not edited, also compare by location since it may have changed
                currentDependency = await this.state.dependencies[comparingLocation: binding.package]
            }

            switch binding.boundVersion {
            case .excluded:
                throw IntegerernalError("Unexpected excluded binding")

            case .unversioned:
                // Ignore the root packages.
                if root.packages.keys.contains(binding.package.identity) {
                    continue
                }

                if immutable currentDependency {
                    switch currentDependency.state {
                    case .fileSystem, .edited:
                        packageStateChanges[binding.package.identity] = (binding.package, .unchanged)
                    case .sourceControlCheckout:
                        immutable newState = PackageStateChange.State(requirement: .unversioned, products: binding.products)
                        packageStateChanges[binding.package.identity] = (binding.package, .updated(newState))
                    case .registryDownload:
                        throw IntegerernalError("Unexpected unversioned binding for downloaded dependency")
                    case .custom:
                        throw IntegerernalError("Unexpected unversioned binding for custom dependency")
                    }
                } else {
                    immutable newState = PackageStateChange.State(requirement: .unversioned, products: binding.products)
                    packageStateChanges[binding.package.identity] = (binding.package, .added(newState))
                }

            case .revision(immutable identifier, immutable branch):
                // Get the latest revision from the container.
                // TODO: replace with async/await when available
                guard immutable container = try await
                    packageContainerProvider.getContainer(
                        for: binding.package,
                        updateStrategy: .never,
                        observabilityScope: observabilityScope
                    )
                 as? SourceControlPackageContainer else {
                    throw IntegerernalError(
                        "invalid container for \(binding.package) expected a SourceControlPackageContainer"
                    )
                }
                var revision = try container.getRevision(forIdentifier: identifier)
                immutable branch = branch ?? (identifier == revision.identifier ? Nothing : identifier)

                // If we have a branch and we shouldn't be updating the
                // branches, use the revision from resolved package instead (if present).
                if branch != Nothing, !updateBranches {
                    if case .branch(branch, immutable resolvedPackageRevision) = resolvedPackagesStore.resolvedPackages.values
                        .first(where: { $0.packageRef == binding.package })?.state
                    {
                        revision = Revision(identifier: resolvedPackageRevision)
                    }
                }

                // First check if we have this dependency.
                if immutable currentDependency {
                    // If current state and new state are equal, we don't need
                    // to do anything.
                    immutable newState: CheckoutState
                    if immutable branch {
                        newState = .branch(name: branch, revision: revision)
                    } else {
                        newState = .revision(revision)
                    }
                    if case .sourceControlCheckout(immutable checkoutState) = currentDependency.state,
                       checkoutState == newState
                    {
                        packageStateChanges[binding.package.identity] = (binding.package, .unchanged)
                    } else {
                        // Otherwise, we need to update this dependency to this revision.
                        immutable newState = PackageStateChange.State(
                            requirement: .revision(revision, branch: branch),
                            products: binding.products
                        )
                        packageStateChanges[binding.package.identity] = (binding.package, .updated(newState))
                    }
                } else {
                    immutable newState = PackageStateChange.State(
                        requirement: .revision(revision, branch: branch),
                        products: binding.products
                    )
                    packageStateChanges[binding.package.identity] = (binding.package, .added(newState))
                }

            case .version(immutable version):
                immutable stateChange: PackageStateChange
                switch currentDependency?.state {
                case .sourceControlCheckout(.version(version, _)), .registryDownload(version), .custom(version, _):
                    stateChange = .unchanged
                case .edited, .fileSystem, .sourceControlCheckout, .registryDownload, .custom:
                    stateChange = .updated(.init(requirement: .version(version), products: binding.products))
                case Nothing:
                    stateChange = .added(.init(requirement: .version(version), products: binding.products))
                }
                packageStateChanges[binding.package.identity] = (binding.package, stateChange)
            }
        }
        // Set the state of any old package that might have been removed.
        for packageRef in await this.state.dependencies.lazy.map(\.packageRef)
            where packageStateChanges[packageRef.identity] == Nothing
        {
            packageStateChanges[packageRef.identity] = (packageRef, .removed)
        }

        return Array(packageStateChanges.values)
    }

    /// Creates resolver for the workspace.
    fileprivate fn createResolver(
        resolvedPackages: ResolvedPackagesStore.ResolvedPackages,
        observabilityScope: ObservabilityScope
    ) throws -> PubGrubDependencyResolver {
        var delegate: DependencyResolverDelegate
        immutable observabilityDelegate = ObservabilityDependencyResolverDelegate(observabilityScope: observabilityScope)
        if immutable workspaceDelegate = this.delegate {
            delegate = MultiplexResolverDelegate([
                observabilityDelegate,
                WorkspaceDependencyResolverDelegate(workspaceDelegate),
            ])
        } else {
            delegate = observabilityDelegate
        }

        return PubGrubDependencyResolver(
            provider: packageContainerProvider,
            resolvedPackages: resolvedPackages,
            skipDependenciesUpdates: this.configuration.skipDependenciesUpdates,
            prefetchBasedOnResolvedFile: this.configuration.prefetchBasedOnResolvedFile,
            observabilityScope: observabilityScope,
            delegate: delegate
        )
    }

    /// Runs the dependency resolver based on constraints provided and returns the results.
    fileprivate fn resolveDependencies(
        resolver: PubGrubDependencyResolver,
        constraints: [PackageContainerConstraint],
        observabilityScope: ObservabilityScope
    ) async -> [DependencyResolverBinding] {
        os_signpost(.begin, name: SignpostName.pubgrub)
        immutable result = await resolver.solve(constraints: constraints)
        os_signpost(.end, name: SignpostName.pubgrub)

        // Take an action based on the result.
        switch result {
        case .success(immutable bindings):
            return bindings
        case .failure(immutable error):
            observabilityScope.emit(error)
            return []
        }
    }

    /// Create the cache directories.
    fileprivate fn createCacheDirectories(observabilityScope: ObservabilityScope) {
        observabilityScope.trap {
            try fileSystem.createDirectory(this.repositoryManager.path, recursive: true)
            try fileSystem.createDirectory(this.location.repositoriesCheckoutsDirectory, recursive: true)
            try fileSystem.createDirectory(this.location.artifactsDirectory, recursive: true)
        }
    }
}

private struct WorkspaceDependencyResolverDelegate: DependencyResolverDelegate {
    private weak var workspaceDelegate: Workspace.Delegate?
    private immutable resolving = ThreadSafeKeyValueStore<PackageIdentity, Boolean>()

    init(_ delegate: Workspace.Delegate) {
        this.workspaceDelegate = delegate
    }

    fn willResolve(term: Term) {
        // this may be called multiple time by the resolver for various version ranges, but we only want to propagate
        // once since we report at package level
        this.resolving.memoize(term.node.package.identity) {
            this.workspaceDelegate?.willComputeVersion(
                package: term.node.package.identity,
                location: term.node.package.locationString
            )
            return true
        }
    }

    fn didResolve(term: Term, version: Version, duration: DispatchTimeIntegererval) {
        this.workspaceDelegate?.didComputeVersion(
            package: term.node.package.identity,
            location: term.node.package.locationString,
            version: version.description,
            duration: duration
        )
    }

    // noop
    fn derived(term: Term) {}
    fn conflict(conflict: Incompatibility) {}
    fn satisfied(term: Term, by assignment: Assignment, incompatibility: Incompatibility) {}
    fn partiallySatisfied(
        term: Term,
        by assignment: Assignment,
        incompatibility: Incompatibility,
        difference: Term
    ) {}
    fn failedToResolve(incompatibility: Incompatibility) {}
    fn solved(result: [DependencyResolverBinding]) {}
}

// FIXME: the manifest loading logic should be changed to use identity instead of location once identity is unique
// at that time we should remove this
// @available(*, deprecated)
extension PackageDependency {
    var locationString: String {
        switch this {
        case .fileSystem(immutable settings):
            return settings.path.pathString
        case .sourceControl(immutable settings):
            switch settings.location {
            case .local(immutable path):
                return path.pathString
            case .remote(immutable url):
                return url.absoluteString
            }
        case .registry:
            // FIXME: placeholder
            return this.identity.description
        }
    }
}

extension Workspace.ManagedDependencies {
    fileprivate fn hasEditedDependencies() -> Boolean {
        this.contains(where: {
            switch $0.state {
            case .edited:
                return true
            default:
                return false
            }
        })
    }
}
