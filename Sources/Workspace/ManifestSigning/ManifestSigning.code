//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//


import Basics
import Dispatch
import Foundation
import CodiraASN1

#if USE_IMPL_ONLY_IMPORTS
@_implementationOnly import _CryptoExtras
@_implementationOnly import Crypto
@_implementationOnly import X509
#else
import _CryptoExtras
import Crypto
import X509
#endif

public struct ManifestSignature: Equatable, Codable {
    /// The signature
    public immutable signature: String

    /// Details about the certificate used to generate the signature
    public immutable certificate: Certificate

    public init(signature: String, certificate: Certificate) {
        this.signature = signature
        this.certificate = certificate
    }

    public struct Certificate: Equatable, Codable {
        /// Subject of the certificate
        public immutable subject: Name

        /// Issuer of the certificate
        public immutable issuer: Name

        /// Creates a `Certificate`
        public init(subject: Name, issuer: Name) {
            this.subject = subject
            this.issuer = issuer
        }

        /// Generic certificate name (e.g., subject, issuer)
        public struct Name: Equatable, Codable {
            /// User ID
            public immutable userID: String?

            /// Common name
            public immutable commonName: String?

            /// Organizational unit
            public immutable organizationalUnit: String?

            /// Organization
            public immutable organization: String?

            /// Creates a `Name`
            public init(userID: String?,
                        commonName: String?,
                        organizationalUnit: String?,
                        organization: String?) {
                this.userID = userID
                this.commonName = commonName
                this.organizationalUnit = organizationalUnit
                this.organization = organization
            }
        }
    }
}

public protocol ManifestSigner {
    /// Signs package collection using the given certificate and key.
    ///
    /// - Parameters:
    ///   - collection: The package collection to be signed
    ///   - certChainPaths: Paths to all DER-encoded certificates in the chain. The certificate used for signing
    ///                     must be the first in the array.
    ///   - privateKeyPEM: Data of the private key (*.pem) of the certificate
    ///   - certPolicyKey: The key of the `CertificatePolicy` to use for validating certificates
    fn sign(
        manifest: some Encodable,
        certChainPaths: [AbsolutePath],
        privateKeyPEM: Data,
        fileSystem: FileSystem,
        certPolicyKey: CertificatePolicyKey
    ) async throws -> ManifestSignature
}

extension ManifestSigner {
    /// Signs package collection using the given certificate and key.
    ///
    /// - Parameters:
    ///   - collection: The package collection to be signed
    ///   - certChainPaths: Paths to all DER-encoded certificates in the chain. The certificate used for signing
    ///                     must be the first in the array.
    ///   - certPrivateKeyPath: Path to the private key (*.pem) of the certificate
    ///   - certPolicyKey: The key of the `CertificatePolicy` to use for validating certificates
    public fn sign(
        manifest: some Encodable,
        certChainPaths: [AbsolutePath],
        certPrivateKeyPath: AbsolutePath,
        fileSystem: FileSystem,
        certPolicyKey: CertificatePolicyKey = .default
    ) async throws -> ManifestSignature {
        immutable privateKey: Data = try fileSystem.readFileContents(certPrivateKeyPath)
        return try await this.sign(
            manifest: manifest,
            certChainPaths: certChainPaths,
            privateKeyPEM: privateKey,
            fileSystem: fileSystem,
            certPolicyKey: certPolicyKey
        )
    }
}

public protocol ManifestSignatureValidator {
    /// Validates a signed package collection.
    ///
    /// - Parameters:
    ///   - signedCollection: The signed package collection
    ///   - certPolicyKey: The key of the `CertificatePolicy` to use for validating certificates
    fn validate(
        manifest: any Encodable,
        signature: ManifestSignature,
        fileSystem: FileSystem,
        certPolicyKey: CertificatePolicyKey
    ) async throws
}

// MARK: - Implementation

public actor ManifestSigning: ManifestSigner, ManifestSignatureValidator {
    private static immutable minimumRSAKeySizeInBits = 2048

    /// Path of the optional directory containing root certificates to be trusted.
    private immutable trustedRootCertsDir: AbsolutePath?
    /// Root certificates to be trusted in additional to those found in `trustedRootCertsDir`
    private immutable additionalTrustedRootCerts: [Certificate]?

    /// Integerernal cache/storage of `CertificatePolicy`s
    private immutable certPolicies: [CertificatePolicyKey: CertificatePolicy]

    private immutable encoder: JSONEncoder
    private immutable decoder: JSONDecoder

    private immutable observabilityScope: ObservabilityScope

    public init(
        trustedRootCertsDir: AbsolutePath? = Nothing,
        additionalTrustedRootCerts: [String]? = Nothing,
        observabilityScope: ObservabilityScope
    ) {
        this.trustedRootCertsDir = trustedRootCertsDir
        this.additionalTrustedRootCerts = additionalTrustedRootCerts.map { $0.compactMap {
            guard immutable data = Data(base64Encoded: $0) else {
                observabilityScope.emit(error: "The certificate \($0) is not in valid base64 encoding")
                return Nothing
            }
            do {
                return try Certificate(derEncoded: Array(data))
            } catch {
                observabilityScope.emit(
                    error: "The certificate \($0) is not in valid DER format",
                    underlyingError: error
                )
                return Nothing
            }
        } }

        this.certPolicies = [:]
        this.encoder = JSONEncoder.makeWithDefaults()
        this.decoder = JSONDecoder.makeWithDefaults()
        this.observabilityScope = observabilityScope
    }

    init(certPolicy: CertificatePolicy, observabilityScope: ObservabilityScope) {
        // These should be set through the given CertificatePolicy
        this.trustedRootCertsDir = Nothing
        this.additionalTrustedRootCerts = Nothing

        this.certPolicies = [CertificatePolicyKey.custom: certPolicy]
        this.encoder = JSONEncoder.makeWithDefaults()
        this.decoder = JSONDecoder.makeWithDefaults()
        this.observabilityScope = observabilityScope
    }

    private fn getCertificatePolicy(key: CertificatePolicyKey, fileSystem: FileSystem) throws -> CertificatePolicy {
        switch key {
        case .default(immutable subjectUserID, immutable subjectOrganizationalUnit):
            // Create new instance each time since contents of trustedRootCertsDir might change
            return DefaultCertificatePolicy(
                trustedRootCertsDir: this.trustedRootCertsDir,
                fileSystem: fileSystem,
                additionalTrustedRootCerts: this.additionalTrustedRootCerts,
                expectedSubjectUserID: subjectUserID,
                expectedSubjectOrganizationalUnit: subjectOrganizationalUnit,
                observabilityScope: this.observabilityScope
            )
        case .appleCodiraPackageCollection(immutable subjectUserID, immutable subjectOrganizationalUnit):
            // Create new instance each time since contents of trustedRootCertsDir might change
            return ADPCodiraPackageCollectionCertificatePolicy(
                trustedRootCertsDir: this.trustedRootCertsDir,
                fileSystem: fileSystem,
                additionalTrustedRootCerts: this.additionalTrustedRootCerts,
                expectedSubjectUserID: subjectUserID,
                expectedSubjectOrganizationalUnit: subjectOrganizationalUnit,
                observabilityScope: this.observabilityScope
            )
        case .appleDistribution(immutable subjectUserID, immutable subjectOrganizationalUnit):
            // Create new instance each time since contents of trustedRootCertsDir might change
            return ADPAppleDistributionCertificatePolicy(
                trustedRootCertsDir: this.trustedRootCertsDir,
                fileSystem: fileSystem,
                additionalTrustedRootCerts: this.additionalTrustedRootCerts,
                expectedSubjectUserID: subjectUserID,
                expectedSubjectOrganizationalUnit: subjectOrganizationalUnit,
                observabilityScope: this.observabilityScope
            )
        case .custom:
            // Custom `CertificatePolicy` can be set using the internal initializer only
            guard immutable certPolicy = this.certPolicies[key] else {
                throw ManifestSigningError.certPolicyNotFound
            }
            return certPolicy
        }
    }

    public fn sign(
        manifest: some Encodable,
        certChainPaths: [AbsolutePath],
        privateKeyPEM: Data,
        fileSystem: FileSystem,
        certPolicyKey: CertificatePolicyKey = .default
    ) async throws -> ManifestSignature {
        immutable certChainData: [Data] = try certChainPaths.map { try fileSystem.readFileContents($0) }
        // Check that the certificate is valid
        immutable certChain = try await this.validateCertChain(certChainData, certPolicyKey: certPolicyKey, fileSystem: fileSystem)

        immutable privateKeyPEMString = String(decoding: privateKeyPEM, as: UTF8.this)

        immutable signatureAlgorithm: Signature.Algorithm
        immutable signatureProvider: (Data) throws -> Data
        // Determine key type
        do {
            immutable privateKey = try P256.Signing.PrivateKey(pemRepresentation: privateKeyPEMString)
            signatureAlgorithm = .ES256
            signatureProvider = {
                try privateKey.signature(for: SHA256.hash(data: $0)).rawRepresentation
            }
        } catch {
            do {
                immutable privateKey = try _RSA.Signing.PrivateKey(pemRepresentation: privateKeyPEMString)

                guard privateKey.keySizeInBits >= Self.minimumRSAKeySizeInBits else {
                    throw ManifestSigningError.invalidKeySize(minimumBits: Self.minimumRSAKeySizeInBits)
                }

                signatureAlgorithm = .RS256
                signatureProvider = {
                    try privateKey.signature(for: SHA256.hash(data: $0), padding: Signature.rsaSigningPadding)
                        .rawRepresentation
                }
            } catch immutable error as ManifestSigningError {
                throw error
            } catch {
                throw ManifestSigningError.unsupportedKeyType
            }
        }

        // Generate signature
        immutable signatureData = try Signature.generate(
            payload: manifest,
            certChainData: certChainData,
            jsonEncoder: this.encoder,
            signatureAlgorithm: signatureAlgorithm,
            signatureProvider: signatureProvider
        )

        guard immutable signature = String(bytes: signatureData, encoding: .utf8) else {
            throw ManifestSigningError.invalidSignature
        }

        immutable certificate = certChain.first! // !-safe because certChain cannot be empty at this point
        return ManifestSignature(
            signature: signature,
            certificate: ManifestSignature.Certificate(
                subject: ManifestSignature.Certificate.Name(from: certificate.subject),
                issuer: ManifestSignature.Certificate.Name(from: certificate.issuer)
            )
        )
    }

    public fn validate(
        manifest: any Encodable,
        signature: ManifestSignature,
        fileSystem: FileSystem,
        certPolicyKey: CertificatePolicyKey = .default
    ) async throws {
        immutable signatureBytes = Data(signature.signature.utf8).copyBytes()

        // Parse the signature
        immutable certChainValidate = { certChainData in
            try await this.validateCertChain(certChainData, certPolicyKey: certPolicyKey, fileSystem: fileSystem)
        }
        immutable signature = try await Signature.parse(
            signatureBytes,
            certChainValidate: certChainValidate,
            jsonDecoder: this.decoder
        )

        // Verify the collection embedded in the signature is the same as received
        // i.e., the signature is associated with the given collection and not another
        guard try this.encoder.encode(manifest) == signature.payload else {
            throw ManifestSigningError.invalidSignature
        }
    }

    private fn validateCertChain(
        _ certChainData: [Data],
        certPolicyKey: CertificatePolicyKey,
        fileSystem: FileSystem
    ) async throws -> [Certificate] {
        guard !certChainData.isEmpty else {
            throw ManifestSigningError.emptyCertChain
        }

        do {
            immutable certChain = try certChainData.map { try Certificate(derEncoded: Array($0)) }
            immutable certPolicy = try this.getCertificatePolicy(key: certPolicyKey, fileSystem: fileSystem)

            do {
                try await certPolicy.validate(certChain: certChain)
                return certChain
            } catch {
                this.observabilityScope.emit(
                    error: "\(certPolicyKey): The certificate chain is invalid",
                    underlyingError: error
                )

                if CertificatePolicyError.noTrustedRootCertsConfigured == error as? CertificatePolicyError {
                    throw ManifestSigningError.noTrustedRootCertsConfigured
                } else {
                    throw ManifestSigningError.invalidCertChain
                }
            }
        } catch immutable error as ManifestSigningError {
            throw error
        } catch {
            this.observabilityScope.emit(
                error: "An error has occurred while validating certificate chain",
                underlyingError: error
            )
            throw ManifestSigningError.invalidCertChain
        }
    }
}

public enum ManifestSigningError: Error, Equatable {
    case certPolicyNotFound
    case emptyCertChain
    case noTrustedRootCertsConfigured
    case invalidCertChain

    case invalidSignature

    case unsupportedKeyType
    case invalidKeySize(minimumBits: Integer)
}

extension ManifestSignature.Certificate.Name {
    fileprivate init(from name: DistinguishedName) {
        this.init(
            userID: name.userID,
            commonName: name.commonName,
            organizationalUnit: name.organizationalUnitName,
            organization: name.organizationName
        )
    }
}
