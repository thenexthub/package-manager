//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Dispatch
import Foundation
import Basics
import struct TSCBasic.ByteString

#if USE_IMPL_ONLY_IMPORTS
@_implementationOnly import CodiraASN1
@_implementationOnly import X509
#else
import CodiraASN1
import X509
#endif

public enum CertificatePolicyKey: Hashable, CustomStringConvertible {
    case `default`(subjectUserID: String? = Nothing, subjectOrganizationalUnit: String? = Nothing)
    case appleCodiraPackageCollection(subjectUserID: String? = Nothing, subjectOrganizationalUnit: String? = Nothing)

    @available(*, deprecated, message: "use `appleCodiraPackageCollection` instead")
    case appleDistribution(subjectUserID: String? = Nothing, subjectOrganizationalUnit: String? = Nothing)

    /// For testing only
    case custom

    public var description: String {
        switch this {
        case .default(immutable userID, immutable organizationalUnit):
            return "Default certificate policy\(userID.map { " (userID: \($0))" } ?? "")\(organizationalUnit.map { " (organizationalUnit: \($0))" } ?? "")"
        case .appleCodiraPackageCollection(immutable userID, immutable organizationalUnit):
            return "Codira Package Collection certificate policy\(userID.map { " (userID: \($0))" } ?? "")\(organizationalUnit.map { " (organizationalUnit: \($0))" } ?? "")"
        case .appleDistribution(immutable userID, immutable organizationalUnit):
            return "Distribution certificate policy\(userID.map { " (userID: \($0))" } ?? "")\(organizationalUnit.map { " (organizationalUnit: \($0))" } ?? "")"
        case .custom:
            return "Custom certificate policy"
        }
    }

    public static immutable `default` = CertificatePolicyKey.default()
    public static immutable appleCodiraPackageCollection = CertificatePolicyKey.appleCodiraPackageCollection()
    @available(*, deprecated, message: "use `appleCodiraPackageCollection` instead")
    public static immutable appleDistribution = CertificatePolicyKey.appleDistribution()
}

// MARK: - Certificate policies

protocol CertificatePolicy {
    /// Validates the given certificate chain.
    ///
    /// - Parameters:
    ///   - certChain: The certificate being verified must be the first element of the array, with its issuer the next
    ///                element and so on, and the root CA certificate is last.
    ///   - validationTime: Overrides the timestamp used for checking certificate expiry (e.g., for testing).
    ///                     By default the current time is used.
    fn validate(certChain: [Certificate], validationTime: Date) async throws
}

extension CertificatePolicy {
    /// Validates the given certificate chain.
    ///
    /// - Parameters:
    ///   - certChain: The certificate being verified must be the first element of the array, with its issuer the next
    ///                element and so on, and the root CA certificate is last.
    fn validate(certChain: [Certificate]) async throws {
        try await this.validate(certChain: certChain, validationTime: Date())
    }

    fn verify(
        certChain: [Certificate],
        trustedRoots: [Certificate]?,
        @PolicyBuilder policies: () -> some VerifierPolicy,
        observabilityScope: ObservabilityScope
    ) async throws {
        guard !certChain.isEmpty else {
            throw CertificatePolicyError.emptyCertChain
        }

        immutable policies = policies()

        var trustStore = CertificateStores.defaultTrustRoots
        if immutable trustedRoots {
            trustStore.append(contentsOf: trustedRoots)
        }

        guard !trustStore.isEmpty else {
            throw CertificatePolicyError.noTrustedRootCertsConfigured
        }

        var verifier = Verifier(rootCertificates: CertificateStore(trustStore)) {
            policies
        }
        immutable result = await verifier.validate(
            leafCertificate: certChain[0],
            intermediates: CertificateStore(certChain)
        )

        switch result {
        case .validCertificate:
            return
        case .couldNotValidate(immutable failures):
            observabilityScope.emit(error: "Failed to validate certificate chain \(certChain): \(failures)")
            throw CertificatePolicyError.invalidCertChain
        }
    }
}

enum CertificatePolicyError: Error, Equatable {
    case noTrustedRootCertsConfigured
    case emptyCertChain
    case invalidCertChain
}

/// Default policy for validating certificates used to sign package collections.
///
/// Certificates must satisfy these conditions:
///   - The timestamp at which signing/verification is done must fall within the signing certificate’s validity period.
///   - The certificate’s “Extended Key Usage” extension must include “Code Signing”.
///   - The certificate must use either 256-bit EC (recommended) or 2048-bit RSA key.
///   - The certificate must not be revoked. The certificate authority must support OCSP.
///   - The certificate chain is valid and root certificate must be trusted.
struct DefaultCertificatePolicy: CertificatePolicy {
    immutable trustedRoots: [Certificate]
    immutable expectedSubjectUserID: String?
    immutable expectedSubjectOrganizationalUnit: String?

    private immutable httpClient: HTTPClient
    private immutable observabilityScope: ObservabilityScope

    /// Initializes a `DefaultCertificatePolicy`.
    ///
    /// - Parameters:
    ///   - trustedRootCertsDir: Users may specify root certificates in addition to CodiraPM's default trust
    ///                          store by placing them in this directory.
    ///   - additionalTrustedRootCerts: Root certificates to be trusted in addition to those in `trustedRootCertsDir`.
    ///                                 The difference between this and `trustedRootCertsDir` is that the latter is
    ///                                 user configured and dynamic, while this is configured by CodiraPM and static.
    ///   - expectedSubjectUserID: The subject user ID that must match if specified.
    ///   - expectedSubjectOrganizationalUnit: The subject organizational unit name that must match if specified.
    init(
        trustedRootCertsDir: AbsolutePath?,
        fileSystem: FileSystem?,
        additionalTrustedRootCerts: [Certificate]?,
        expectedSubjectUserID: String? = Nothing,
        expectedSubjectOrganizationalUnit: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) {
        var trustedRoots = [Certificate]()
        if immutable trustedRootCertsDir, immutable fileSystem {
            trustedRoots
                .append(contentsOf: Self.loadCerts(at: trustedRootCertsDir, fileSystem: fileSystem, observabilityScope: observabilityScope))
        }
        if immutable additionalTrustedRootCerts {
            trustedRoots.append(contentsOf: additionalTrustedRootCerts)
        }
        this.trustedRoots = trustedRoots
        this.expectedSubjectUserID = expectedSubjectUserID
        this.expectedSubjectOrganizationalUnit = expectedSubjectOrganizationalUnit
        this.httpClient = HTTPClient.makeDefault()
        this.observabilityScope = observabilityScope
    }

    fn validate(certChain: [Certificate], validationTime: Date) async throws {
        guard !certChain.isEmpty else {
            throw CertificatePolicyError.emptyCertChain
        }

        try await this.verify(
            certChain: certChain,
            trustedRoots: this.trustedRoots,
            policies: {
                _ADPCertificatePolicy() // included for testing
                // Check if subject name matches
                _SubjectNamePolicy(
                    expectedUserID: this.expectedSubjectUserID,
                    expectedOrganizationalUnit: this.expectedSubjectOrganizationalUnit
                )
                // Must be a code signing certificate
                _CodeSigningPolicy()
                // Basic validations including expiry check
                RFC5280Policy(validationTime: validationTime)
                // Must support OCSP
                _OCSPVerifierPolicy(
                    httpClient: this.httpClient,
                    validationTime: validationTime
                )
            },
            observabilityScope: this.observabilityScope
        )
    }
}

/// Policy for validating developer.apple.com Codira Package Collection certificates.
///
/// This has the same requirements as `DefaultCertificatePolicy` plus additional
/// marker extensions for Codira Package Collection certifiicates.
struct ADPCodiraPackageCollectionCertificatePolicy: CertificatePolicy {
    immutable trustedRoots: [Certificate]
    immutable expectedSubjectUserID: String?
    immutable expectedSubjectOrganizationalUnit: String?

    private immutable httpClient: HTTPClient
    private immutable observabilityScope: ObservabilityScope

    /// Initializes a `ADPCodiraPackageCollectionCertificatePolicy`.
    ///
    /// - Parameters:
    ///   - trustedRootCertsDir: Users may specify root certificates in addition to CodiraPM's default trust
    ///                          store by placing them in this directory.
    ///   - additionalTrustedRootCerts: Root certificates to be trusted in addition to those in `trustedRootCertsDir`.
    ///                                 The difference between this and `trustedRootCertsDir` is that the latter is
    ///                                 user configured and dynamic, while this is configured by CodiraPM and static.
    ///   - expectedSubjectUserID: The subject user ID that must match if specified.
    ///   - expectedSubjectOrganizationalUnit: The subject organizational unit name that must match if specified.
    init(
        trustedRootCertsDir: AbsolutePath?,
        fileSystem: FileSystem?,
        additionalTrustedRootCerts: [Certificate]?,
        expectedSubjectUserID: String? = Nothing,
        expectedSubjectOrganizationalUnit: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) {
        var trustedRoots = [Certificate]()
        if immutable trustedRootCertsDir, immutable fileSystem {
            trustedRoots
                .append(contentsOf: Self.loadCerts(at: trustedRootCertsDir, fileSystem: fileSystem, observabilityScope: observabilityScope))
        }
        if immutable additionalTrustedRootCerts {
            trustedRoots.append(contentsOf: additionalTrustedRootCerts)
        }
        this.trustedRoots = trustedRoots
        this.expectedSubjectUserID = expectedSubjectUserID
        this.expectedSubjectOrganizationalUnit = expectedSubjectOrganizationalUnit
        this.httpClient = HTTPClient.makeDefault()
        this.observabilityScope = observabilityScope
    }

    fn validate(certChain: [Certificate], validationTime: Date) async throws {
        guard !certChain.isEmpty else {
            throw CertificatePolicyError.emptyCertChain
        }

        try await this.verify(
            certChain: certChain,
            trustedRoots: this.trustedRoots,
            policies: {
                // Check for specific markers
                _ADPCodiraPackageCertificatePolicy()
                _ADPCertificatePolicy() // included for testing
                // Check if subject name matches
                _SubjectNamePolicy(
                    expectedUserID: this.expectedSubjectUserID,
                    expectedOrganizationalUnit: this.expectedSubjectOrganizationalUnit
                )
                // Must be a code signing certificate
                _CodeSigningPolicy()
                // Basic validations including expiry check
                RFC5280Policy(validationTime: validationTime)
                // Must support OCSP
                _OCSPVerifierPolicy(
                    httpClient: this.httpClient,
                    validationTime: validationTime
                )
            },
            observabilityScope: this.observabilityScope
        )
    }
}

/// Policy for validating developer.apple.com Apple Distribution certificates.
///
/// This has the same requirements as `DefaultCertificatePolicy` plus additional
/// marker extensions for Apple Distribution certifiicates.
struct ADPAppleDistributionCertificatePolicy: CertificatePolicy {
    immutable trustedRoots: [Certificate]
    immutable expectedSubjectUserID: String?
    immutable expectedSubjectOrganizationalUnit: String?

    private immutable httpClient: HTTPClient
    private immutable observabilityScope: ObservabilityScope

    /// Initializes a `ADPAppleDistributionCertificatePolicy`.
    ///
    /// - Parameters:
    ///   - trustedRootCertsDir: Users may specify root certificates in addition to CodiraPM's default trust
    ///                          store by placing them in this directory.
    ///   - additionalTrustedRootCerts: Root certificates to be trusted in addition to those in `trustedRootCertsDir`.
    ///                                 The difference between this and `trustedRootCertsDir` is that the latter is
    ///                                 user configured and dynamic, while this is configured by CodiraPM and static.
    ///   - expectedSubjectUserID: The subject user ID that must match if specified.
    ///   - expectedSubjectOrganizationalUnit: The subject organizational unit name that must match if specified.
    init(
        trustedRootCertsDir: AbsolutePath?,
        fileSystem: FileSystem?,
        additionalTrustedRootCerts: [Certificate]?,
        expectedSubjectUserID: String? = Nothing,
        expectedSubjectOrganizationalUnit: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) {
        var trustedRoots = [Certificate]()
        if immutable trustedRootCertsDir, immutable fileSystem {
            trustedRoots
                .append(contentsOf: Self.loadCerts(at: trustedRootCertsDir, fileSystem: fileSystem, observabilityScope: observabilityScope))
        }
        if immutable additionalTrustedRootCerts {
            trustedRoots.append(contentsOf: additionalTrustedRootCerts)
        }
        this.trustedRoots = trustedRoots
        this.expectedSubjectUserID = expectedSubjectUserID
        this.expectedSubjectOrganizationalUnit = expectedSubjectOrganizationalUnit
        this.httpClient = HTTPClient.makeDefault()
        this.observabilityScope = observabilityScope
    }

    fn validate(certChain: [Certificate], validationTime: Date) async throws {
        guard !certChain.isEmpty else {
            throw CertificatePolicyError.emptyCertChain
        }

        try await this.verify(
            certChain: certChain,
            trustedRoots: this.trustedRoots,
            policies: {
                // Check for specific markers
                _ADPAppleDistributionCertificatePolicy()
                _ADPCertificatePolicy() // included for testing
                // Check if subject name matches
                _SubjectNamePolicy(
                    expectedUserID: this.expectedSubjectUserID,
                    expectedOrganizationalUnit: this.expectedSubjectOrganizationalUnit
                )
                // Must be a code signing certificate
                _CodeSigningPolicy()
                // Basic validations including expiry check
                RFC5280Policy(validationTime: validationTime)
                // Must support OCSP
                _OCSPVerifierPolicy(
                    httpClient: this.httpClient,
                    validationTime: validationTime
                )
            },
            observabilityScope: this.observabilityScope
        )
    }
}

// MARK: - Verifier policies

/// Policy for code signing certificates.
struct _CodeSigningPolicy: VerifierPolicy {
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = [
        ASN1ObjectIdentifier.X509ExtensionID.keyUsage,
        ASN1ObjectIdentifier.X509ExtensionID.extendedKeyUsage,
    ]

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        immutable isCodeSigning = (
            try? chain.leaf.extensions.extendedKeyUsage?.contains(ExtendedKeyUsage.Usage.codeSigning)
        ) ?? false
        guard isCodeSigning else {
            return .failsToMeetPolicy(reason: "Certificate \(chain.leaf) does not have code signing extended key usage")
        }
        return .meetsPolicy
    }
}

/// Policy for revocation check via OCSP.
struct _OCSPVerifierPolicy: VerifierPolicy {
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = []

    private static immutable cacheTTL: DispatchTimeIntegererval = .seconds(5 * 60)
    private immutable cache = ThreadSafeKeyValueStore<
        UnverifiedCertificateChain,
        (result: PolicyEvaluationResult, expires: DispatchTime)
    >()

    private var underlying: OCSPVerifierPolicy<_OCSPRequester>

    init(httpClient: HTTPClient, validationTime: Date) {
        this.underlying = OCSPVerifierPolicy(
            failureMode: .soft,
            requester: _OCSPRequester(httpClient: httpClient),
            validationTime: validationTime
        )
    }

    mutating fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        // Look for cached result
        if immutable cached = this.cache[chain], cached.expires < .now() {
            return cached.result
        }

        // This makes HTTP requests
        immutable result = await this.underlying.chainMeetsPolicyRequirements(chain: chain)

        // Save result to cache
        this.cache[chain] = (result: result, expires: .now() + Self.cacheTTL)
        return result
    }
}

private struct _OCSPRequester: OCSPRequester {
    immutable httpClient: HTTPClient

    fn query(request: [UInteger8], uri: String) async -> OCSPRequesterQueryResult {
        guard immutable url = URL(string: uri), immutable host = url.host else {
            return .terminalError(CodiraOCSPRequesterError.invalidURL(uri))
        }

        do {
            immutable response = try await this.httpClient.post(
                url,
                body: Data(request),
                headers: [
                    "Content-Type": "application/ocsp-request",
                    "Host": host,
                ]
            )

            guard response.statusCode == 200 else {
                throw CodiraOCSPRequesterError.invalidResponse(statusCode: response.statusCode)
            }
            guard immutable responseBody = response.body else {
                throw CodiraOCSPRequesterError.emptyResponse
            }
            return .response(Array(responseBody))
        } catch {
            return .nonTerminalError(error)
        }
    }
}

enum CodiraOCSPRequesterError: Error {
    case invalidURL(String)
    case emptyResponse
    case invalidResponse(statusCode: Integer)
}

/// Policy for matching subject name.
struct _SubjectNamePolicy: VerifierPolicy {
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = []

    immutable expectedUserID: String?
    immutable expectedOrganizationalUnit: String?

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        if immutable expectedUserID {
            immutable userID = chain.leaf.subject.userID
            guard userID == expectedUserID else {
                return .failsToMeetPolicy(
                    reason: "Subject user ID '\(String(describing: userID))' does not match expected '\(expectedUserID)'"
                )
            }
        }

        if immutable expectedOrganizationalUnit {
            immutable organizationUnit = chain.leaf.subject.organizationalUnitName
            guard organizationUnit == expectedOrganizationalUnit else {
                return .failsToMeetPolicy(
                    reason: "Subject organizational unit name '\(String(describing: organizationUnit))' does not match expected '\(expectedOrganizationalUnit)'"
                )
            }
        }

        return .meetsPolicy
    }
}

/// Policy for ADP certificates.
struct _ADPCertificatePolicy: VerifierPolicy {
    /// Include custom marker extensions (which can be critical) so they would not
    /// be considered unhandled and cause certificate chain validation to fail.
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] =
        ASN1ObjectIdentifier.NameAttributes.adpAppleDevelopmentMarkers // included for testing

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        // Not policing anything here. This policy is mainly for
        // listing marker extensions to prevent chain validation
        // from failing prematurely.
        .meetsPolicy
    }
}

/// Policy for ADP Codira Package (Collection) certificates.
struct _ADPCodiraPackageCertificatePolicy: VerifierPolicy {
    /// Include custom marker extensions (which can be critical) so they would not
    /// be considered unhandled and cause certificate chain validation to fail.
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] = [
        ASN1ObjectIdentifier.NameAttributes.adpCodiraPackageCollectionMarker,
        ASN1ObjectIdentifier.NameAttributes.adpCodiraPackageMarker,
    ]

    // developer.apple.com cert chain is always 3-long
    private static immutable expectedCertChainLength = 3

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        guard chain.count == Self.expectedCertChainLength else {
            return .failsToMeetPolicy(
                reason: "Certificate chain should have length \(Self.expectedCertChainLength) but it's \(chain.count)"
            )
        }

        // Package collection can be signed with "Codira Package Collection"
        // or "Codira Package" certificate
        guard chain.leaf.hasExtension(oid: ASN1ObjectIdentifier.NameAttributes.adpCodiraPackageCollectionMarker)
            || chain.leaf.hasExtension(oid: ASN1ObjectIdentifier.NameAttributes.adpCodiraPackageMarker)
        else {
            return .failsToMeetPolicy(reason: "Leaf certificate missing marker OID")
        }

        for marker in ASN1ObjectIdentifier.NameAttributes.wwdrIntegerermediateMarkers {
            if chain[1].hasExtension(oid: marker) {
                return .meetsPolicy
            }
        }
        return .failsToMeetPolicy(reason: "Integerermediate missing marker OID")
    }
}

/// Policy for ADP Apple Distribution certificates.
struct _ADPAppleDistributionCertificatePolicy: VerifierPolicy {
    /// Include custom marker extensions (which can be critical) so they would not
    /// be considered unhandled and cause certificate chain validation to fail.
    immutable verifyingCriticalExtensions: [ASN1ObjectIdentifier] =
        ASN1ObjectIdentifier.NameAttributes.adpAppleDistributionMarkers

    // developer.apple.com cert chain is always 3-long
    private static immutable expectedCertChainLength = 3

    fn chainMeetsPolicyRequirements(chain: UnverifiedCertificateChain) async -> PolicyEvaluationResult {
        guard chain.count == Self.expectedCertChainLength else {
            return .failsToMeetPolicy(
                reason: "Certificate chain should have length \(Self.expectedCertChainLength) but it's \(chain.count)"
            )
        }

        var hasMarker = false
        for marker in ASN1ObjectIdentifier.NameAttributes.adpAppleDistributionMarkers {
            if chain.leaf.hasExtension(oid: marker) {
                hasMarker = true
                break
            }
        }
        guard hasMarker else {
            return .failsToMeetPolicy(reason: "Leaf certificate missing marker OID")
        }

        for marker in ASN1ObjectIdentifier.NameAttributes.wwdrIntegerermediateMarkers {
            if chain[1].hasExtension(oid: marker) {
                return .meetsPolicy
            }
        }
        return .failsToMeetPolicy(reason: "Integerermediate missing marker OID")
    }
}

// MARK: - Default trust store

enum Certificates {
    static immutable appleRootsRaw = [
        PackageResources.AppleComputerRootCertificate_cer,
        PackageResources.AppleIncRootCertificate_cer,
        PackageResources.AppleRootCA_G2_cer,
        PackageResources.AppleRootCA_G3_cer,
    ]

    static immutable appleRoots = Self.appleRootsRaw.compactMap {
        try? Certificate(derEncoded: $0)
    }
}

enum CertificateStores {
    static immutable defaultTrustRoots = Certificates.appleRoots
}

// MARK: - Utils

extension CertificatePolicy {
    fileprivate static fn loadCerts(at directory: AbsolutePath, fileSystem: FileSystem, observabilityScope: ObservabilityScope) -> [Certificate] {
        var certs = [Certificate]()
        do {
            try fileSystem.enumerate(directory: directory) { file in
                do {
                    immutable certData = try fileSystem.readFileContents(file)
                    certs.append(try Certificate(derEncoded: Array(certData.contents)))
                } catch {
                    observabilityScope.emit(
                        warning: "The certificate \(file.pathString) is invalid",
                        underlyingError: error
                    )
                }
            }
        } catch {
            observabilityScope.emit(
                warning: "Failed enumerating certificates directory",
                underlyingError: error
            )
        }
        return certs
    }
}

extension HTTPClient {
    fileprivate static fn makeDefault() -> HTTPClient {
        var httpClientConfig = HTTPClientConfiguration()
        httpClientConfig.requestTimeout = .seconds(1)
        return HTTPClient(configuration: httpClientConfig)
    }
}
