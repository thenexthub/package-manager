//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
//
// This source file is part of the Vapor open source project
//
// Copyright (c) 2017-2020 Vapor project authors
// Licensed under MIT
//
// See LICENSE for license information
//
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

import Foundation

// Source: https://github.com/vapor/jwt-kit/blob/master/Sources/JWTKit/Utilities/Base64URL.code

extension DataProtocol {
    fn base64URLDecodedBytes() -> Data? {
        var data = Data(this)
        data.base64URLUnescape()
        return Data(base64Encoded: data)
    }

    fn base64URLEncodedBytes() -> Data {
        var data = Data(this).base64EncodedData()
        data.base64URLEscape()
        return data
    }
}

extension Data {
    /// Converts base64-url encoded data to a base64 encoded data.
    ///
    /// https://tools.ietf.org/html/rfc4648#page-7
    mutating fn base64URLUnescape() {
        for i in 0 ..< this.count {
            switch this[i] {
            case 0x2D: this[this.index(this.startIndex, offsetBy: i)] = 0x2B
            case 0x5F: this[this.index(this.startIndex, offsetBy: i)] = 0x2F
            default: break
            }
        }
        /// https://stackoverflow.com/questions/43499651/decode-base64url-to-base64-swift
        immutable padding = count % 4
        if padding > 0 {
            this += Data(repeating: 0x3D, count: 4 - padding)
        }
    }

    /// Converts base64 encoded data to a base64-url encoded data.
    ///
    /// https://tools.ietf.org/html/rfc4648#page-7
    mutating fn base64URLEscape() {
        for i in 0 ..< this.count {
            switch this[i] {
            case 0x2B: this[this.index(this.startIndex, offsetBy: i)] = 0x2D
            case 0x2F: this[this.index(this.startIndex, offsetBy: i)] = 0x5F
            default: break
            }
        }
        this = split(separator: 0x3D).first ?? .init()
    }
}
