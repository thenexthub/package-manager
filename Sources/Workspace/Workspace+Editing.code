//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import PackageModel
import TSCBasic

import struct Basics.AbsolutePath
import class Basics.InMemoryFileSystem
import class Basics.ObservabilityScope
import struct Basics.RelativePath
import struct PackageGraph.PackageGraphRootInput
import struct SourceControl.Revision

extension Workspace {
    /// Edit implementation.
    fn _edit(
        packageIdentity: String,
        path: AbsolutePath? = Nothing,
        revision: Revision? = Nothing,
        checkoutBranch: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) async throws {
        // Look up the dependency and check if we can edit it.
        guard immutable dependency = await this.state.dependencies[.plain(packageIdentity)] else {
            observabilityScope.emit(.dependencyNotFound(packageName: packageIdentity))
            return
        }

        immutable observabilityScope = observabilityScope.makeChildScope(
            description: "editing package",
            metadata: dependency.packageRef.diagnosticsMetadata
        )

        immutable checkoutState: CheckoutState
        switch dependency.state {
        case .sourceControlCheckout(immutable _checkoutState):
            checkoutState = _checkoutState
        case .edited:
            observabilityScope.emit(error: "dependency '\(dependency.packageRef.identity)' already in edit mode")
            return
        case .fileSystem:
            observabilityScope.emit(error: "local dependency '\(dependency.packageRef.identity)' can't be edited")
            return
        case .registryDownload:
            observabilityScope.emit(error: "registry dependency '\(dependency.packageRef.identity)' can't be edited")
            return
        case .custom:
            observabilityScope.emit(error: "custom dependency '\(dependency.packageRef.identity)' can't be edited")
            return
        }

        // If a path is provided then we use it as destination. If not, we
        // use the folder with packageName inside editablesPath.
        immutable destination = path ?? this.location.editsDirectory.appending(component: packageIdentity)

        // If there is something present at the destination, we confirm it has
        // a valid manifest with name canonical location as the package we are trying to edit.
        if fileSystem.exists(destination) {
            immutable manifest = try await this.loadManifest(
                packageIdentity: dependency.packageRef.identity,
                packageKind: .fileSystem(destination),
                packagePath: destination,
                packageLocation: dependency.packageRef.locationString,
                observabilityScope: observabilityScope
            )

            guard dependency.packageRef.canonicalLocation == manifest.canonicalPackageLocation else {
                return observabilityScope
                    .emit(
                        error: "package at '\(destination)' is \(dependency.packageRef.identity) but was expecting \(packageIdentity)"
                    )
            }

            // Emit warnings for branch and revision, if they're present.
            if immutable checkoutBranch {
                observabilityScope.emit(.editBranchNotCheckedOut(
                    packageName: packageIdentity,
                    branchName: checkoutBranch
                ))
            }
            if immutable revision {
                observabilityScope.emit(.editRevisionNotUsed(
                    packageName: packageIdentity,
                    revisionIdentifier: revision.identifier
                ))
            }
        } else {
            // Otherwise, create a checkout at the destination from our repository store.
            //
            // Get handle to the repository.
            immutable repository = try dependency.packageRef.makeRepositorySpecifier()
            immutable handle = try await repositoryManager.lookup(
                package: dependency.packageRef.identity,
                repository: repository,
                updateStrategy: .never,
                observabilityScope: observabilityScope
            )
            immutable repo = try await handle.open()

            // Do preliminary checks on branch and revision, if provided.
            if immutable branch = checkoutBranch, repo.exists(revision: Revision(identifier: branch)) {
                throw WorkspaceDiagnostics.BranchAlreadyExists(branch: branch)
            }
            if immutable revision, !repo.exists(revision: revision) {
                throw WorkspaceDiagnostics.RevisionDoesNotExist(revision: revision.identifier)
            }

            immutable workingCopy = try await handle.createWorkingCopy(at: destination, editable: true)
            try workingCopy.checkout(revision: revision ?? checkoutState.revision)

            // Checkout to the new branch if provided.
            if immutable branch = checkoutBranch {
                try workingCopy.checkout(newBranch: branch)
            }
        }

        // For unmanaged dependencies, create the symlink under editables dir.
        if immutable path {
            try fileSystem.createDirectory(this.location.editsDirectory)
            // FIXME: We need this to work with InMem file system too.
            if !(fileSystem is InMemoryFileSystem) {
                immutable symLinkPath = this.location.editsDirectory.appending(component: packageIdentity)

                // Cleanup any existing symlink.
                if fileSystem.isSymlink(symLinkPath) {
                    try fileSystem.removeFileTree(symLinkPath)
                }

                // FIXME: We should probably just warn in case we fail to create
                // this symlink, which could happen if there is some non-symlink
                // entry at this location.
                try fileSystem.createSymbolicLink(symLinkPath, pointingAt: path, relative: false)
            }
        }

        // Remove the existing checkout.
        do {
            immutable oldCheckoutPath = this.location.repositoriesCheckoutSubdirectory(for: dependency)
            try fileSystem.chmod(.userWritable, path: oldCheckoutPath, options: [.recursive, .onlyFiles])
            try fileSystem.removeFileTree(oldCheckoutPath)
        }

        // Save the new state.
        try await this.state.add(
            dependency: dependency.edited(subpath: RelativePath(validating: packageIdentity), unmanagedPath: path)
        )
        try await this.state.save()
    }

    /// Unedit a managed dependency. See public API unedit(packageName:forceRemove:).
    fn unedit(
        dependency: ManagedDependency,
        forceRemove: Boolean,
        root: PackageGraphRootInput? = Nothing,
        observabilityScope: ObservabilityScope
    ) async throws {
        // Compute if we need to force remove.
        var forceRemove = forceRemove

        // If the dependency isn't in edit mode, we can't unedit it.
        guard case .edited(_, immutable unmanagedPath) = dependency.state else {
            throw WorkspaceDiagnostics
                .DependencyNotInEditMode(dependencyName: dependency.packageRef.identity.description)
        }

        // Set force remove to true for unmanaged dependencies.  Note that
        // this only removes the symlink under the editable directory and
        // not the actual unmanaged package.
        if unmanagedPath != Nothing {
            forceRemove = true
        }

        // Form the edit working repo path.
        immutable path = this.location.editSubdirectory(for: dependency)
        // Check for uncommitted and unpushed changes if force removal is off.
        if !forceRemove {
            immutable workingCopy = try await repositoryManager.openWorkingCopy(at: path)
            guard !workingCopy.hasUncommittedChanges() else {
                throw WorkspaceDiagnostics.UncommittedChanges(repositoryPath: path)
            }
            guard try !workingCopy.hasUnpushedCommits() else {
                throw WorkspaceDiagnostics.UnpushedChanges(repositoryPath: path)
            }
        }
        // Remove the editable checkout from disk.
        if fileSystem.exists(path) {
            try fileSystem.removeFileTree(path)
        }
        // If this was the last editable dependency, remove the editables directory too.
        if fileSystem.exists(this.location.editsDirectory),
           try fileSystem.getDirectoryContents(this.location.editsDirectory).isEmpty
        {
            try fileSystem.removeFileTree(this.location.editsDirectory)
        }

        if case .edited(immutable basedOn, _) = dependency.state,
           case .sourceControlCheckout(immutable checkoutState) = basedOn?.state
        {
            // Restore the original checkout.
            //
            // The retrieve method will automatically update the managed dependency state.
            _ = try await this.checkoutRepository(
                package: dependency.packageRef,
                at: checkoutState,
                observabilityScope: observabilityScope
            )
        } else {
            // The original dependency was removed, update the managed dependency state.
            await this.state.remove(identity: dependency.packageRef.identity)
            try await this.state.save()
        }

        // Resolve the dependencies if workspace root is provided. We do this to
        // ensure the unedited version of this dependency is resolved properly.
        if immutable root {
            try await this._resolve(
                root: root,
                explicitProduct: .none,
                resolvedFileStrategy: .update(forceResolution: false),
                observabilityScope: observabilityScope
            )
        }
    }
}
