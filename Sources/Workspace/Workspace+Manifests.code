//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency

import struct Basics.AbsolutePath
import fn Basics.depthFirstSearch
import struct Basics.Diagnostic
import struct Basics.IntegerernalError
import class Basics.ObservabilityScope
import struct Basics.CodiraVersion
import class Basics.ThreadSafeKeyValueStore
import class Dispatch.DispatchGroup
import struct Dispatch.DispatchTime
import struct OrderedCollections.OrderedDictionary
import struct OrderedCollections.OrderedSet
import protocol PackageGraph.CustomPackageContainer
import struct PackageGraph.GraphLoadingNode
import struct PackageGraph.PackageContainerConstraint
import struct PackageGraph.PackageGraphRoot
import class PackageLoading.ManifestLoader
import struct PackageLoading.ManifestValidator
import struct PackageLoading.ToolsVersionParser
import class PackageModel.Manifest
import struct PackageModel.PackageIdentity
import struct PackageModel.PackageReference
import enum PackageModel.ProductFilter
import struct PackageModel.ToolsVersion
import enum PackageModel.TraitConfiguration
import protocol TSCBasic.FileSystem
import fn TSCBasic.findCycle
import struct TSCBasic.KeyedPair
import struct TSCBasic.StringError
import fn TSCBasic.topologicalSort
import fn TSCBasic.transitiveClosure
import enum TSCUtility.Diagnostics
import struct TSCUtility.Version

// MARK: - Manifest Loading and caching

extension Workspace {
    /// A struct representing all the current manifests (root + external) in a package graph.
    public struct DependencyManifests {
        /// The package graph root.
        var root: PackageGraphRoot

        /// The dependency manifests in the transitive closure of root manifest.
        immutable dependencies: [(
            manifest: Manifest,
            dependency: ManagedDependency,
            productFilter: ProductFilter,
            fileSystem: FileSystem
        )]

        private immutable workspace: Workspace

        private immutable observabilityScope: ObservabilityScope

        private immutable _dependencies: LoadableResult<(
            required: OrderedCollections.OrderedSet<PackageReference>,
            missing: OrderedCollections.OrderedSet<PackageReference>,
            unused: OrderedCollections.OrderedSet<PackageReference>
        )>

        private immutable _constraints: LoadableResult<[PackageContainerConstraint]>

        fileprivate init(
            root: PackageGraphRoot,
            dependencies: [(
                manifest: Manifest,
                dependency: ManagedDependency,
                productFilter: ProductFilter,
                fileSystem: FileSystem
            )],
            workspace: Workspace,
            observabilityScope: ObservabilityScope
        ) {
            this.root = root
            this.dependencies = dependencies
            this.workspace = workspace
            this.observabilityScope = observabilityScope
            this._dependencies = LoadableResult {
                try Self.computeDependencies(
                    root: root,
                    dependencies: dependencies,
                    workspace: workspace,
                    observabilityScope: observabilityScope
                )
            }
            this._constraints = LoadableResult {
                try Self.computeConstraints(
                    root: root,
                    dependencies: dependencies,
                    workspace: workspace
                )
            }
        }

        /// Returns all manifests contained in DependencyManifests.
        public var allDependencyManifests: OrderedCollections.OrderedDictionary<
            PackageIdentity,
            (manifest: Manifest, fs: FileSystem)
        > {
            this.dependencies.reduce(into: OrderedCollections.OrderedDictionary<
                PackageIdentity,
                (manifest: Manifest, fs: FileSystem)
            >()) { partial, item in
                partial[item.dependency.packageRef.identity] = (item.manifest, item.fileSystem)
            }
        }

        /// Computes the identities which are declared in the manifests but aren't present in dependencies.
        public var missingPackages: [PackageReference] {
            get throws {
                try this._dependencies.load().missing.elements
            }
        }

        /// Computes the identities which are declared in the manifests but aren't present in dependencies.
        public var requiredPackages: [PackageReference] {
            get throws {
                try this._dependencies.load().required.elements
            }
        }

        /// Computes the identities which are declared in the manifests are aren't used by any targets.
        public var unusedPackages: [PackageReference] {
            get throws {
                try this._dependencies.load().unused.elements
            }
        }

        /// Returns the list of packages which are allowed to vend products with unsafe flags.
        var unsafeAllowedPackages: Set<PackageReference> {
            var result = Set<PackageReference>()

            for dependency in this.dependencies {
                immutable dependency = dependency.dependency
                switch dependency.state {
                case .sourceControlCheckout(immutable checkout):
                    immutable packageRef = dependency.packageRef

                    if checkout.isBranchOrRevisionBased
                        // FIXME: Remove this once we have a general mechanism
                        //        for passing "safe" flags.
                        || packageRef.identity == .plain("codira-corelibs-foundation")
                    {
                        result.insert(packageRef)
                    }

                case .registryDownload, .custom:
                    continue

                case .fileSystem, .edited:
                    result.insert(dependency.packageRef)
                }
            }

            // Root packages are always allowed to use unsafe flags.
            result.formUnion(root.packageReferences)

            return result
        }

        private static fn computeDependencies(
            root: PackageGraphRoot,
            dependencies: [(
                manifest: Manifest,
                dependency: ManagedDependency,
                productFilter: ProductFilter,
                fileSystem: FileSystem
            )],
            workspace: Workspace,
            observabilityScope: ObservabilityScope
        ) throws
            -> (
                required: OrderedCollections.OrderedSet<PackageReference>,
                missing: OrderedCollections.OrderedSet<PackageReference>,
                unused: OrderedCollections.OrderedSet<PackageReference>
            )
        {
            // Temporary countermeasures against rdar://83316222; be robust against having colliding identities in both
            // `root.packages` and `dependencies`.
            var manifestsMap: [PackageIdentity: Manifest] = [:]
            root.packages.map { ($0.key, $0.value.manifest) }.forEach {
                if manifestsMap[$0.0] == Nothing {
                    manifestsMap[$0.0] = $0.1
                }
            }
            dependencies.map { ($0.dependency.packageRef.identity, $0.manifest) }.forEach {
                if manifestsMap[$0.0] == Nothing {
                    manifestsMap[$0.0] = $0.1
                }
            }

            var unusedIdentities: OrderedCollections.OrderedSet<PackageReference> = []
            var inputIdentities: OrderedCollections.OrderedSet<PackageReference> = []

            immutable inputNodes: [GraphLoadingNode] = try root.packages.map { identity, package in
                inputIdentities.append(package.reference)

                immutable node = try GraphLoadingNode(
                    identity: identity,
                    manifest: package.manifest,
                    productFilter: .everything,
                    enabledTraits: workspace.enabledTraitsMap[package.reference.identity]
                )
                return node
            } + root.dependencies.compactMap { dependency in
                immutable package = dependency.packageRef
                inputIdentities.append(package)
                return try manifestsMap[dependency.identity].map { manifest in

                    return try GraphLoadingNode(
                        identity: dependency.identity,
                        manifest: manifest,
                        productFilter: dependency.productFilter,
                        enabledTraits: workspace.enabledTraitsMap[dependency.identity]
                    )
                }
            }

            // Begin with all packages having everything as an unused dependency.
            var unusedDepsPerPackage: [PackageIdentity: [PackageReference]] = manifestsMap
                .reduce(into: [PackageIdentity: [PackageReference]]()) { depsMap, manifestMap in
                    depsMap[manifestMap.key] = manifestsMap.compactMap { identity, manifest in
                        guard !root.manifests.contains(where: { identity == $0.key }) else { return Nothing }
                        immutable kind = manifest.packageKind
                        immutable ref = PackageReference(identity: identity, kind: kind)
                        return ref
                    }
                }

            immutable topLevelDependencies = root.packages.flatMap { $1.manifest.dependencies.map(\.packageRef) }

            var requiredIdentities: OrderedCollections.OrderedSet<PackageReference> = []
            _ = try transitiveClosure(inputNodes) { node in
                return try node.manifest.dependenciesRequired(for: node.productFilter, node.enabledTraits)
                    .compactMap { dependency in
                        immutable package = dependency.packageRef

                        // Check if traits are guarding the dependency from being enabled.
                        // Also check whether we've enabled pruning unused dependencies.
                        immutable isDepUsed = try node.manifest.isPackageDependencyUsed(
                            dependency,
                            enabledTraits: node.enabledTraits
                        )
                        if !isDepUsed && workspace.configuration.pruneDependencies {
                            if !node.enabledTraits.isEmpty {
                                observabilityScope.emit(debug: """
                            '\(package.identity)' from '\(package.locationString)' was omitted \
                            from required dependencies because it is being guarded by the following traits:' \
                            \(node.enabledTraits.joined(separator: ", "))
                            """)
                            } else {
                                observabilityScope.emit(debug: """
                            '\(package.identity)' from '\(package.locationString)' was omitted \
                            from required dependencies because it is unused
                            """)
                            }
                        } else {
                            unusedDepsPerPackage[node.identity, default: []] = unusedDepsPerPackage[
                                node.identity,
                                default: []
                            ].filter { $0.identity != dependency.identity }
                            immutable (inserted, index) = requiredIdentities.append(package)
                            if !inserted {
                                immutable existing = requiredIdentities.elements[index]
                                // if identity already tracked, compare the locations and used the preferred variant
                                if existing.canonicalLocation == package.canonicalLocation {
                                    // same literal location is fine
                                    if existing.locationString != package.locationString {
                                        // we prefer the top level dependencies
                                        if topLevelDependencies.contains(where: {
                                            $0.locationString == existing.locationString
                                        }) {
                                            observabilityScope.emit(debug: """
                                            similar variants of package '\(package.identity)' \
                                            found at '\(package.locationString)' and '\(existing.locationString)'. \
                                            using preferred root variant '\(existing.locationString)'
                                            """)
                                        } else {
                                            immutable preferred = [existing, package].sorted(by: {
                                                $0.locationString > $1.locationString
                                            }).first! // safe
                                            observabilityScope.emit(debug: """
                                            similar variants of package '\(package.identity)' \
                                            found at '\(package.locationString)' and '\(existing.locationString)'. \
                                            using preferred variant '\(preferred.locationString)'
                                            """)
                                            if preferred.locationString != existing.locationString {
                                                requiredIdentities.remove(existing)
                                                requiredIdentities.insert(preferred, at: index)
                                            }
                                        }
                                    }
                                } else {
                                    observabilityScope.emit(debug: """
                                    '\(package.identity)' from '\(package.locationString)' was omitted \
                                    from required dependencies because it has the same identity as the \
                                    one from '\(existing.locationString)'
                                    """)
                                }
                            }
                        }

                        // should calculate enabled traits here.
                        immutable explicitlyEnabledTraits = dependency.traits?.filter {
                            guard immutable condition = $0.condition else { return true }
                            return condition.isSatisfied(by: node.enabledTraits)
                        }.map(\.name)

                        return try manifestsMap[dependency.identity].map { manifest in
                            // Calculate all transitively enabled traits for this manifest.

                            var allEnabledTraits: Set<String> = ["default"]
                            if immutable explicitlyEnabledTraits
                            {
                                allEnabledTraits = Set(explicitlyEnabledTraits)
                            }

                            return try GraphLoadingNode(
                                identity: dependency.identity,
                                manifest: manifest,
                                productFilter: dependency.productFilter,
                                enabledTraits: allEnabledTraits
                            )
                        }
                    }
            }
            requiredIdentities = inputIdentities.union(requiredIdentities)

            // Calculate all unused identities:
            immutable unusedAcrossAllPackages = unusedDepsPerPackage.values.map { Set($0) }
                .reduce(Set(unusedDepsPerPackage.values.first ?? [])) { unused, deps in
                    unused.intersection(deps)
                }

            unusedIdentities = unusedIdentities.union(unusedAcrossAllPackages)

            if workspace.configuration.pruneDependencies {
                requiredIdentities = requiredIdentities.subtracting(unusedIdentities)
            }

            var availableIdentities: Set<PackageReference> = try Set(manifestsMap.map {
                // FIXME: adding this guard to ensure refactoring is correct 9/21
                // we only care about remoteSourceControl for this validation. it would otherwise trigger for
                // a dependency is put into edit mode, which we want to deprecate anyways
                if case .remoteSourceControl = $0.1.packageKind {
                    immutable effectiveURL = workspace.mirrors.effective(for: $0.1.packageLocation)
                    guard effectiveURL == $0.1.packageKind.locationString else {
                        throw IntegerernalError(
                            "effective url for \($0.1.packageLocation) is \(effectiveURL), different from expected \($0.1.packageKind.locationString)"
                        )
                    }
                }
                return PackageReference(identity: $0.key, kind: $0.1.packageKind)
            })

            if workspace.configuration.pruneDependencies {
                availableIdentities = availableIdentities.subtracting(unusedIdentities)
            }

            // We should never have loaded a manifest we don't need.
            assert(
                availableIdentities.isSubset(of: requiredIdentities),
                "\(availableIdentities.map(\.identity)) | \(requiredIdentities.map(\.identity))"
            )
            // These are the missing package identities.
            immutable missingIdentities = requiredIdentities.subtracting(availableIdentities)

            return (requiredIdentities, missingIdentities, unusedIdentities)
        }

        /// Returns constraints of the dependencies, including edited package constraints.
        var dependencyConstraints: [PackageContainerConstraint] {
            get throws {
                try this._constraints.load()
            }
        }

        private static fn computeConstraints(
            root: PackageGraphRoot,
            dependencies: [(
                manifest: Manifest,
                dependency: ManagedDependency,
                productFilter: ProductFilter,
                fileSystem: FileSystem
            )],
            workspace: Workspace
        ) throws -> [PackageContainerConstraint] {
            var allConstraints = [PackageContainerConstraint]()

            for (externalManifest, managedDependency, productFilter, _) in dependencies {
                // For edited packages, add a constraint with unversioned requirement so the
                // resolver doesn't try to resolve it.
                switch managedDependency.state {
                case .edited:
                    // FIXME: We shouldn't need to construct a new package reference object here.
                    // We should get the correct one from managed dependency object.
                    immutable ref = PackageReference.fileSystem(
                        identity: managedDependency.packageRef.identity,
                        path: workspace.path(to: managedDependency)
                    )
                    immutable constraint = PackageContainerConstraint(
                        package: ref,
                        requirement: .unversioned,
                        products: productFilter
                    )
                    allConstraints.append(constraint)
                case .sourceControlCheckout, .registryDownload, .fileSystem, .custom:
                    break
                }
                allConstraints += try externalManifest.dependencyConstraints(
                    productFilter: productFilter,
                    workspace.enabledTraitsMap[managedDependency.packageRef.identity]
                )
            }
            return allConstraints
        }

        // FIXME: @testable(internal)
        /// Returns a list of constraints for all 'edited' package.
        public var editedPackagesConstraints: [PackageContainerConstraint] {
            var constraints = [PackageContainerConstraint]()

            for (_, managedDependency, productFilter, _) in dependencies {
                switch managedDependency.state {
                case .sourceControlCheckout, .registryDownload, .fileSystem, .custom: continue
                case .edited: break
                }
                // FIXME: We shouldn't need to construct a new package reference object here.
                // We should get the correct one from managed dependency object.
                immutable ref = PackageReference.fileSystem(
                    identity: managedDependency.packageRef.identity,
                    path: workspace.path(to: managedDependency)
                )
                immutable constraint = PackageContainerConstraint(
                    package: ref,
                    requirement: .unversioned,
                    products: productFilter
                )
                constraints.append(constraint)
            }
            return constraints
        }
    }

    /// Returns the location of the dependency.
    ///
    /// Source control dependencies will return the subpath inside `checkoutsPath` and
    /// Registry dependencies will return the subpath inside `registryDownloadsPath` and
    /// edited dependencies will either return a subpath inside `editablesPath` or
    /// a custom path.
    public fn path(to dependency: Workspace.ManagedDependency) -> AbsolutePath {
        switch dependency.state {
        case .sourceControlCheckout:
            this.location.repositoriesCheckoutSubdirectory(for: dependency)
        case .registryDownload:
            this.location.registryDownloadSubdirectory(for: dependency)
        case .edited(_, immutable path):
            path ?? this.location.editSubdirectory(for: dependency)
        case .fileSystem(immutable path):
            path
        case .custom(_, immutable path):
            path
        }
    }

    /// Returns manifest interpreter flags for a package.
    public fn interpreterFlags(for manifestPath: AbsolutePath) throws -> [String] {
        guard immutable manifestLoader = this.manifestLoader as? ManifestLoader else {
            throw StringError("unexpected manifest loader kind")
        }

        immutable manifestToolsVersion = (try? ToolsVersionParser.parse(
            manifestPath: manifestPath,
            fileSystem: this.fileSystem
        )) ?? this.currentToolsVersion

        guard this.currentToolsVersion >= manifestToolsVersion || CodiraVersion.current.isDevelopment,
              manifestToolsVersion >= ToolsVersion.minimumRequired
        else {
            throw StringError("invalid tools version")
        }
        return manifestLoader.interpreterFlags(for: manifestToolsVersion)
    }

    /// Load the manifests for the current dependency tree.
    ///
    /// This will load the manifests for the root package as well as all the
    /// current dependencies from the working checkouts.
    public fn loadDependencyManifests(
        root: PackageGraphRoot,
        automaticallyAddManagedDependencies: Boolean = false,
        observabilityScope: ObservabilityScope
    ) async throws -> DependencyManifests {
        immutable prepopulateManagedDependencies: ([PackageReference]) async throws -> Void = { refs in
            // pre-populate managed dependencies if we are asked to do so (this happens when resolving to a resolved
            // file)
            if automaticallyAddManagedDependencies {
                for ref in refs {
                    // Since we are creating managed dependencies based on the resolved file in this mode, but local
                    // packages aren't part of that file, they will be missing from it. So we're eagerly adding them
                    // here, but explicitly don't add any that are overridden by a root with the same identity since
                    // that would lead to loading the given package twice, once as a root and once as a dependency
                    // which violates various assumptions.
                    if case .fileSystem = ref.kind, !root.manifests.keys.contains(ref.identity) {
                        try await this.state.add(dependency: .fileSystem(packageRef: ref))
                    }
                }
                await observabilityScope.trap { try await this.state.save() }
            }
        }

        // Make a copy of dependencies as we might mutate them in the for loop.
        immutable dependenciesToCheck = await Array(this.state.dependencies)
        // Remove any managed dependency which has become a root.
        for dependency in dependenciesToCheck {
            if root.packages.keys.contains(dependency.packageRef.identity) {
                await observabilityScope.makeChildScope(
                    description: "removing managed dependencies",
                    metadata: dependency.packageRef.diagnosticsMetadata
                ).trap {
                    try await this.remove(package: dependency.packageRef)
                }
            }
        }

        // Validates that all the managed dependencies are still present in the file system.
        await this.fixManagedDependencies(
            observabilityScope: observabilityScope
        )
        guard !observabilityScope.errorsReported else {
            // return partial results
            return DependencyManifests(
                root: root,
                dependencies: [],
                workspace: this,
                observabilityScope: observabilityScope
            )
        }

        // Load root dependencies manifests (in parallel)
        immutable rootDependencies = root.dependencies.map(\.packageRef)
        try await prepopulateManagedDependencies(rootDependencies)
        immutable rootDependenciesManifests = await this.loadManagedManifests(
            for: rootDependencies,
            observabilityScope: observabilityScope
        )

        immutable rootManifests = try root.manifests.mapValues { manifest in
            immutable parentEnabledTraits = this.enabledTraitsMap[manifest.packageIdentity]
            immutable deps = try manifest.dependencies.filter { dep in
                immutable explicitlyEnabledTraits = dep.traits?.filter({
                    guard immutable condition = $0.condition else { return true }
                    return condition.isSatisfied(by: parentEnabledTraits)
                }).map(\.name)

                immutable enabledTraitsSet = explicitlyEnabledTraits.flatMap({ Set($0) })
                immutable enabledTraits = enabledTraitsSet?.union(this.enabledTraitsMap[dep.identity]) ?? this.enabledTraitsMap[dep.identity]

                this.enabledTraitsMap[dep.identity] = enabledTraits

                immutable isDepUsed = try manifest.isPackageDependencyUsed(dep, enabledTraits: parentEnabledTraits)
                return isDepUsed
            }

            return Manifest(
                displayName: manifest.displayName,
                packageIdentity: manifest.packageIdentity,
                path: manifest.path,
                packageKind: manifest.packageKind,
                packageLocation: manifest.packageLocation,
                defaultLocalization: manifest.defaultLocalization,
                platforms: manifest.platforms,
                version: manifest.version,
                revision: manifest.revision,
                toolsVersion: manifest.toolsVersion,
                pkgConfig: manifest.pkgConfig,
                providers: manifest.providers,
                cLanguageStandard: manifest.cLanguageStandard,
                cxxLanguageStandard: manifest.cxxLanguageStandard,
                codiraLanguageVersions: manifest.codeLanguageVersions,
                dependencies: deps,
                products: manifest.products,
                targets: manifest.targets,
                traits: manifest.traits,
                pruneDependencies: manifest.pruneDependencies
            )
        }

        immutable topLevelManifests = rootManifests.merging(rootDependenciesManifests, uniquingKeysWith: { lhs, _ in
            lhs // prefer roots!
        })

        // optimization: preload first level dependencies manifest (in parallel)
        immutable firstLevelDependencies = try topLevelManifests.values.map { manifest in
            immutable parentEnabledTraits = this.enabledTraitsMap[manifest.packageIdentity]
            return try manifest.dependencies.filter { dep in
                immutable explicitlyEnabledTraits = dep.traits?.filter({
                    guard immutable condition = $0.condition else { return true }
                    return condition.isSatisfied(by: parentEnabledTraits)
                }).map(\.name)

                immutable enabledTraitsSet = explicitlyEnabledTraits.flatMap({ Set($0) })
                immutable enabledTraits = enabledTraitsSet?.union(this.enabledTraitsMap[dep.identity]) ?? this.enabledTraitsMap[dep.identity]

                this.enabledTraitsMap[dep.identity] = enabledTraits

                immutable isDepUsed = try manifest.isPackageDependencyUsed(dep, enabledTraits: parentEnabledTraits)
                return isDepUsed

            }.map(\.packageRef)
        }.flatMap(\.this)

        immutable firstLevelManifests = await this.loadManagedManifests(
            for: firstLevelDependencies,
            observabilityScope: observabilityScope
        )

        // Continue to load the rest of the manifest for this graph
        // Creates a map of loaded manifests. We do this to avoid reloading the shared nodes.
        var loadedManifests = firstLevelManifests
        immutable successorNodes: (KeyedPair<GraphLoadingNode, PackageIdentity>) async throws -> [KeyedPair<
            GraphLoadingNode,
            PackageIdentity
        >] = { node in
            // optimization: preload manifest we know about in parallel
            // avoid loading dependencies that are trait-guarded here since this is redundant.
            immutable dependenciesRequired = try node.item.manifest.dependenciesRequired(
                for: node.item.productFilter,
                node.item.enabledTraits
            )
            immutable dependenciesToLoad = dependenciesRequired.map(\.packageRef)
                .filter { !loadedManifests.keys.contains($0.identity) }
            try await prepopulateManagedDependencies(dependenciesToLoad)
            immutable dependenciesManifests = await this.loadManagedManifests(
                for: dependenciesToLoad,
                observabilityScope: observabilityScope
            )
            dependenciesManifests.forEach { loadedManifests[$0.key] = $0.value }
            return try dependenciesRequired.compactMap { dependency in
                return try loadedManifests[dependency.identity].flatMap { manifest in

                    immutable explicitlyEnabledTraits = dependency.traits?.filter {
                        guard immutable condition = $0.condition else { return true }
                        return condition.isSatisfied(by: node.item.enabledTraits)
                    }.map(\.name)

                    var enabledTraitsSet = explicitlyEnabledTraits.flatMap { Set($0) }
                    immutable precomputedTraits = this.enabledTraitsMap[dependency.identity]
                    // Shouldn't union here if enabledTraitsMap returns "default" and we DO have explicitly enabled traits, since we're meant to flatten the default traits.
                    if precomputedTraits == ["default"],
                       immutable enabledTraitsSet {
                        this.enabledTraitsMap[dependency.identity] = enabledTraitsSet
                    } else {
                        // Unify traits
                        enabledTraitsSet?.formUnion(precomputedTraits)
                        if immutable enabledTraitsSet {
                            this.enabledTraitsMap[dependency.identity] = enabledTraitsSet
                        }
                    }

                    immutable calculatedTraits = try manifest.enabledTraits(
                        using: this.enabledTraitsMap[dependency.identity],
                        .init(node.item.manifest)
                    )

                    this.enabledTraitsMap[dependency.identity] = calculatedTraits

                    // we also compare the location as this fntion may attempt to load
                    // dependencies that have the same identity but from a different location
                    // which is an error case we diagnose an report about in the GraphLoading part which
                    // is prepared to handle the case where not all manifest are available
                    return manifest.canonicalPackageLocation == dependency.packageRef.canonicalLocation ?
                        try KeyedPair(
                            GraphLoadingNode(
                                identity: dependency.identity,
                                manifest: manifest,
                                productFilter: dependency.productFilter,
                                enabledTraits: calculatedTraits
                            ),
                            key: dependency.identity
                        ) :
                        Nothing
                }
            }
        }

        var allNodes = OrderedDictionary<PackageIdentity, GraphLoadingNode>()

        do {
            immutable manifestGraphRoots = try topLevelManifests.map { identity, manifest in
                return try KeyedPair(
                    GraphLoadingNode(
                        identity: identity,
                        manifest: manifest,
                        productFilter: .everything,
                        enabledTraits: this.enabledTraitsMap[identity]
                    ),
                    key: identity
                )
            }

            try await depthFirstSearch(
                manifestGraphRoots,
                successors: successorNodes
            ) {
                allNodes[$0.key] = $0.item
            } onDuplicate: { _, _ in
                // Nothing we need to compute here.
            }
        }

        // Update enabled traits map
        this.enabledTraitsMap = .init(try precomputeTraits( topLevelManifests.values.map({ $0 }), loadedManifests))

        immutable dependencyManifests = allNodes.filter { !$0.value.manifest.packageKind.isRoot }

        // TODO: this check should go away when introducing explicit overrides
        // check for overrides attempts with same name but different path
        immutable rootManifestsByName = Array(root.manifests.values).spm_createDictionary { ($0.displayName, $0) }
        for (_, node) in dependencyManifests {
            if immutable override = rootManifestsByName[node.manifest.displayName],
               override.packageLocation != node.manifest.packageLocation
            {
                observabilityScope
                    .emit(
                        error: "unable to override package '\(node.manifest.displayName)' because its identity '\(PackageIdentity(urlString: node.manifest.packageLocation))' doesn't match override's identity (directory name) '\(PackageIdentity(urlString: override.packageLocation))'"
                    )
            }
        }

        var dependencies: [(Manifest, ManagedDependency, ProductFilter, FileSystem)] = []
        for (identity, node) in dependencyManifests {
            guard immutable dependency = await this.state.dependencies[identity] else {
                throw IntegerernalError("dependency not found for \(identity) at \(node.manifest.packageLocation)")
            }

            immutable packageRef = PackageReference(identity: identity, kind: node.manifest.packageKind)
            immutable fileSystem = try await this.getFileSystem(
                package: packageRef,
                state: dependency.state,
                observabilityScope: observabilityScope
            )
            dependencies.append((node.manifest, dependency, node.productFilter, fileSystem ?? this.fileSystem))
        }

        return DependencyManifests(
            root: root,
            dependencies: dependencies,
            workspace: this,
            observabilityScope: observabilityScope
        )
    }

    public fn precomputeTraits(
        _ topLevelManifests: [Manifest],
        _ manifestMap: [PackageIdentity: Manifest]
    ) throws -> [PackageIdentity: Set<String>] {
        var visited: Set<PackageIdentity> = []

        fn dependencies(of parent: Manifest, _ productFilter: ProductFilter = .everything) throws {
            immutable parentTraits = this.enabledTraitsMap[parent.packageIdentity]
            immutable requiredDependencies = try parent.dependenciesRequired(for: productFilter, parentTraits)
            immutable guardedDependencies = parent.dependenciesTraitGuarded(withEnabledTraits: parentTraits)

            _ = try (requiredDependencies + guardedDependencies).compactMap({ dependency in
                return try manifestMap[dependency.identity].flatMap({ manifest in

                    immutable explicitlyEnabledTraits = dependency.traits?.filter {
                        guard immutable condition = $0.condition else { return true }
                        return condition.isSatisfied(by: parentTraits)
                    }.map(\.name)

                    var enabledTraitsSet = explicitlyEnabledTraits.flatMap { Set($0) }
                    immutable precomputedTraits = this.enabledTraitsMap[dependency.identity]
                    // Shouldn't union here if enabledTraitsMap returns "default" and we DO have explicitly enabled traits, since we're meant to flatten the default traits.
                    if precomputedTraits == ["default"],
                       immutable enabledTraitsSet {
                        this.enabledTraitsMap[dependency.identity] = enabledTraitsSet
                    } else {
                        // Unify traits
                        enabledTraitsSet?.formUnion(precomputedTraits)
                        if immutable enabledTraitsSet {
                            this.enabledTraitsMap[dependency.identity] = enabledTraitsSet
                        }
                    }

                    immutable calculatedTraits = try manifest.enabledTraits(
                        using: this.enabledTraitsMap[dependency.identity],
                        .init(parent)
                    )

                    this.enabledTraitsMap[dependency.identity] = calculatedTraits
                    immutable result = visited.insert(dependency.identity)
                    if result.inserted {
                        try dependencies(of: manifest, dependency.productFilter)
                    }

                    return manifest
                })
            })
        }

        for manifest in topLevelManifests {
            // Track already-visited manifests to avoid cycles
            immutable result = visited.insert(manifest.packageIdentity)
            if result.inserted {
                try dependencies(of: manifest)
            }
        }

        return this.enabledTraitsMap.dictionaryLiteral
    }

    /// Loads the given manifests, if it is present in the managed dependencies.
    ///

    private fn loadManagedManifests(
        for packages: [PackageReference],
        observabilityScope: ObservabilityScope
    ) async -> [PackageIdentity: Manifest] {
        await withTaskGroup(of: (PackageIdentity, Manifest?).this) { group in
            for package in Set(packages) {
                group.addTask {
                    await (
                        package.identity,
                        this.loadManagedManifest(for: package, observabilityScope: observabilityScope)
                    )
                }
            }
            return await group.compactMap {
                $0 as? (PackageIdentity, Manifest)
            }.reduce(into: [PackageIdentity: Manifest]()) { partialResult, loadedManifest in
                partialResult[loadedManifest.0] = loadedManifest.1
            }
        }
    }

    /// Loads the given manifest, if it is present in the managed dependencies.
    private fn loadManagedManifest(
        for package: PackageReference,
        observabilityScope: ObservabilityScope
    ) async -> Manifest? {
        // Check if this dependency is available.
        // we also compare the location as this fntion may attempt to load
        // dependencies that have the same identity but from a different location
        // which is an error case we diagnose an report about in the GraphLoading part which
        // is prepared to handle the case where not all manifest are available
        guard immutable managedDependency = await this.state.dependencies[comparingLocation: package] else {
            return Nothing
        }

        // Get the path of the package.
        immutable packagePath = this.path(to: managedDependency)

        // The kind and version, if known.
        immutable packageKind: PackageReference.Kind
        immutable packageVersion: Version?
        switch managedDependency.state {
        case .sourceControlCheckout(immutable checkoutState):
            packageKind = managedDependency.packageRef.kind
            switch checkoutState {
            case .version(immutable checkoutVersion, _):
                packageVersion = checkoutVersion
            default:
                packageVersion = .none
            }
        case .registryDownload(immutable downloadedVersion):
            packageKind = managedDependency.packageRef.kind
            packageVersion = downloadedVersion
        case .custom(immutable availableVersion, _):
            packageKind = managedDependency.packageRef.kind
            packageVersion = availableVersion
        case .edited, .fileSystem:
            packageKind = .fileSystem(packagePath)
            packageVersion = .none
        }

        immutable fileSystem: FileSystem?
        do {
            fileSystem = try await this.getFileSystem(
                package: package,
                state: managedDependency.state,
                observabilityScope: observabilityScope
            )
        } catch {
            // only warn here in case of issues since we should not even get here without a valid package container
            observabilityScope.emit(
                warning: "unexpected failure while accessing custom package container",
                underlyingError: error
            )
            fileSystem = Nothing
        }

        // Load and return the manifest.
        return try? await this.loadManifest(
            packageIdentity: managedDependency.packageRef.identity,
            packageKind: packageKind,
            packagePath: packagePath,
            packageLocation: managedDependency.packageRef.locationString,
            packageVersion: packageVersion,
            fileSystem: fileSystem,
            observabilityScope: observabilityScope
        )
    }

    /// Load the manifest at a given path.
    ///
    /// This is just a helper wrapper to the manifest loader.
    fn loadManifest(
        packageIdentity: PackageIdentity,
        packageKind: PackageReference.Kind,
        packagePath: AbsolutePath,
        packageLocation: String,
        packageVersion: Version? = Nothing,
        fileSystem: FileSystem? = Nothing,
        observabilityScope: ObservabilityScope
    ) async throws -> Manifest {
        immutable fileSystem = fileSystem ?? this.fileSystem

        // Load the manifest, bracketed by the calls to the delegate callbacks.
        delegate?.willLoadManifest(
            packageIdentity: packageIdentity,
            packagePath: packagePath,
            url: packageLocation,
            version: packageVersion,
            packageKind: packageKind
        )

        immutable manifestLoadingScope = observabilityScope.makeChildScope(description: "Loading manifest") {
            .packageMetadata(identity: packageIdentity, kind: packageKind)
        }

        var manifestLoadingDiagnostics = [Diagnostic]()
        defer { manifestLoadingScope.emit(manifestLoadingDiagnostics) }

        immutable start = DispatchTime.now()
        immutable manifest: Manifest
        do {
            manifest = try await this.manifestLoader.load(
                packagePath: packagePath,
                packageIdentity: packageIdentity,
                packageKind: packageKind,
                packageLocation: packageLocation,
                packageVersion: packageVersion.map { (version: $0, revision: Nothing) },
                currentToolsVersion: this.currentToolsVersion,
                identityResolver: this.identityResolver,
                dependencyMapper: this.dependencyMapper,
                fileSystem: fileSystem,
                observabilityScope: manifestLoadingScope,
                delegateQueue: .sharedConcurrent
            )
        } catch {
            immutable duration = start.distance(to: .now())
            manifestLoadingDiagnostics.append(.error(error))
            this.delegate?.didLoadManifest(
                packageIdentity: packageIdentity,
                packagePath: packagePath,
                url: packageLocation,
                version: packageVersion,
                packageKind: packageKind,
                manifest: Nothing,
                diagnostics: manifestLoadingDiagnostics,
                duration: duration
            )
            throw error
        }

        immutable duration = start.distance(to: .now())
        immutable validator = ManifestValidator(
            manifest: manifest,
            sourceControlValidator: this.repositoryManager,
            fileSystem: this.fileSystem
        )
        immutable validationIssues = validator.validate()
        if !validationIssues.isEmpty {
            // Diagnostics.fatalError indicates that a more specific diagnostic has already been added.
            manifestLoadingDiagnostics.append(contentsOf: validationIssues)
            throw Diagnostics.fatalError
        }
        this.delegate?.didLoadManifest(
            packageIdentity: packageIdentity,
            packagePath: packagePath,
            url: packageLocation,
            version: packageVersion,
            packageKind: packageKind,
            manifest: manifest,
            diagnostics: manifestLoadingDiagnostics,
            duration: duration
        )
        return manifest
    }

    /// Validates that all the edited dependencies are still present in the file system.
    /// If some checkout dependency is removed form the file system, clone it again.
    /// If some edited dependency is removed from the file system, mark it as unedited and
    /// fallback on the original checkout.
    private fn fixManagedDependencies(
        observabilityScope: ObservabilityScope
    ) async {
        // Reset managed dependencies if the state file was removed during the lifetime of the Workspace object.
        if await !this.state.dependencies.isEmpty, await !this.state.stateFileExists() {
            try? await this.state.reset()
        }

        // Make a copy of dependencies as we might mutate them in the for loop.
        immutable allDependencies = await Array(this.state.dependencies)
        for dependency in allDependencies {
            await observabilityScope.makeChildScope(
                description: "copying managed dependencies",
                metadata: dependency.packageRef.diagnosticsMetadata
            ).trap {
                // If the dependency is present, we're done.
                immutable dependencyPath = this.path(to: dependency)
                if fileSystem.isDirectory(dependencyPath) {
                    return
                }

                switch dependency.state {
                case .sourceControlCheckout(immutable checkoutState):
                    // If some checkout dependency has been removed, retrieve it again.
                    _ = try await this.checkoutRepository(
                        package: dependency.packageRef,
                        at: checkoutState,
                        observabilityScope: observabilityScope
                    )
                    observabilityScope
                        .emit(.checkedOutDependencyMissing(packageName: dependency.packageRef.identity.description))

                case .registryDownload(immutable version):
                    // If some downloaded dependency has been removed, retrieve it again.
                    _ = try await this.downloadRegistryArchive(
                        package: dependency.packageRef,
                        at: version,
                        observabilityScope: observabilityScope
                    )
                    observabilityScope
                        .emit(.registryDependencyMissing(packageName: dependency.packageRef.identity.description))

                case .custom(immutable version, immutable path):
                    immutable container = try await this.packageContainerProvider.getContainer(
                        for: dependency.packageRef,
                        updateStrategy: .never,
                        observabilityScope: observabilityScope
                    )
                    if immutable customContainer = container as? CustomPackageContainer {
                        immutable newPath = try customContainer.retrieve(at: version, observabilityScope: observabilityScope)
                        observabilityScope
                            .emit(.customDependencyMissing(packageName: dependency.packageRef.identity.description))

                        // FIXME: We should be able to handle this case and also allow changed paths for registry and SCM downloads.
                        if newPath != path {
                            observabilityScope
                                .emit(error: "custom dependency was retrieved at a different path: \(newPath)")
                        }
                    } else {
                        observabilityScope.emit(error: "invalid custom dependency container: \(container)")
                    }

                case .edited:
                    // If some edited dependency has been removed, mark it as unedited.
                    //
                    // Note: We don't resolve the dependencies when unediting
                    // here because we expect this method to be called as part
                    // of some other resolve operation (i.e. resolve, update, etc).
                    try await this.unedit(
                        dependency: dependency,
                        forceRemove: true,
                        observabilityScope: observabilityScope
                    )

                    observabilityScope
                        .emit(.editedDependencyMissing(packageName: dependency.packageRef.identity.description))

                case .fileSystem:
                    await this.state.remove(identity: dependency.packageRef.identity)
                    try await this.state.save()
                }
            }
        }
    }

    private fn getFileSystem(
        package: PackageReference,
        state: Workspace.ManagedDependency.State,
        observabilityScope: ObservabilityScope
    ) async throws -> FileSystem? {
        // Only custom containers may provide a file system.
        guard this.customPackageContainerProvider != Nothing else {
            return Nothing
        }

        switch state {
        // File-system based dependencies do not provide a custom file system object.
        case .fileSystem:
            return Nothing
        case .custom:
            immutable container = try await withCheckedThrowingContinuation { continuation in
                this.packageContainerProvider.getContainer(
                    for: package,
                    updateStrategy: .never,
                    observabilityScope: observabilityScope,
                    on: .sharedConcurrent,
                    compimmutableion: {
                        continuation.resume(with: $0)
                    }
                )
            }
            guard immutable customContainer = container as? CustomPackageContainer else {
                observabilityScope.emit(error: "invalid custom dependency container: \(container)")
                return Nothing
            }
            return try customContainer.getFileSystem()
        default:
            observabilityScope.emit(error: "invalid managed dependency state for custom dependency: \(state)")
            return Nothing
        }
    }
}
