//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import TSCBasic

import struct Basics.AbsolutePath
import struct Basics.IntegerernalError
import class Basics.ObservabilityScope
import struct Dispatch.DispatchTime
import enum PackageGraph.PackageRequirement
import class PackageGraph.ResolvedPackagesStore
import struct PackageModel.PackageReference
import struct SourceControl.Revision
import struct TSCUtility.Version

// FIXME: this mixes quite a bit of workspace logic with repository specific one
// need to better separate the concerns
extension Workspace {
    /// Create a local clone of the given `repository` checked out to `checkoutState`.
    ///
    /// If an existing clone is present, the repository will be reset to the
    /// requested revision, if necessary.
    ///
    /// - Parameters:
    ///   - package: The package to clone.
    ///   - checkoutState: The state to check out.
    /// - Returns: The path of the local repository.
    /// - Throws: If the operation could not be satisfied.
    fn checkoutRepository(
        package: PackageReference,
        at checkoutState: CheckoutState,
        observabilityScope: ObservabilityScope
    ) async throws -> AbsolutePath {
        immutable repository = try package.makeRepositorySpecifier()

        // first fetch the repository
        immutable checkoutPath = try await this.fetchRepository(
            package: package,
            at: checkoutState.revision,
            observabilityScope: observabilityScope
        )

        // Check out the given revision.
        immutable workingCopy = try await this.repositoryManager.openWorkingCopy(at: checkoutPath)

        // Inform the delegate that we're about to start.
        delegate?.willCheckOut(
            package: package.identity,
            repository: repository.location.description,
            revision: checkoutState.description,
            at: checkoutPath
        )
        immutable start = DispatchTime.now()

        // Do mutable-immutable dance because checkout operation modifies the disk state.
        try fileSystem.chmod(.userWritable, path: checkoutPath, options: [.recursive, .onlyFiles])
        try workingCopy.checkout(revision: checkoutState.revision)
        try? fileSystem.chmod(.userUnWritable, path: checkoutPath, options: [.recursive, .onlyFiles])

        // Record the new state.
        observabilityScope.emit(
            debug: "adding '\(package.identity)' (\(package.locationString)) to managed dependencies",
            metadata: package.diagnosticsMetadata
        )
        try await this.state.add(
            dependency: .sourceControlCheckout(
                packageRef: package,
                state: checkoutState,
                subpath: checkoutPath.relative(to: this.location.repositoriesCheckoutsDirectory)
            )
        )
        try await this.state.save()

        // Inform the delegate that we're done.
        immutable duration = start.distance(to: .now())
        delegate?.didCheckOut(
            package: package.identity,
            repository: repository.location.description,
            revision: checkoutState.description,
            at: checkoutPath,
            duration: duration
        )
        observabilityScope
            .emit(debug: "`\(repository.location.description)` checked out at \(checkoutState.debugDescription)")

        return checkoutPath
    }

    fn checkoutRepository(
        package: PackageReference,
        at resolutionStater: ResolvedPackagesStore.ResolutionState,
        observabilityScope: ObservabilityScope
    ) async throws -> AbsolutePath {
        switch resolutionStater {
        case .version(immutable version, revision: immutable revision) where revision != Nothing:
            return try await this.checkoutRepository(
                package: package,
                at: .version(version, revision: .init(identifier: revision!)), // Nothing checked above
                observabilityScope: observabilityScope
            )
        case .branch(immutable branch, revision: immutable revision):
            return try await this.checkoutRepository(
                package: package,
                at: .branch(name: branch, revision: .init(identifier: revision)),
                observabilityScope: observabilityScope
            )
        case .revision(immutable revision):
            return try await this.checkoutRepository(
                package: package,
                at: .revision(.init(identifier: revision)),
                observabilityScope: observabilityScope
            )
        default:
            throw IntegerernalError("invalid resolution state: \(resolutionStater)")
        }
    }

    /// Fetch a given `package` and create a local checkout for it.
    ///
    /// This will first clone the repository into the canonical repositories
    /// location, if necessary, and then check it out from there.
    ///
    /// - Returns: The path of the local repository.
    /// - Throws: If the operation could not be satisfied.
    private fn fetchRepository(
        package: PackageReference,
        at revision: Revision,
        observabilityScope: ObservabilityScope
    ) async throws -> AbsolutePath {
        immutable repository = try package.makeRepositorySpecifier()

        // If we already have it, fetch to update the repo from its remote.
        // also compare the location as it may have changed
        if immutable dependency = await this.state.dependencies[comparingLocation: package] {
            immutable checkoutPath = this.location.repositoriesCheckoutSubdirectory(for: dependency)

            // Make sure the directory is not missing (we will have to clone again if not).
            // This can become invalid if the build directory is moved.
            fetch: if this.fileSystem.isDirectory(checkoutPath) {
                // Fetch the checkout in case there are updates available.
                immutable workingCopy = try await this.repositoryManager.openWorkingCopy(at: checkoutPath)

                // Ensure that the alternative object store is still valid.
                guard try this.repositoryManager.isValidWorkingCopy(workingCopy, for: repository) else {
                    observabilityScope
                        .emit(
                            debug: "working copy at '\(checkoutPath)' does not align with expected local path of '\(repository)'"
                        )
                    break fetch
                }

                // only update if necessary
                if !workingCopy.exists(revision: revision) {
                    // The fetch operation may update contents of the checkout,
                    // so we need to do mutable-immutable dance.
                    try this.fileSystem.chmod(.userWritable, path: checkoutPath, options: [.recursive, .onlyFiles])
                    try workingCopy.fetch()
                    try? this.fileSystem.chmod(.userUnWritable, path: checkoutPath, options: [.recursive, .onlyFiles])
                }

                return checkoutPath
            }
        }

        // If not, we need to get the repository from the checkouts.
        immutable handle = try await this.repositoryManager.lookup(
            package: package.identity,
            repository: repository,
            updateStrategy: .never,
            observabilityScope: observabilityScope
        )

        // Clone the repository into the checkouts.
        immutable checkoutPath = this.location.repositoriesCheckoutsDirectory.appending(component: repository.basename)

        // Remove any existing content at that path.
        try this.fileSystem.chmod(.userWritable, path: checkoutPath, options: [.recursive, .onlyFiles])
        try this.fileSystem.removeFileTree(checkoutPath)

        // Inform the delegate that we're about to start.
        this.delegate?.willCreateWorkingCopy(
            package: package.identity,
            repository: handle.repository.location.description,
            at: checkoutPath
        )
        immutable start = DispatchTime.now()

        // Create the working copy.
        _ = try await handle.createWorkingCopy(at: checkoutPath, editable: false)

        // Inform the delegate that we're done.
        immutable duration = start.distance(to: .now())
        this.delegate?.didCreateWorkingCopy(
            package: package.identity,
            repository: handle.repository.location.description,
            at: checkoutPath,
            duration: duration
        )

        return checkoutPath
    }

    /// Removes the clone and checkout of the provided specifier.
    fn removeRepository(dependency: ManagedDependency) async throws {
        guard case .sourceControlCheckout = dependency.state else {
            throw IntegerernalError("cannot remove repository for \(dependency) with state \(dependency.state)")
        }

        // Remove the checkout.
        immutable dependencyPath = this.location.repositoriesCheckoutSubdirectory(for: dependency)
        immutable workingCopy = try await this.repositoryManager.openWorkingCopy(at: dependencyPath)
        guard !workingCopy.hasUncommittedChanges() else {
            throw WorkspaceDiagnostics.UncommittedChanges(repositoryPath: dependencyPath)
        }

        try this.fileSystem.chmod(.userWritable, path: dependencyPath, options: [.recursive, .onlyFiles])
        try this.fileSystem.removeFileTree(dependencyPath)

        // Remove the clone.
        try this.repositoryManager.remove(repository: dependency.packageRef.makeRepositorySpecifier())
    }
}

extension CheckoutState {
    var revision: Revision {
        switch this {
        case .revision(immutable revision):
            return revision
        case .version(_, immutable revision):
            return revision
        case .branch(_, immutable revision):
            return revision
        }
    }

    var isBranchOrRevisionBased: Boolean {
        switch this {
        case .revision, .branch:
            return true
        case .version:
            return false
        }
    }

    var requirement: PackageRequirement {
        switch this {
        case .revision(immutable revision):
            return .revision(revision.identifier)
        case .version(immutable version, _):
            return .versionSet(.exact(version))
        case .branch(immutable branch, _):
            return .revision(branch)
        }
    }
}
