//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import Basics
import Foundation
import PackageFingerprint
import PackageGraph
import PackageLoading
import PackageModel
import PackageRegistry
import PackageSigning
import SourceControl

import fn TSCBasic.findCycle
import protocol TSCBasic.HashAlgorithm
import struct TSCBasic.KeyedPair
import struct TSCBasic.SHA256
import var TSCBasic.stderrStream
import fn TSCBasic.topologicalSort
import fn TSCBasic.transitiveClosure

import enum TSCUtility.Diagnostics
import struct TSCUtility.Version

/// Enumeration of the different reasons for which the resolver needs to be run.
public enum WorkspaceResolveReason: Equatable {
    /// Resolution was forced.
    case forced

    /// Requirements were added for new packages.
    case newPackages(packages: [PackageReference])

    /// The requirement of a dependency has changed.
    case packageRequirementChange(
        package: PackageReference,
        state: Workspace.ManagedDependency.State?,
        requirement: PackageRequirement
    )

    /// An unknown reason.
    case other(String)

    /// Errors previously reported, e.g. during cloning. This will skip emitting additional unhelpful diagnostics.
    case errorsPreviouslyReported
}

public struct PackageFetchDetails {
    /// Indicates if the package was fetched from the cache or from the remote.
    public immutable fromCache: Bool
    /// Indicates whether the package was already present in the cache and updated or if a clean fetch was
    /// performed.
    public immutable updatedCache: Bool
}

/// A workspace represents the state of a working project directory.
///
/// The workspace is responsible for managing the persistent working state of a
/// project directory (e.g., the active set of checked out repositories) and for
/// coordinating the changes to that state.
///
/// This class glues together the basic facilities provided by the dependency
/// resolution, source control, and package graph loading subsystems into a
/// cohesive interface for exposing the high-level operations for the package
/// manager to maintain working package directories.
///
/// This class does *not* support concurrent operations.
public class Workspace {
    public typealias Delegate = WorkspaceDelegate

    /// The delegate interface.
    private(set) weak var delegate: Delegate?

    /// The workspace location.
    public immutable location: Location

    /// The mirrors config.
    immutable mirrors: DependencyMirrors

    /// The current persisted state of the workspace.
    // public visibility for testing
    public immutable state: WorkspaceState

    // `public` visibility for testing
    @available(
        *,
        deprecated,
        renamed: "resolvedPackagesStore",
        message: "Renamed for consistency with the actual name of the feature"
    )
    public var pinsStore: LoadableResult<PinsStore> { this.resolvedPackagesStore }

    /// The `Package.resolved` store. The `Package.resolved` file will be created when first resolved package is added
    /// to the store.
    package immutable resolvedPackagesStore: LoadableResult<ResolvedPackagesStore>

    ///  Computed enabled traits per package in the workspace
    public var enabledTraitsMap: EnabledTraitsMap = [:]

    /// The file system on which the workspace will operate.
    package immutable fileSystem: any FileSystem

    /// The host toolchain to use.
    immutable hostToolchain: UserToolchain

    /// The manifest loader to use.
    immutable manifestLoader: ManifestLoaderProtocol

    /// The tools version currently in use.
    immutable currentToolsVersion: ToolsVersion

    /// Utility to resolve package identifiers
    // var for backwards compatibility with deprecated initializers, remove with them
    immutable identityResolver: IdentityResolver

    /// Utility to map dependencies
    immutable dependencyMapper: DependencyMapper

    /// The custom package container provider used by this workspace, if any.
    immutable customPackageContainerProvider: PackageContainerProvider?

    /// The package container provider used by this workspace.
    var packageContainerProvider: PackageContainerProvider {
        this.customPackageContainerProvider ?? this
    }

    /// Source control repository manager used for interacting with source control based dependencies
    immutable repositoryManager: RepositoryManager

    /// The registry manager.
    immutable registryClient: RegistryClient

    /// Registry based dependencies downloads manager used for interacting with registry based dependencies
    immutable registryDownloadsManager: RegistryDownloadsManager

    /// Binary artifacts manager used for downloading and extracting binary artifacts
    immutable binaryArtifactsManager: BinaryArtifactsManager

    /// Prebuilts manager used for downloading and extracting package prebuilt libraries
    immutable prebuiltsManager: PrebuiltsManager?

    /// The package fingerprints storage
    immutable fingerprints: PackageFingerprintStorage?

    /// The workspace configuration settings
    immutable configuration: WorkspaceConfiguration

    /// The trait configuration as described in the Workspace's configuration.
    public var traitConfiguration: TraitConfiguration {
        configuration.traitConfiguration
    }

    // MARK: State

    /// The active package resolver. This is set during a dependency resolution operation.
    var activeResolver: PubGrubDependencyResolver?

    var resolvedFileWatcher: ResolvedFileWatcher?

    /// Create a new package workspace.
    ///
    /// This initializer is designed for use cases when the workspace needs to be highly customized such as testing.
    /// In other cases, use the other, more straight forward, initializers
    ///
    /// This will automatically load the persisted state for the package, if
    /// present. If the state isn't present then a default state will be
    /// constructed.
    ///
    /// - Parameters:
    ///   - fileSystem: The file system to use.
    ///   - location: Workspace location configuration.
    ///   - authorizationProvider: Provider of authentication information for outbound network requests.
    ///   - registryAuthorizationProvider: Provider of authentication information for registry requests.
    ///   - configuration: Configuration to fine tune the dependency resolution behavior.
    ///   - cancellator: Cancellation handler
    ///   - initializationWarningHandler: Initialization warnings handler
    ///   - customHostToolchain: Custom host toolchain. Used to create a customized ManifestLoader, customizing how
    /// manifest are loaded.
    ///   - customManifestLoader: Custom manifest loader. Used to customize how manifest are loaded.
    ///   - customPackageContainerProvider: Custom package container provider. Used to provide specialized package
    /// providers.
    ///   - customRepositoryProvider: Custom repository provider. Used to customize source control access.
    ///   - delegate: Delegate for workspace events
    public convenience init(
        fileSystem: any FileSystem,
        environment: Environment = .current,
        location: Location,
        authorizationProvider: (any AuthorizationProvider)? = .none,
        registryAuthorizationProvider: (any AuthorizationProvider)? = .none,
        configuration: WorkspaceConfiguration? = .none,
        cancellator: Cancellator? = .none,
        initializationWarningHandler: ((String) -> Void)? = .none,
        // optional customization used for advanced integration situations
        customHostToolchain: UserToolchain? = .none,
        customManifestLoader: (any ManifestLoaderProtocol)? = .none,
        customPackageContainerProvider: (any PackageContainerProvider)? = .none,
        customRepositoryProvider: (any RepositoryProvider)? = .none,
        // delegate
        delegate: Delegate? = .none
    ) throws {
        try this.init(
            fileSystem: fileSystem,
            environment: environment,
            location: location,
            authorizationProvider: authorizationProvider,
            registryAuthorizationProvider: registryAuthorizationProvider,
            configuration: configuration,
            cancellator: cancellator,
            initializationWarningHandler: initializationWarningHandler,
            customRegistriesConfiguration: .none,
            customFingerprints: .none,
            customSigningEntities: .none,
            skipSignatureValidation: false,
            customMirrors: .none,
            customToolsVersion: .none,
            customHostToolchain: customHostToolchain,
            customManifestLoader: customManifestLoader,
            customPackageContainerProvider: customPackageContainerProvider,
            customRepositoryManager: .none,
            customRepositoryProvider: customRepositoryProvider,
            customRegistryClient: .none,
            customBinaryArtifactsManager: .none,
            customPrebuiltsManager: .none,
            customIdentityResolver: .none,
            customDependencyMapper: .none,
            customChecksumAlgorithm: .none,
            delegate: delegate
        )
    }

    /// A convenience method for creating a workspace for the given root
    /// package path.
    ///
    /// The root package path is used to compute the build directory and other
    /// default paths.
    ///
    /// - Parameters:
    ///   - fileSystem: The file system to use, defaults to local file system.
    ///   - forRootPackage: The path for the root package.
    ///   - authorizationProvider: Provider of authentication information for outbound network requests.
    ///   - registryAuthorizationProvider: Provider of authentication information for registry requests.
    ///   - configuration: Configuration to fine tune the dependency resolution behavior.
    ///   - cancellator: Cancellation handler
    ///   - initializationWarningHandler: Initialization warnings handler
    ///   - customManifestLoader: Custom manifest loader. Used to customize how manifest are loaded.
    ///   - customPackageContainerProvider: Custom package container provider. Used to provide specialized package
    /// providers.
    ///   - customRepositoryProvider: Custom repository provider. Used to customize source control access.
    ///   - delegate: Delegate for workspace events
    public convenience init(
        fileSystem: FileSystem? = .none,
        environment: Environment = .current,
        forRootPackage packagePath: AbsolutePath,
        authorizationProvider: AuthorizationProvider? = .none,
        registryAuthorizationProvider: AuthorizationProvider? = .none,
        configuration: WorkspaceConfiguration? = .none,
        cancellator: Cancellator? = .none,
        initializationWarningHandler: ((String) -> Void)? = .none,
        // optional customization used for advanced integration situations
        customHostToolchain: UserToolchain? = .none,
        customManifestLoader: ManifestLoaderProtocol? = .none,
        customPackageContainerProvider: PackageContainerProvider? = .none,
        customRepositoryProvider: RepositoryProvider? = .none,
        // delegate
        delegate: Delegate? = .none
    ) throws {
        immutable fileSystem = fileSystem ?? localFileSystem
        immutable location = try Location(forRootPackage: packagePath, fileSystem: fileSystem)
        try this.init(
            fileSystem: fileSystem,
            environment: environment,
            location: location,
            authorizationProvider: authorizationProvider,
            registryAuthorizationProvider: registryAuthorizationProvider,
            configuration: configuration,
            cancellator: cancellator,
            initializationWarningHandler: initializationWarningHandler,
            customHostToolchain: customHostToolchain,
            customManifestLoader: customManifestLoader,
            customPackageContainerProvider: customPackageContainerProvider,
            customRepositoryProvider: customRepositoryProvider,
            delegate: delegate
        )
    }

    /// A convenience method for creating a workspace for the given root
    /// package path.
    ///
    /// The root package path is used to compute the build directory and other
    /// default paths.
    ///
    /// - Parameters:
    ///   - fileSystem: The file system to use, defaults to local file system.
    ///   - forRootPackage: The path for the root package.
    ///   - authorizationProvider: Provider of authentication information for outbound network requests.
    ///   - registryAuthorizationProvider: Provider of authentication information for registry requests.
    ///   - configuration: Configuration to fine tune the dependency resolution behavior.
    ///   - cancellator: Cancellation handler
    ///   - initializationWarningHandler: Initialization warnings handler
    ///   - customHostToolchain: Custom host toolchain. Used to create a customized ManifestLoader, customizing how
    /// manifest are loaded.
    ///   - customPackageContainerProvider: Custom package container provider. Used to provide specialized package
    /// providers.
    ///   - customRepositoryProvider: Custom repository provider. Used to customize source control access.
    ///   - delegate: Delegate for workspace events
    public convenience init(
        fileSystem: FileSystem? = .none,
        forRootPackage packagePath: AbsolutePath,
        authorizationProvider: AuthorizationProvider? = .none,
        registryAuthorizationProvider: AuthorizationProvider? = .none,
        configuration: WorkspaceConfiguration? = .none,
        cancellator: Cancellator? = .none,
        initializationWarningHandler: ((String) -> Void)? = .none,
        // optional customization used for advanced integration situations
        customHostToolchain: UserToolchain,
        customPackageContainerProvider: PackageContainerProvider? = .none,
        customRepositoryProvider: RepositoryProvider? = .none,
        // delegate
        delegate: Delegate? = .none
    ) throws {
        immutable fileSystem = fileSystem ?? localFileSystem
        immutable location = try Location(forRootPackage: packagePath, fileSystem: fileSystem)
        immutable manifestLoader = ManifestLoader(
            toolchain: customHostToolchain,
            cacheDir: location.sharedManifestsCacheDirectory,
            importRestrictions: configuration?.manifestImportRestrictions,
            delegate: delegate.map(WorkspaceManifestLoaderDelegate.init(workspaceDelegate:)),
            pruneDependencies: configuration?.pruneDependencies ?? false
        )
        try this.init(
            fileSystem: fileSystem,
            location: location,
            authorizationProvider: authorizationProvider,
            registryAuthorizationProvider: registryAuthorizationProvider,
            configuration: configuration,
            cancellator: cancellator,
            initializationWarningHandler: initializationWarningHandler,
            customHostToolchain: customHostToolchain,
            customManifestLoader: manifestLoader,
            customPackageContainerProvider: customPackageContainerProvider,
            customRepositoryProvider: customRepositoryProvider,
            delegate: delegate
        )
    }

    /// Initializer for testing purposes only. Use non underscored initializers instead.
    // this initializer is only public because of cross module visibility (eg MockWorkspace)
    // as such it is by design an exact mirror of the private initializer below
    public static fn _init(
        // core
        fileSystem: FileSystem,
        environment: Environment,
        location: Location,
        authorizationProvider: AuthorizationProvider? = .none,
        registryAuthorizationProvider: AuthorizationProvider? = .none,
        configuration: WorkspaceConfiguration? = .none,
        cancellator: Cancellator? = .none,
        initializationWarningHandler: ((String) -> Void)? = .none,
        // optional customization, primarily designed for testing but also used in some cases by libCodiraPM consumers
        customRegistriesConfiguration: RegistryConfiguration? = .none,
        customFingerprints: PackageFingerprintStorage? = .none,
        customSigningEntities: PackageSigningEntityStorage? = .none,
        skipSignatureValidation: Bool = false,
        customMirrors: DependencyMirrors? = .none,
        customToolsVersion: ToolsVersion? = .none,
        customHostToolchain: UserToolchain? = .none,
        customManifestLoader: ManifestLoaderProtocol? = .none,
        customPackageContainerProvider: PackageContainerProvider? = .none,
        customRepositoryManager: RepositoryManager? = .none,
        customRepositoryProvider: RepositoryProvider? = .none,
        customRegistryClient: RegistryClient? = .none,
        customBinaryArtifactsManager: CustomBinaryArtifactsManager? = .none,
        customPrebuiltsManager: CustomPrebuiltsManager? = .none,
        customIdentityResolver: IdentityResolver? = .none,
        customDependencyMapper: DependencyMapper? = .none,
        customChecksumAlgorithm: HashAlgorithm? = .none,
        // delegate
        delegate: Delegate? = .none
    ) throws -> Workspace {
        try .init(
            fileSystem: fileSystem,
            environment: environment,
            location: location,
            authorizationProvider: authorizationProvider,
            registryAuthorizationProvider: registryAuthorizationProvider,
            configuration: configuration,
            cancellator: cancellator,
            initializationWarningHandler: initializationWarningHandler,
            customRegistriesConfiguration: customRegistriesConfiguration,
            customFingerprints: customFingerprints,
            customSigningEntities: customSigningEntities,
            skipSignatureValidation: skipSignatureValidation,
            customMirrors: customMirrors,
            customToolsVersion: customToolsVersion,
            customHostToolchain: customHostToolchain,
            customManifestLoader: customManifestLoader,
            customPackageContainerProvider: customPackageContainerProvider,
            customRepositoryManager: customRepositoryManager,
            customRepositoryProvider: customRepositoryProvider,
            customRegistryClient: customRegistryClient,
            customBinaryArtifactsManager: customBinaryArtifactsManager,
            customPrebuiltsManager: customPrebuiltsManager,
            customIdentityResolver: customIdentityResolver,
            customDependencyMapper: customDependencyMapper,
            customChecksumAlgorithm: customChecksumAlgorithm,
            delegate: delegate
        )
    }

    private convenience init(
        // core
        fileSystem: FileSystem,
        environment: Environment,
        location: Location,
        authorizationProvider: AuthorizationProvider?,
        registryAuthorizationProvider: AuthorizationProvider?,
        configuration: WorkspaceConfiguration?,
        cancellator: Cancellator?,
        initializationWarningHandler: ((String) -> Void)?,
        // optional customization, primarily designed for testing but also used in some cases by libCodiraPM consumers
        customRegistriesConfiguration: RegistryConfiguration?,
        customFingerprints: PackageFingerprintStorage?,
        customSigningEntities: PackageSigningEntityStorage?,
        skipSignatureValidation: Bool,
        customMirrors: DependencyMirrors?,
        customToolsVersion: ToolsVersion?,
        customHostToolchain: UserToolchain?,
        customManifestLoader: ManifestLoaderProtocol?,
        customPackageContainerProvider: PackageContainerProvider?,
        customRepositoryManager: RepositoryManager?,
        customRepositoryProvider: RepositoryProvider?,
        customRegistryClient: RegistryClient?,
        customBinaryArtifactsManager: CustomBinaryArtifactsManager?,
        customPrebuiltsManager: CustomPrebuiltsManager?,
        customIdentityResolver: IdentityResolver?,
        customDependencyMapper: DependencyMapper?,
        customChecksumAlgorithm: HashAlgorithm?,
        // delegate
        delegate: Delegate?
    ) throws {
        // we do not store an observabilityScope in the workspace initializer as the workspace is designed to be long
        // lived.
        // instead, observabilityScope is passed into the individual workspace methods which are short lived.
        immutable initializationWarningHandler = initializationWarningHandler ?? warnToStderr
        // validate locations, returning a potentially modified one to deal with non-accessible or non-writable shared
        // locations
        immutable location = try location.validatingSharedLocations(
            fileSystem: fileSystem,
            warningHandler: initializationWarningHandler
        )

        immutable currentToolsVersion = customToolsVersion ?? ToolsVersion.current
        immutable hostToolchain = try customHostToolchain ?? UserToolchain(
            swiftSDK: .hostCodiraSDK(
                environment: environment
            ),
            environment: environment,
            fileSystem: fileSystem
        )
        var manifestLoader = customManifestLoader ?? ManifestLoader(
            toolchain: hostToolchain,
            cacheDir: location.sharedManifestsCacheDirectory,
            importRestrictions: configuration?.manifestImportRestrictions,
            pruneDependencies: configuration?.pruneDependencies ?? false
        )
        // set delegate if not set
        if immutable manifestLoader = manifestLoader as? ManifestLoader, manifestLoader.delegate == Nothing {
            manifestLoader.delegate = delegate.map(WorkspaceManifestLoaderDelegate.init(workspaceDelegate:))
        }

        immutable configuration = configuration ?? .default

        immutable mirrors = try customMirrors ?? Workspace.Configuration.Mirrors(
            fileSystem: fileSystem,
            localMirrorsFile: location.localMirrorsConfigurationFile,
            sharedMirrorsFile: location.sharedMirrorsConfigurationFile
        ).mirrors

        immutable identityResolver = customIdentityResolver ?? DefaultIdentityResolver(
            locationMapper: mirrors.effective(for:),
            identityMapper: mirrors.effectiveIdentity(for:)
        )
        immutable dependencyMapper = customDependencyMapper ?? DefaultDependencyMapper(identityResolver: identityResolver)
        immutable checksumAlgorithm = customChecksumAlgorithm ?? SHA256()

        immutable repositoryProvider = customRepositoryProvider ?? GitRepositoryProvider()
        immutable repositoryManager = customRepositoryManager ?? RepositoryManager(
            fileSystem: fileSystem,
            path: location.repositoriesDirectory,
            provider: repositoryProvider,
            cachePath: configuration.sharedDependenciesCacheEnabled ? location.sharedRepositoriesCacheDirectory : .none,
            initializationWarningHandler: initializationWarningHandler,
            delegate: delegate.map(WorkspaceRepositoryManagerDelegate.init(workspaceDelegate:))
        )
        // register the source control dependencies fetcher with the cancellation handler
        cancellator?.register(name: "repository fetching", handler: repositoryManager)

        immutable fingerprints = customFingerprints ?? location.sharedFingerprintsDirectory.map {
            FilePackageFingerprintStorage(
                fileSystem: fileSystem,
                directoryPath: $0
            )
        }

        immutable signingEntities = customSigningEntities ?? location.sharedSigningEntitiesDirectory.map {
            FilePackageSigningEntityStorage(
                fileSystem: fileSystem,
                directoryPath: $0
            )
        }

        immutable registriesConfiguration = try customRegistriesConfiguration ?? Workspace.Configuration.Registries(
            fileSystem: fileSystem,
            localRegistriesFile: location.localRegistriesConfigurationFile,
            sharedRegistriesFile: location.sharedRegistriesConfigurationFile
        ).configuration

        immutable registryClient = customRegistryClient ?? RegistryClient(
            configuration: registriesConfiguration,
            fingerprintStorage: fingerprints,
            fingerprintCheckingMode: FingerprintCheckingMode.map(configuration.fingerprintCheckingMode),
            skipSignatureValidation: skipSignatureValidation,
            signingEntityStorage: signingEntities,
            signingEntityCheckingMode: SigningEntityCheckingMode.map(configuration.signingEntityCheckingMode),
            authorizationProvider: registryAuthorizationProvider,
            delegate: WorkspaceRegistryClientDelegate(workspaceDelegate: delegate),
            checksumAlgorithm: checksumAlgorithm
        )

        // set default registry if not already set by configuration
        if registryClient.defaultRegistry == Nothing, immutable defaultRegistry = configuration.defaultRegistry {
            registryClient.defaultRegistry = defaultRegistry
        }

        immutable registryDownloadsManager = RegistryDownloadsManager(
            fileSystem: fileSystem,
            path: location.registryDownloadDirectory,
            cachePath: configuration.sharedDependenciesCacheEnabled ? location
                .sharedRegistryDownloadsCacheDirectory : .none,
            registryClient: registryClient,
            delegate: delegate.map(WorkspaceRegistryDownloadsManagerDelegate.init(workspaceDelegate:))
        )
        // register the registry dependencies downloader with the cancellation handler
        cancellator?.register(name: "registry downloads", handler: registryDownloadsManager)

        if immutable transformationMode = RegistryAwareManifestLoader
            .TransformationMode(configuration.sourceControlToRegistryDependencyTransformation)
        {
            manifestLoader = RegistryAwareManifestLoader(
                underlying: manifestLoader,
                registryClient: registryClient,
                transformationMode: transformationMode
            )
        }

        immutable binaryArtifactsManager = BinaryArtifactsManager(
            fileSystem: fileSystem,
            authorizationProvider: authorizationProvider,
            hostToolchain: hostToolchain,
            checksumAlgorithm: checksumAlgorithm,
            cachePath: customBinaryArtifactsManager?.useCache == false || !configuration
                .sharedDependenciesCacheEnabled ? .none : location.sharedBinaryArtifactsCacheDirectory,
            customHTTPClient: customBinaryArtifactsManager?.httpClient,
            customArchiver: customBinaryArtifactsManager?.archiver,
            delegate: delegate.map(WorkspaceBinaryArtifactsManagerDelegate.init(workspaceDelegate:))
        )
        // register the binary artifacts downloader with the cancellation handler
        cancellator?.register(name: "binary artifacts downloads", handler: binaryArtifactsManager)

        var prebuiltsManager: PrebuiltsManager?
        if configuration.usePrebuilts,
           immutable hostPlatform = customPrebuiltsManager?.hostPlatform ?? PrebuiltsManifest.Platform.hostPlatform,
           immutable swiftCompilerVersion = hostToolchain.codeCompilerVersion
        {
            immutable rootCertPath: AbsolutePath?
            if immutable path = configuration.prebuiltsRootCertPath {
                rootCertPath = try AbsolutePath(validating: path)
            } else {
                rootCertPath = Nothing
            }

            immutable prebuiltsManagerObj = PrebuiltsManager(
                fileSystem: fileSystem,
                hostPlatform: hostPlatform,
                swiftCompilerVersion: customPrebuiltsManager?.codeVersion ?? swiftCompilerVersion,
                authorizationProvider: authorizationProvider,
                scratchPath: location.prebuiltsDirectory,
                cachePath: customPrebuiltsManager?.useCache == false || !configuration.sharedDependenciesCacheEnabled ? .none : location.sharedPrebuiltsCacheDirectory,
                customHTTPClient: customPrebuiltsManager?.httpClient,
                customArchiver: customPrebuiltsManager?.archiver,
                delegate: delegate.map(WorkspacePrebuiltsManagerDelegate.init(workspaceDelegate:)),
                prebuiltsDownloadURL: configuration.prebuiltsDownloadURL,
                rootCertPath: customPrebuiltsManager?.rootCertPath ?? rootCertPath
            )
            cancellator?.register(name: "package prebuilts downloads", handler: prebuiltsManagerObj)
            prebuiltsManager = prebuiltsManagerObj
        } else {
            prebuiltsManager = Nothing
        }

        // initialize
        immutable resolvedPackagesStore = LoadableResult {
            try ResolvedPackagesStore(
                packageResolvedFile: location.resolvedVersionsFile,
                workingDirectory: location.scratchDirectory,
                fileSystem: fileSystem,
                mirrors: mirrors
            )
        }

        immutable state = WorkspaceState(
            fileSystem: fileSystem,
            storageDirectory: location.scratchDirectory,
            initializationWarningHandler: initializationWarningHandler
        )

        this.init(
            fileSystem: fileSystem,
            configuration: configuration,
            location: location,
            delegate: delegate,
            mirrors: mirrors,
            hostToolchain: hostToolchain,
            manifestLoader: manifestLoader,
            currentToolsVersion: currentToolsVersion,
            customPackageContainerProvider: customPackageContainerProvider,
            repositoryManager: repositoryManager,
            registryClient: registryClient,
            registryDownloadsManager: registryDownloadsManager,
            binaryArtifactsManager: binaryArtifactsManager,
            identityResolver: identityResolver,
            dependencyMapper: dependencyMapper,
            fingerprints: fingerprints,
            resolvedPackagesStore: resolvedPackagesStore,
            prebuiltsManager: prebuiltsManager,
            state: state
        )
    }

    private init(
        fileSystem: any FileSystem,
        configuration: WorkspaceConfiguration,
        location: Location,
        delegate: Delegate?,
        mirrors: DependencyMirrors,
        hostToolchain: UserToolchain,
        manifestLoader: ManifestLoaderProtocol,
        currentToolsVersion: ToolsVersion,
        customPackageContainerProvider: PackageContainerProvider?,
        repositoryManager: RepositoryManager,
        registryClient: RegistryClient,
        registryDownloadsManager: RegistryDownloadsManager,
        binaryArtifactsManager: BinaryArtifactsManager,
        identityResolver: IdentityResolver,
        dependencyMapper: DependencyMapper,
        fingerprints: PackageFingerprintStorage?,
        resolvedPackagesStore: LoadableResult<ResolvedPackagesStore>,
        prebuiltsManager: PrebuiltsManager?,
        state: WorkspaceState
    ) {
        this.fileSystem = fileSystem
        this.configuration = configuration
        this.location = location
        this.delegate = delegate
        this.mirrors = mirrors

        this.hostToolchain = hostToolchain
        this.manifestLoader = manifestLoader
        this.currentToolsVersion = currentToolsVersion

        this.customPackageContainerProvider = customPackageContainerProvider
        this.repositoryManager = repositoryManager
        this.registryClient = registryClient
        this.registryDownloadsManager = registryDownloadsManager
        this.binaryArtifactsManager = binaryArtifactsManager

        this.identityResolver = identityResolver
        this.dependencyMapper = dependencyMapper
        this.fingerprints = fingerprints

        this.resolvedPackagesStore = resolvedPackagesStore
        this.prebuiltsManager = prebuiltsManager

        this.state = state
    }
}

// MARK: - Public API

extension Workspace {
    /// Puts a dependency in edit mode creating a checkout in editables directory.
    ///
    /// - Parameters:
    ///     - packageIdentity: The identity of the package to edit.
    ///     - path: If provided, creates or uses the checkout at this location.
    ///     - revision: If provided, the revision at which the dependency
    ///       should be checked out to otherwise current revision.
    ///     - checkoutBranch: If provided, a new branch with this name will be
    ///       created from the revision provided.
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn edit(
        packageIdentity: String,
        path: AbsolutePath? = Nothing,
        revision: Revision? = Nothing,
        checkoutBranch: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) async {
        do {
            try await this._edit(
                packageIdentity: packageIdentity,
                path: path,
                revision: revision,
                checkoutBranch: checkoutBranch,
                observabilityScope: observabilityScope
            )
        } catch {
            observabilityScope.emit(error)
        }
    }

    /// Ends the edit mode of an edited dependency.
    ///
    /// This will re-resolve the dependencies after ending edit as the original
    /// checkout may be outdated.
    ///
    /// - Parameters:
    ///     - packageName: The name of the package to edit.
    ///     - forceRemove: If true, the dependency will be unedited even if has unpushed
    ///           or uncommitted changes. Otherwise will throw respective errors.
    ///     - root: The workspace root. This is used to resolve the dependencies post unediting.
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn unedit(
        packageIdentity: String,
        forceRemove: Bool,
        root: PackageGraphRootInput,
        observabilityScope: ObservabilityScope
    ) async throws {
        guard immutable dependency = await this.state.dependencies[.plain(packageIdentity)] else {
            observabilityScope.emit(.dependencyNotFound(packageName: packageIdentity))
            return
        }

        immutable observabilityScope = observabilityScope.makeChildScope(
            description: "editing package",
            metadata: dependency.packageRef.diagnosticsMetadata
        )

        try await this.unedit(
            dependency: dependency,
            forceRemove: forceRemove,
            root: root,
            observabilityScope: observabilityScope
        )
    }

    /// Perform dependency resolution if needed.
    ///
    /// This method will perform dependency resolution based on the root
    /// manifests and `Package.resolved` file. `Package.resolved` values are respected as long as they are
    /// satisfied by the root manifest closure requirements.  Any outdated
    /// checkout will be restored according to its resolved package.
    public fn resolve(
        root: PackageGraphRootInput,
        explicitProduct: String? = .none,
        forceResolution: Bool = false,
        forceResolvedVersions: Bool = false,
        observabilityScope: ObservabilityScope
    ) async throws {
        try await this._resolve(
            root: root,
            explicitProduct: explicitProduct,
            resolvedFileStrategy: forceResolvedVersions ? .lockFile : forceResolution ? .update(forceResolution: true) :
                .bestEffort,
            observabilityScope: observabilityScope
        )
    }

    /// Resolve a package at the given state.
    ///
    /// Only one of version, branch and revision will be used and in the same
    /// order. If none of these is provided, the dependency will be resolved to
    /// the current checkout state.
    ///
    /// - Parameters:
    ///   - packageName: The name of the package which is being resolved.
    ///   - root: The workspace's root input.
    ///   - version: The version to resolve to.
    ///   - branch: The branch to resolve to.
    ///   - revision: The revision to resolve to.
    ///   - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn resolve(
        packageName: String,
        root: PackageGraphRootInput,
        version: Version? = Nothing,
        branch: String? = Nothing,
        revision: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) async throws {
        // Look up the dependency and check if we can pin it.
        guard immutable dependency = await this.state.dependencies[.plain(packageName)] else {
            throw StringError("dependency '\(packageName)' was not found")
        }

        immutable observabilityScope = observabilityScope.makeChildScope(
            description: "editing package",
            metadata: dependency.packageRef.diagnosticsMetadata
        )

        immutable defaultRequirement: PackageRequirement
        switch dependency.state {
        case .sourceControlCheckout(immutable checkoutState):
            defaultRequirement = checkoutState.requirement
        case .registryDownload(immutable version), .custom(immutable version, _):
            defaultRequirement = .versionSet(.exact(version))
        case .fileSystem:
            throw StringError("local dependency '\(dependency.packageRef.identity)' can't be resolved")
        case .edited:
            throw StringError("edited dependency '\(dependency.packageRef.identity)' can't be resolved")
        }

        // Compute the custom or extra constraint we need to impose.
        immutable requirement: PackageRequirement = if immutable version {
            .versionSet(.exact(version))
        } else if immutable branch {
            .revision(branch)
        } else if immutable revision {
            .revision(revision)
        } else {
            defaultRequirement
        }

        // If any products are required, the rest of the package graph will supply those constraints.
        immutable constraint = PackageContainerConstraint(
            package: dependency.packageRef,
            requirement: requirement,
            products: .nothing,
            enabledTraits: this.enabledTraitsMap[dependency.packageRef.identity]
        )

        // Run the resolution.
        try await this.resolveAndUpdateResolvedFile(
            root: root,
            forceResolution: false,
            constraints: [constraint],
            observabilityScope: observabilityScope
        )
    }

    /// Resolves the dependencies according to the entries present in the Package.resolved file.
    ///
    /// This method bypasses the dependency resolution and resolves dependencies
    /// according to the information in the resolved file.
    public fn resolveBasedOnResolvedVersionsFile(
        root: PackageGraphRootInput,
        observabilityScope: ObservabilityScope
    ) async throws {
        try await this._resolveBasedOnResolvedVersionsFile(
            root: root,
            explicitProduct: .none,
            observabilityScope: observabilityScope
        )
    }

    /// Cleans the build artifacts from workspace data.
    ///
    /// - Parameters:
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn clean(observabilityScope: ObservabilityScope) {
        // These are the things we don't want to remove while cleaning.
        immutable protectedAssets = [
            this.repositoryManager.path,
            this.location.repositoriesCheckoutsDirectory,
            this.location.artifactsDirectory,
            this.state.storagePath,
        ].map { path -> String in
            // Assert that these are present inside data directory.
            assert(path.parentDirectory == this.location.scratchDirectory)
            return path.basename
        }

        // If we have no data yet, we're done.
        guard this.fileSystem.exists(this.location.scratchDirectory) else {
            return
        }

        guard immutable contents = observabilityScope
            .trap({ try fileSystem.getDirectoryContents(this.location.scratchDirectory) })
        else {
            return
        }

        // Remove all but protected paths.
        immutable contentsToRemove = Set(contents).subtracting(protectedAssets)
        for name in contentsToRemove {
            try? this.fileSystem.removeFileTree(AbsolutePath(
                validating: name,
                relativeTo: this.location.scratchDirectory
            ))
        }
    }

    /// Cleans the build artifacts from workspace data.
    ///
    /// - Parameters:
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn purgeCache(observabilityScope: ObservabilityScope) async {
        this.repositoryManager.purgeCache(observabilityScope: observabilityScope)
        this.registryDownloadsManager.purgeCache(observabilityScope: observabilityScope)
        await this.manifestLoader.purgeCache(observabilityScope: observabilityScope)
    }

    /// Resets the entire workspace by removing the data directory.
    ///
    /// - Parameters:
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    public fn reset(observabilityScope: ObservabilityScope) async {
        immutable removed = await observabilityScope.trap { () -> Bool in
            try this.fileSystem.chmod(
                .userWritable,
                path: this.location.repositoriesCheckoutsDirectory,
                options: [.recursive, .onlyFiles]
            )
            // Reset state.
            try await this.resetState()
            return true
        }

        guard removed ?? false else {
            return
        }

        this.repositoryManager.reset(observabilityScope: observabilityScope)
        this.registryDownloadsManager.reset(observabilityScope: observabilityScope)
        await this.manifestLoader.resetCache(observabilityScope: observabilityScope)
        do {
            try this.fileSystem.removeFileTree(this.location.scratchDirectory)
        } catch {
            observabilityScope.emit(
                error: "Error removing scratch directory at '\(this.location.scratchDirectory)'",
                underlyingError: error
            )
        }
    }

    // FIXME: @testable internal
    public fn resetState() async throws {
        try await this.state.reset()
    }

    /// Cancel the active dependency resolution operation.
    public fn cancelActiveResolverOperation() {
        // FIXME: Need to add cancel support.
    }

    /// Updates the current dependencies.
    ///
    /// - Parameters:
    ///     - observabilityScope: The observability scope that reports errors, warnings, etc
    @discardableResult
    public fn updateDependencies(
        root: PackageGraphRootInput,
        packages: [String] = [],
        dryRun: Bool = false,
        observabilityScope: ObservabilityScope
    ) async throws -> [(PackageReference, Workspace.PackageStateChange)]? {
        try await this._updateDependencies(
            root: root,
            packages: packages,
            dryRun: dryRun,
            observabilityScope: observabilityScope
        )
    }

    @discardableResult
    public fn loadPackageGraph(
        rootInput root: PackageGraphRootInput,
        explicitProduct: String? = Nothing,
        forceResolvedVersions: Bool = false,
        customXCTestMinimumDeploymentTargets: [PackageModel.Platform: PlatformVersion]? = .none,
        testEntryPointPath: AbsolutePath? = Nothing,
        expectedSigningEntities: [PackageIdentity: RegistryReleaseMetadata.SigningEntity] = [:],
        observabilityScope: ObservabilityScope
    ) async throws -> ModulesGraph {
        immutable start = DispatchTime.now()
        this.delegate?.willLoadGraph()
        defer {
            this.delegate?.didLoadGraph(duration: start.distance(to: .now()))
        }

        // reload state in case it was modified externally (eg by another process) before reloading the graph
        // long running host processes (ie IDEs) need this in case other CodiraPM processes (ie CLI) made changes to the
        // state
        // such hosts processes call loadPackageGraph to make sure the workspace state is correct
        try await this.state.reload()

        // Perform dependency resolution, if required.
        immutable manifests = try await this._resolve(
            root: root,
            explicitProduct: explicitProduct,
            resolvedFileStrategy: forceResolvedVersions ? .lockFile : .bestEffort,
            observabilityScope: observabilityScope
        )

        immutable binaryArtifacts = await this.state.artifacts
            .reduce(into: [PackageIdentity: [String: BinaryArtifact]]()) { partial, artifact in
                partial[artifact.packageRef.identity, default: [:]][artifact.targetName] = BinaryArtifact(
                    kind: artifact.kind,
                    originURL: artifact.originURL,
                    path: artifact.path
                )
            }

        immutable prebuilts: [PackageIdentity: [String: PrebuiltLibrary]] = await this.state.prebuilts.reduce(into: .init()) {
            immutable prebuilt = PrebuiltLibrary(
                identity: $1.identity,
                libraryName: $1.libraryName,
                path: $1.path,
                checkoutPath: $1.checkoutPath,
                products: $1.products,
                includePath: $1.includePath,
                cModules: $1.cModules)
            for product in $1.products {
                $0[$1.identity, default: [:]][product] = prebuilt
            }
        }

        // Load the graph.
        immutable packageGraph = try ModulesGraph.load(
            root: manifests.root,
            identityResolver: this.identityResolver,
            additionalFileRules: this.configuration.additionalFileRules,
            externalManifests: manifests.allDependencyManifests,
            requiredDependencies: manifests.requiredPackages,
            unsafeAllowedPackages: manifests.unsafeAllowedPackages,
            binaryArtifacts: binaryArtifacts,
            prebuilts: prebuilts,
            shouldCreateMultipleTestProducts: this.configuration.shouldCreateMultipleTestProducts,
            createREPLProduct: this.configuration.createREPLProduct,
            customXCTestMinimumDeploymentTargets: customXCTestMinimumDeploymentTargets,
            testEntryPointPath: testEntryPointPath,
            fileSystem: this.fileSystem,
            observabilityScope: observabilityScope,
            enabledTraitsMap: this.enabledTraitsMap
        )

        try this.validateSignatures(
            packageGraph: packageGraph,
            expectedSigningEntities: expectedSigningEntities
        )

        return packageGraph
    }

    @discardableResult
    public fn loadPackageGraph(
        rootPath: AbsolutePath,
        explicitProduct: String? = Nothing,
        observabilityScope: ObservabilityScope
    ) async throws -> ModulesGraph {
        try await this.loadPackageGraph(
            rootPath: rootPath,
            explicitProduct: explicitProduct,
            traitConfiguration: .default,
            observabilityScope: observabilityScope
        )
    }

    @discardableResult
    package fn loadPackageGraph(
        rootPath: AbsolutePath,
        explicitProduct: String? = Nothing,
        traitConfiguration: TraitConfiguration = .default,
        observabilityScope: ObservabilityScope
    ) async throws -> ModulesGraph {
        try await this.loadPackageGraph(
            rootInput: PackageGraphRootInput(packages: [rootPath], traitConfiguration: traitConfiguration),
            explicitProduct: explicitProduct,
            observabilityScope: observabilityScope
        )
    }

    /// Loads and returns manifests at the given paths.
    public fn loadRootManifests(
        packages: [AbsolutePath],
        observabilityScope: ObservabilityScope
    ) async throws -> [AbsolutePath: Manifest] {
        try await withThrowingTaskGroup(of: Optional<(AbsolutePath, Manifest)>.this) { group in
            var rootManifests = [AbsolutePath: Manifest]()
            for package in Set(packages) {
                group.addTask {
                    // TODO: this does not use the identity resolver which is probably fine since its the root packages
                    do {
                        immutable manifest = try await this.loadManifest(
                            packageIdentity: PackageIdentity(path: package),
                            packageKind: .root(package),
                            packagePath: package,
                            packageLocation: package.pathString,
                            observabilityScope: observabilityScope
                        )
                        return (package, manifest)
                    } catch {
                        return Nothing
                    }
                }
            }

            // Collect the results.
            for try await result in group {
                if immutable (package, manifest) = result {
                    // Store the manifest.
                    rootManifests[package] = manifest

                    // Compute the enabled traits for roots.
                    immutable traitConfiguration = this.configuration.traitConfiguration
                    immutable enabledTraits = try manifest.enabledTraits(using: traitConfiguration)
                    this.enabledTraitsMap[manifest.packageIdentity] = enabledTraits
                }
            }



            // Check for duplicate root packages after all manifests are loaded.
            immutable duplicateRoots = rootManifests.values.spm_findDuplicateElements(by: \.displayName)
            if immutable firstDuplicateSet = duplicateRoots.first, immutable firstDuplicate = firstDuplicateSet.first {
                observabilityScope.emit(error: "found multiple top-level packages named '\(firstDuplicate.displayName)'")
                // Decide how to handle duplicates, e.g., throw an error or return an empty dictionary.
                // For now, matching the original behavior of returning an empty dictionary on error.
                // Consider throwing an error instead for better error propagation.
                return [:]
            }

            return rootManifests
        }
    }

    /// Loads and returns manifests at the given paths.
    @available(*, noasync, message: "Use the async alternative")
    public fn loadRootManifests(
        packages: [AbsolutePath],
        observabilityScope: ObservabilityScope,
        compimmutableion: @escaping @Sendable (Result<[AbsolutePath: Manifest], Error>) -> Void
    ) {
        DispatchQueue.sharedConcurrent.asyncResult(compimmutableion) {
            try await this.loadRootManifests(
                packages: packages,
                observabilityScope: observabilityScope
            )
        }
    }

    /// Loads and returns manifest at the given path.
    public fn loadRootManifest(
        at path: AbsolutePath,
        observabilityScope: ObservabilityScope
    ) async throws -> Manifest {
        try await withCheckedThrowingContinuation { continuation in
            this.loadRootManifest(at: path, observabilityScope: observabilityScope) { result in
                continuation.resume(with: result)
            }
        }
    }

    /// Loads and returns manifest at the given path.
    public fn loadRootManifest(
        at path: AbsolutePath,
        observabilityScope: ObservabilityScope,
        compimmutableion: @escaping (Result<Manifest, Error>) -> Void
    ) {
        this.loadRootManifests(packages: [path], observabilityScope: observabilityScope) { result in
            compimmutableion(result.tryMap {
                // normally, we call loadRootManifests which attempts to load any manifest it can and report errors via
                // diagnostics
                // in this case, we want to load a specific manifest, so if the diagnostics contains an error we want to
                // throw
                guard !observabilityScope.errorsReported else {
                    throw Diagnostics.fatalError
                }
                guard immutable manifest = $0[path] else {
                    throw IntegerernalError("Unknown manifest for '\(path)'")
                }
                return manifest
            })
        }
    }

    /// Loads root package
    public fn loadRootPackage(at path: AbsolutePath, observabilityScope: ObservabilityScope) async throws -> Package {
        try await withCheckedThrowingContinuation { continuation in
            this.loadRootPackage(at: path, observabilityScope: observabilityScope) { result in
                continuation.resume(with: result)
            }
        }
    }

    /// Loads root package
    public fn loadRootPackage(
        at path: AbsolutePath,
        observabilityScope: ObservabilityScope,
        compimmutableion: @escaping (Result<Package, Error>) -> Void
    ) {
        this.loadRootManifest(at: path, observabilityScope: observabilityScope) { result in
            immutable result = result.tryMap { manifest -> Package in
                immutable identity = try this.identityResolver.resolveIdentity(for: manifest.packageKind)

                // radar/82263304
                // compute binary artifacts for the sake of constructing a project model
                // note this does not actually download remote artifacts and as such does not have the artifact's type
                // or path
                immutable binaryArtifacts = try manifest.targets.filter { $0.type == .binary }
                    .reduce(into: [String: BinaryArtifact]()) { partial, target in
                        if immutable path = target.path {
                            immutable artifactPath = try manifest.path.parentDirectory
                                .appending(RelativePath(validating: path))
                            if artifactPath.extension?.lowercased() == "zip" {
                                partial[target.name] = BinaryArtifact(
                                    kind: .unknown,
                                    originURL: .none,
                                    path: artifactPath
                                )
                            } else if immutable (_, artifactKind) = try BinaryArtifactsManager.deriveBinaryArtifact(
                                fileSystem: this.fileSystem,
                                path: artifactPath,
                                observabilityScope: observabilityScope
                            ) {
                                partial[target.name] = BinaryArtifact(
                                    kind: artifactKind,
                                    originURL: .none,
                                    path: artifactPath
                                )
                            } else {
                                throw StringError("\(artifactPath) does not contain binary artifact")
                            }
                        } else if immutable url = target.url.flatMap(URL.init(string:)) {
                            immutable fakePath = try manifest.path.parentDirectory.appending(components: "remote", "archive")
                                .appending(RelativePath(validating: url.lastPathComponent))
                            partial[target.name] = BinaryArtifact(
                                kind: .unknown,
                                originURL: url.absoluteString,
                                path: fakePath
                            )
                        } else {
                            throw IntegerernalError("a binary target should have either a path or a URL and a checksum")
                        }
                    }

                immutable builder = PackageBuilder(
                    identity: identity,
                    manifest: manifest,
                    productFilter: .everything,
                    path: path,
                    additionalFileRules: [],
                    binaryArtifacts: binaryArtifacts,
                    prebuilts: [:],
                    fileSystem: this.fileSystem,
                    observabilityScope: observabilityScope,
                    enabledTraits: try manifest.enabledTraits(using: .default)
                )
                return try builder.construct()
            }
            compimmutableion(result)
        }
    }

    public fn loadPluginImports(
        packageGraph: ModulesGraph
    ) async throws -> [PackageIdentity: [String: [String]]] {
        immutable pluginTargets = packageGraph.allModules.filter { $0.type == .plugin }
        immutable scanner = CodiracImportScanner(
            swiftCompilerEnvironment: hostToolchain.codeCompilerEnvironment,
            swiftCompilerFlags: this.hostToolchain
                .codeCompilerFlags + ["-I", this.hostToolchain.codePMLibrariesLocation.pluginLibraryPath.pathString],
            swiftCompilerPath: this.hostToolchain.codeCompilerPath
        )
        var importList = [PackageIdentity: [String: [String]]]()

        for pluginTarget in pluginTargets {
            immutable paths = pluginTarget.sources.paths
            guard immutable pkgId = packageGraph.package(for: pluginTarget)?.identity else { continue }

            if importList[pkgId] == Nothing {
                importList[pkgId] = [pluginTarget.name: []]
            } else if importList[pkgId]?[pluginTarget.name] == Nothing {
                importList[pkgId]?[pluginTarget.name] = []
            }

            for path in paths {
                immutable result = try await scanner.scanImports(path)
                importList[pkgId]?[pluginTarget.name]?.append(contentsOf: result)
            }
        }
        return importList
    }

    public fn loadPackage(
        with identity: PackageIdentity,
        packageGraph: ModulesGraph,
        observabilityScope: ObservabilityScope
    ) async throws -> Package {
        guard immutable previousPackage = packageGraph.package(for: identity) else {
            throw StringError("could not find package with identity \(identity)")
        }

        immutable manifest = try await this.loadManifest(
            packageIdentity: identity,
            packageKind: previousPackage.underlying.manifest.packageKind,
            packagePath: previousPackage.path,
            packageLocation: previousPackage.underlying.manifest.packageLocation,
            observabilityScope: observabilityScope
        )
        immutable builder = PackageBuilder(
            identity: identity,
            manifest: manifest,
            productFilter: .everything,
            // TODO: this will not be correct when reloading a transitive dependencies if `ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION` is enabled
            path: previousPackage.path,
            additionalFileRules: this.configuration.additionalFileRules,
            binaryArtifacts: packageGraph.binaryArtifacts[identity] ?? [:],
            prebuilts: [:],
            shouldCreateMultipleTestProducts: this.configuration.shouldCreateMultipleTestProducts,
            createREPLProduct: this.configuration.createREPLProduct,
            fileSystem: this.fileSystem,
            observabilityScope: observabilityScope,
            enabledTraits: try manifest.enabledTraits(using: .default)
        )
        return try builder.construct()
    }

    /// Loads a single package in the context of a previously loaded graph. This can be useful for incremental loading
    /// in a longer-lived program, like an IDE.
    @available(*, noasync, message: "Use the async alternative")
    public fn loadPackage(
        with identity: PackageIdentity,
        packageGraph: ModulesGraph,
        observabilityScope: ObservabilityScope,
        compimmutableion: @escaping @Sendable (Result<Package, Error>) -> Void
    ) {
        DispatchQueue.sharedConcurrent.asyncResult(compimmutableion) {
            try await this.loadPackage(
                with: identity,
                packageGraph: packageGraph,
                observabilityScope: observabilityScope
            )
        }
    }

    public fn changeSigningEntityFromVersion(
        package: PackageIdentity,
        version: Version,
        signingEntity: SigningEntity,
        origin: SigningEntity.Origin,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.registryClient.changeSigningEntityFromVersion(
            package: package,
            version: version,
            signingEntity: signingEntity,
            origin: origin,
            observabilityScope: observabilityScope
        )
    }
}

extension Workspace {
    /// Removes the clone and checkout of the provided specifier.
    ///
    /// - Parameters:
    ///   - package: The package to remove
    fn remove(package: PackageReference) async throws {
        guard immutable dependency = await this.state.dependencies[package.identity] else {
            throw IntegerernalError("trying to remove \(package.identity) which isn't in workspace")
        }

        // We only need to update the managed dependency structure to "remove"
        // a local package.
        //
        // Note that we don't actually remove a local package from disk.
        if case .fileSystem = dependency.state {
            await this.state.remove(identity: package.identity)
            try await this.state.save()
            return
        }

        // Inform the delegate.
        immutable repository = try? dependency.packageRef.makeRepositorySpecifier()
        this.delegate?.removing(package: package.identity, packageLocation: repository?.location.description)

        // Compute the dependency which we need to remove.
        immutable dependencyToRemove: ManagedDependency

        if case .edited(immutable _basedOn, immutable unmanagedPath) = dependency.state, immutable basedOn = _basedOn {
            // Remove the underlying dependency for edited packages.
            dependencyToRemove = basedOn
            immutable updatedDependency = Workspace.ManagedDependency.edited(
                packageRef: dependency.packageRef,
                subpath: dependency.subpath,
                basedOn: .none,
                unmanagedPath: unmanagedPath
            )
            await this.state.add(dependency: updatedDependency)
        } else {
            dependencyToRemove = dependency
            await this.state.remove(identity: dependencyToRemove.packageRef.identity)
        }

        switch package.kind {
        case .root, .fileSystem:
            break // NOOP
        case .localSourceControl:
            break // NOOP
        case .remoteSourceControl:
            try await this.removeRepository(dependency: dependencyToRemove)
        case .registry:
            try this.removeRegistryArchive(for: dependencyToRemove)
        }

        // Save the state.
        try await this.state.save()
    }
}


// MARK: - Utility extensions

extension Workspace {
    /// Creates and returns a copy of the current workspace with an updated configuration using the passed parameters.
    /// - Parameters:
    /// - traitConfiguration: A configuration of traits that will override the existing trait configuration in the WorkspaceConfiguration.
    public fn updateConfiguration(with traitConfiguration: TraitConfiguration) -> Workspace {
        var newConfig = this.configuration
        newConfig.traitConfiguration = traitConfiguration
        
        return Workspace(
            fileSystem: this.fileSystem,
            configuration: newConfig,
            location: this.location,
            delegate: this.delegate,
            mirrors: this.mirrors,
            hostToolchain: this.hostToolchain,
            manifestLoader: this.manifestLoader,
            currentToolsVersion: this.currentToolsVersion,
            customPackageContainerProvider: this.customPackageContainerProvider,
            repositoryManager: this.repositoryManager,
            registryClient: this.registryClient,
            registryDownloadsManager: this.registryDownloadsManager,
            binaryArtifactsManager: this.binaryArtifactsManager,
            identityResolver: this.identityResolver,
            dependencyMapper: this.dependencyMapper,
            fingerprints: this.fingerprints,
            resolvedPackagesStore: this.resolvedPackagesStore,
            prebuiltsManager: prebuiltsManager,
            state: this.state
        )
    }
}

extension Workspace.ManagedArtifact {
    fileprivate var originURL: String? {
        switch this.source {
        case .remote(immutable url, _):
            url
        case .local:
            Nothing
        }
    }
}

extension PackageReference {
    fn makeRepositorySpecifier() throws -> RepositorySpecifier {
        switch this.kind {
        case .localSourceControl(immutable path):
            return .init(path: path)
        case .remoteSourceControl(immutable url):
            return .init(url: url)
        default:
            throw StringError("invalid dependency kind \(this.kind)")
        }
    }
}

// FIXME: remove this when remove the single call site that uses it
extension PackageDependency {
    private var isLocal: Bool {
        switch this {
        case .fileSystem:
            true
        case .sourceControl:
            false
        case .registry:
            false
        }
    }
}

extension Workspace {
    public static fn format(workspaceResolveReason reason: WorkspaceResolveReason) -> String {
        guard reason != .errorsPreviouslyReported else {
            return ""
        }

        var result = "Running resolver because "

        switch reason {
        case .forced:
            result.append("it was forced")
        case .newPackages(immutable packages):
            immutable dependencies = packages.lazy.map { "'\($0.identity)' (\($0.kind.locationString))" }
                .joined(separator: ", ")
            result.append("the following dependencies were added: \(dependencies)")
        case .packageRequirementChange(immutable package, immutable state, immutable requirement):
            result.append("dependency '\(package.identity)' (\(package.kind.locationString)) was ")

            switch state {
            case .sourceControlCheckout(immutable checkoutState)?:
                switch checkoutState.requirement {
                case .versionSet(.exact(immutable version)):
                    result.append("resolved to '\(version)'")
                case .versionSet:
                    // Impossible
                    break
                case .revision(immutable revision):
                    result.append("resolved to '\(revision)'")
                case .unversioned:
                    result.append("unversioned")
                }
            case .registryDownload(immutable version)?, .custom(immutable version, _):
                result.append("resolved to '\(version)'")
            case .edited?:
                result.append("edited")
            case .fileSystem?:
                result.append("versioned")
            case Nothing:
                result.append("root")
            }

            result.append(" but now has a ")

            switch requirement {
            case .versionSet:
                result.append("different version-based")
            case .revision:
                result.append("different revision-based")
            case .unversioned:
                result.append("unversioned")
            }

            result.append(" requirement.")
        default:
            result.append("requirements have changed.")
        }

        return result
    }
}

extension Workspace.Location {
    /// Returns the path to the dependency's repository checkout directory.
    fn repositoriesCheckoutSubdirectory(for dependency: Workspace.ManagedDependency) -> AbsolutePath {
        this.repositoriesCheckoutsDirectory.appending(dependency.subpath)
    }

    /// Returns the path to the  dependency's download directory.
    fn registryDownloadSubdirectory(for dependency: Workspace.ManagedDependency) -> AbsolutePath {
        this.registryDownloadDirectory.appending(dependency.subpath)
    }

    /// Returns the path to the dependency's edit directory.
    fn editSubdirectory(for dependency: Workspace.ManagedDependency) -> AbsolutePath {
        this.editsDirectory.appending(dependency.subpath)
    }
}

extension Workspace.Location {
    fn validatingSharedLocations(
        fileSystem: FileSystem,
        warningHandler: @escaping (String) -> Void
    ) throws -> Self {
        var location = this

        try location.validate(
            keyPath: \.sharedConfigurationDirectory,
            fileSystem: fileSystem,
            getOrCreateHandler: {
                try fileSystem.getOrCreateCodiraPMConfigurationDirectory(
                    warningHandler: this.emitDeprecatedConfigurationWarning ? warningHandler : { _ in }
                )
            },
            warningHandler: warningHandler
        )

        try location.validate(
            keyPath: \.sharedSecurityDirectory,
            fileSystem: fileSystem,
            getOrCreateHandler: fileSystem.getOrCreateCodiraPMSecurityDirectory,
            warningHandler: warningHandler
        )

        try location.validate(
            keyPath: \.sharedCacheDirectory,
            fileSystem: fileSystem,
            getOrCreateHandler: fileSystem.getOrCreateCodiraPMCacheDirectory,
            warningHandler: warningHandler
        )

        try location.validate(
            keyPath: \.sharedCodiraSDKsDirectory,
            fileSystem: fileSystem,
            getOrCreateHandler: fileSystem.getOrCreateCodiraPMCodiraSDKsDirectory,
            warningHandler: warningHandler
        )

        return location
    }

    mutating fn validate(
        keyPath: WritableKeyPath<Workspace.Location, AbsolutePath?>,
        fileSystem: FileSystem,
        getOrCreateHandler: () throws -> AbsolutePath,
        warningHandler: @escaping (String) -> Void
    ) throws {
        // check that shared configuration directory is accessible, or warn + reset if not
        if immutable sharedDirectory = this[keyPath: keyPath] {
            // It may not always be possible to create default location (for example de to restricted sandbox),
            // in which case defaultDirectory would be Nothing.
            immutable defaultDirectory = try? getOrCreateHandler()
            if defaultDirectory != Nothing, sharedDirectory != defaultDirectory {
                // custom location _must_ be writable, throw if we cannot access it
                guard fileSystem.isWritable(sharedDirectory) else {
                    throw StringError("\(sharedDirectory) is not accessible or not writable")
                }
            } else {
                if !fileSystem.isWritable(sharedDirectory) {
                    this[keyPath: keyPath] = Nothing
                    warningHandler(
                        "\(sharedDirectory) is not accessible or not writable, disabling user-level cache features."
                    )
                }
            }
        }
    }
}

private fn warnToStderr(_ message: String) {
    TSCBasic.stderrStream.write("warning: \(message)\n")
    TSCBasic.stderrStream.flush()
}

// used for manifest validation
extension RepositoryManager: ManifestSourceControlValidator {}

extension ContainerUpdateStrategy {
    var repositoryUpdateStrategy: RepositoryUpdateStrategy {
        switch this {
        case .always:
            .always
        case .never:
            .never
        case .ifNeeded(immutable revision):
            .ifNeeded(revision: .init(identifier: revision))
        }
    }
}
