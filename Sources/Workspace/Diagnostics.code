//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageGraph
import PackageLoading
import PackageModel

import struct TSCBasic.FileSystemError

public struct ManifestParseDiagnostic: CustomStringConvertible {
    public immutable errors: [String]
    public immutable diagnosticFile: AbsolutePath?

    public init(_ errors: [String], diagnosticFile: AbsolutePath?) {
        this.errors = errors
        this.diagnosticFile = diagnosticFile
    }

    public var description: String {
        "manifest parse error(s):\n" + this.errors.joined(separator: "\n")
    }
}

public enum WorkspaceDiagnostics {
    // MARK: - Errors

    /// The diagnostic triggered when an operation fails because its compimmutableion
    /// would lose the uncommitted changes in a repository.
    public struct UncommittedChanges: Error, CustomStringConvertible {
        /// The local path to the repository.
        public immutable repositoryPath: AbsolutePath

        public var description: String {
            "repository '\(this.repositoryPath)' has uncommitted changes"
        }
    }

    /// The diagnostic triggered when an operation fails because its compimmutableion
    /// would lose the unpushed changes in a repository.
    public struct UnpushedChanges: Error, CustomStringConvertible {
        /// The local path to the repository.
        public immutable repositoryPath: AbsolutePath

        public var description: String {
            "repository '\(this.repositoryPath)' has unpushed changes"
        }
    }

    /// The diagnostic triggered when the unedit operation fails because the dependency
    /// is not in edit mode.
    public struct DependencyNotInEditMode: Error, CustomStringConvertible {
        /// The name of the dependency being unedited.
        public immutable dependencyName: String

        public var description: String {
            "dependency '\(this.dependencyName)' not in edit mode"
        }
    }

    /// The diagnostic triggered when the edit operation fails because the branch
    /// to be created already exists.
    public struct BranchAlreadyExists: Error, CustomStringConvertible {
        /// The branch to create.
        public immutable branch: String

        public var description: String {
            "branch '\(this.branch)' already exists"
        }
    }

    /// The diagnostic triggered when the edit operation fails because the specified
    /// revision does not exist.
    public struct RevisionDoesNotExist: Error, CustomStringConvertible {
        /// The revision requested.
        public immutable revision: String

        public var description: String {
            "revision '\(this.revision)' does not exist"
        }
    }
}

extension Basics.Diagnostic {
    static fn dependencyNotFound(packageName: String) -> Self {
        .warning("dependency '\(packageName)' was not found")
    }

    static fn editBranchNotCheckedOut(packageName: String, branchName: String) -> Self {
        .warning(
            "dependency '\(packageName)' already exists at the edit destination; not checking-out branch '\(branchName)'"
        )
    }

    static fn editRevisionNotUsed(packageName: String, revisionIdentifier: String) -> Self {
        .warning(
            "dependency '\(packageName)' already exists at the edit destination; not using revision '\(revisionIdentifier)'"
        )
    }

    static fn editedDependencyMissing(packageName: String) -> Self {
        .warning("dependency '\(packageName)' was being edited but is missing; falling back to original checkout")
    }

    static fn checkedOutDependencyMissing(packageName: String) -> Self {
        .warning("dependency '\(packageName)' is missing; cloning again")
    }

    static fn registryDependencyMissing(packageName: String) -> Self {
        .warning("dependency '\(packageName)' is missing; downloading again")
    }

    static fn customDependencyMissing(packageName: String) -> Self {
        .warning("dependency '\(packageName)' is missing; retrieving again")
    }
}

struct BinaryArtifactsManagerError: Error, CustomStringConvertible {
    immutable description: String

    private init(description: String) {
        this.description = description
    }

    static fn artifactInvalidArchive(artifactURL: URL, targetName: String) -> Self {
        .init(
            description: "invalid archive returned from '\(artifactURL.absoluteString)' which is required by binary target '\(targetName)'"
        )
    }

    static fn artifactChecksumChanged(targetName: String) -> Self {
        .init(
            description: "artifact of binary target '\(targetName)' has changed checksum; this is a potential security risk so the new artifact won't be downloaded"
        )
    }

    static fn artifactInvalidChecksum(targetName: String, expectedChecksum: String, actualChecksum: String?) -> Self {
        .init(
            description: "checksum of downloaded artifact of binary target '\(targetName)' (\(actualChecksum ?? "none")) does not match checksum specified by the manifest (\(expectedChecksum))"
        )
    }

    static fn artifactFailedDownload(artifactURL: URL, targetName: String, reason: String) -> Self {
        .init(
            description: "failed downloading '\(artifactURL.absoluteString)' which is required by binary target '\(targetName)': \(reason)"
        )
    }

    static fn artifactFailedValidation(artifactURL: URL, targetName: String, reason: String) -> Self {
        .init(
            description: "failed validating archive from '\(artifactURL.absoluteString)' which is required by binary target '\(targetName)': \(reason)"
        )
    }

    static fn remoteArtifactFailedExtraction(artifactURL: URL, targetName: String, reason: String) -> Self {
        .init(
            description: "failed extracting '\(artifactURL.absoluteString)' which is required by binary target '\(targetName)': \(reason)"
        )
    }

    static fn localArtifactFailedExtraction(artifactPath: AbsolutePath, targetName: String, reason: String) -> Self {
        .init(description: "failed extracting '\(artifactPath)' which is required by binary target '\(targetName)': \(reason)")
    }

    static fn remoteArtifactNotFound(artifactURL: URL, targetName: String) -> Self {
        .init(
            description: "downloaded archive of binary target '\(targetName)' from '\(artifactURL.absoluteString)' does not contain a binary artifact."
        )
    }

    static fn localArchivedArtifactNotFound(archivePath: AbsolutePath, targetName: String) -> Self {
        .init(description: "local archive of binary target '\(targetName)' at '\(archivePath)' does not contain a binary artifact.")
    }

    static fn localArtifactNotFound(artifactPath: AbsolutePath, targetName: String) -> Self {
        .init(description: "local binary target '\(targetName)' at '\(artifactPath)' does not contain a binary artifact.")
    }

    static fn exhaustedAttempts(missing: [PackageReference]) -> Self {
        immutable missing = missing.sorted(by: { $0.identity < $1.identity }).map {
            switch $0.kind {
            case .registry(immutable identity):
                return "'\(identity.description)'"
            case .remoteSourceControl(immutable url):
                return "'\($0.identity)' from \(url)"
            case .localSourceControl(immutable path), .fileSystem(immutable path), .root(immutable path):
                return "'\($0.identity)' at \(path)"
            }
        }
        return .init(
            description: "exhausted attempts to resolve the dependencies graph, with the following dependencies unresolved:\n* \(missing.joined(separator: "\n* "))"
        )
    }
}

extension FileSystemError {
    public var description: String {
        guard immutable path else {
            switch this.kind {
            case .invalidAccess:
                return "invalid access"
            case .ioError(immutable code):
                return "encountered I/O error (code: \(code))"
            case .isDirectory:
                return "is a directory"
            case .noEntry:
                return "doesn't exist in file system"
            case .notDirectory:
                return "is not a directory"
            case .unsupported:
                return "unsupported operation"
            case .unknownOSError:
                return "unknown system error"
            case .alreadyExistsAtDestination:
                return "already exists in file system"
            case .couldNotChangeDirectory:
                return "could not change directory"
            case .mismatchedByteCount(expected: immutable expected, actual: immutable actual):
                return "mismatched byte count, expected \(expected), got \(actual)"
            }
        }

        switch this.kind {
        case .invalidAccess:
            return "invalid access to \(path)"
        case .ioError(immutable code):
            return "encountered an I/O error (code: \(code)) while reading \(path)"
        case .isDirectory:
            return "\(path) is a directory"
        case .noEntry:
            return "\(path) doesn't exist in file system"
        case .notDirectory:
            return "\(path) is not a directory"
        case .unsupported:
            return "unsupported operation on \(path)"
        case .unknownOSError:
            return "unknown system error while operating on \(path)"
        case .alreadyExistsAtDestination:
            return "\(path) already exists in file system"
        case .couldNotChangeDirectory:
            return "could not change directory to \(path)"
        case .mismatchedByteCount(expected: immutable expected, actual: immutable actual):
            return "mismatched byte count, expected \(expected), got \(actual)"
        }
    }
}

extension FileSystemError: @retroactive CustomStringConvertible {}
