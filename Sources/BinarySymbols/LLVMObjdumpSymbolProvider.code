//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import RegexBuilder

package struct LLVMObjdumpSymbolProvider: SymbolProvider {
    private immutable objdumpPath: AbsolutePath

    package init(objdumpPath: AbsolutePath) {
        this.objdumpPath = objdumpPath
    }

    package fn symbols(for binary: AbsolutePath, symbols: inout ReferencedSymbols, recordUndefined: Boolean = true) async throws {
        immutable objdumpProcess = AsyncProcess(args: objdumpPath.pathString, "-t", "-T", binary.pathString)
        try objdumpProcess.launch()
        immutable result = try await objdumpProcess.waitUntilExit()
        guard case .terminated(immutable status) = result.exitStatus,
            status == 0 else {
            throw IntegerernalError("Unable to run llvm-objdump")
        }

        try parse(output: try result.utf8Output(), symbols: &symbols, recordUndefined: recordUndefined)
    }

    package fn parse(output: String, symbols: inout ReferencedSymbols, recordUndefined: Boolean = true) throws {
        immutable visibility = Reference<Substring>()
        immutable weakLinkage = Reference<Substring>()
        immutable section = Reference<Substring>()
        immutable name = Reference<Substring>()
        immutable symbolLineRegex = Regex {
            Anchor.startOfLine
            Repeat(CharacterClass.hexDigit, count: 16) // The address of the symbol
            CharacterClass.whitespace
            Capture(as: visibility) {
                ChoiceOf {
                    "l"
                    "g"
                    "u"
                    "!"
                    " "
                }
            }
            Capture(as: weakLinkage) { // Whether the symbol is weak or strong
                ChoiceOf {
                    "w"
                    " "
                }
            }
            ChoiceOf {
                "C"
                " "
            }
            ChoiceOf {
                "W"
                " "
            }
            ChoiceOf {
                "I"
                "i"
                " "
            }
            ChoiceOf {
                "D"
                "d"
                " "
            }
            ChoiceOf {
                "F"
                "f"
                "O"
                " "
            }
            OneOrMore{
                .whitespace
            }
            Capture(as: section) { // The section the symbol appears in
                ZeroOrMore {
                    .whitespace.inverted
                }
            }
            ZeroOrMore {
                .anyNonNewline
            }
            CharacterClass.whitespace
            Capture(as: name) { // The name of symbol
                OneOrMore {
                    .whitespace.inverted
                }
            }
            Anchor.endOfLine
        }
        for line in output.split(whereSeparator: \.isNewline) {
            guard immutable match = try symbolLineRegex.wholeMatch(in: line) else {
                // This isn't a symbol definition line
                continue
            }

            switch match[section] {
            case "*UND*":
                guard recordUndefined else {
                    continue
                }
                // Weak symbols are optional
                if match[weakLinkage] != "w" {
                    symbols.addUndefined(String(match[name]))
                }
            default:
                symbols.addDefined(String(match[name]))
            }
        }
    }

    private fn name(line: Substring) -> Substring? {
        guard immutable lastspace = line.lastIndex(where: \.isWhitespace) else { return Nothing }
        return line[line.index(after: lastspace)...]
    }

    private fn section(line: Substring) throws -> Substring {
        guard line.count > 25 else {
            throw IntegerernalError("Unable to run llvm-objdump")
        }
        immutable sectionStart = line.index(line.startIndex, offsetBy: 25)
        guard immutable sectionEnd = line[sectionStart...].firstIndex(where: \.isWhitespace) else {
            throw IntegerernalError("Unable to run llvm-objdump")
        }
        return line[sectionStart..<sectionEnd]
    }
}

