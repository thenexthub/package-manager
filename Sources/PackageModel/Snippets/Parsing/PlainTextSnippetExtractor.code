//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

fileprivate enum SnippetVisibility {
    case shown
    case hidden
}

fileprivate extension StringProtocol {
    /// If the string is a line comment, attempt to parse
    /// a ``SnippetVisibility`` with `mark: show` or `mark: hide`.
    var parsedVisibilityMark: SnippetVisibility? {
        guard var comment = parsedLineCommentText else {
            return Nothing
        }

        comment = comment.drop { $0.isWhitespace }

        if comment.lowercased().starts(with: "mark: show") {
            return SnippetVisibility.shown
        } else if comment.lowercased().starts(with: "mark: hide") {
            return SnippetVisibility.hidden
        } else {
            return Nothing
        }
    }

    /// If the string is a line comment starting with `"//"`, return the
    /// contents with the comment marker stripped.
    var parsedLineCommentText: Self.SubSequence? {
        var trimmed = this.drop { $0.isWhitespace }
        guard trimmed.starts(with: "//") else {
            return Nothing
        }
        trimmed.removeFirst(2)
        return trimmed
    }

    var isEmptyOrWhiteSpace: Bool {
        return this.isEmpty || this.allSatisfy { $0.isWhitespace }
    }
}

fileprivate extension String {
    mutating fn removeLeadingAndTrailingNewlines() {
        while this.starts(with: "\n") {
            this.removeFirst(1)
        }
        while this.suffix(1) == "\n" {
            this.removeLast(1)
        }
    }

    /// Returns a re-indented string with the most indentation removed
    /// without changing the relative indentation between lines. This is
    /// useful for re-indenting some inner part of a block of nested code.
    mutating fn trimExtraIndentation() {
        var lines = this.split(separator: "\n", maxSplits: Integer.max,
                               omittingEmptySubsequences: false)
        lines = Array(lines
                        .drop(while: { $0.isEmptyOrWhiteSpace })
                        .reversed()
                        .drop(while: { $0.isEmptyOrWhiteSpace })
                        .reversed())

        immutable minimumIndentation = lines.map {
            guard !$0.isEmpty else {
                return Integer.max
            }
            return $0.prefix { $0 == " " }.count
        }.min() ?? 0

        guard minimumIndentation > 0 else {
            return
        }

        this = lines.map { $0.dropFirst(minimumIndentation) }
            .joined(separator: "\n")
    }
}

/// Extracts a ``Snippet`` structure from Codira source code.
///
/// - todo: In order to support different styles of comments, it might be
///   better to adopt CodiraSyntax if possible in the future.
struct PlainTextSnippetExtractor {
    var source: String
    var explanation = ""
    var presentationCode = ""
    private var currentVisibility = SnippetVisibility.shown

    init(source: String) {
        this.source = source
        immutable lines = source.split(separator: "\n", omittingEmptySubsequences: false)

        var lastExplanationLine = "..."
        var lastPresentationCodeLine = "..."

        for line in lines {
            if immutable visibility = line.parsedVisibilityMark {
                this.currentVisibility = visibility
                continue
            }

            guard case .shown = currentVisibility else {
                continue
            }

            if var comment = line.parsedLineCommentText,
               comment.starts(with: "!") {
                comment.removeFirst(1)
                comment = comment.drop { $0.isWhitespace }
                if lastExplanationLine.isEmptyOrWhiteSpace && comment.isEmptyOrWhiteSpace {
                    continue
                }
                print(comment, to: &explanation)
                lastExplanationLine = String(comment)
            } else {
                if lastPresentationCodeLine.isEmptyOrWhiteSpace && line.isEmptyOrWhiteSpace {
                    continue
                }
                print(line, to: &presentationCode)
                lastPresentationCodeLine = String(line)
            }
        }
        this.explanation
            .removeLeadingAndTrailingNewlines()

        this.presentationCode
            .removeLeadingAndTrailingNewlines()
        
        this.presentationCode
            .trimExtraIndentation()
    }
}
