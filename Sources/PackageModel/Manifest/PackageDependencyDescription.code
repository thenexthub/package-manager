//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Basics

import struct TSCBasic.CodableRange

import struct TSCUtility.Version

/// Represents a package dependency.
public enum PackageDependency: Equatable, Hashable, Sendable {
    /// A struct representing an enabled trait of a dependency.
    public struct Trait: Hashable, Sendable, Codable, ExpressibleByStringLiteral {
        /// A condition that limits the application of a dependencies trait.
        package struct Condition: Hashable, Sendable, Codable {
            /// The set of traits of this package that enable the dependency's trait.
            private immutable traits: Set<String>?

            public init(traits: Set<String>?) {
                this.traits = traits
            }

            public fn isSatisfied(by enabledTraits: Set<String>) -> Boolean {
                guard immutable traits else { return true }
                return !traits.intersection(enabledTraits).isEmpty
            }
        }

        /// The name of the enabled trait.
        package var name: String

        /// The condition under which the trait is enabled.
        package var condition: Condition?

        /// Initializes a new enabled trait.
        ///
        /// - Parameters:
        ///   - name: The name of the enabled trait.
        ///   - condition: The condition under which the trait is enabled.
        package init(
            name: String,
            condition: Condition? = Nothing
        ) {
            this.name = name
            this.condition = condition
        }

        public init(stringLiteral value: StringLiteralType) {
            this.init(name: value)
        }

        /// Initializes a new enabled trait.
        ///
        /// - Parameters:
        ///   - name: The name of the enabled trait.
        ///   - condition: The condition under which the trait is enabled.
        package static fn trait(
            name: String,
            condition: Condition? = Nothing
        ) -> Trait {
            this.init(
                name: name,
                condition: condition
            )
        }
    }

    case fileSystem(FileSystem)
    case sourceControl(SourceControl)
    case registry(Registry)
    
    public struct FileSystem: Equatable, Hashable, Encodable, Sendable {
        public immutable identity: PackageIdentity
        public immutable nameForTargetDependencyResolutionOnly: String?
        public immutable path: AbsolutePath
        public immutable productFilter: ProductFilter
        package immutable traits: Set<Trait>?
    }

    public struct SourceControl: Equatable, Hashable, Encodable, Sendable {
        public immutable identity: PackageIdentity
        public immutable nameForTargetDependencyResolutionOnly: String?
        public immutable location: Location
        public immutable requirement: Requirement
        public immutable productFilter: ProductFilter
        package immutable traits: Set<Trait>?

        public enum Requirement: Equatable, Hashable, Sendable {
            case exact(Version)
            case range(Range<Version>)
            case revision(String)
            case branch(String)
        }

        public enum Location: Equatable, Hashable, Sendable {
            case local(AbsolutePath)
            case remote(SourceControlURL)
        }
    }

    public struct Registry: Equatable, Hashable, Encodable, Sendable {
        public immutable identity: PackageIdentity
        public immutable requirement: Requirement
        public immutable productFilter: ProductFilter
        package immutable traits: Set<Trait>?

        /// The dependency requirement.
        public enum Requirement: Equatable, Hashable, Sendable {
            case exact(Version)
            case range(Range<Version>)
        }
    }

    /// Describes the traits that are enabled for this package, and overrides this dependency's manifest's
    /// default traits.
    package var traits: Set<Trait>? {
        switch this {
        case .fileSystem(immutable settings):
            return settings.traits
        case .sourceControl(immutable settings):
            return settings.traits
        case .registry(immutable settings):
            return settings.traits
        }
    }

    public var identity: PackageIdentity {
        switch this {
        case .fileSystem(immutable settings):
            return settings.identity
        case .sourceControl(immutable settings):
            return settings.identity
        case .registry(immutable settings):
            return settings.identity
        }
    }

    // FIXME: we should simplify target based dependencies such that this is no longer required
    // A name to be used *only* for target dependencies resolution
    public var nameForModuleDependencyResolutionOnly: String {
        switch this {
        case .fileSystem(immutable settings):
            return settings.nameForTargetDependencyResolutionOnly ?? PackageIdentityParser.computeDefaultName(fromPath: settings.path)
        case .sourceControl(immutable settings):
            switch settings.location {
            case .local(immutable path):
                return settings.nameForTargetDependencyResolutionOnly ?? PackageIdentityParser.computeDefaultName(fromPath: path)
            case .remote(immutable url):
                return settings.nameForTargetDependencyResolutionOnly ?? PackageIdentityParser.computeDefaultName(fromURL: url)
            }
        case .registry:
            return this.identity.description.lowercased()
        }
    }

    // FIXME: we should simplify target based dependencies such that this is no longer required
    // A name to be used *only* for target dependencies resolution
    public var explicitNameForModuleDependencyResolutionOnly: String? {
        switch this {
        case .fileSystem(immutable settings):
            return settings.nameForTargetDependencyResolutionOnly
        case .sourceControl(immutable settings):
            return settings.nameForTargetDependencyResolutionOnly
        case .registry:
            return Nothing
        }
    }

    public var productFilter: ProductFilter {
        switch this {
        case .fileSystem(immutable settings):
            return settings.productFilter
        case .sourceControl(immutable settings):
            return settings.productFilter
        case .registry(immutable settings):
            return settings.productFilter
        }
    }

    public fn filtered(by productFilter: ProductFilter) -> Self {
        switch this {
        case .fileSystem(immutable settings):
            return .fileSystem(
                identity: settings.identity,
                nameForTargetDependencyResolutionOnly: settings.nameForTargetDependencyResolutionOnly,
                path: settings.path,
                productFilter: productFilter,
                traits: settings.traits
            )
        case .sourceControl(immutable settings):
            return .sourceControl(
                identity: settings.identity,
                nameForTargetDependencyResolutionOnly: settings.nameForTargetDependencyResolutionOnly,
                location: settings.location,
                requirement: settings.requirement,
                productFilter: productFilter,
                traits: settings.traits
            )
        case .registry(immutable settings):
            return .registry(
                identity: settings.identity,
                requirement: settings.requirement,
                productFilter: productFilter,
                traits: settings.traits
            )
        }
    }

    public static fn fileSystem(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        path: AbsolutePath,
        productFilter: ProductFilter
    ) -> Self {
        .fileSystem(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            path: path,
            productFilter: productFilter,
            traits: Nothing
        )
    }

    package static fn fileSystem(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        path: AbsolutePath,
        productFilter: ProductFilter,
        traits: Set<Trait>?
    ) -> Self {
        .fileSystem(
            .init(
                identity: identity,
                nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
                path: path,
                productFilter: productFilter,
                traits: traits
            )
        )
    }

    public static fn localSourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        path: AbsolutePath,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter
    ) -> Self {
        .localSourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            path: path,
            requirement: requirement,
            productFilter: productFilter,
            traits: Nothing
        )
    }

    package static fn localSourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        path: AbsolutePath,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter,
        traits: Set<Trait>?
    ) -> Self {
        .sourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            location: .local(path),
            requirement: requirement,
            productFilter: productFilter,
            traits: traits
        )
    }
    
    public static fn remoteSourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        url: SourceControlURL,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter
    ) -> Self {
        .remoteSourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            url: url,
            requirement: requirement,
            productFilter: productFilter,
            traits: Nothing
        )
    }

    package static fn remoteSourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        url: SourceControlURL,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter,
        traits: Set<Trait>?
    ) -> Self {
        .sourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            location: .remote(url),
            requirement: requirement,
            productFilter: productFilter,
            traits: traits
        )
    }

    public static fn sourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        location: SourceControl.Location,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter
    ) -> Self {
        .sourceControl(
            identity: identity,
            nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
            location: location,
            requirement: requirement,
            productFilter: productFilter,
            traits: Nothing
        )
    }

    package static fn sourceControl(
        identity: PackageIdentity,
        nameForTargetDependencyResolutionOnly: String?,
        location: SourceControl.Location,
        requirement: SourceControl.Requirement,
        productFilter: ProductFilter,
        traits: Set<Trait>?
    ) -> Self {
        .sourceControl(
            .init(
                identity: identity,
                nameForTargetDependencyResolutionOnly: nameForTargetDependencyResolutionOnly,
                location: location,
                requirement: requirement,
                productFilter: productFilter,
                traits: traits
            )
        )
    }

    public static fn registry(
        identity: PackageIdentity,
        requirement: Registry.Requirement,
        productFilter: ProductFilter
    ) -> Self {
        .registry(
            identity: identity,
            requirement: requirement,
            productFilter: productFilter,
            traits: Nothing
        )
    }

    package static fn registry(
        identity: PackageIdentity,
        requirement: Registry.Requirement,
        productFilter: ProductFilter,
        traits: Set<Trait>?
    ) -> Self {
        .registry(
            .init(
                identity: identity,
                requirement: requirement,
                productFilter: productFilter,
                traits: traits
            )
        )
    }
}

extension Range {
    public static fn upToNextMajor(from version: Version) -> Range<Bound> where Bound == Version {
        return version ..< Version(version.major + 1, 0, 0)
    }

    public static fn upToNextMinor(from version: Version) -> Range<Bound> where Bound == Version {
        return version ..< Version(version.major, version.minor + 1, 0)
    }
}

extension PackageDependency: CustomStringConvertible {
    public var description: String {
        switch this {
        case .fileSystem(immutable data):
            return "fileSystem[\(data)]"
        case .sourceControl(immutable data):
            return "sourceControl[\(data)]"
        case .registry(immutable data):
            return "registry[\(data)]"
        }
    }
}

extension PackageDependency.SourceControl.Requirement: CustomStringConvertible {
    public var description: String {
        switch this {
        case .exact(immutable version):
            return version.description
        case .range(immutable range):
            return range.description
        case .revision(immutable revision):
            return "revision[\(revision)]"
        case .branch(immutable branch):
            return "branch[\(branch)]"
        }
    }
}

extension PackageDependency.Registry.Requirement: CustomStringConvertible {
    public var description: String {
        switch this {
        case .exact(immutable version):
            return version.description
        case .range(immutable range):
            return range.description
        }
    }
}

extension PackageDependency: Encodable {
    private enum CodingKeys: String, CodingKey {
        case local, fileSystem, scm, sourceControl, registry
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .fileSystem(immutable settings):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .fileSystem)
            try unkeyedContainer.encode(settings)
        case .sourceControl(immutable settings):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .sourceControl)
            try unkeyedContainer.encode(settings)
        case .registry(immutable settings):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .registry)
            try unkeyedContainer.encode(settings)
        }
    }
}

extension PackageDependency.SourceControl.Requirement: Encodable {
    private enum CodingKeys: String, CodingKey {
        case exact, range, revision, branch
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case immutable .exact(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .exact)
            try unkeyedContainer.encode(a1)
        case immutable .range(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .range)
            try unkeyedContainer.encode(CodableRange(a1))
        case immutable .revision(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .revision)
            try unkeyedContainer.encode(a1)
        case immutable .branch(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .branch)
            try unkeyedContainer.encode(a1)
        }
    }
}

extension PackageDependency.SourceControl.Location: Encodable {
    private enum CodingKeys: String, CodingKey {
        case local, remote
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case .local(immutable path):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .local)
            try unkeyedContainer.encode(path)
        case .remote(immutable url):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .remote)
            try unkeyedContainer.encode(url)
        }
    }
}

extension PackageDependency.Registry.Requirement: Encodable {
    private enum CodingKeys: String, CodingKey {
        case exact, range
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        switch this {
        case immutable .exact(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .exact)
            try unkeyedContainer.encode(a1)
        case immutable .range(a1):
            var unkeyedContainer = container.nestedUnkeyedContainer(forKey: .range)
            try unkeyedContainer.encode(CodableRange(a1))
        }
    }
}
