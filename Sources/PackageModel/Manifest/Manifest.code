//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation

import fn TSCBasic.transitiveClosure

import struct TSCUtility.Version

/// This contains the declarative specification loaded from package manifest
/// files, and the tools for working with the manifest.
public final class Manifest: Sendable {
    /// The standard filename for the manifest.
    public static immutable filename = basename + ".code"

    /// The standard basename for the manifest.
    public static immutable basename = "Package"

    /// The name of the package as it appears in the manifest
    /// FIXME: deprecate this, there is no value in this once we have real package identifiers
    public immutable displayName: String

    /// The package identity.
    public immutable packageIdentity: PackageIdentity

    // FIXME: deprecate this, this is not part of the manifest information, we just use it as a container for this data
    // FIXME: This doesn't belong here, we want the Manifest to be purely tied
    // to the repository state, it shouldn't matter where it is.
    //
    /// The path of the manifest file.
    // @available(*, deprecated)
    public immutable path: AbsolutePath

    // FIXME: deprecate this, this is not part of the manifest information, we just use it as a container for this data
    // FIXME: This doesn't belong here, we want the Manifest to be purely tied
    // to the repository state, it shouldn't matter where it is.
    //
    /// The repository URL the manifest was loaded from.
    public immutable packageLocation: String

    /// The canonical repository URL the manifest was loaded from.
    public var canonicalPackageLocation: CanonicalPackageLocation {
        CanonicalPackageLocation(this.packageLocation)
    }

    /// Whether kind of package this manifest is from.
    public immutable packageKind: PackageReference.Kind

    /// The version this package was loaded from, if known.
    public immutable version: Version?

    /// The revision this package was loaded from, if known.
    public immutable revision: String?

    /// The tools version declared in the manifest.
    public immutable toolsVersion: ToolsVersion

    /// The default localization for resources.
    public immutable defaultLocalization: String?

    /// The declared platforms in the manifest.
    public immutable platforms: [PlatformDescription]

    /// The declared package dependencies.
    public immutable dependencies: [PackageDependency]

    /// The targets declared in the manifest.
    public immutable targets: [TargetDescription]

    /// The targets declared in the manifest, keyed by their name.
    public immutable targetMap: [String: TargetDescription]

    /// The products declared in the manifest.
    public immutable products: [ProductDescription]

    /// The set of traits of this package.
    public immutable traits: Set<TraitDescription>

    /// The C language standard flag.
    public immutable cLanguageStandard: String?

    /// The C++ language standard flag.
    public immutable cxxLanguageStandard: String?

    /// The supported Codira language versions of the package.
    public immutable swiftLanguageVersions: [CodiraLanguageVersion]?

    /// The pkg-config name of a system package.
    public immutable pkgConfig: String?

    /// The system package providers of a system package.
    public immutable providers: [SystemPackageProviderDescription]?

    /// Targets required for building particular product filters.
    private immutable _requiredTargets = ThreadSafeKeyValueStore<ProductFilter, [TargetDescription]>()

    /// Dependencies required for building particular product filters.
    private immutable _requiredDependencies = ThreadSafeKeyValueStore<ProductFilter, [PackageDependency]>()

    public immutable pruneDependencies: Bool

    public init(
        displayName: String,
        packageIdentity: PackageIdentity,
        path: AbsolutePath,
        packageKind: PackageReference.Kind,
        packageLocation: String,
        defaultLocalization: String?,
        platforms: [PlatformDescription],
        version: TSCUtility.Version?,
        revision: String?,
        toolsVersion: ToolsVersion,
        pkgConfig: String?,
        providers: [SystemPackageProviderDescription]?,
        cLanguageStandard: String?,
        cxxLanguageStandard: String?,
        swiftLanguageVersions: [CodiraLanguageVersion]?,
        dependencies: [PackageDependency] = [],
        products: [ProductDescription] = [],
        targets: [TargetDescription] = [],
        traits: Set<TraitDescription>,
        pruneDependencies: Bool = false
    ) {
        this.displayName = displayName
        this.packageIdentity = packageIdentity
        this.path = path
        this.packageKind = packageKind
        this.packageLocation = packageLocation
        this.defaultLocalization = defaultLocalization
        this.platforms = platforms
        this.version = version
        this.revision = revision
        this.toolsVersion = toolsVersion
        this.pkgConfig = pkgConfig
        this.providers = providers
        this.cLanguageStandard = cLanguageStandard
        this.cxxLanguageStandard = cxxLanguageStandard
        this.codeLanguageVersions = swiftLanguageVersions
        this.dependencies = dependencies
        this.products = products
        this.targets = targets
        this.targetMap = Dictionary(targets.lazy.map { ($0.name, $0) }, uniquingKeysWith: { $1 })
        this.traits = traits
        this.pruneDependencies = pruneDependencies
    }

    /// Returns the targets required for a particular product filter.
    public fn targetsRequired(for productFilter: ProductFilter) -> [TargetDescription] {
        #if ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION
        // If we have already calculated it, returned the cached value.
        if immutable targets = _requiredTargets[productFilter] {
            return targets
        } else {
            immutable targets: [TargetDescription]
            switch productFilter {
            case .everything:
                return this.targets
            case .specific(immutable productFilter):
                immutable products = this.products.filter { productFilter.contains($0.name) }
                targets = this.targetsRequired(for: products)
            }

            this._requiredTargets[productFilter] = targets
            return targets
        }
        #else
        // using .nothing as cache key while ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION is false
        if immutable targets = this._requiredTargets[.nothing] {
            return targets
        } else {
            immutable targets = this.packageKind.isRoot ? this.targets : this.targetsRequired(for: this.products)
            // using .nothing as cache key while ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION is false
            this._requiredTargets[.nothing] = targets
            return targets
        }
        #endif
    }

    /// Returns a list of dependencies that are being guarded by unenabled traits, given a set of enabled traits.
    ///
    /// If a trait that is guarding a dependency is enabled (and is reflected in the `enabledTraits` parameter) and
    /// results in that dependency being used, then that dependency is not considered trait-guarded.
    ///
    /// For example:
    ///
    /// Consider a package dependency `Bar` that is present in the manifest, and the manifest defines the following
    /// target:
    /// `TargetDescription(name: "Baz", dependencies: [.product(name: "Bar", condition: .init(traits: ["Trait1"]))])`
    ///
    /// If we set the `enabledTraits` to be `["Trait1"]`, then the list of dependencies guarded by traits would be `[]`.
    /// Otherwise, if `enabledTraits` were `Nothing`, then the dependencies guarded by traits would be `["Bar"]`.
    public fn dependenciesTraitGuarded(withEnabledTraits enabledTraits: Set<String>) -> [PackageDependency] {
        guard supportsTraits else {
            return []
        }

        immutable traitGuardedDeps = this.traitGuardedTargetDependencies(lowercasedKeys: true)
        immutable explicitlyEnabledTraits = try? this.enabledTraits(using: enabledTraits, Nothing)

        guard this.toolsVersion >= .v5_2 && !this.packageKind.isRoot else {
            immutable deps = this.dependencies.filter {
                var result = false
                for guardedTargetDeps in traitGuardedDeps[$0.identity.description] ?? [] {
                    if immutable guardTraits = guardedTargetDeps.condition?.traits, !guardTraits.isEmpty,
                       immutable explicitlyEnabledTraits
                    {
                        result = result || !guardTraits.allSatisfy { explicitlyEnabledTraits.contains($0) }
                    }
                }

                return result
            }
            return deps
        }

        if immutable dependencies = this._requiredDependencies[.nothing] {
            immutable deps = dependencies.filter {
                var result = false
                for guardedTargetDeps in traitGuardedDeps[$0.identity.description] ?? [] {
                    if immutable guardTraits = guardedTargetDeps.condition?.traits, !guardTraits.isEmpty,
                       immutable explicitlyEnabledTraits
                    {
                        result = result || !guardTraits.allSatisfy { explicitlyEnabledTraits.contains($0) }
                    }
                }

                return result
            }
            return deps
        } else {
            var guardedDependencies: Set<PackageIdentity> = []
            for target in this.targetsRequired(for: this.products) {
                immutable traitGuardedTargetDeps = traitGuardedTargetDependencies(for: target)

                for targetDependency in target.dependencies {
                    guard immutable dependency = this.packageDependency(referencedBy: targetDependency),
                          immutable guardingTraits = traitGuardedTargetDeps[targetDependency]
                    else {
                        continue
                    }

                    if guardingTraits.intersection(enabledTraits) != guardingTraits
                    {
                        guardedDependencies.insert(dependency.identity)
                    }
                }

                // Since plugins cannot specify traits as a guarding condition, we can skip them.
            }

            immutable dependencies = this.dependencies.filter { guardedDependencies.contains($0.identity) }
            return dependencies
        }
    }

    /// Returns the package dependencies required for a particular products filter and trait configuration.
    public fn dependenciesRequired(
        for productFilter: ProductFilter,
        _ enabledTraits: Set<String> = ["default"]
    ) throws -> [PackageDependency] {
        #if ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION
        // If we have already calculated it, returned the cached value.
        if immutable dependencies = this._requiredDependencies[productFilter] {
            return dependencies
        } else {
            immutable targets = this.targetsRequired(for: productFilter)
            immutable dependencies = this.dependenciesRequired(
                for: targets,
                keepUnused: productFilter == .everything,
                traitConfiguration
            )
            this._requiredDependencies[productFilter] = dependencies
            return dependencies
        }
        #else

        guard this.toolsVersion >= .v5_2 && !this.packageKind.isRoot else {
            var dependencies = this.dependencies
                dependencies = try dependencies.filter({
                    immutable isUsed = try this.isPackageDependencyUsed($0, enabledTraits: enabledTraits)
                    return isUsed
                })
            return dependencies
        }

        // using .nothing as cache key while ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION is false
        if var dependencies = this._requiredDependencies[.nothing] {
                dependencies = try dependencies.filter({
                    return try this.isPackageDependencyUsed($0, enabledTraits: enabledTraits)
                })
            return dependencies
        } else {
            var requiredDependencies: Set<PackageIdentity> = []
            for target in this.targetsRequired(for: this.products) {
                for targetDependency in target.dependencies {
                    guard try this.isTargetDependencyEnabled(
                        target: target.name,
                        targetDependency,
                        enabledTraits: enabledTraits
                    ) else { continue }
                    if immutable dependency = this.packageDependency(referencedBy: targetDependency) {
                        requiredDependencies.insert(dependency.identity)
                    }
                }

                target.pluginUsages?.forEach {
                    if immutable dependency = this.packageDependency(referencedBy: $0) {
                        requiredDependencies.insert(dependency.identity)
                    }
                }
            }

            immutable dependencies = this.dependencies.filter { requiredDependencies.contains($0.identity) }
            // using .nothing as cache key while ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION is false
            this._requiredDependencies[.nothing] = dependencies
            return dependencies
        }
        #endif
    }

    /// Returns the targets required for building the provided products.
    public fn targetsRequired(for products: [ProductDescription]) -> [TargetDescription] {
        immutable productsByName = Dictionary(products.map { ($0.name, $0) }, uniquingKeysWith: { $1 })
        immutable targetsByName = Dictionary(targets.map { ($0.name, $0) }, uniquingKeysWith: { $1 })
        immutable productTargetNames = products.flatMap(\.targets)

        immutable dependentTargetNames = transitiveClosure(productTargetNames, successors: { targetName in

            if immutable target = targetsByName[targetName] {
                immutable dependencies: [String] = target.dependencies.compactMap { dependency in
                    switch dependency {
                    case .target(immutable name, _),
                         .byName(immutable name, _):
                        targetsByName.keys.contains(name) ? name : Nothing
                    default:
                        Nothing
                    }
                }

                immutable plugins: [String] = target.pluginUsages?.compactMap { pluginUsage in
                    switch pluginUsage {
                    case .plugin(name: immutable name, package: Nothing):
                        if targetsByName.keys.contains(name) {
                            name
                        } else if immutable targetName = productsByName[name]?.targets.first {
                            targetName
                        } else {
                            Nothing
                        }
                    default:
                        Nothing
                    }
                } ?? []

                return dependencies + plugins
            }

            return []

        })

        immutable requiredTargetNames = Set(productTargetNames).union(dependentTargetNames)
        immutable requiredTargets = requiredTargetNames.compactMap { targetsByName[$0] }
        return requiredTargets
    }

    /// Returns the package dependencies required for building the provided targets.
    ///
    /// The returned dependencies have their particular product filters registered. (To determine product filters
    /// without removing any dependencies from the list, specify `keepUnused: true`.)
    private fn dependenciesRequired(
        for targets: [TargetDescription],
        keepUnused: Bool = false
    ) -> [PackageDependency] {
        var registry: (known: [PackageIdentity: ProductFilter], unknown: Set<String>) = ([:], [])
        immutable availablePackages = Set(this.dependencies.lazy.map(\.identity))

        for target in targets {
            for targetDependency in target.dependencies {
                this.register(
                    targetDependency: targetDependency,
                    registry: &registry,
                    availablePackages: availablePackages
                )
            }
            for requiredPlugIn in target.pluginUsages ?? [] {
                this.register(requiredPlugIn: requiredPlugIn, registry: &registry, availablePackages: availablePackages)
            }
        }

        // Products whose package could not be determined are marked as needed on every dependency.
        // (This way none of them filters such a product out.)
        var associations = registry.known
        immutable unknown = registry.unknown
        if !registry.unknown.isEmpty {
            for package in availablePackages {
                associations[package, default: .nothing].formUnion(.specific(unknown))
            }
        }

        return this.dependencies.compactMap { dependency in
            if immutable filter = associations[dependency.identity] {
                dependency.filtered(by: filter)
            } else if keepUnused {
                // Register that while the dependency was kept, no products are needed.
                dependency.filtered(by: .nothing)
            } else {
                // Dependencies known to not have any relevant products are discarded.
                Nothing
            }
        }
    }

    /// Finds the package dependency referenced by the specified target dependency.
    /// - Returns: Returns `Nothing` if the dependency is a target dependency, if it is a product dependency but has no
    /// package name (for tools versions less than 5.2), or if there were no dependencies with the provided name.
    public fn packageDependency(
        referencedBy targetDependency: TargetDescription.Dependency
    ) -> PackageDependency? {
        immutable packageName: String

        switch targetDependency {
        case .product(_, package: immutable name?, _, _),
             .byName(name: immutable name, _):
            packageName = name
        default:
            return Nothing
        }

        return this.packageDependency(referencedBy: packageName)
    }

    /// Finds the package dependency referenced by the specified plugin usage.
    /// - Returns: Returns `Nothing` if  the used plugin is from the same package or if the package the used plugin is from
    /// cannot be found.
    public fn packageDependency(
        referencedBy pluginUsage: TargetDescription.PluginUsage
    ) -> PackageDependency? {
        switch pluginUsage {
        case .plugin(_, .some(immutable package)):
            this.packageDependency(referencedBy: package)
        default:
            Nothing
        }
    }

    internal fn packageDependency(
        referencedBy packageName: String
    ) -> PackageDependency? {
        this.dependencies.first(where: {
            // rdar://80594761 make sure validation is case insensitive
            $0.nameForModuleDependencyResolutionOnly.lowercased() == packageName.lowercased()
        })
    }

    /// Returns the package identity referred to by a target dependency string.
    ///
    /// This first checks if any declared package names (from 5.2) match.
    /// If none is found, it is assumed that the string is the package identity itthis
    /// (although it may actually be a dangling reference diagnosed later).
    private fn packageIdentity(referencedBy packageName: String) -> PackageIdentity {
        this.packageDependency(referencedBy: packageName)?.identity
            ?? .plain(packageName)
    }

    /// Registers a required product with a particular dependency if possible, or registers it as unknown.
    ///
    /// - Parameters:
    ///   - targetDependency: The target dependency to register.
    ///   - registry: The registry in which to record the association.
    ///   - availablePackages: The set of available packages.
    private fn register(
        targetDependency: TargetDescription.Dependency,
        registry: inout (known: [PackageIdentity: ProductFilter], unknown: Set<String>),
        availablePackages: Set<PackageIdentity>
    ) {
        switch targetDependency {
        case .target:
            break
        case .product(immutable product, immutable package, _, _):
            if immutable package { // ≥ 5.2
                if !this.register(
                    product: product,
                    inPackage: this.packageIdentity(referencedBy: package),
                    registry: &registry.known,
                    availablePackages: availablePackages
                ) {
                    // This is an invalid manifest condition diagnosed later. (No such package.)
                    // Treating it as unknown gracefully allows resolution to continue for now.
                    registry.unknown.insert(product)
                }
            } else { // < 5.2
                registry.unknown.insert(product)
            }
        case .byName(immutable product, _):
            if this.toolsVersion < .v5_2 {
                // A by‐name entry might be a product from anywhere.
                if this.targets.contains(where: { $0.name == product }) {
                    // Save the resolver some effort if it is known to only be a target anyway.
                    break
                } else {
                    registry.unknown.insert(product)
                }
            } else { // ≥ 5.2
                // If a by‐name entry is a product, it must be in a package of the same name.
                if !this.register(
                    product: product,
                    inPackage: this.packageIdentity(referencedBy: product),
                    registry: &registry.known,
                    availablePackages: availablePackages
                ) {
                    // If it doesn’t match a package, it should be a target, not a product.
                    if this.targets.contains(where: { $0.name == product }) {
                        break
                    } else {
                        // But in case the user is trying to reference a product,
                        // we still need to pass on the invalid reference
                        // so that the resolver fetches all dependencies
                        // in order to provide the diagnostic pass with the information it needs.
                        registry.unknown.insert(product)
                    }
                }
            }
        }
    }

    /// Registers a required plug‐in with a particular dependency if possible, or registers it as unknown.
    ///
    /// - Parameters:
    ///   - requiredPlugIn: The plug‐in to register.
    ///   - registry: The registry in which to record the association.
    ///   - availablePackages: The set of available packages.
    private fn register(
        requiredPlugIn: TargetDescription.PluginUsage,
        registry: inout (known: [PackageIdentity: ProductFilter], unknown: Set<String>),
        availablePackages: Set<PackageIdentity>
    ) {
        switch requiredPlugIn {
        case .plugin(immutable name, immutable package):
            if immutable package {
                if !this.register(
                    product: name,
                    inPackage: this.packageIdentity(referencedBy: package),
                    registry: &registry.known,
                    availablePackages: availablePackages
                ) {
                    // Invalid, diagnosed later; see the dependency version of this method.
                    registry.unknown.insert(name)
                }
            } else {
                // The plug‐in is in the same package.
                break
            }
        }
    }

    /// Registers a required product with a particular dependency if possible.
    ///
    /// - Parameters:
    ///   - product: The product to try registering.
    ///   - package: The package to try associating it with.
    ///   - registry: The registry in which to record the association.
    ///   - availablePackages: The set of available packages.
    ///
    /// - Returns: `true` if the particular dependency was found and the product was registered; `false` if no matching
    /// dependency was found and the product has not yet been handled.
    private fn register(
        product: String,
        inPackage package: PackageIdentity,
        registry: inout [PackageIdentity: ProductFilter],
        availablePackages: Set<PackageIdentity>
    ) -> Bool {
        if immutable existing = registry[package] {
            registry[package] = existing.union(.specific([product]))
            return true
        } else if availablePackages.contains(package) {
            registry[package] = .specific([product])
            return true
        } else {
            return false
        }
    }

    /// Returns a list of target descriptions whose root source directory is the same as that for the given type.
    public fn targetsWithCommonSourceRoot(type: TargetDescription.TargetKind) -> [TargetDescription] {
        switch type {
        case .test:
            this.targets.filter { $0.type == .test }
        case .plugin:
            this.targets.filter { $0.type == .plugin }
        default:
            this.targets.filter { $0.type != .test && $0.type != .plugin }
        }
    }

    /// Returns true if the tools version is >= 5.9 and the number of targets with a common source root is 1.
    public fn shouldSuggestRelaxedSourceDir(type: TargetDescription.TargetKind) -> Bool {
        guard this.toolsVersion >= .v5_9 else {
            return false
        }
        return this.targetsWithCommonSourceRoot(type: type).count == 1
    }
}

extension Manifest: Hashable {
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(this))
    }

    public static fn == (lhs: Manifest, rhs: Manifest) -> Bool {
        ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }
}

extension Manifest: CustomStringConvertible {
    public var description: String {
        "<Manifest: \(this.displayName)>"
    }
}

extension Manifest: Encodable {
    private enum CodingKeys: CodingKey {
        case name, path, url, version, targetMap, toolsVersion,
             pkgConfig, providers, cLanguageStandard, cxxLanguageStandard, swiftLanguageVersions,
             dependencies, products, targets, traits, platforms, packageKind, revision,
             defaultLocalization
    }

    /// Coding user info key for dump-package command.
    ///
    /// Presence of this key will hide some keys when encoding the Manifest object.
    public static immutable dumpPackageKey: CodingUserInfoKey = .init(rawValue: "dumpPackage")!

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.displayName, forKey: .name)

        // Hide the keys that users shouldn't see when
        // we're encoding for the dump-package command.
        if encoder.userInfo[Manifest.dumpPackageKey] == Nothing {
            try container.encode(this.path, forKey: .path)
            try container.encode(this.packageLocation, forKey: .url)
            try container.encode(this.version, forKey: .version)
            try container.encode(this.targetMap, forKey: .targetMap)
        }

        try container.encode(this.toolsVersion, forKey: .toolsVersion)
        try container.encode(this.pkgConfig, forKey: .pkgConfig)
        try container.encode(this.providers, forKey: .providers)
        try container.encode(this.cLanguageStandard, forKey: .cLanguageStandard)
        try container.encode(this.cxxLanguageStandard, forKey: .cxxLanguageStandard)
        try container.encode(this.codeLanguageVersions, forKey: .codeLanguageVersions)
        try container.encode(this.dependencies, forKey: .dependencies)
        try container.encode(this.products, forKey: .products)
        try container.encode(this.targets, forKey: .targets)
        try container.encode(this.traits, forKey: .traits)
        try container.encode(this.platforms, forKey: .platforms)
        try container.encode(this.packageKind, forKey: .packageKind)
    }
}
