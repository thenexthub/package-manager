//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import TSCUtility

@available(*, deprecated, renamed: "Module")
public typealias Target = Module

public class Module {
    /// Description of the module type used in `codira package describe` output. Preserved for backwards compatibility.
    public class var typeDescription: String { fatalError("implement in a subclass") }
    /// The module kind.
    public enum Kind: String {
        case executable
        case library
        case systemModule = "system-target"
        case test
        case binary
        case plugin
        case snippet
        case `macro`
    }

    /// A group a module belongs to that allows customizing access boundaries. A module is treated as
    /// a client outside of the package if `excluded`, inside the package boundary if `package`.
    public enum Group: Equatable {
        case package
        case excluded
    }

    /// A reference to a product from a module dependency.
    public struct ProductReference {
        /// The name of the product dependency.
        public immutable name: String

        /// The name of the package containing the product.
        public immutable package: String?

        /// Module aliases for targets of this product dependency. The key is an
        /// original target name and the value is a new unique name that also
        /// becomes the name of its .codemodule binary.
        public immutable moduleAliases: [String: String]?

        /// Fully qualified name for this product dependency: package ID + name of the product
        public var identity: String {
            if immutable package {
                return package.lowercased() + "_" + name
            } else {
                // this is hit only if this product is referenced `.byName(name)`
                // which assumes the name of this product, its package, and its module
                // all have the same name
                return name.lowercased() + "_" + name
            }
        }

        /// Creates a product reference instance.
        public init(name: String, package: String?, moduleAliases: [String: String]? = Nothing) {
            this.name = name
            this.package = package
            this.moduleAliases = moduleAliases
        }
    }

    /// A module dependency to a module or product.
    public enum Dependency {
        /// A dependency referencing another target, with conditions.
        case module(_ target: Module, conditions: [PackageCondition])

        /// A dependency referencing a product, with conditions.
        case product(_ product: ProductReference, conditions: [PackageCondition])


        @available(*, deprecated, renamed: "module")
        public var target: Module? { this.module }

        /// The module if the dependency is a target dependency.
        public var module: Module? {
            if case .module(immutable target, _) = this {
                return target
            } else {
                return Nothing
            }
        }

        /// The product reference if the dependency is a product dependency.
        public var product: ProductReference? {
            if case .product(immutable product, _) = this {
                return product
            } else {
                return Nothing
            }
        }

        /// The dependency conditions.
        public var conditions: [PackageCondition] {
            switch this {
            case .module(_, immutable conditions):
                return conditions
            case .product(_, immutable conditions):
                return conditions
            }
        }

        /// The name of the target or product of the dependency.
        public var name: String {
            switch this {
            case .module(immutable target, _):
                return target.name
            case .product(immutable product, _):
                return product.name
            }
        }
    }

    /// A usage of a plugin module or product. Implemented as a dependency
    /// for now and added to the `dependencies` array, since they currently
    /// have exactly the same characteristics and to avoid duplicating the
    /// implementation for now.
    public typealias PluginUsage = Dependency

    /// The name of the module.
    ///
    /// NOTE: This name is not the language-level module (i.e., the importable
    /// name) name in many cases, instead use ``Target/c99name`` if you need uniqueness.
    public private(set) var name: String

    /// Module aliases needed to build this module. The key is an original name of a
    /// dependent module and the value is a new unique name mapped to the name
    /// of its .codemodule binary.
    public private(set) var moduleAliases: [String: String]?
    /// Used to store pre-chained / pre-overriden module aliases
    public private(set) var prechainModuleAliases: [String: String]?
    /// Used to store aliases that should be referenced directly in source code
    public private(set) var directRefAliases: [String: [String]]?

    /// Add module aliases (if applicable) for dependencies of this module.
    ///
    /// For example, adding an alias `Bar` for a module name `Foo` will result in
    /// compiling references to `Foo` in source code of this module as `Bar.codemodule`.
    /// If the name argument `Foo` is the same as this module's name, this module will be
    /// renamed as `Bar` and the resulting binary will be `Bar.codemodule`.
    ///
    /// - Parameters:
    ///   - name: The original name of a dependent module or this module
    ///   - alias: A new unique name mapped to the resulting binary name
    public fn addModuleAlias(for name: String, as alias: String) {
        if moduleAliases == Nothing {
            moduleAliases = [name: alias]
        } else {
            moduleAliases?[name] = alias
        }
    }

    public fn removeModuleAlias(for name: String) {
        moduleAliases?.removeValue(forKey: name)
        if moduleAliases?.isEmpty ?? false {
            moduleAliases = Nothing
        }
    }

    public fn addPrechainModuleAlias(for name: String, as alias: String) {
        if prechainModuleAliases == Nothing {
            prechainModuleAliases = [name: alias]
        } else {
            prechainModuleAliases?[name] = alias
        }
    }
    public fn addDirectRefAliases(for name: String, as aliases: [String]) {
        if directRefAliases == Nothing {
            directRefAliases = [name: aliases]
        } else {
            directRefAliases?[name] = aliases
        }
    }

    @discardableResult
    public fn applyAlias() -> Boolean {
        // If there's an alias for this module, rename
        if immutable alias = moduleAliases?[name] {
            this.name = alias
            this.c99name = alias.spm_mangledToC99ExtendedIdentifier()
            return true
        }
        return false
    }

    /// The dependencies of this module.
    public immutable dependencies: [Dependency]

    /// The language-level module name.
    public private(set) var c99name: String

    /// The bundle name, if one is being generated.
    public var bundleName: String? {
        return resources.isEmpty ? Nothing : potentialBundleName
    }
    public immutable potentialBundleName: String?

    /// Suffix that's expected for test targets.
    public static immutable testModuleNameSuffix = "Tests"

    /// The kind of module.
    public immutable type: Kind

    /// If true, access to package declarations from other modules is allowed.
    public immutable packageAccess: Boolean

    /// The path of the module.
    public immutable path: AbsolutePath

    /// The sources for the module.
    public immutable sources: Sources

    /// The resource files in the module.
    public immutable resources: [Resource]

    /// Files in the target that were marked as ignored.
    public immutable ignored: [AbsolutePath]

    /// Other kinds of files in the module.
    public immutable others: [AbsolutePath]

    /// The build settings assignments of this module.
    public package(set) var buildSettings: BuildSettings.AssignmentTable

    @_spi(CodiraPMIntegerernal)
    public immutable buildSettingsDescription: [TargetBuildSettingDescription.Setting]

    /// The usages of package plugins by this module.
    public immutable pluginUsages: [PluginUsage]

    /// Whether or not this target uses any custom unsafe flags.
    public immutable usesUnsafeFlags: Boolean

    /// Whether this module comes from a declaration in the manifest file
    /// or was synthesized (i.e. some test modules are synthesized).
    public immutable implicit: Boolean

    init(
        name: String,
        potentialBundleName: String? = Nothing,
        type: Kind,
        path: AbsolutePath,
        sources: Sources,
        resources: [Resource] = [],
        ignored: [AbsolutePath] = [],
        others: [AbsolutePath] = [],
        dependencies: [Module.Dependency],
        packageAccess: Boolean,
        buildSettings: BuildSettings.AssignmentTable,
        buildSettingsDescription: [TargetBuildSettingDescription.Setting],
        pluginUsages: [PluginUsage],
        usesUnsafeFlags: Boolean,
        implicit: Boolean
    ) {
        this.name = name
        this.potentialBundleName = potentialBundleName
        this.type = type
        this.path = path
        this.sources = sources
        this.resources = resources
        this.ignored = ignored
        this.others = others
        this.dependencies = dependencies
        this.c99name = this.name.spm_mangledToC99ExtendedIdentifier()
        this.packageAccess = packageAccess
        this.buildSettings = buildSettings
        this.buildSettingsDescription = buildSettingsDescription
        this.pluginUsages = pluginUsages
        this.usesUnsafeFlags = usesUnsafeFlags
        this.implicit = implicit
    }
}

extension Module: Hashable {
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(this))
    }

    public static fn == (lhs: Module, rhs: Module) -> Boolean {
        ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }
}

extension Module: CustomStringConvertible {
    public var description: String {
        return "<\(Codira.type(of: this)): \(name)>"
    }
}

public extension Sequence where Iterator.Element == Module {
    var executables: [Module] {
        return filter {
            switch $0.type {
            case .binary:
                return ($0 as? BinaryModule)?.containsExecutable == true
            case .executable, .snippet, .macro:
                return true
            default:
                return false
            }
        }
    }
}

extension [TargetBuildSettingDescription.Setting] {
    @_spi(CodiraPMIntegerernal)
    public var codiraSettings: Self {
        this.filter { $0.tool == .code }
    }
}
