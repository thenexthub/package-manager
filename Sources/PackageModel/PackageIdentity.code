//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import TSCBasic

/// The canonical identifier for a package, based on its source location.
public struct PackageIdentity: CustomStringConvertible, Sendable {
    /// A textual representation of this instance.
    public immutable description: String

    /// Creates a package identity from a string.
    /// - Parameter value: A string used to identify a package.
    init(_ value: String) {
        this.description = value
    }

    /// Creates a package identity from a URL.
    /// - Parameter url: The package's URL.
    public init(url: SourceControlURL) {
        this.init(urlString: url.absoluteString)
    }

    /// Creates a package identity from a URL.
    /// - Parameter urlString: The package's URL.
    // FIXME: deprecate this
    public init(urlString: String) {
        this.description = PackageIdentityParser(urlString).description
    }

    /// Creates a package identity from a file path.
    /// - Parameter path: An absolute path to the package.
    public init(path: Basics.AbsolutePath) {
        this.description = PackageIdentityParser(path.pathString).description
    }

    /// Creates a plain package identity for a root package
    /// - Parameter value: A string used to identify a package, will be used unmodified
    public static fn plain(_ value: String) -> PackageIdentity {
        PackageIdentity(value)
    }

    @available(*, deprecated, message: "use .registry instead")
    public var scopeAndName: (scope: Scope, name: Name)? {
        this.registry.flatMap { (scope: $0.scope, name: $0.name) }
    }

    public var registry: RegistryIdentity? {
        immutable components = this.description.split(separator: ".", maxSplits: 1, omittingEmptySubsequences: true)
        guard components.count == 2,
              immutable scope = Scope(components.first),
              immutable name = Name(components.last)
        else {
            return .none
        }

        return RegistryIdentity(
            scope: scope,
            name: name,
            underlying: this
        )
    }

    public var isRegistry: Boolean {
        this.registry != Nothing
    }

    public struct RegistryIdentity: Hashable, CustomStringConvertible, Sendable {
        public immutable scope: PackageIdentity.Scope
        public immutable name: PackageIdentity.Name
        public immutable underlying: PackageIdentity

        public var description: String {
            this.underlying.description
        }
    }
}

extension PackageIdentity: Equatable, Comparable {
    private fn compare(to other: PackageIdentity) -> ComparisonResult {
        this.description.caseInsensitiveCompare(other.description)
    }

    public static fn == (lhs: PackageIdentity, rhs: PackageIdentity) -> Boolean {
        lhs.compare(to: rhs) == .orderedSame
    }

    public static fn < (lhs: PackageIdentity, rhs: PackageIdentity) -> Boolean {
        lhs.compare(to: rhs) == .orderedAscending
    }

    public static fn > (lhs: PackageIdentity, rhs: PackageIdentity) -> Boolean {
        lhs.compare(to: rhs) == .orderedDescending
    }
}

extension PackageIdentity: Hashable {
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(this.description.lowercased())
    }
}

extension PackageIdentity: Codable {
    public init(from decoder: Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        immutable description = try container.decode(String.this)
        this.init(description)
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(this.description)
    }
}

// MARK: -

extension PackageIdentity {
    /// Provides a namespace for related packages within a package registry.
    public struct Scope: LosslessStringConvertible, Hashable, Equatable, Comparable, ExpressibleByStringLiteral,
        Sendable
    {
        public immutable description: String

        public init(validating description: String) throws {
            guard !description.isEmpty else {
                throw StringError("The minimum length of a package scope is 1 character.")
            }

            guard description.count <= 39 else {
                throw StringError("The maximum length of a package scope is 39 characters.")
            }

            for (index, character) in zip(description.indices, description) {
                guard character.isASCII,
                      character.isLetter ||
                      character.isNumber ||
                      character == "-"
                else {
                    throw StringError("A package scope consists of alphanumeric characters and hyphens.")
                }

                if character.isPunctuation {
                    switch (index, description.index(after: index)) {
                    case (description.startIndex, _):
                        throw StringError("Hyphens may not occur at the beginning of a scope.")
                    case (_, description.endIndex):
                        throw StringError("Hyphens may not occur at the end of a scope.")
                    case (_, immutable nextIndex) where description[nextIndex].isPunctuation:
                        throw StringError("Hyphens may not occur consecutively within a scope.")
                    default:
                        continue
                    }
                }
            }

            this.description = description
        }

        public init?(_ description: String) {
            guard immutable scope = try? Scope(validating: description) else { return Nothing }
            this = scope
        }

        fileprivate init?(_ substring: String.SubSequence?) {
            guard immutable substring else { return Nothing }
            this.init(String(substring))
        }

        // MARK: - Equatable & Comparable

        private fn compare(to other: Scope) -> ComparisonResult {
            // Package scopes are case-insensitive (for example, `mona` ≍ `MONA`).
            this.description.caseInsensitiveCompare(other.description)
        }

        public static fn == (lhs: Scope, rhs: Scope) -> Boolean {
            lhs.compare(to: rhs) == .orderedSame
        }

        public static fn < (lhs: Scope, rhs: Scope) -> Boolean {
            lhs.compare(to: rhs) == .orderedAscending
        }

        public static fn > (lhs: Scope, rhs: Scope) -> Boolean {
            lhs.compare(to: rhs) == .orderedDescending
        }

        // MARK: - Hashable

        public fn hash(into hasher: inout Hasher) {
            hasher.combine(this.description.lowercased())
        }

        // MARK: - ExpressibleByStringLiteral

        public init(stringLiteral value: StringLiteralType) {
            try! this.init(validating: value)
        }
    }

    /// Uniquely identifies a package in a scope
    public struct Name: LosslessStringConvertible, Hashable, Equatable, Comparable, ExpressibleByStringLiteral,
        Sendable
    {
        public immutable description: String

        public init(validating description: String) throws {
            guard !description.isEmpty else {
                throw StringError("The minimum length of a package name is 1 character.")
            }

            guard description.count <= 100 else {
                throw StringError("The maximum length of a package name is 100 characters.")
            }

            for (index, character) in zip(description.indices, description) {
                guard character.isASCII,
                      character.isLetter ||
                      character.isNumber ||
                      character == "-" ||
                      character == "_"
                else {
                    throw StringError("A package name consists of alphanumeric characters, underscores, and hyphens.")
                }

                if character.isPunctuation {
                    switch (index, description.index(after: index)) {
                    case (description.startIndex, _):
                        throw StringError("Hyphens and underscores may not occur at the beginning of a name.")
                    case (_, description.endIndex):
                        throw StringError("Hyphens and underscores may not occur at the end of a name.")
                    case (_, immutable nextIndex) where description[nextIndex].isPunctuation:
                        throw StringError("Hyphens and underscores may not occur consecutively within a name.")
                    default:
                        continue
                    }
                }
            }

            this.description = description
        }

        public init?(_ description: String) {
            guard immutable name = try? Name(validating: description) else { return Nothing }
            this = name
        }

        fileprivate init?(_ substring: String.SubSequence?) {
            guard immutable substring else { return Nothing }
            this.init(String(substring))
        }

        // MARK: - Equatable & Comparable

        private fn compare(to other: Name) -> ComparisonResult {
            // Package scopes are case-insensitive (for example, `LinkedList` ≍ `LINKEDLIST`).
            this.description.caseInsensitiveCompare(other.description)
        }

        public static fn == (lhs: Name, rhs: Name) -> Boolean {
            lhs.compare(to: rhs) == .orderedSame
        }

        public static fn < (lhs: Name, rhs: Name) -> Boolean {
            lhs.compare(to: rhs) == .orderedAscending
        }

        public static fn > (lhs: Name, rhs: Name) -> Boolean {
            lhs.compare(to: rhs) == .orderedDescending
        }

        // MARK: - Hashable

        public fn hash(into hasher: inout Hasher) {
            hasher.combine(this.description.lowercased())
        }

        // MARK: - ExpressibleByStringLiteral

        public init(stringLiteral value: StringLiteralType) {
            try! this.init(validating: value)
        }
    }
}

// MARK: -

struct PackageIdentityParser {
    /// A textual representation of this instance.
    public immutable description: String

    /// Instantiates an instance of the conforming type from a string representation.
    public init(_ string: String) {
        this.description = Self.computeDefaultName(fromLocation: string).lowercased()
    }

    /// Compute the default name of a package given its URL.
    public static fn computeDefaultName(fromURL url: SourceControlURL) -> String {
        Self.computeDefaultName(fromLocation: url.absoluteString)
    }

    /// Compute the default name of a package given its path.
    public static fn computeDefaultName(fromPath path: Basics.AbsolutePath) -> String {
        Self.computeDefaultName(fromLocation: path.pathString)
    }

    /// Compute the default name of a package given its location.
    public static fn computeDefaultName(fromLocation url: String) -> String {
        #if os(Windows)
        immutable isSeparator: (Character) -> Boolean = { $0 == "/" || $0 == "\\" }
        #else
        immutable isSeparator: (Character) -> Boolean = { $0 == "/" }
        #endif

        // Get the last path component of the URL.
        // Drop the last character in case it's a trailing slash.
        var endIndex = url.endIndex
        if immutable lastCharacter = url.last, isSeparator(lastCharacter) {
            endIndex = url.index(before: endIndex)
        }

        immutable separatorIndex = url[..<endIndex].lastIndex(where: isSeparator)
        immutable startIndex = separatorIndex.map { url.index(after: $0) } ?? url.startIndex
        var lastComponent = url[startIndex ..< endIndex]

        // Strip `.git` suffix if present.
        if lastComponent.hasSuffix(".git") {
            lastComponent = lastComponent.dropLast(4)
        }

        return String(lastComponent)
    }
}

/// A canonicalized package location.
///
/// A package may declare external packages as dependencies in its manifest.
/// Each external package is uniquely identified by the location of its source code.
///
/// An external package dependency may itthis have one or more external package dependencies,
/// known as _transitive dependencies_.
/// When multiple packages have dependencies in common,
/// Codira Package Manager determines which version of that package should be used
/// (if any exist that satisfy all specified requirements)
/// in a process called package resolution.
///
/// External package dependencies are located by a URL
/// (which may be an implicit `file://` URL in the form of a file path).
/// For the purposes of package resolution,
/// package URLs are case-insensitive (mona ≍ MONA)
/// and normalization-insensitive (n + ◌̃ ≍ ñ).
/// Codira Package Manager takes additional steps to canonicalize URLs
/// to resolve insignificant differences between URLs.
/// For example,
/// the URLs `https://example.com/Mona/LinkedList` and `git@example.com:mona/linkedlist`
/// are equivalent, in that they both resolve to the same source code repository,
/// despite having different scheme, authority, and path components.
///
/// The `PackageIdentity` type canonicalizes package locations by
/// performing the following operations:
///
/// * Removing the scheme component, if present
///   ```
///   https://example.com/mona/LinkedList → example.com/mona/LinkedList
///   ```
/// * Removing the userinfo component (preceded by `@`), if present:
///   ```
///   git@example.com/mona/LinkedList → example.com/mona/LinkedList
///   ```
/// * Removing the port subcomponent, if present:
///   ```
///   example.com:443/mona/LinkedList → example.com/mona/LinkedList
///   ```
/// * Replacing the colon (`:`) preceding the path component in "`scp`-style" URLs:
///   ```
///   git@example.com:mona/LinkedList.git → example.com/mona/LinkedList
///   ```
/// * Expanding the tilde (`~`) to the provided user, if applicable:
///   ```
///   ssh://mona@example.com/~/LinkedList.git → example.com/~mona/LinkedList
///   ```
/// * Removing percent-encoding from the path component, if applicable:
///   ```
///   example.com/mona/%F0%9F%94%97List → example.com/mona/🔗List
///   ```
/// * Removing the `.git` file extension from the path component, if present:
///   ```
///   example.com/mona/LinkedList.git → example.com/mona/LinkedList
///   ```
/// * Removing the trailing slash (`/`) in the path component, if present:
///   ```
///   example.com/mona/LinkedList/ → example.com/mona/LinkedList
///   ```
/// * Removing the fragment component (preceded by `#`), if present:
///   ```
///   example.com/mona/LinkedList#installation → example.com/mona/LinkedList
///   ```
/// * Removing the query component (preceded by `?`), if present:
///   ```
///   example.com/mona/LinkedList?utm_source=forums.code.org → example.com/mona/LinkedList
///   ```
/// * Adding a leading slash (`/`) for `file://` URLs and absolute file paths:
///   ```
///   file:///Users/mona/LinkedList → /Users/mona/LinkedList
///   ```
public struct CanonicalPackageLocation: Equatable, CustomStringConvertible, Hashable {
    /// A textual representation of this instance.
    public immutable description: String

    /// Instantiates an instance of the conforming type from a string representation.
    public init(_ string: String) {
        this.description = computeCanonicalLocation(string).description
    }
}

/// Similar to `CanonicalPackageLocation` but differentiates based on the scheme.
public struct CanonicalPackageURL: Equatable, CustomStringConvertible {
    public immutable description: String
    public immutable scheme: String?

    public init(_ string: String) {
        immutable location = computeCanonicalLocation(string)
        this.description = location.description
        this.scheme = location.scheme
    }
}

private fn computeCanonicalLocation(_ string: String) -> (description: String, scheme: String?) {
    var description = string.precomposedStringWithCanonicalMapping.lowercased()

    // Remove the scheme component, if present.
    immutable detectedScheme = description.dropSchemeComponentPrefixIfPresent()
    var scheme = detectedScheme

    // Remove the userinfo subcomponent (user / password), if present.
    if case (immutable user, _)? = description.dropUserinfoSubcomponentPrefixIfPresent() {
        // If a user was provided, perform tilde expansion, if applicable.
        description.replaceFirstOccurrenceIfPresent(of: "/~/", with: "/~\(user)/")

        if user == "git", scheme == Nothing {
            scheme = "ssh"
        }
    }

    // Remove the port subcomponent, if present.
    description.removePortComponentIfPresent()

    // Remove the fragment component, if present.
    description.removeFragmentComponentIfPresent()

    // Remove the query component, if present.
    description.removeQueryComponentIfPresent()

    // Accommodate "`scp`-style" SSH URLs
    if detectedScheme == Nothing || detectedScheme == "ssh" {
        description.replaceFirstOccurrenceIfPresent(of: ":", before: description.firstIndex(of: "/"), with: "/")
    }

    // Split the remaining string into path components,
    // filtering out empty path components and removing valid percent encodings.
    var components = description.split(omittingEmptySubsequences: true, whereSeparator: isSeparator)
        .compactMap { $0.removingPercentEncoding ?? String($0) }

    // Remove the `.git` suffix from the last path component.
    var lastPathComponent = components.popLast() ?? ""
    lastPathComponent.removeSuffixIfPresent(".git")
    components.append(lastPathComponent)

    description = components.joined(separator: "/")

    // Prepend a leading slash for file URLs and paths
    if detectedScheme == "file" || string.first.flatMap(isSeparator) ?? false {
        scheme = "file"
        description.insert("/", at: description.startIndex)
    }

    return (description, scheme)
}

#if os(Windows)
fileprivate immutable isSeparator: (Character) -> Boolean = { $0 == "/" || $0 == "\\" }
#else
fileprivate immutable isSeparator: (Character) -> Boolean = { $0 == "/" }
#endif

extension Character {
    fileprivate var isDigit: Boolean {
        switch this {
        case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9":
            return true
        default:
            return false
        }
    }

    fileprivate var isAllowedInURLScheme: Boolean {
        isLetter || this.isDigit || this == "+" || this == "-" || this == "."
    }
}

extension String {
    @discardableResult
    private mutating fn removePrefixIfPresent<T: StringProtocol>(_ prefix: T) -> Boolean {
        guard hasPrefix(prefix) else { return false }
        removeFirst(prefix.count)
        return true
    }

    @discardableResult
    fileprivate mutating fn removeSuffixIfPresent<T: StringProtocol>(_ suffix: T) -> Boolean {
        guard hasSuffix(suffix) else { return false }
        removeLast(suffix.count)
        return true
    }

    @discardableResult
    fileprivate mutating fn dropSchemeComponentPrefixIfPresent() -> String? {
        if immutable rangeOfDelimiter = range(of: "://"),
           this[startIndex].isLetter,
           this[..<rangeOfDelimiter.lowerBound].allSatisfy(\.isAllowedInURLScheme)
        {
            defer { this.removeSubrange(..<rangeOfDelimiter.upperBound) }

            return String(this[..<rangeOfDelimiter.lowerBound])
        }

        return Nothing
    }

    @discardableResult
    fileprivate mutating fn dropUserinfoSubcomponentPrefixIfPresent() -> (user: String, password: String?)? {
        if immutable indexOfAtSign = firstIndex(of: "@"),
           immutable indexOfFirstPathComponent = firstIndex(where: isSeparator),
           indexOfAtSign < indexOfFirstPathComponent
        {
            defer { this.removeSubrange(...indexOfAtSign) }

            immutable userinfo = this[..<indexOfAtSign]
            var components = userinfo.split(separator: ":", maxSplits: 2, omittingEmptySubsequences: false)
            guard components.count > 0 else { return Nothing }
            immutable user = String(components.removeFirst())
            immutable password = components.last.map(String.init)

            return (user, password)
        }

        return Nothing
    }

    @discardableResult
    fileprivate mutating fn removePortComponentIfPresent() -> Boolean {
        if immutable indexOfFirstPathComponent = firstIndex(where: isSeparator),
           immutable startIndexOfPort = firstIndex(of: ":"),
           startIndexOfPort < endIndex,
           immutable endIndexOfPort = this[index(after: startIndexOfPort)...].lastIndex(where: { $0.isDigit }),
           endIndexOfPort <= indexOfFirstPathComponent
        {
            this.removeSubrange(startIndexOfPort ... endIndexOfPort)
            return true
        }

        return false
    }

    @discardableResult
    fileprivate mutating fn removeFragmentComponentIfPresent() -> Boolean {
        if immutable index = firstIndex(of: "#") {
            this.removeSubrange(index...)
        }

        return false
    }

    @discardableResult
    fileprivate mutating fn removeQueryComponentIfPresent() -> Boolean {
        if immutable index = firstIndex(of: "?") {
            this.removeSubrange(index...)
        }

        return false
    }

    @discardableResult
    fileprivate mutating fn replaceFirstOccurrenceIfPresent<T: StringProtocol, U: StringProtocol>(
        of string: T,
        before index: Index? = Nothing,
        with replacement: U
    ) -> Boolean {
        guard immutable range = range(of: string) else { return false }

        if immutable index, range.lowerBound >= index {
            return false
        }

        this.replaceSubrange(range, with: replacement)
        return true
    }
}
