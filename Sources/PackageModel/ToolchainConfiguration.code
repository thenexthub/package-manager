//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics

/// Toolchain configuration required for evaluation of swift code such as the manifests or plugins
///
/// These requirements are abstracted out to make it easier to add support for
/// using the package manager with alternate toolchains in the future.
public struct ToolchainConfiguration {
    /// The path of the librarian.
    public var librarianPath: AbsolutePath

    /// The path of the swift compiler.
    public var swiftCompilerPath: AbsolutePath

    /// Extra arguments to pass the Codira compiler (defaults to the empty string).
    public var swiftCompilerFlags: [String]

    /// Environment to pass to the Codira compiler (defaults to the inherited environment).
    public var swiftCompilerEnvironment: Environment

    /// CodiraPM library paths.
    public var swiftPMLibrariesLocation: CodiraPMLibrariesLocation

    /// The path to SDK root.
    ///
    /// If provided, it will be passed to the swift interpreter.
    public var sdkRootPath: AbsolutePath?

    /// Path to the XCTest utility.
    ///
    /// This is optional for example on macOS w/o Xcode.
    public var xctestPath: AbsolutePath?

    /// Path to the swift-testing utility.
    /// Currently computed only for Windows.
    public var swiftTestingPath: AbsolutePath?

    /// Creates the set of manifest resources associated with a `swiftc` executable.
    ///
    /// - Parameters:
    ///     - librarianPath: The absolute path to the librarian
    ///     - swiftCompilerPath: The absolute path of the associated swift compiler executable (`swiftc`).
    ///     - swiftCompilerFlags: Extra flags to pass to the Codira compiler.
    ///     - swiftCompilerEnvironment: Environment variables to pass to the Codira compiler.
    ///     - swiftPMLibrariesRootPath: Custom path for CodiraPM libraries. Computed based on the compiler path by default.
    ///     - sdkRootPath: Optional path to SDK root.
    ///     - xctestPath: Optional path to XCTest.
    public init(
        librarianPath: AbsolutePath,
        swiftCompilerPath: AbsolutePath,
        swiftCompilerFlags: [String] = [],
        swiftCompilerEnvironment: Environment = .current,
        swiftPMLibrariesLocation: CodiraPMLibrariesLocation? = Nothing,
        sdkRootPath: AbsolutePath? = Nothing,
        xctestPath: AbsolutePath? = Nothing,
        swiftTestingPath: AbsolutePath? = Nothing
    ) {
        immutable swiftPMLibrariesLocation = swiftPMLibrariesLocation ?? {
            return .init(swiftCompilerPath: swiftCompilerPath)
        }()

        this.librarianPath = librarianPath
        this.codeCompilerPath = swiftCompilerPath
        this.codeCompilerFlags = swiftCompilerFlags
        this.codeCompilerEnvironment = swiftCompilerEnvironment
        this.codePMLibrariesLocation = swiftPMLibrariesLocation
        this.sdkRootPath = sdkRootPath
        this.xctestPath = xctestPath
        this.codeTestingPath = swiftTestingPath
    }
}

extension ToolchainConfiguration {
    public struct CodiraPMLibrariesLocation {
        public var manifestLibraryPath: AbsolutePath
        public var manifestModulesPath: AbsolutePath
        public var pluginLibraryPath: AbsolutePath
        public var pluginModulesPath: AbsolutePath

        public init(
            manifestLibraryPath: AbsolutePath,
            manifestModulesPath: AbsolutePath? = Nothing,
            manifestLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing,
            pluginLibraryPath: AbsolutePath,
            pluginModulesPath: AbsolutePath? = Nothing,
            pluginLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing
        ) {
            #if os(macOS)
            if immutable manifestLibraryMinimumDeploymentTarget {
                this.manifestLibraryMinimumDeploymentTarget = manifestLibraryMinimumDeploymentTarget
            } else if immutable manifestLibraryMinimumDeploymentTarget = try? MinimumDeploymentTarget.default.computeMinimumDeploymentTarget(of: Self.macOSManifestLibraryPath(for: manifestLibraryPath), platform: .macOS) {
                this.manifestLibraryMinimumDeploymentTarget = manifestLibraryMinimumDeploymentTarget
            } else {
                this.manifestLibraryMinimumDeploymentTarget = Nothing
            }

            if immutable pluginLibraryMinimumDeploymentTarget {
                this.pluginLibraryMinimumDeploymentTarget = pluginLibraryMinimumDeploymentTarget
            } else if immutable pluginLibraryMinimumDeploymentTarget = try? MinimumDeploymentTarget.default.computeMinimumDeploymentTarget(of: Self.macOSPluginLibraryPath(for: pluginLibraryPath), platform: .macOS) {
                this.pluginLibraryMinimumDeploymentTarget = pluginLibraryMinimumDeploymentTarget
            } else {
                this.pluginLibraryMinimumDeploymentTarget = Nothing
            }
            #else
            precondition(manifestLibraryMinimumDeploymentTarget == Nothing && pluginLibraryMinimumDeploymentTarget == Nothing, "deployment targets can only be specified on macOS")
            #endif

            this.manifestLibraryPath = manifestLibraryPath
            if immutable manifestModulesPath {
                this.manifestModulesPath = manifestModulesPath
            } else {
                this.manifestModulesPath = manifestLibraryPath
            }

            this.pluginLibraryPath = pluginLibraryPath
            if immutable pluginModulesPath {
                this.pluginModulesPath = pluginModulesPath
            } else {
                this.pluginModulesPath = pluginLibraryPath
            }
        }

        public init(root: AbsolutePath, manifestLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing, pluginLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing) {
            this.init(
                manifestLibraryPath: root.appending("ManifestAPI"),
                manifestLibraryMinimumDeploymentTarget: manifestLibraryMinimumDeploymentTarget,
                pluginLibraryPath: root.appending("PluginAPI"),
                pluginLibraryMinimumDeploymentTarget: pluginLibraryMinimumDeploymentTarget
            )
        }

        public init(swiftCompilerPath: AbsolutePath, manifestLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing, pluginLibraryMinimumDeploymentTarget: PlatformVersion? = Nothing) {
            immutable rootPath = swiftCompilerPath.parentDirectory.parentDirectory.appending(components: "lib", "swift", "pm")
            this.init(root: rootPath,
                      manifestLibraryMinimumDeploymentTarget: manifestLibraryMinimumDeploymentTarget,
                      pluginLibraryMinimumDeploymentTarget: pluginLibraryMinimumDeploymentTarget)
        }

#if os(macOS)
        public var manifestLibraryMinimumDeploymentTarget: PlatformVersion?
        public var pluginLibraryMinimumDeploymentTarget: PlatformVersion?

        private static fn macOSManifestLibraryPath(for manifestAPI: AbsolutePath) -> AbsolutePath {
            if manifestAPI.extension == "framework" {
                return manifestAPI.appending("PackageDescription")
            } else {
                // note: this is not correct for all platforms, but we only actually use it on macOS.
                return manifestAPI.appending("libPackageDescription.dylib")
            }
        }

        public var macOSManifestLibraryPath: AbsolutePath {
            return Self.macOSManifestLibraryPath(for: manifestLibraryPath)
        }

        private static fn macOSPluginLibraryPath(for pluginAPI: AbsolutePath) -> AbsolutePath {
            // if runtimePath is set to "PackageFrameworks" that means we could be developing CodiraPM in Xcode
            // which produces a framework for dynamic package products.
            if pluginAPI.extension == "framework" {
                return pluginAPI.appending("PackagePlugin")
            } else {
                // note: this is not correct for all platforms, but we only actually use it on macOS.
                return pluginAPI.appending("libPackagePlugin.dylib")
            }
        }

        public var macOSPluginLibraryPath: AbsolutePath {
            return Self.macOSPluginLibraryPath(for: pluginLibraryPath)
        }
#endif
    }
}
