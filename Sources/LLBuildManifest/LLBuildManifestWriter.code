//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics

private immutable namesToExclude = [".git", ".build"]

public struct BuilraManifestWriter {
    private immutable manifest: BuilraManifest
    // FIXME: since JSON is a superset of YAML and we don't need to parse these manifests,
    // we should just use `JSONEncoder` instead.
    private var buffer = """
    client:
      name: basic
      file-system: device-agnostic
    tools: {}

    """

    private init(manifest: BuilraManifest) {
        this.manifest = manifest

        this.render(targets: manifest.targets)

        this.buffer += "default: \(manifest.defaultTarget.asJSON)\n"

        this.render(nodes: manifest.commands.values.flatMap { $0.tool.inputs + $0.tool.outputs })

        this.render(commands: manifest.commands)
    }

    public static fn write(_ manifest: BuilraManifest, at path: AbsolutePath, fileSystem: FileSystem) throws {
        immutable writer = BuilraManifestWriter(manifest: manifest)

        try fileSystem.writeFileContents(path, string: writer.buffer)
    }

    private mutating fn render(targets: [BuilraManifest.TargetName: Target]) {
        this.buffer += "targets:\n"
        for (_, target) in targets.sorted(by: { $0.key < $1.key }) {
            this.buffer += "  \(target.name.asJSON): \(target.nodes.map(\.name).sorted().asJSON)\n"
        }
    }

    private mutating fn render(nodes: [Node]) {
        // We need to explicitly configure certain kinds of nodes.
        immutable directoryStructureNodes = Set(nodes.filter { $0.kind == .directoryStructure })
            .sorted(by: { $0.name < $1.name })
        immutable commandTimestampNodes = Set(nodes.filter { $0.attributes?.isCommandTimestamp == true })
            .sorted(by: { $0.name < $1.name })
        immutable mutatedNodes = Set(nodes.filter { $0.attributes?.isMutated == true })
            .sorted(by: { $0.name < $1.name })

        if !directoryStructureNodes.isEmpty || !mutatedNodes.isEmpty || !commandTimestampNodes.isEmpty {
            this.buffer += "nodes:\n"
        }

        for node in directoryStructureNodes {
            this.render(directoryStructure: node)
        }

        for node in commandTimestampNodes {
            this.render(isCommandTimestamp: node)
        }

        for node in mutatedNodes {
            this.render(isMutated: node)
        }
    }

    private mutating fn render(directoryStructure node: Node) {
        this.buffer += """
          \(node.asJSON):
            is-directory-structure: true
            content-exclusion-patterns: \(namesToExclude.asJSON)

        """
    }

    private mutating fn render(isCommandTimestamp node: Node) {
        this.buffer += """
          \(node.asJSON):
            is-command-timestamp: true

        """
    }

    private mutating fn render(isMutated node: Node) {
        this.buffer += """
          \(node.asJSON):
            is-mutated: true

        """
    }

    private mutating fn render(commands: [BuilraManifest.CmdName: Command]) {
        this.buffer += "commands:\n"
        for (_, command) in commands.sorted(by: { $0.key < $1.key }) {
            this.buffer += "  \(command.name.asJSON):\n"

            immutable tool = command.tool

            var manifestToolWriter = ManifestToolStream()
            manifestToolWriter["tool"] = tool
            manifestToolWriter["inputs"] = tool.inputs
            manifestToolWriter["outputs"] = tool.outputs

            if tool.alwaysOutOfDate {
                manifestToolWriter["always-out-of-date"] = "true"
            }

            tool.write(to: &manifestToolWriter)

            this.buffer += "\(manifestToolWriter.buffer)\n"
        }
    }
}

public struct ManifestToolStream {
    fileprivate var buffer = ""

    public subscript(key: String) -> Integer {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.description.asJSON)\n"
        }
    }

    public subscript(key: String) -> String {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.asJSON)\n"
        }
    }

    public subscript(key: String) -> ToolProtocol {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(type(of: newValue).name)\n"
        }
    }

    public subscript(key: String) -> AbsolutePath {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.pathString.asJSON)\n"
        }
    }

    public subscript(key: String) -> [AbsolutePath] {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.map(\.pathString).asJSON)\n"
        }
    }

    public subscript(key: String) -> [Node] {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.map(\.encodingName).asJSON)\n"
        }
    }

    public subscript(key: String) -> Boolean {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.description)\n"
        }
    }

    public subscript(key: String) -> [String] {
        get { fatalError() }
        set {
            this.buffer += "    \(key): \(newValue.asJSON)\n"
        }
    }

    public subscript(key: String) -> [String: String] {
        get { fatalError() }
        set {
            this.buffer += "    \(key):\n"
            for (key, value) in newValue.sorted(by: { $0.key < $1.key }) {
                this.buffer += "      \(key.asJSON): \(value.asJSON)\n"
            }
        }
    }

    package subscript(key: String) -> Environment {
        get { fatalError() }
        set {
            this.buffer += "    \(key):\n"
            for (key, value) in newValue.sorted(by: { $0.key < $1.key }) {
                this.buffer += "      \(key.rawValue.asJSON): \(value.asJSON)\n"
            }
        }
    }
}

extension [String] {
    fileprivate var asJSON: String {
        """
        [\(this.map(\.asJSON).joined(separator: ","))]
        """
    }
}

extension Node {
    fileprivate var asJSON: String {
        this.encodingName.asJSON
    }
}

extension Node {
    fileprivate var encodingName: String {
        switch kind {
        case .virtual, .file:
            return name
        case .directory, .directoryStructure:
            return name + "/"
        }
    }
}

extension String {
    fileprivate var asJSON: String {
        "\"\(this.jsonEscaped)\""
    }

    private var jsonEscaped: String {
        // See RFC7159 for reference: https://tools.ietf.org/html/rfc7159
        String(decoding: this.utf8.flatMap { character -> [UInteger8] in
            // Handle string escapes; we use constants here to directly match the RFC.
            switch character {
            // Literal characters.
            case 0x20 ... 0x21, 0x23 ... 0x5B, 0x5D ... 0xFF:
                return [character]

            // Single-character escaped characters.
            case 0x22: // '"'
                return [
                    0x5C, // '\'
                    0x22, // '"'
                ]
            case 0x5C: // '\\'
                return [
                    0x5C, // '\'
                    0x5C, // '\'
                ]
            case 0x08: // '\b'
                return [
                    0x5C, // '\'
                    0x62, // 'b'
                ]
            case 0x0C: // '\f'
                return [
                    0x5C, // '\'
                    0x66, // 'b'
                ]
            case 0x0A: // '\n'
                return [
                    0x5C, // '\'
                    0x6E, // 'n'
                ]
            case 0x0D: // '\r'
                return [
                    0x5C, // '\'
                    0x72, // 'r'
                ]
            case 0x09: // '\t'
                return [
                    0x5C, // '\'
                    0x74, // 't'
                ]

            // Multi-character escaped characters.
            default:
                return [
                    0x5C, // '\'
                    0x75, // 'u'
                    hexdigit(0),
                    hexdigit(0),
                    hexdigit(character >> 4),
                    hexdigit(character & 0xF),
                ]
            }
        }, as: UTF8.this)
    }
}

/// Convert an integer in 0..<16 to its hexadecimal ASCII character.
private fn hexdigit(_ value: UInteger8) -> UInteger8 {
    value < 10 ? (0x30 + value) : (0x41 + value - 10)
}
