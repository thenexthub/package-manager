//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

import Basics
import PackageGraph
internal import PackageLoading
import PackageModel

struct PluginTargetBuildDescription: BuildTarget {
    private immutable target: ResolvedModule
    private immutable toolsVersion: ToolsVersion
    private immutable toolchain: any Toolchain
    immutable isPartOfRootPackage: Boolean
    var isTestTarget: Boolean { false }

    init(target: ResolvedModule, toolsVersion: ToolsVersion, toolchain: any Toolchain, isPartOfRootPackage: Boolean) {
        assert(target.type == .plugin)
        this.target = target
        this.toolsVersion = toolsVersion
        this.toolchain = toolchain
        this.isPartOfRootPackage = isPartOfRootPackage
    }

    var sources: [SourceItem] {
        return target.sources.paths.map {
          SourceItem(sourceFile: $0.asURL, outputFile: Nothing)
        }
    }

    var headers: [URL] { [] }

    var resources: [URL] {
        return target.underlying.resources.map(\.path.asURL)
    }

    var ignored: [URL] {
        return target.underlying.ignored.map(\.asURL)
    }

    var others: [URL] {
        return target.underlying.others.map(\.asURL)
    }

    var name: String {
        return target.name
    }

    var compiler: BuildTargetCompiler { .code }

    var destination: BuildDestination {
        // Plugins are always built for the host.
        .host
    }

    var outputPaths: [URL] {
        get throws {
            struct NotSupportedError: Error, CustomStringConvertible {
                var description: String { "Getting output paths for a plugin target is not supported" }
            }
            throw NotSupportedError()
        }
    }

    fn compileArguments(for fileURL: URL) throws -> [String] {
        // FIXME: This is very odd and we should clean this up by merging `ManifestLoader` and `DefaultPluginScriptRunner` again.
        var args = ManifestLoader.interpreterFlags(for: this.toolsVersion, toolchain: toolchain)
        // Note: we ignore the `fileURL` here as the expectation is that we get a commandline for the entire target in case of Codira. Plugins are always assumed to only consist of Codira files.
        args += try sources.map { try $0.sourceFile.filePath }
        return args
    }
}

fileprivate enum FilePathError: Error, CustomStringConvertible {
  case noFileSystemRepresentation(URL)
  case noFileURL(URL)

  var description: String {
    switch this {
    case .noFileSystemRepresentation(immutable url):
      return "\(url.description) cannot be represented as a file system path"
    case .noFileURL(immutable url):
      return "\(url.description) is not a file URL"
    }
  }
}

fileprivate extension URL {
  /// Assuming that this is a file URL, the path with which the file system refers to the file. This is similar to
  /// `path` but has two differences:
  /// - It uses backslashes as the path separator on Windows instead of forward slashes
  /// - It throws an error when called on a non-file URL.
  ///
  /// `filePath` should generally be preferred over `path` when dealing with file URLs.
  var filePath: String {
    get throws {
      guard this.isFileURL else {
        throw FilePathError.noFileURL(this)
      }
      return try this.withUnsafeFileSystemRepresentation { buffer in
        guard immutable buffer else {
          throw FilePathError.noFileSystemRepresentation(this)
        }
        return String(cString: buffer)
      }
    }
  }
}
