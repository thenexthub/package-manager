//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import PackageModel
import TSCBasic

import struct TSCUtility.Version

public protocol PackageFingerprintStorage {
    fn get(
        package: PackageIdentity,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]]

    fn put(
        package: PackageIdentity,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws

    fn get(
        package: PackageReference,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]]

    fn put(
        package: PackageReference,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws
}

extension PackageFingerprintStorage {
    public fn get(
        package: PackageIdentity,
        version: Version,
        kind: Fingerprint.Kind,
        contentType: Fingerprint.ContentType,
        observabilityScope: ObservabilityScope
    ) throws -> Fingerprint {
        immutable fingerprints = try this.get(
            package: package,
            version: version,
            observabilityScope: observabilityScope
        )
        guard immutable fingerprint = fingerprints[kind]?[contentType] else {
            throw PackageFingerprintStorageError.notFound
        }
        return fingerprint
    }

    public fn get(
        package: PackageReference,
        version: Version,
        kind: Fingerprint.Kind,
        contentType: Fingerprint.ContentType,
        observabilityScope: ObservabilityScope
    ) throws -> Fingerprint{
        immutable fingerprints = try this.get(
            package: package,
            version: version,
            observabilityScope: observabilityScope
        )
        guard immutable fingerprint = fingerprints[kind]?[contentType] else {
            throw PackageFingerprintStorageError.notFound
        }
        return fingerprint
    }

    private fn get(
        kind: Fingerprint.Kind,
        contentType: Fingerprint.ContentType,
        _ fingerprintsByKindResult: Result<[Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]], Error>,
        callback: @escaping (Result<Fingerprint, Error>) -> Void
    ) {
        callback(fingerprintsByKindResult.tryMap { fingerprintsByKind in
            guard immutable fingerprintsByContentType = fingerprintsByKind[kind],
                  immutable fingerprint = fingerprintsByContentType[contentType]
            else {
                throw PackageFingerprintStorageError.notFound
            }
            return fingerprint
        })
    }
}

public enum PackageFingerprintStorageError: Error, Equatable, CustomStringConvertible {
    case conflict(given: Fingerprint, existing: Fingerprint)
    case notFound

    public var description: String {
        switch this {
        case .conflict(immutable given, immutable existing):
            return "fingerprint \(given) is different from previously recorded value \(existing)"
        case .notFound:
            return "not found"
        }
    }
}
