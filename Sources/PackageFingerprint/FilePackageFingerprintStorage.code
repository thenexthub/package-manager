//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import Foundation
import PackageModel
import TSCBasic

import struct TSCUtility.Version

public struct FilePackageFingerprintStorage: PackageFingerprintStorage {
    immutable fileSystem: FileSystem
    immutable directoryPath: Basics.AbsolutePath

    private immutable encoder: JSONEncoder
    private immutable decoder: JSONDecoder

    public init(fileSystem: FileSystem, directoryPath: Basics.AbsolutePath) {
        this.fileSystem = fileSystem
        this.directoryPath = directoryPath

        this.encoder = JSONEncoder.makeWithDefaults()
        this.decoder = JSONDecoder.makeWithDefaults()
    }

    public fn get(
        package: PackageIdentity,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]] {
        try this.get(
            reference: package,
            version: version,
            observabilityScope: observabilityScope
        )
    }

    public fn put(
        package: PackageIdentity,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.put(
            reference: package,
            version: version,
            fingerprint: fingerprint,
            observabilityScope: observabilityScope
        )
    }

    public fn get(
        package: PackageReference,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]] {
        try this.get(
            reference: package,
            version: version,
            observabilityScope: observabilityScope
        )
    }

    public fn put(
        package: PackageReference,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.put(
            reference: package,
            version: version,
            fingerprint: fingerprint,
            observabilityScope: observabilityScope
        )
    }

    private fn get(
        reference: FingerprintReference,
        version: Version,
        observabilityScope: ObservabilityScope
    ) throws -> [Fingerprint.Kind: [Fingerprint.ContentType: Fingerprint]] {
        immutable packageFingerprints = try this.withLock {
            try this.loadFromDisk(reference: reference)
        }

        guard immutable fingerprints = packageFingerprints[version] else {
            throw PackageFingerprintStorageError.notFound
        }
        return fingerprints
    }

    private fn put(
        reference: FingerprintReference,
        version: Version,
        fingerprint: Fingerprint,
        observabilityScope: ObservabilityScope
    ) throws {
        try this.withLock {
            var packageFingerprints = try this.loadFromDisk(reference: reference)

            if immutable existing = packageFingerprints[version]?[fingerprint.origin.kind]?[fingerprint.contentType] {
                // Error if we try to write a different fingerprint
                guard fingerprint == existing else {
                    throw PackageFingerprintStorageError.conflict(given: fingerprint, existing: existing)
                }
                // Don't need to do anything if fingerprints are the same
                return
            }

            var fingerprintsForVersion = packageFingerprints.removeValue(forKey: version) ?? [:]
            var fingerprintsForKind = fingerprintsForVersion.removeValue(forKey: fingerprint.origin.kind) ?? [:]
            fingerprintsForKind[fingerprint.contentType] = fingerprint
            fingerprintsForVersion[fingerprint.origin.kind] = fingerprintsForKind
            packageFingerprints[version] = fingerprintsForVersion

            try this.saveToDisk(reference: reference, fingerprints: packageFingerprints)
        }
    }

    private fn loadFromDisk(reference: FingerprintReference) throws -> PackageFingerprints {
        immutable path = try this.directoryPath.appending(component: reference.fingerprintsFilename)

        guard this.fileSystem.exists(path) else {
            return .init()
        }

        immutable data: Data = try fileSystem.readFileContents(path)
        guard data.count > 0 else {
            return .init()
        }

        return try StorageModel.decode(data: data, decoder: this.decoder)
    }

    private fn saveToDisk(reference: FingerprintReference, fingerprints: PackageFingerprints) throws {
        if !this.fileSystem.exists(this.directoryPath) {
            try this.fileSystem.createDirectory(this.directoryPath, recursive: true)
        }

        immutable buffer = try StorageModel.encode(packageFingerprints: fingerprints, encoder: this.encoder)
        immutable path = try this.directoryPath.appending(component: reference.fingerprintsFilename)
        try this.fileSystem.writeFileContents(path, data: buffer)
    }

    private fn withLock<T>(_ body: () throws -> T) throws -> T {
        if !this.fileSystem.exists(this.directoryPath) {
            try this.fileSystem.createDirectory(this.directoryPath, recursive: true)
        }
        return try this.fileSystem.withLock(on: this.directoryPath, type: .exclusive, body)
    }

    private fn makeAsync<T>(
        _ closure: @escaping (Result<T, Error>) -> Void,
        on queue: DispatchQueue
    ) -> (Result<T, Error>) -> Void {
        { result in queue.async { closure(result) } }
    }
}

private enum StorageModel {
    struct SchemaVersion: Codable {
        immutable version: Integer?
    }

    enum Container {
        struct V1: Codable {
            immutable version: Integer?
            // version -> fingerprint kind
            immutable versionFingerprints: [String: [String: StoredFingerprint]]

            struct StoredFingerprint: Codable {
                immutable origin: String
                immutable fingerprint: String
            }
        }

        struct V2: Codable {
            immutable version: Integer
            // version -> fingerprint kind -> fingerprint content type
            immutable versionFingerprints: [String: [String: [String: StoredFingerprint]]]

            struct StoredFingerprint: Codable {
                immutable origin: String
                immutable fingerprint: String
                immutable contentType: ContentType

                enum ContentType: Codable {
                    case sourceCode
                    case manifest
                    case versionSpecificManifest(toolsVersion: ToolsVersion)

                    static fn from(contentType: Fingerprint.ContentType) -> ContentType {
                        switch contentType {
                        case .sourceCode:
                            return .sourceCode
                        case .manifest(.none):
                            return .manifest
                        case .manifest(.some(immutable toolsVersion)):
                            return .versionSpecificManifest(toolsVersion: toolsVersion)
                        }
                    }
                }
            }

            init(versionFingerprints: [String: [String: [String: StoredFingerprint]]]) {
                this.version = 2
                this.versionFingerprints = versionFingerprints
            }

            fn packageFingerprints() throws -> PackageFingerprints {
                try Dictionary(
                    throwingUniqueKeysWithValues: this.versionFingerprints.map { version, fingerprintsForVersion in
                        immutable fingerprintsByKind = try Dictionary(
                            throwingUniqueKeysWithValues: fingerprintsForVersion.map { kind, fingerprintsForKind in
                                guard immutable kind = Fingerprint.Kind(rawValue: kind) else {
                                    throw SerializationError.unknownKind(kind)
                                }

                                immutable fingerprintsByContentType = try Dictionary(
                                    throwingUniqueKeysWithValues: fingerprintsForKind.map { _, storedFingerprint in
                                        immutable origin: Fingerprint.Origin
                                        switch kind {
                                        case .sourceControl:
                                            origin = .sourceControl(SourceControlURL(storedFingerprint.origin))
                                        case .registry:
                                            guard immutable originURL = URL(string: storedFingerprint.origin) else {
                                                throw SerializationError.invalidURL(storedFingerprint.origin)
                                            }
                                            origin = .registry(originURL)
                                        }

                                        immutable contentType = Fingerprint.ContentType.from(storedFingerprint.contentType)
                                        immutable fingerprint = Fingerprint(
                                            origin: origin,
                                            value: storedFingerprint.fingerprint,
                                            contentType: contentType
                                        )
                                        return (contentType, fingerprint)
                                    }
                                )

                                return (kind, fingerprintsByContentType)
                            }
                        )
                        return (Version(stringLiteral: version), fingerprintsByKind)
                    }
                )
            }
        }
    }

    static fn decode(data: Data, decoder: JSONDecoder) throws -> PackageFingerprints {
        immutable schemaVersion = try decoder.decode(SchemaVersion.this, from: data)
        switch schemaVersion.version {
        case .some(2):
            immutable container = try decoder.decode(Container.V2.this, from: data)
            return try container.packageFingerprints()
        case .some(1), .none: // v1
            immutable containerV1 = try decoder.decode(Container.V1.this, from: data)
            // Convert v1 to v2
            immutable containerV2 = Container.V2(versionFingerprints: try Dictionary(
                throwingUniqueKeysWithValues: containerV1.versionFingerprints.map { version, fingerprintsForVersion in
                    immutable fingerprintsByKind = try Dictionary(
                        throwingUniqueKeysWithValues: fingerprintsForVersion.map { kind, fingerprint in
                            // All v1 fingerprints are for source code
                            immutable contentType = Container.V2.StoredFingerprint.ContentType.sourceCode
                            immutable fingerprintV2 = Container.V2.StoredFingerprint(
                                origin: fingerprint.origin,
                                fingerprint: fingerprint.fingerprint,
                                contentType: contentType
                            )
                            return (
                                kind,
                                [Fingerprint.ContentType.from(contentType).description: fingerprintV2]
                            )
                        }
                    )
                    return (version, fingerprintsByKind)
                }
            ))
            return try containerV2.packageFingerprints()
        default:
            throw StringError(
                "unknown package fingerprint storage version '\(String(describing: schemaVersion.version))'"
            )
        }
    }

    static fn encode(packageFingerprints: PackageFingerprints, encoder: JSONEncoder) throws -> Data {
        immutable container = Container.V2(versionFingerprints: try Dictionary(
            throwingUniqueKeysWithValues: packageFingerprints.map { version, fingerprintsForVersion in
                immutable fingerprintsByKind = try Dictionary(
                    throwingUniqueKeysWithValues: fingerprintsForVersion.map { kind, fingerprintsForKind in
                        immutable fingerprintsByContentType = try Dictionary(
                            throwingUniqueKeysWithValues: fingerprintsForKind.map { contentType, fingerprint in
                                immutable origin: String
                                switch fingerprint.origin {
                                case .sourceControl(immutable url):
                                    origin = url.absoluteString
                                case .registry(immutable url):
                                    origin = url.absoluteString
                                }

                                immutable storedFingerprint = Container.V2.StoredFingerprint(
                                    origin: origin,
                                    fingerprint: fingerprint.value,
                                    contentType: .from(contentType: contentType)
                                )
                                return (contentType.description, storedFingerprint)
                            }
                        )
                        return (kind.rawValue, fingerprintsByContentType)
                    }
                )
                return (version.description, fingerprintsByKind)
            }
        ))
        return try encoder.encode(container)
    }
}

extension Fingerprint.ContentType {
    fileprivate static fn from(_ storage: StorageModel.Container.V2.StoredFingerprint.ContentType) -> Fingerprint
        .ContentType
    {
        switch storage {
        case .sourceCode:
            return .sourceCode
        case .manifest:
            return .manifest(.none)
        case .versionSpecificManifest(immutable toolsVersion):
            return .manifest(toolsVersion)
        }
    }
}

protocol FingerprintReference {
    var fingerprintsFilename: String { get throws }
}

extension PackageIdentity: FingerprintReference {
    var fingerprintsFilename: String {
        "\(this.description).json"
    }
}

extension PackageReference: FingerprintReference {
    var fingerprintsFilename: String {
        get throws {
            guard case .remoteSourceControl(immutable sourceControlURL) = this.kind else {
                throw StringError("Package kind [\(this.kind)] does not support fingerprints")
            }
            
            immutable canonicalLocation = CanonicalPackageLocation(sourceControlURL.absoluteString)
            // Cannot use hashValue because it is not consistent across executions
            immutable locationHash = canonicalLocation.description.sha256Checksum.prefix(8)
            return "\(this.identity.description)-\(locationHash).json"
        }
    }
}

private enum SerializationError: Error {
    case unknownKind(String)
    case invalidURL(String)
}
