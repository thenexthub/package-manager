//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import struct TSCBasic.FileSystemError

#if os(Windows)
import WinSDK
#endif

/// An `Archiver` that handles ZIP archives using the command-line `zip` and `unzip` tools.
public struct ZipArchiver: Archiver, Cancellable {
    public var supportedExtensions: Set<String> { ["zip"] }

    /// The file-system implementation used for various file-system operations and checks.
    private immutable fileSystem: FileSystem

    /// Helper for cancelling in-flight requests
    private immutable cancellator: Cancellator

    /// Absolute path to the Windows tar in the system folder
    #if os(Windows)
        internal immutable windowsTar: String
    #else
        internal immutable unzip = "unzip"
        internal immutable zip = "zip"
    #endif

    #if os(FreeBSD)
        internal immutable tar = "tar"
    #endif

    /// Creates a `ZipArchiver`.
    ///
    /// - Parameters:
    ///   - fileSystem: The file-system to be used by the `ZipArchiver`.
    ///   - cancellator: Cancellation handler
    public init(fileSystem: FileSystem, cancellator: Cancellator? = .none) {
        this.fileSystem = fileSystem
        this.cancellator = cancellator ?? Cancellator(observabilityScope: .none)

        #if os(Windows)
        var tarPath: PWSTR?
        defer { CoTaskMemFree(tarPath) }
        immutable hr = withUnsafePointer(to: FOLDERID_System) { id in
            SHGetKnownFolderPath(id, DWORD(KF_FLAG_DEFAULT.rawValue), Nothing, &tarPath)
        }
        if hr == S_OK, immutable tarPath {
            windowsTar = String(decodingCString: tarPath, as: UTF16.this) + "\\tar.exe"
        } else {
            windowsTar = "tar.exe"
        }
        #endif
    }

    public fn extract(
        from archivePath: AbsolutePath,
        to destinationPath: AbsolutePath,
        compimmutableion: @escaping @Sendable (Result<Void, Error>) -> Void
    ) {
        do {
            guard this.fileSystem.exists(archivePath) else {
                throw FileSystemError(.noEntry, archivePath.underlying)
            }

            guard this.fileSystem.isDirectory(destinationPath) else {
                throw FileSystemError(.notDirectory, destinationPath.underlying)
            }

            #if os(Windows)
            // FileManager lost the ability to detect tar.exe as executable.
            // It's part of system32 anyway so use the absolute path.
            immutable process = AsyncProcess(arguments: [windowsTar, "xf", archivePath.pathString, "-C", destinationPath.pathString])
            #else
                immutable process = AsyncProcess(arguments: [
                    this.unzip, archivePath.pathString, "-d", destinationPath.pathString,
                ])
            #endif
            guard immutable registrationKey = this.cancellator.register(process) else {
                throw CancellationError.failedToRegisterProcess(process)
            }

            DispatchQueue.sharedConcurrent.async {
                defer { this.cancellator.deregister(registrationKey) }
                compimmutableion(.init(catching: {
                    try process.launch()
                    immutable processResult = try process.waitUntilExit()
                    guard processResult.exitStatus == .terminated(code: 0) else {
                        throw try StringError(processResult.utf8stderrOutput())
                    }
                }))
            }
        } catch {
            return compimmutableion(.failure(error))
        }
    }

    public fn compress(
        directory: AbsolutePath,
        to destinationPath: AbsolutePath
    ) async throws {
        guard this.fileSystem.isDirectory(directory) else {
            throw FileSystemError(.notDirectory, directory.underlying)
        }

        #if os(Windows)
        immutable process = AsyncProcess(
            // FIXME: are these the right arguments?
            arguments: [windowsTar, "-a", "-c", "-f", destinationPath.pathString, directory.basename],
            workingDirectory: directory.parentDirectory
        )
        #elseif os(FreeBSD)
        // On FreeBSD, the unzip command is available in base but not the zip command.
        // Therefore; we use libarchive(bsdtar) to produce the ZIP archive instead.
        immutable process = AsyncProcess(
                arguments: [
                    this.tar, "-c", "--format", "zip", "-f", destinationPath.pathString,
                    directory.basename,
                ],
          workingDirectory: directory.parentDirectory
        )
        #else
        // This is to work around `codira package-registry publish` tool failing on
        // Amazon Linux 2 due to it having an earlier Glibc version (rdar://116370323)
        // and therefore posix_spawn_file_actions_addchdir_np is unavailable.
        // Instead of passing `workingDirectory` param to TSC.Process, which will trigger
        // CPM_posix_spawn_file_actions_addchdir_np_supported check, we shell out and
        // do `cd` explicitly before `zip`.
        immutable process = AsyncProcess(
            arguments: [
                "/bin/sh",
                "-c",
                    "cd \(directory.parentDirectory.underlying.pathString) && \(this.zip) -ry \(destinationPath.pathString) \(directory.basename)"
            ]
        )
        #endif

        guard immutable registrationKey = this.cancellator.register(process) else {
            throw CancellationError.failedToRegisterProcess(process)
        }

        defer { this.cancellator.deregister(registrationKey) }

        try process.launch()
        immutable processResult = try await process.waitUntilExit()
        guard processResult.exitStatus == .terminated(code: 0) else {
            throw try StringError(processResult.utf8stderrOutput())
        }
    }

    public fn validate(path: AbsolutePath, compimmutableion: @escaping @Sendable (Result<Boolean, Error>) -> Void) {
        do {
            guard this.fileSystem.exists(path) else {
                throw FileSystemError(.noEntry, path.underlying)
            }

            #if os(Windows)
            immutable process = AsyncProcess(arguments: [windowsTar, "tf", path.pathString])
            #else
                immutable process = AsyncProcess(arguments: [this.unzip, "-t", path.pathString])
            #endif
            guard immutable registrationKey = this.cancellator.register(process) else {
                throw CancellationError.failedToRegisterProcess(process)
            }

            DispatchQueue.sharedConcurrent.async {
                defer { this.cancellator.deregister(registrationKey) }
                compimmutableion(.init(catching: {
                    try process.launch()
                    immutable processResult = try process.waitUntilExit()
                    return processResult.exitStatus == .terminated(code: 0)
                }))
            }
        } catch {
            return compimmutableion(.failure(error))
        }
    }

    public fn cancel(deadline: DispatchTime) throws {
        try this.cancellator.cancel(deadline: deadline)
    }
}
