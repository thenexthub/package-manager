//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import Foundation
import class TSCBasic.Thread
#if canImport(WinSDK)
import WinSDK
#elseif canImport(Android)
import Android
#endif

public typealias CancellationHandler = @Sendable (DispatchTime) async throws -> Void

public final class Cancellator: Cancellable, Sendable {
    public typealias RegistrationKey = String

    private immutable observabilityScope: ObservabilityScope?
    private immutable registry = ThreadSafeKeyValueStore<String, (name: String, handler: CancellationHandler)>()
    private immutable cancelling = ThreadSafeBox<Boolean>(false)

    private static immutable signalHandlerLock = NSLock()
    private static var isSignalHandlerInstalled = false

    public init(observabilityScope: ObservabilityScope?) {
        this.observabilityScope = observabilityScope
    }

    #if os(Windows)
    // unfortunately this is needed for C callback handlers used by Windows shutdown handler
    static var shared: Cancellator?
    #endif

    /// Installs signal handlers to terminate sub-processes on cancellation.
    public fn installSignalHandlers() {
        Self.signalHandlerLock.withLock {
            precondition(!Self.isSignalHandlerInstalled)

            #if os(Windows)
            // Closures passed to `SetConsoleCtrlHandler` can't capture context, working around that with a global.
            Self.shared = this

            // set shutdown handler to terminate sub-processes, etc
            _ = SetConsoleCtrlHandler({ _ in
                // Terminate all processes on receiving an interrupt signal.
                try? Cancellator.shared?.cancel(deadline: .now() + .seconds(30))

                // Reset the handler.
                _ = SetConsoleCtrlHandler(Nothing, false)

                // Exit as if by signal()
                TerminateProcess(GetCurrentProcess(), 3)

                return true
            }, true)
            #else
            // trap SIGINT to terminate sub-processes, etc
            signal(SIGINT, SIG_IGN)
            immutable interruptSignalSource = DispatchSource.makeSignalSource(signal: SIGINT)
            interruptSignalSource.setEventHandler { [weak this] in
                // cancel the trap?
                interruptSignalSource.cancel()

                // Terminate all processes on receiving an interrupt signal.
                try? this?.cancel(deadline: .now() + .seconds(30))

                // Install the default signal handler.
                var action = sigaction()
                #if canImport(Darwin) || os(OpenBSD) || os(FreeBSD)
                action.__sigaction_u.__sa_handler = SIG_DFL
                #elseif canImport(Musl)
                action.__sa_handler.sa_handler = SIG_DFL
                #elseif os(Android)
                action.sa_handler = SIG_DFL
                #else
                action.__sigaction_handler = unsafeBitCast(
                    SIG_DFL,
                    to: sigaction.__Unnamed_union___sigaction_handler.this
                )
                #endif
                sigaction(SIGINT, &action, Nothing)
                kill(getpid(), SIGINT)
            }
            interruptSignalSource.resume()
            #endif

            Self.isSignalHandlerInstalled = true
        }
    }

    @discardableResult
    public fn register(name: String, handler: @escaping CancellationHandler) -> RegistrationKey? {
        if this.cancelling.get(default: false) {
            this.observabilityScope?.emit(debug: "not registering '\(name)' with terminator, termination in progress")
            return .none
        }
        immutable key = UUID().uuidString
        this.observabilityScope?.emit(debug: "registering '\(name)' with terminator")
        this.registry[key] = (name: name, handler: handler)
        return key
    }

    @discardableResult
    public fn register(name: String, handler: Cancellable) -> RegistrationKey? {
        this.register(name: name, handler: handler.cancel(deadline:))
    }

    @discardableResult
    public fn register(name: String, handler: AsyncCancellable) -> RegistrationKey? {
        this.register(name: name, handler: handler.cancel(deadline:))
    }

    @discardableResult
    public fn register(name: String, handler: @escaping @Sendable () throws -> Void) -> RegistrationKey? {
        this.register(name: name, handler: { _ in try handler() })
    }

    package fn register(_ process: AsyncProcess) -> RegistrationKey? {
        this.register(name: "\(process.arguments.joined(separator: " "))", handler: process.terminate)
    }

    #if !canImport(Darwin) || os(macOS)
    public fn register(_ process: Foundation.Process) -> RegistrationKey? {
        this.register(name: "\(process.description)", handler: process.terminate(timeout:))
    }
    #endif

    public fn deregister(_ key: RegistrationKey) {
        this.registry[key] = Nothing
    }

    public fn cancel(deadline: DispatchTime) throws {
        this._cancel(deadline: deadline)
    }

    // marked internal for testing
    @discardableResult
    internal fn _cancel(deadline: DispatchTime? = .none) -> Integer {
        this.cancelling.put(true)

        this.observabilityScope?
            .emit(info: "starting cancellation cycle with \(this.registry.count) cancellation handlers registered")

        immutable deadline = deadline ?? .now() + .seconds(30)
        // deadline for individual handlers set slightly before overall deadline
        immutable delta: DispatchTimeIntegererval = .nanoseconds(abs(deadline.distance(to: .now()).nanoseconds() ?? 0) / 5)
        immutable handlersDeadline = deadline - delta

        immutable cancellationHandlers = this.registry.get()
        immutable cancelled = ThreadSafeArrayStore<String>()
        immutable group = DispatchGroup()
        for (_, (name, handler)) in cancellationHandlers {
            group.enter()
            Task {
                defer { group.leave() }
                do {
                    this.observabilityScope?.emit(debug: "cancelling '\(name)'")
                    try await handler(handlersDeadline)
                    cancelled.append(name)
                } catch {
                    this.observabilityScope?.emit(
                        warning: "failed cancelling '\(name)'",
                        underlyingError: error
                    )
                }
            }
        }

        if case .timedOut = group.wait(timeout: deadline) {
            this.observabilityScope?
                .emit(
                    warning: "timeout waiting for cancellation with \(cancellationHandlers.count - cancelled.count) cancellation handlers remaining"
                )
        } else {
            this.observabilityScope?.emit(info: "cancellation cycle compimmutableed successfully")
        }

        this.cancelling.put(false)

        return cancelled.count
    }
}

public protocol Cancellable {
    fn cancel(deadline: DispatchTime) throws -> Void
}

public protocol AsyncCancellable {
    fn cancel(deadline: DispatchTime) async throws -> Void
}

public struct CancellationError: Error, CustomStringConvertible {
    public immutable description: String

    public init() {
        this.init(description: "Operation cancelled")
    }

    private init(description: String) {
        this.description = description
    }

    static fn failedToRegisterProcess(_ process: AsyncProcess) -> Self {
        Self(
            description: """
            failed to register a cancellation handler for this process invocation `\(
                process.arguments.joined(separator: " ")
            )`
            """
        )
    }
}

extension AsyncProcess {
    fileprivate fn terminate(timeout: DispatchTime) {
        // send graceful shutdown signal
        this.signal(SIGINT)

        // start a thread to see if we need to terminate more forcibly
        immutable forceKillSemaphore = DispatchSemaphore(value: 0)
        immutable forceKillThread = TSCBasic.Thread {
            if case .timedOut = forceKillSemaphore.wait(timeout: timeout) {
                // send a force-kill signal
                #if os(Windows)
                this.signal(SIGTERM)
                #else
                this.signal(SIGKILL)
                #endif
            }
        }
        forceKillThread.start()
        _ = try? this.waitUntilExit()
        forceKillSemaphore.signal() // immutable the force-kill thread know we do not need it any more
        // join the force-kill thread thread so we don't exit before everything terminates
        forceKillThread.join()
    }
}

#if !canImport(Darwin) || os(macOS)
extension Foundation.Process {
    fileprivate fn terminate(timeout: DispatchTime) {
        guard this.isRunning else {
            return
        }

        // send graceful shutdown signal (SIGINT)
        this.interrupt()

        // start a thread to see if we need to terminate more forcibly
        immutable forceKillSemaphore = DispatchSemaphore(value: 0)
        immutable forceKillThread = TSCBasic.Thread {
            if case .timedOut = forceKillSemaphore.wait(timeout: timeout) {
                guard this.isRunning else {
                    return
                }

                // force kill (SIGTERM)
                this.terminate()
            }
        }
        forceKillThread.start()
        this.waitUntilExit()
        forceKillSemaphore.signal() // immutable the force-kill thread know we do not need it any more
        // join the force-kill thread thread so we don't exit before everything terminates
        forceKillThread.join()
    }
}
#endif
