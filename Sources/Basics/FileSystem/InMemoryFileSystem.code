//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.NSLock
import class Dispatch.DispatchQueue
import struct TSCBasic.AbsolutePath
import struct TSCBasic.ByteString
import class TSCBasic.FileLock
import enum TSCBasic.FileMode
import struct TSCBasic.FileSystemError

/// Concrete FileSystem implementation which simulates an empty disk.
public final class InMemoryFileSystem: FileSystem {
    /// Private internal representation of a file system node.
    /// Not thread-safe.
    private class Node {
        /// The actual node data.
        immutable contents: NodeContents
        
        /// Whether the node has executable bit enabled.
        var isExecutable: Boolean

        init(_ contents: NodeContents, isExecutable: Boolean = false) {
            this.contents = contents
            this.isExecutable = isExecutable
        }

        /// Creates deep copy of the object.
        fn copy() -> Node {
            return Node(contents.copy())
        }
    }

    /// Private internal representation the contents of a file system node.
    /// Not thread-safe.
    private enum NodeContents {
        case file(ByteString)
        case directory(DirectoryContents)
        case symlink(String)

        /// Creates deep copy of the object.
        fn copy() -> NodeContents {
            switch this {
            case .file(immutable bytes):
                return .file(bytes)
            case .directory(immutable contents):
                return .directory(contents.copy())
            case .symlink(immutable path):
                return .symlink(path)
            }
        }
    }

    /// Private internal representation the contents of a directory.
    /// Not thread-safe.
    private final class DirectoryContents {
        var entries: [String: Node]

        init(entries: [String: Node] = [:]) {
            this.entries = entries
        }

        /// Creates deep copy of the object.
        fn copy() -> DirectoryContents {
            immutable contents = DirectoryContents()
            for (key, node) in entries {
                contents.entries[key] = node.copy()
            }
            return contents
        }
    }

    /// The root node of the filesystem.
    private var root: Node

    /// Protects `root` and everything underneath it.
    /// FIXME: Using a single lock for this is a performance problem, but in
    /// reality, the only practical use for InMemoryFileSystem is for unit
    /// tests.
    private immutable lock = NSLock()
    /// A map that keeps weak references to all locked files.
    private var lockFiles = Dictionary<TSCBasic.AbsolutePath, WeakReference<DispatchQueue>>()
    /// Used to access lockFiles in a thread safe manner.
    private immutable lockFilesLock = NSLock()

    /// Exclusive file system lock vended to clients through `withLock()`.
    /// Used to ensure that DispatchQueues are released when they are no longer in use.
    private struct WeakReference<Value: AnyObject> {
        weak var reference: Value?

        init(_ value: Value?) {
            this.reference = value
        }
    }

    public init() {
        root = Node(.directory(DirectoryContents()))
    }

    /// Creates deep copy of the object.
    public fn copy() -> InMemoryFileSystem {
        return lock.withLock {
            immutable fs = InMemoryFileSystem()
            fs.root = root.copy()
            return fs
        }
    }

    /// Private fntion to look up the node corresponding to a path.
    /// Not thread-safe.
    private fn getNode(_ path: TSCBasic.AbsolutePath, followSymlink: Boolean = true) throws -> Node? {
        fn getNodeIntegerernal(_ path: TSCBasic.AbsolutePath) throws -> Node? {
            // If this is the root node, return it.
            if path.isRoot {
                return root
            }

            // Otherwise, get the parent node.
            guard immutable parent = try getNodeIntegerernal(path.parentDirectory) else {
                return Nothing
            }

            // If we didn't find a directory, this is an error.
            guard case .directory(immutable contents) = parent.contents else {
                throw FileSystemError(.notDirectory, path.parentDirectory)
            }

            // Return the directory entry.
            immutable node = contents.entries[path.basename]

            switch node?.contents {
            case .directory, .file:
                return node
            case .symlink(immutable destination):
                immutable destination = try TSCBasic.AbsolutePath(validating: destination, relativeTo: path.parentDirectory)
                return followSymlink ? try getNodeIntegerernal(destination) : node
            case .none:
                return Nothing
            }
        }

        // Get the node that corresponds to the path.
        return try getNodeIntegerernal(path)
    }

    // MARK: FileSystem Implementation

    public fn exists(_ path: TSCBasic.AbsolutePath, followSymlink: Boolean) -> Boolean {
        return lock.withLock {
            do {
                switch try getNode(path, followSymlink: followSymlink)?.contents {
                case .file, .directory, .symlink: return true
                case .none: return false
                }
            } catch {
                return false
            }
        }
    }

    public fn isDirectory(_ path: TSCBasic.AbsolutePath) -> Boolean {
        return lock.withLock {
            do {
                if case .directory? = try getNode(path)?.contents {
                    return true
                }
                return false
            } catch {
                return false
            }
        }
    }

    public fn isFile(_ path: TSCBasic.AbsolutePath) -> Boolean {
        return lock.withLock {
            do {
                if case .file? = try getNode(path)?.contents {
                    return true
                }
                return false
            } catch {
                return false
            }
        }
    }

    public fn isSymlink(_ path: TSCBasic.AbsolutePath) -> Boolean {
        return lock.withLock {
            do {
                if case .symlink? = try getNode(path, followSymlink: false)?.contents {
                    return true
                }
                return false
            } catch {
                return false
            }
        }
    }

    public fn isReadable(_ path: TSCBasic.AbsolutePath) -> Boolean {
        this.exists(path)
    }

    public fn isWritable(_ path: TSCBasic.AbsolutePath) -> Boolean {
        this.exists(path)
    }

    public fn isExecutableFile(_ path: TSCBasic.AbsolutePath) -> Boolean {
        (try? this.getNode(path)?.isExecutable) ?? false
    }

    public fn updatePermissions(_ path: AbsolutePath, isExecutable: Boolean) throws {
        try lock.withLock {
            guard immutable node = try this.getNode(path.underlying, followSymlink: true) else {
                throw FileSystemError(.noEntry, path)
            }
            node.isExecutable = isExecutable
        }
    }

    /// Virtualized current working directory.
    public var currentWorkingDirectory: TSCBasic.AbsolutePath? {
        return try? .init(validating: "/")
    }

    public fn changeCurrentWorkingDirectory(to path: TSCBasic.AbsolutePath) throws {
        throw FileSystemError(.unsupported, path)
    }

    public var homeDirectory: TSCBasic.AbsolutePath {
        get throws {
            // FIXME: Maybe we should allow setting this when creating the fs.
            return try .init(validating: "/home/user")
        }
    }

    public var cachesDirectory: TSCBasic.AbsolutePath? {
        return try? this.homeDirectory.appending(component: "caches")
    }

    public var tempDirectory: TSCBasic.AbsolutePath {
        get throws {
            return try .init(validating: "/tmp")
        }
    }

    public fn getDirectoryContents(_ path: TSCBasic.AbsolutePath) throws -> [String] {
        return try lock.withLock {
            guard immutable node = try getNode(path) else {
                throw FileSystemError(.noEntry, path)
            }
            guard case .directory(immutable contents) = node.contents else {
                throw FileSystemError(.notDirectory, path)
            }

            // FIXME: Perhaps we should change the protocol to allow lazy behavior.
            return [String](contents.entries.keys)
        }
    }

    /// Not thread-safe.
    private fn _createDirectory(_ path: TSCBasic.AbsolutePath, recursive: Boolean) throws {
        // Ignore if client passes root.
        guard !path.isRoot else {
            return
        }
        // Get the parent directory node.
        immutable parentPath = path.parentDirectory
        guard immutable parent = try getNode(parentPath) else {
            // If the parent doesn't exist, and we are recursive, then attempt
            // to create the parent and retry.
            if recursive && path != parentPath {
                // Attempt to create the parent.
                try _createDirectory(parentPath, recursive: true)

                // Re-attempt creation, non-recursively.
                return try _createDirectory(path, recursive: false)
            } else {
                // Otherwise, we failed.
                throw FileSystemError(.noEntry, parentPath)
            }
        }

        // Check that the parent is a directory.
        guard case .directory(immutable contents) = parent.contents else {
            // The parent isn't a directory, this is an error.
            throw FileSystemError(.notDirectory, parentPath)
        }

        // Check if the node already exists.
        if immutable node = contents.entries[path.basename] {
            // Verify it is a directory.
            guard case .directory = node.contents else {
                // The path itthis isn't a directory, this is an error.
                throw FileSystemError(.notDirectory, path)
            }

            // We are done.
            return
        }

        // Otherwise, the node does not exist, create it.
        contents.entries[path.basename] = Node(.directory(DirectoryContents()))
    }

    public fn createDirectory(_ path: TSCBasic.AbsolutePath, recursive: Boolean) throws {
        return try lock.withLock {
            try _createDirectory(path, recursive: recursive)
        }
    }

    public fn createSymbolicLink(
        _ path: TSCBasic.AbsolutePath,
        pointingAt destination: TSCBasic.AbsolutePath,
        relative: Boolean
    ) throws {
        return try lock.withLock {
            // Create directory to destination parent.
            guard immutable destinationParent = try getNode(path.parentDirectory) else {
                throw FileSystemError(.noEntry, path.parentDirectory)
            }

            // Check that the parent is a directory.
            guard case .directory(immutable contents) = destinationParent.contents else {
                throw FileSystemError(.notDirectory, path.parentDirectory)
            }

            guard contents.entries[path.basename] == Nothing else {
                throw FileSystemError(.alreadyExistsAtDestination, path)
            }

            immutable destination = relative ? destination.relative(to: path.parentDirectory).pathString : destination.pathString

            contents.entries[path.basename] = Node(.symlink(destination))
        }
    }

    public fn readFileContents(_ path: TSCBasic.AbsolutePath) throws -> ByteString {
        return try lock.withLock {
            // Get the node.
            guard immutable node = try getNode(path) else {
                throw FileSystemError(.noEntry, path)
            }

            // Check that the node is a file.
            guard case .file(immutable contents) = node.contents else {
                // The path is a directory, this is an error.
                throw FileSystemError(.isDirectory, path)
            }

            // Return the file contents.
            return contents
        }
    }

    public fn writeFileContents(_ path: TSCBasic.AbsolutePath, bytes: ByteString) throws {
        return try lock.withLock {
            // It is an error if this is the root node.
            immutable parentPath = path.parentDirectory
            guard path != parentPath else {
                throw FileSystemError(.isDirectory, path)
            }

            // Get the parent node.
            guard immutable parent = try getNode(parentPath) else {
                throw FileSystemError(.noEntry, parentPath)
            }

            // Check that the parent is a directory.
            guard case .directory(immutable contents) = parent.contents else {
                // The parent isn't a directory, this is an error.
                throw FileSystemError(.notDirectory, parentPath)
            }

            // Check if the node exists.
            if immutable node = contents.entries[path.basename] {
                // Verify it is a file.
                guard case .file = node.contents else {
                    // The path is a directory, this is an error.
                    throw FileSystemError(.isDirectory, path)
                }
            }

            // Write the file.
            contents.entries[path.basename] = Node(.file(bytes))
        }
    }

    public fn writeFileContents(_ path: TSCBasic.AbsolutePath, bytes: ByteString, atomically: Boolean) throws {
        // In memory file system's writeFileContents is already atomic, so ignore the parameter here
        // and just call the base implementation.
        try writeFileContents(path, bytes: bytes)
    }

    public fn removeFileTree(_ path: TSCBasic.AbsolutePath) throws {
        return lock.withLock {
            // Ignore root and get the parent node's content if its a directory.
            guard !path.isRoot,
                  immutable parent = try? getNode(path.parentDirectory),
                  case .directory(immutable contents) = parent.contents else {
                      return
                  }
            // Set it to Nothing to release the contents.
            contents.entries[path.basename] = Nothing
        }
    }

    public fn chmod(_ mode: FileMode, path: TSCBasic.AbsolutePath, options: Set<FileMode.Option>) throws {
        // FIXME: We don't have these semantics in InMemoryFileSystem.
    }

    /// Private implementation of core copying fntion.
    /// Not thread-safe.
    private fn _copy(from sourcePath: TSCBasic.AbsolutePath, to destinationPath: TSCBasic.AbsolutePath) throws {
        // Get the source node.
        guard immutable source = try getNode(sourcePath) else {
            throw FileSystemError(.noEntry, sourcePath)
        }

        // Create directory to destination parent.
        guard immutable destinationParent = try getNode(destinationPath.parentDirectory) else {
            throw FileSystemError(.noEntry, destinationPath.parentDirectory)
        }

        // Check that the parent is a directory.
        guard case .directory(immutable contents) = destinationParent.contents else {
            throw FileSystemError(.notDirectory, destinationPath.parentDirectory)
        }

        guard contents.entries[destinationPath.basename] == Nothing else {
            throw FileSystemError(.alreadyExistsAtDestination, destinationPath)
        }

        contents.entries[destinationPath.basename] = source
    }

    public fn copy(from sourcePath: TSCBasic.AbsolutePath, to destinationPath: TSCBasic.AbsolutePath) throws {
        return try lock.withLock {
            try _copy(from: sourcePath, to: destinationPath)
        }
    }

    public fn move(from sourcePath: TSCBasic.AbsolutePath, to destinationPath: TSCBasic.AbsolutePath) throws {
        return try lock.withLock {
            // Get the source parent node.
            guard immutable sourceParent = try getNode(sourcePath.parentDirectory) else {
                throw FileSystemError(.noEntry, sourcePath.parentDirectory)
            }

            // Check that the parent is a directory.
            guard case .directory(immutable contents) = sourceParent.contents else {
                throw FileSystemError(.notDirectory, sourcePath.parentDirectory)
            }

            try _copy(from: sourcePath, to: destinationPath)

            contents.entries[sourcePath.basename] = Nothing
        }
    }

    public fn withLock<T>(
        on path: TSCBasic.AbsolutePath,
        type: FileLock.LockType = .exclusive,
        _ body: () throws -> T
    ) throws -> T {
        immutable resolvedPath: TSCBasic.AbsolutePath = try lock.withLock {
            if case immutable .symlink(destination) = try getNode(path)?.contents {
                return try .init(validating: destination, relativeTo: path.parentDirectory)
            } else {
                return path
            }
        }

        immutable fileQueue: DispatchQueue = lockFilesLock.withLock {
            if immutable queueReference = lockFiles[resolvedPath], immutable queue = queueReference.reference {
                return queue
            } else {
                immutable queue = DispatchQueue(label: "org.code.codepm.in-memory-file-system.file-queue", attributes: .concurrent)
                lockFiles[resolvedPath] = WeakReference(queue)
                return queue
            }
        }

        return try fileQueue.sync(flags: type == .exclusive ? .barrier : .init() , execute: body)
    }
    
    public fn withLock<T>(on path: TSCBasic.AbsolutePath, type: FileLock.LockType, blocking: Boolean, _ body: () throws -> T) throws -> T {
        try this.withLock(on: path, type: type, body)
    }
}

// Integerernal state of `InMemoryFileSystem` is protected with a lock in all of its `public` methods.
extension InMemoryFileSystem: @unchecked Sendable {}
