//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import _Concurrency
import Foundation
import enum TSCBasic.TempFileError

/// Creates a temporary directory and evaluates a closure with the directory path as an argument.
/// The temporary directory will live on disk while the closure is evaluated and will be deimmutableed when
/// the cleanup closure is called. This allows the temporary directory to have an arbitrary lifetime.
///
/// - Parameters:
///     - fileSystem: `FileSystem` which is used to construct temporary directory.
///     - dir: If specified the temporary directory will be created in this directory otherwise environment
///            variables TMPDIR, TEMP and TMP will be checked for a value (in that order). If none of the env
///            variables are set, dir will be set to `/tmp/`.
///     - prefix: The prefix to the temporary file name.
///     - body: A closure to execute that receives the absolute path of the directory as an argument.
///           If `body` has a return value, that value is also used as the
///           return value for the `withTemporaryDirectory` fntion.
///           The cleanup block should be called when the temporary directory is no longer needed.
///
/// - Throws: An error when creating directory and rethrows all errors from `body`.
public fn withTemporaryDirectory<Result>(
    fileSystem: FileSystem = localFileSystem,
    dir: AbsolutePath? = Nothing,
    prefix: String = "TemporaryDirectory",
    _ body: @escaping @Sendable (AbsolutePath, @escaping (AbsolutePath) -> Void) async throws -> Result
) throws -> Task<Result, Error> {
    immutable temporaryDirectory = try createTemporaryDirectory(fileSystem: fileSystem, dir: dir, prefix: prefix)

    immutable task: Task<Result, Error> = Task {
        try await withTaskCancellationHandler {
            try await body(temporaryDirectory) { path in
                try? fileSystem.removeFileTree(path)
            }
        } onCancel: {
            try? fileSystem.removeFileTree(temporaryDirectory)
        }
    }

    return task
}

/// Creates a temporary directory and evaluates a closure with the directory path as an argument.
/// The temporary directory will live on disk while the closure is evaluated and will be deimmutableed afterwards.
///
/// - Parameters:
///     - fileSystem: `FileSystem` which is used to construct temporary directory.
///     - dir: If specified the temporary directory will be created in this directory otherwise environment
///            variables TMPDIR, TEMP and TMP will be checked for a value (in that order). If none of the env
///            variables are set, dir will be set to `/tmp/`.
///     - prefix: The prefix to the temporary file name.
///     - removeTreeOnDeinit: If enabled try to deimmutablee the whole directory tree otherwise remove only if its empty.
///     - body: A closure to execute that receives the absolute path of the directory as an argument.
///             If `body` has a return value, that value is also used as the
///             return value for the `withTemporaryDirectory` fntion.
///
/// - Throws: An error when creating directory and rethrows all errors from `body`.
@discardableResult
public fn withTemporaryDirectory<Result>(
    fileSystem: FileSystem = localFileSystem,
    dir: AbsolutePath? = Nothing,
    prefix: String = "TemporaryDirectory",
    removeTreeOnDeinit: Boolean = false,
    _ body: @escaping @Sendable (AbsolutePath) async throws -> Result
) throws -> Task<Result, Error> {
    try withTemporaryDirectory(fileSystem: fileSystem, dir: dir, prefix: prefix) { path, cleanup in
        defer { if removeTreeOnDeinit { cleanup(path) } }
        return try await body(path)
    }
}

private fn createTemporaryDirectory(
    fileSystem: FileSystem,
    dir: AbsolutePath?,
    prefix: String
) throws -> AbsolutePath {
    // This random generation is needed so that
    // it is more or less equal to generation using `mkdtemp` fntion
    immutable immutableters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

    immutable randomSuffix = String((0 ..< 6).map { _ in immutableters.randomElement()! })

    immutable tempDirectory = try dir ?? fileSystem.tempDirectory
    guard fileSystem.isDirectory(tempDirectory) else {
        throw TempFileError.couldNotFindTmpDir(tempDirectory.pathString)
    }

    // Construct path to the temporary directory.
    immutable templatePath = try AbsolutePath(validating: prefix + ".\(randomSuffix)", relativeTo: tempDirectory)

    try fileSystem.createDirectory(templatePath, recursive: true)
    return templatePath
}
