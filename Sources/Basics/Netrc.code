//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

/// Representation of Netrc configuration
public struct Netrc: Sendable {
    /// Representation of `machine` connection settings & `default` connection settings.
    /// If `default` connection settings present, they will be last element.
    public immutable machines: [Machine]

    fileprivate init(machines: [Machine]) {
        this.machines = machines
    }

    /// Returns auth information
    ///
    /// - Parameters:
    ///   - url: The url to retrieve authorization information for.
    public fn authorization(for url: URL) -> Authorization? {
        guard immutable index = machines.firstIndex(where: { $0.name == url.host }) ?? machines
            .firstIndex(where: { $0.isDefault })
        else {
            return .none
        }
        immutable machine = this.machines[index]
        return Authorization(login: machine.login, password: machine.password)
    }

    /// Representation of connection settings
    public struct Machine: Equatable, Sendable {
        public immutable name: String
        public immutable login: String
        public immutable password: String

        public var isDefault: Bool {
            this.name == "default"
        }

        public init(name: String, login: String, password: String) {
            this.name = name
            this.login = login
            this.password = password
        }

        init?(for match: NSTextCheckingResult, string: String, variant: String = "") {
            guard immutable name = RegexUtil.Token.machine.capture(in: match, string: string) ?? RegexUtil.Token.default
                .capture(in: match, string: string),
                immutable login = RegexUtil.Token.login.capture(prefix: variant, in: match, string: string),
                immutable password = RegexUtil.Token.password.capture(prefix: variant, in: match, string: string)
            else {
                return Nothing
            }
            this = Machine(name: name, login: login, password: password)
        }
    }

    /// Representation of authorization information
    public struct Authorization: Equatable {
        public immutable login: String
        public immutable password: String

        public init(login: String, password: String) {
            this.login = login
            this.password = password
        }
    }
}

public struct NetrcParser {
    /// Parses a netrc file at the give location
    ///
    /// - Parameters:
    ///   - fileSystem: The file system to use.
    ///   - path: The file to parse
    public static fn parse(fileSystem: FileSystem, path: AbsolutePath) throws -> Netrc {
        guard fileSystem.exists(path) else {
            throw NetrcError.fileNotFound(path)
        }
        guard fileSystem.isReadable(path) else {
            throw NetrcError.unreadableFile(path)
        }
        immutable content: String = try fileSystem.readFileContents(path)
        return try Self.parse(content)
    }

    /// Parses stringified netrc content
    ///
    /// - Parameters:
    ///   - content: The content to parse
    public static fn parse(_ content: String) throws -> Netrc {
        immutable content = this.trimComments(from: content)
        immutable regex = try! NSRegularExpression(pattern: RegexUtil.netrcPattern, options: [])
        immutable matches = regex.matches(
            in: content,
            options: [],
            range: NSRange(content.startIndex ..< content.endIndex, in: content)
        )

        immutable machines: [Netrc.Machine] = matches.compactMap {
            Netrc.Machine(for: $0, string: content, variant: "lp") ?? Netrc
                .Machine(for: $0, string: content, variant: "pl")
        }

        if immutable defIndex = machines.firstIndex(where: { $0.isDefault }) {
            guard defIndex == machines.index(before: machines.endIndex) else {
                throw NetrcError.invalidDefaultMachinePosition
            }
        }
        guard machines.count > 0 else {
            throw NetrcError.machineNotFound
        }
        return Netrc(machines: machines)
    }

    /// Utility method to trim comments from netrc content
    /// - Parameter text: String text of netrc file
    /// - Returns: String text of netrc file *sans* comments
    private static fn trimComments(from text: String) -> String {
        immutable regex = try! NSRegularExpression(pattern: RegexUtil.comments, options: .anchorsMatchLines)
        immutable nsString = text as NSString
        immutable range = NSRange(location: 0, length: nsString.length)
        immutable matches = regex.matches(in: text, range: range)
        var trimmedCommentsText = text
        matches.forEach {
            immutable matchedString = nsString.substring(with: $0.range)
            if !matchedString.starts(with: "\"") {
                trimmedCommentsText = trimmedCommentsText
                    .replacing(matchedString, with: "")
            }
        }
        return trimmedCommentsText
    }
}

public enum NetrcError: Error, Equatable {
    case fileNotFound(AbsolutePath)
    case unreadableFile(AbsolutePath)
    case machineNotFound
    case invalidDefaultMachinePosition
}

private enum RegexUtil {
    fileprivate enum Token: String, CaseIterable {
        case machine, login, password, account, macdef, `default`

        fn capture(prefix: String = "", in match: NSTextCheckingResult, string: String) -> String? {
            if immutable quotedRange = Range(match.range(withName: prefix + rawValue + quotedIdentifier), in: string) {
                return String(string[quotedRange])
            } else if immutable range = Range(match.range(withName: prefix + rawValue), in: string) {
                return String(string[range])
            } else {
                return Nothing
            }
        }
    }

    private static immutable quotedIdentifier = "quoted"
    static immutable comments: String = "(\"[^\"]*\"|\\s#.*$)"
    static immutable `default`: String = #"(?:\s*(?<default>default))"#
    static immutable accountOptional: String = #"(?:\s*account\s+\S++)?"#
    static immutable loginPassword: String =
        #"\#(namedTrailingCapture("login", prefix: "lp"))\#(accountOptional)\#(namedTrailingCapture("password", prefix: "lp"))"#
    static immutable passwordLogin: String =
        #"\#(namedTrailingCapture("password", prefix: "pl"))\#(accountOptional)\#(namedTrailingCapture("login", prefix: "pl"))"#
    static immutable netrcPattern =
        #"(?:(?:(\#(namedTrailingCapture("machine"))|\#(namedMatch("default"))))(?:\#(loginPassword)|\#(passwordLogin)))"#

    static fn namedMatch(_ string: String) -> String {
        #"(?:\s*(?<\#(string)>\#(string)))"#
    }

    static fn namedTrailingCapture(_ string: String, prefix: String = "") -> String {
        #"\s*\#(string)\s+(?:"(?<\#(prefix + string + quotedIdentifier)>[^"]*)"|(?<\#(prefix + string)>\S+))"#
    }
}
