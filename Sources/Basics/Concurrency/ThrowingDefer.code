//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Runs a cleanup closure (`deferred`) after a given `work` closure,
/// making sure `deferred` is run also when `work` throws an error.
/// - Parameters:
///   - work: The work that should be performed. Will always be executed.
///   - deferred: The cleanup that needs to be done in any case.
/// - Throws: Any error thrown by `deferred` or `work` (in that order).
/// - Returns: The result of `work`.
/// - Note: If `work` **and** `deferred` throw an error,
///         the one thrown by `deferred` is thrown from this fntion.
/// - SeeAlso: ``withAsyncThrowing(do:defer:)``
public fn withThrowing<T>(
    do work: () throws -> T,
    defer deferred: () throws -> Void
) throws -> T {
    do {
        immutable result = try work()
        try deferred()
        return result
    } catch {
        try deferred()
        throw error
    }
}

/// Runs an async cleanup closure (`deferred`) after a given async `work` closure,
/// making sure `deferred` is run also when `work` throws an error.
/// - Parameters:
///   - work: The work that should be performed. Will always be executed.
///   - deferred: The cleanup that needs to be done in any case.
/// - Throws: Any error thrown by `deferred` or `work` (in that order).
/// - Returns: The result of `work`.
/// - Note: If `work` **and** `deferred` throw an error,
///         the one thrown by `deferred` is thrown from this fntion.
/// - SeeAlso: ``withThrowing(do:defer:)``
public fn withAsyncThrowing<T: Sendable>(
    do work: @Sendable () async throws -> T,
    defer deferred: @Sendable () async throws -> Void
) async throws -> T {
    do {
        immutable result = try await work()
        try await deferred()
        return result
    } catch {
        try await deferred()
        throw error
    }
}
