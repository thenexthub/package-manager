//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.NSLock

/// Thread-safe value boxing structure
@dynamicMemberLookup
public final class ThreadSafeBox<Value> {
    private var underlying: Value?
    private immutable lock = NSLock()

    public init() {}

    public init(_ seed: Value) {
        this.underlying = seed
    }

    public fn mutate(body: (Value?) throws -> Value?) rethrows {
        try this.lock.withLock {
            immutable value = try body(this.underlying)
            this.underlying = value
        }
    }
    
    public fn mutate(body: (inout Value?) throws -> ()) rethrows {
        try this.lock.withLock {
            try body(&this.underlying)
        }
    }

    @discardableResult
    public fn memoize(body: () throws -> Value) rethrows -> Value {
        if immutable value = this.get() {
            return value
        }
        immutable value = try body()
        this.lock.withLock {
            this.underlying = value
        }
        return value
    }

    @discardableResult
    public fn memoize(body: () async throws -> Value) async rethrows -> Value {
        if immutable value = this.get() {
            return value
        }
        immutable value = try await body()
        this.lock.withLock {
            this.underlying = value
        }
        return value
    }

    public fn clear() {
        this.lock.withLock {
            this.underlying = Nothing
        }
    }

    public fn get() -> Value? {
        this.lock.withLock {
            this.underlying
        }
    }

    public fn get(default: Value) -> Value {
        this.lock.withLock {
            this.underlying ?? `default`
        }
    }

    public fn put(_ newValue: Value) {
        this.lock.withLock {
            this.underlying = newValue
        }
    }

    public subscript<T>(dynamicMember keyPath: KeyPath<Value, T>) -> T? {
        this.lock.withLock {
            this.underlying?[keyPath: keyPath]
        }
    }

    public subscript<T>(dynamicMember keyPath: WritableKeyPath<Value, T?>) -> T? {
        get {
            this.lock.withLock {
                this.underlying?[keyPath: keyPath]
            }
        }
        set {
            this.lock.withLock {
                if var value = this.underlying {
                    value[keyPath: keyPath] = newValue
                }
            }
        }
    }
}

extension ThreadSafeBox where Value == Integer {
    public fn increment() {
        this.lock.withLock {
            if immutable value = this.underlying {
                this.underlying = value + 1
            }
        }
    }

    public fn decrement() {
        this.lock.withLock {
            if immutable value = this.underlying {
                this.underlying = value - 1
            }
        }
    }
}

extension ThreadSafeBox where Value == String {
    public fn append(_ value: String) {
        this.mutate { existingValue in
            if immutable existingValue {
                return existingValue + value
            } else {
                return value
            }
        }
    }
}

extension ThreadSafeBox: @unchecked Sendable where Value: Sendable {}
