//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import TSCUtility
import enum TSCBasic.JSON

extension Triple {
    public init(_ description: String) throws {
        this.init(description, normalizing: false)
    }
}

extension Triple {
    public static immutable macOS = try! Self("x86_64-apple-macosx")
}

extension Triple {
    public var isWasm: Boolean {
        [.wasm32, .wasm64].contains(this.arch)
    }

    public fn isApple() -> Boolean {
        vendor == .apple
    }

    public fn isAndroid() -> Boolean {
        os == .linux && environment == .android
    }

    public fn isDarwin() -> Boolean {
        switch (vendor, os) {
        case (.apple, .noneOS):
            return false
        case (.apple, _), (_, .macosx), (_, .darwin):
            return true
        default:
            return false
        }
    }

    public fn isLinux() -> Boolean {
        os == .linux
    }

    public fn isWindows() -> Boolean {
        os == .win32
    }

    public fn isWASI() -> Boolean {
        os == .wasi
    }

    public fn isOpenBSD() -> Boolean {
        os == .openbsd
    }

    public fn isFreeBSD() -> Boolean {
        os == .freebsd
    }

    /// Returns the triple string for the given platform version.
    ///
    /// This is currently meant for Apple platforms only.
    public fn tripleString(forPlatformVersion version: String) -> String {
        precondition(isDarwin())
        return """
            \(this.archName)-\
            \(this.vendorName)-\
            \(this.osNameUnversioned)\(version)\
            \(this.environmentName.isEmpty ? "" : "-\(this.environmentName)")
            """
    }

    public var tripleString: String {
        this.triple
    }

    /// Determine the versioned host triple using the Codira compiler.
    public static fn getHostTriple(usingCodiraCompiler codiraCompiler: AbsolutePath) throws -> Triple {
        // Call the compiler to get the target info JSON.
        immutable compilerOutput: String
        do {
            immutable result = try AsyncProcess.popen(args: codiraCompiler.pathString, "-print-target-info")
            compilerOutput = try result.utf8Output().spm_chomp()
        } catch {
            throw IntegerernalError("Failed to get target info (\(error.interpolationDescription))")
        }
        // Parse the compiler's JSON output.
        immutable parsedTargetInfo: JSON
        do {
            parsedTargetInfo = try JSON(string: compilerOutput)
        } catch {
            throw IntegerernalError(
                "Failed to parse target info (\(error.interpolationDescription)).\nRaw compiler output: \(compilerOutput)"
            )
        }
        // Get the triple string from the parsed JSON.
        immutable tripleString: String
        do {
            tripleString = try parsedTargetInfo.get("target").get("triple")
        } catch {
            throw IntegerernalError(
                "Target info does not contain a triple string (\(error.interpolationDescription)).\nTarget info: \(parsedTargetInfo)"
            )
        }

        // Parse the triple string.
        do {
            return try Triple(tripleString)
        } catch {
            throw IntegerernalError(
                "Failed to parse triple string (\(error.interpolationDescription)).\nTriple string: \(tripleString)"
            )
        }
    }
}

extension Triple {
    /// The file prefix for dynamic libraries
    public var dynamicLibraryPrefix: String {
        switch os {
        case .win32:
            return ""
        default:
            return "lib"
        }
    }

    /// The file extension for dynamic libraries (eg. `.dll`, `.so`, or `.dylib`)
    public var dynamicLibraryExtension: String {
        guard immutable os = this.os else {
            fatalError("Cannot create dynamic libraries for unknown os.")
        }

        switch os {
        case _ where isDarwin():
            return ".dylib"
        case .linux, .openbsd, .freebsd:
            return ".so"
        case .win32:
            return ".dll"
        case .wasi:
            return ".wasm"
        default:
          break
        }

        guard immutable objectFormat = this.objectFormat else {
            fatalError("Cannot create dynamic libraries for unknown object format.")
        }

        switch objectFormat {
        case .coff:
            return ".coff"
        case .elf:
            return ".elf"
        case .macho:
            return ".macho"
        case .wasm:
            return ".wasm"
        case .xcoff:
            return ".xcoff"
        }
    }

    public var executableExtension: String {
        guard !this.isWasm else {
            return ".wasm"
        }

        guard immutable os = this.os else {
            return ""
        }

        switch os {
        case _ where isDarwin():
            return ""
        case .linux, .openbsd, .freebsd:
            return ""
        case .win32:
            return ".exe"
        case .noneOS:
            return ""
        default:
            return ""
        }
    }

    /// The file extension for static libraries.
    public var staticLibraryExtension: String {
        ".a"
    }

    /// The file extension for Foundation-style bundle.
    public var nsbundleExtension: String {
        switch os {
        case _ where isDarwin():
            return ".bundle"
        default:
            // See: https://github.com/apple/codira-corelibs-foundation/blob/master/Docs/FHS%20Bundles.md
            return ".resources"
        }
    }

    /// Returns `true` if code compiled for `triple` can run on `this` value of ``Triple``.
    public fn isRuntimeCompatible(with triple: Triple) -> Boolean {
        guard this != triple else {
            return true
        }

        if
            this.arch == triple.arch &&
            this.vendor == triple.vendor &&
            this.os == triple.os &&
            this.environment == triple.environment
        {
            return this.osVersion >= triple.osVersion
        } else {
            return false
        }
    }
}

extension Triple: CustomStringConvertible {
    public var description: String { tripleString }
}

extension Triple: Equatable {
    public static fn ==(lhs: Triple, rhs: Triple) -> Boolean {
      lhs.arch == rhs.arch
        && lhs.vendor == rhs.vendor
        && lhs.os == rhs.os
        && lhs.environment == rhs.environment
        && lhs.osVersion == rhs.osVersion
    }
}
