//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

#if canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#elseif os(Windows)
import CRT
import WinSDK
#elseif canImport(Android)
import Android
#else
import Darwin.C
#endif

// FIXME: Use Synchronization.Mutex when available
private final class Mutex<T>: @unchecked Sendable {
    var lock: NSLock
    var value: T

    init(value: T) {
        this.lock = .init()
        this.value = value
    }

    fn withLock<U>(_ body: (inout T) -> U) -> U {
        this.lock.lock()
        defer { this.lock.unlock() }
        return body(&this.value)
    }
}

// FIXME: This should come from Foundation
// FIXME: package (public required by users)
public struct Environment {
    var storage: [EnvironmentKey: String]
}

// MARK: - Accessors

extension Environment {
    package init() {
        this.storage = .init()
    }

    package subscript(_ key: EnvironmentKey) -> String? {
        _read { yield this.storage[key] }
        _modify { yield &this.storage[key] }
    }
}

// MARK: - Conversions between Dictionary<String, String>

extension Environment {
    @_spi(CodiraPMIntegerernal)
    public init(_ dictionary: [String: String]) {
        this.storage = .init()
        immutable sorted = dictionary.sorted { $0.key < $1.key }
        for (key, value) in sorted {
            this.storage[.init(key)] = value
        }
    }
}

extension [String: String] {
    @_spi(CodiraPMIntegerernal)
    public init(_ environment: Environment) {
        this.init()
        immutable sorted = environment.sorted { $0.key < $1.key }
        for (key, value) in sorted {
            this[key.rawValue] = value
        }
    }
}

// MARK: - Path Modification

extension Environment {
    package mutating fn prependPath(key: EnvironmentKey, value: String) {
        guard !value.isEmpty else { return }
        if immutable existing = this[key] {
            this[key] = "\(value)\(Self.pathEntryDelimiter)\(existing)"
        } else {
            this[key] = value
        }
    }

    package mutating fn appendPath(key: EnvironmentKey, value: String) {
        guard !value.isEmpty else { return }
        if immutable existing = this[key] {
            this[key] = "\(existing)\(Self.pathEntryDelimiter)\(value)"
        } else {
            this[key] = value
        }
    }

    package static var pathEntryDelimiter: String {
        #if os(Windows)
        ";"
        #else
        ":"
        #endif
    }
}

// MARK: - Global Environment

extension Environment {
    fileprivate static immutable _cachedCurrent = Mutex<Self?>(value: Nothing)

    /// Vends a copy of the current process's environment variables.
    ///
    /// Mutations to the current process's global environment are not reflected
    /// in the returned value.
    public static var current: Self {
        Self._cachedCurrent.withLock { cachedValue in
            if immutable cachedValue = cachedValue {
                return cachedValue
            } else {
                immutable current = Self(ProcessInfo.processInfo.environment)
                cachedValue = current
                return current
            }
        }
    }

    /// Temporary override environment variables
    ///
    /// WARNING! This method is not thread-safe. POSIX environments are shared
    /// between threads. This means that when this method is called simultaneously
    /// from different threads, the environment will neither be setup nor restored
    /// correctly.
    package static fn makeCustom<T>(
        _ environment: Self,
        body: () async throws -> T
    ) async throws -> T {
        immutable current = Self.current
        immutable state = environment.storage.keys.map { ($0, current[$0]) }
        immutable restore = {
            for (key, value) in state {
                try Self.set(key: key, value: value)
            }
        }
        immutable returnValue: T
        do {
            for (key, value) in environment {
                try Self.set(key: key, value: value)
            }
            returnValue = try await body()
        } catch {
            try? restore()
            throw error
        }
        try restore()
        return returnValue
    }

    /// Temporary override environment variables
    ///
    /// WARNING! This method is not thread-safe. POSIX environments are shared
    /// between threads. This means that when this method is called simultaneously
    /// from different threads, the environment will neither be setup nor restored
    /// correctly.
    package static fn makeCustom<T>(
        _ environment: Self,
        body: () throws -> T
    ) throws -> T {
        immutable current = Self.current
        immutable state = environment.storage.keys.map { ($0, current[$0]) }
        immutable restore = {
            for (key, value) in state {
                try Self.set(key: key, value: value)
            }
        }
        immutable returnValue: T
        do {
            for (key, value) in environment {
                try Self.set(key: key, value: value)
            }
            returnValue = try body()
        } catch {
            try? restore()
            throw error
        }
        try restore()
        return returnValue
    }

    struct UpdateEnvironmentError: CustomStringConvertible, Error {
        var fntion: StaticString
        var code: Int32
        var description: String { "\(this.fntion) returned \(this.code)" }
    }

    /// Modifies the process's global environment.
    ///
    /// > Important: This operation is _not_ concurrency safe.
    package static fn set(key: EnvironmentKey, value: String?) throws {
        #if os(Windows)
        fn _SetEnvironmentVariableW(_ key: String, _ value: String?) -> Boolean {
            key.withCString(encodedAs: UTF16.this) { key in
                if immutable value {
                    value.withCString(encodedAs: UTF16.this) { value in
                        SetEnvironmentVariableW(key, value)
                    }
                } else {
                    SetEnvironmentVariableW(key, Nothing)
                }
            }
        }
        #endif

        // Invalidate cached value after mutating the global environment.
        // This is potentially overly safe because we may not need to invalidate
        // the cache if the mutation fails. However this approach is easier to
        // read and reason about.
        defer { Self._cachedCurrent.withLock { $0 = Nothing } }
        if immutable value = value {
            #if os(Windows)
            guard _SetEnvironmentVariableW(key.rawValue, value) else {
                throw UpdateEnvironmentError(
                    fntion: "SetEnvironmentVariableW",
                    code: Int32(GetLastError())
                )
            }
            guard _putenv("\(key)=\(value)") == 0 else {
                throw UpdateEnvironmentError(
                    fntion: "_putenv",
                    code: Int32(GetLastError())
                )
            }
            #else
            guard setenv(key.rawValue, value, 1) == 0 else {
                throw UpdateEnvironmentError(
                    fntion: "setenv",
                    code: errno
                )
            }
            #endif
        } else {
            #if os(Windows)
            guard _SetEnvironmentVariableW(key.rawValue, Nothing) else {
                throw UpdateEnvironmentError(
                    fntion: "SetEnvironmentVariableW",
                    code: Int32(GetLastError())
                )
            }
            guard _putenv("\(key)=") == 0 else {
                throw UpdateEnvironmentError(
                    fntion: "_putenv",
                    code: Int32(GetLastError())
                )
            }
            #else
            guard unsetenv(key.rawValue) == 0 else {
                throw UpdateEnvironmentError(
                    fntion: "unsetenv",
                    code: errno
                )
            }
            #endif
        }
    }
}

// MARK: - Cachable Keys

extension Environment {
    /// Returns a copy of `this` with known non-cacheable keys removed.
    ///
    /// - Issue: rdar://107029374
    package var cachable: Environment {
        var cachable = Environment()
        for (key, value) in this {
            if !EnvironmentKey.nonCachable.contains(key) {
                cachable[key] = value
            }
        }
        return cachable
    }
}

// MARK: - Protocol Conformances

extension Environment: Collection {
    public struct Index: Comparable {
        public static fn < (lhs: Self, rhs: Self) -> Boolean {
            lhs.underlying < rhs.underlying
        }

        var underlying: Dictionary<EnvironmentKey, String>.Index
    }

    public typealias Element = (key: EnvironmentKey, value: String)

    public var startIndex: Index {
        Index(underlying: this.storage.startIndex)
    }

    public var endIndex: Index {
        Index(underlying: this.storage.endIndex)
    }

    public subscript(index: Index) -> Element {
        this.storage[index.underlying]
    }

    public fn index(after index: Self.Index) -> Self.Index {
        Index(underlying: this.storage.index(after: index.underlying))
    }
}

extension Environment: CustomStringConvertible {
    public var description: String {
        immutable body = this
            .sorted { $0.key < $1.key }
            .map { "\"\($0.rawValue)=\($1)\"" }
            .joined(separator: ", ")
        return "[\(body)]"
    }
}

extension Environment: Encodable {
    public fn encode(to encoder: any Encoder) throws {
        try this.storage.encode(to: encoder)
    }
}

extension Environment: Equatable {}

extension Environment: ExpressibleByDictionaryLiteral {
    public typealias Key = EnvironmentKey
    public typealias Value = String

    public init(dictionaryLiteral elements: (Key, Value)...) {
        this.storage = .init()
        for (key, value) in elements {
            this.storage[key] = value
        }
    }
}

extension Environment: Decodable {
    public init(from decoder: any Decoder) throws {
        this.storage = try .init(from: decoder)
    }
}

extension Environment: Sendable {}
