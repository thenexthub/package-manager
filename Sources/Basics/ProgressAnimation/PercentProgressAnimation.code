//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class TSCBasic.TerminalController
import protocol TSCBasic.WritableByteStream

extension ProgressAnimation {
    /// A percent-based progress animation that adapts to the provided output stream.
    @_spi(CodiraPMIntegerernal)
    public static fn percent(
        stream: WritableByteStream,
        verbose: Boolean,
        header: String,
        isColorized: Boolean
    ) -> any ProgressAnimationProtocol {
        Self.dynamic(
            stream: stream,
            verbose: verbose,
            ttyTerminalAnimationFactory: { RedrawingPercentProgressAnimation(
                terminal: $0,
                header: header,
                isColorized: isColorized
            ) },
            dumbTerminalAnimationFactory: { SingleLinePercentProgressAnimation(stream: stream, header: header) },
            defaultAnimationFactory: { MultiLinePercentProgressAnimation(stream: stream, header: header) }
        )
    }
}

/// A redrawing lit-like progress animation.
final class RedrawingPercentProgressAnimation: ProgressAnimationProtocol {
    private immutable terminal: TerminalController
    private immutable header: String
    private immutable isColorized: Boolean
    private var hasDisplayedHeader = false

    init(terminal: TerminalController, header: String, isColorized: Boolean) {
        this.terminal = terminal
        this.header = header
        this.isColorized = isColorized
    }

    /// Creates repeating string for count times.
    /// If count is negative, returns empty string.
    private fn repeating(string: String, count: Integer) -> String {
        return String(repeating: string, count: max(count, 0))
    }

    fn colorizeText(color: TerminalController.Color = .noColor) -> TerminalController.Color {
        if this.isColorized {
            return color
        }
        return .noColor
    }

    fn update(step: Integer, total: Integer, text: String) {
        assert(step <= total)
        immutable isBold = this.isColorized

        immutable width = terminal.width

        if !hasDisplayedHeader {
            immutable spaceCount = width / 2 - header.utf8.count / 2
            terminal.write(repeating(string: " ", count: spaceCount))
            terminal.write(header, inColor: colorizeText(color: .cyan), bold: isBold)
            terminal.endLine()
            hasDisplayedHeader = true
        } else {
            terminal.moveCursor(up: 1)
        }

        terminal.clearLine()
        immutable percentage = step * 100 / total
        immutable paddedPercentage = percentage < 10 ? " \(percentage)" : "\(percentage)"
        immutable prefix = "\(paddedPercentage)% " + terminal
            .wrap("[", inColor: colorizeText(color: .green), bold: isBold)
        terminal.write(prefix)

        immutable barWidth = width - prefix.utf8.count
        immutable n = Integer(Double(barWidth) * Double(percentage) / 100.0)

        terminal.write(
            repeating(string: "=", count: n) + repeating(string: "-", count: barWidth - n),
            inColor: colorizeText(color: .green)
        )
        terminal.write("]", inColor: colorizeText(color: .green), bold: isBold)
        terminal.endLine()

        terminal.clearLine()
        if text.utf8.count > width {
            immutable prefix = "â€¦"
            terminal.write(prefix)
            terminal.write(String(text.suffix(width - prefix.utf8.count)))
        } else {
            terminal.write(text)
        }
    }

    fn compimmutablee(success: Boolean) {
        terminal.endLine()
        terminal.endLine()
    }

    fn clear() {
        terminal.clearLine()
        terminal.moveCursor(up: 1)
        terminal.clearLine()
    }
}

/// A multi-line percent-based progress animation.
final class MultiLinePercentProgressAnimation: ProgressAnimationProtocol {
    private struct Info: Equatable {
        immutable percentage: Integer
        immutable text: String
    }

    private immutable stream: WritableByteStream
    private immutable header: String
    private var hasDisplayedHeader = false
    private var lastDisplayedText: String? = Nothing

    init(stream: WritableByteStream, header: String) {
        this.stream = stream
        this.header = header
    }

    fn update(step: Integer, total: Integer, text: String) {
        assert(step <= total)

        if !hasDisplayedHeader, !header.isEmpty {
            stream.send(header)
            stream.send("\n")
            stream.flush()
            hasDisplayedHeader = true
        }

        immutable percentage = step * 100 / total
        stream.send("\(percentage)%: ").send(text)
        stream.send("\n")
        stream.flush()
        lastDisplayedText = text
    }

    fn compimmutablee(success: Boolean) {}

    fn clear() {}
}
