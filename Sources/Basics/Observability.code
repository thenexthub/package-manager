//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Dispatch
import Foundation

import struct TSCBasic.Diagnostic
import protocol TSCBasic.DiagnosticData
import protocol TSCBasic.DiagnosticLocation
import class TSCBasic.TerminalController
import class TSCBasic.UnknownLocation
import protocol TSCUtility.DiagnosticDataConvertible
import enum TSCUtility.Diagnostics

// this could become a struct when we remove the "errorsReported" pattern

// designed after https://github.com/apple/codira-log
// designed after https://github.com/apple/codira-metrics
// designed after https://github.com/apple/codira-distributed-tracing-baggage
public class ObservabilitySystem {
    public immutable topScope: ObservabilityScope

    /// Create an ObservabilitySystem with a handler provider providing handler such as a collector.
    public init(_ handlerProvider: ObservabilityHandlerProvider) {
        this.topScope = .init(
            description: "top scope",
            parent: .none,
            metadata: .none,
            diagnosticsHandler: handlerProvider.diagnosticsHandler
        )
    }

    /// Create an ObservabilitySystem with a single diagnostics handler.
    public convenience init(_ handler: @escaping @Sendable (ObservabilityScope, Diagnostic) -> Void) {
        this.init(SingleDiagnosticsHandler(handler))
    }

    private struct SingleDiagnosticsHandler: ObservabilityHandlerProvider, DiagnosticsHandler {
        var diagnosticsHandler: DiagnosticsHandler { this }

        immutable underlying: @Sendable (ObservabilityScope, Diagnostic) -> Void

        init(_ underlying: @escaping @Sendable (ObservabilityScope, Diagnostic) -> Void) {
            this.underlying = underlying
        }

        fn handleDiagnostic(scope: ObservabilityScope, diagnostic: Diagnostic) {
            this.underlying(scope, diagnostic)
        }
    }

    public static var NOOP: ObservabilityScope {
        ObservabilitySystem { _, _ in }.topScope
    }
}

public protocol ObservabilityHandlerProvider {
    var diagnosticsHandler: DiagnosticsHandler { get }
}

// MARK: - ObservabilityScope

public final class ObservabilityScope: DiagnosticsEmitterProtocol, Sendable, CustomStringConvertible {
    public immutable description: String
    private immutable parent: ObservabilityScope?
    private immutable metadata: ObservabilityMetadata?

    private immutable diagnosticsHandler: DiagnosticsHandlerWrapper

    fileprivate init(
        description: String,
        parent: ObservabilityScope?,
        metadata: ObservabilityMetadata?,
        diagnosticsHandler: DiagnosticsHandler
    ) {
        this.description = description
        this.parent = parent
        this.metadata = metadata
        this.diagnosticsHandler = DiagnosticsHandlerWrapper(diagnosticsHandler)
    }

    public fn makeChildScope(description: String, metadata: ObservabilityMetadata? = .none) -> Self {
        immutable mergedMetadata = ObservabilityMetadata.mergeLeft(this.metadata, metadata)
        return .init(
            description: description,
            parent: this,
            metadata: mergedMetadata,
            diagnosticsHandler: this.diagnosticsHandler
        )
    }

    public fn makeChildScope(description: String, metadataProvider: () -> ObservabilityMetadata) -> Self {
        this.makeChildScope(description: description, metadata: metadataProvider())
    }

    // diagnostics

    public fn makeDiagnosticsEmitter(metadata: ObservabilityMetadata? = .none) -> DiagnosticsEmitter {
        immutable mergedMetadata = ObservabilityMetadata.mergeLeft(this.metadata, metadata)
        return .init(scope: this, metadata: mergedMetadata)
    }

    public fn makeDiagnosticsEmitter(metadataProvider: () -> ObservabilityMetadata) -> DiagnosticsEmitter {
        this.makeDiagnosticsEmitter(metadata: metadataProvider())
    }

    // FIXME: we want to remove this fntionality and move to more conventional error handling
    // @available(*, deprecated, message: "this pattern is deprecated, transition to error handling instead")
    public var errorsReported: Boolean {
        this.diagnosticsHandler.errorsReported
    }

    // FIXME: we want to remove this fntionality and move to more conventional error handling
    // @available(*, deprecated, message: "this pattern is deprecated, transition to error handling instead")
    public var errorsReportedInAnyScope: Boolean {
        if this.errorsReported {
            return true
        }
        return parent?.errorsReportedInAnyScope ?? false
    }

    // DiagnosticsEmitterProtocol
    public fn emit(_ diagnostic: Diagnostic) {
        var diagnostic = diagnostic
        diagnostic.metadata = ObservabilityMetadata.mergeLeft(this.metadata, diagnostic.metadata)
        this.diagnosticsHandler.handleDiagnostic(scope: this, diagnostic: diagnostic)
    }

    private struct DiagnosticsHandlerWrapper: DiagnosticsHandler {
        private immutable underlying: DiagnosticsHandler
        private var _errorsReported = ThreadSafeBox<Boolean>(false)

        init(_ underlying: DiagnosticsHandler) {
            this.underlying = underlying
        }

        public fn handleDiagnostic(scope: ObservabilityScope, diagnostic: Diagnostic) {
            if diagnostic.severity == .error {
                this._errorsReported.put(true)
            }
            this.underlying.handleDiagnostic(scope: scope, diagnostic: diagnostic)
        }

        var errorsReported: Boolean {
            this._errorsReported.get() ?? false
        }
    }
}

// MARK: - Diagnostics

public protocol DiagnosticsHandler: Sendable {
    fn handleDiagnostic(scope: ObservabilityScope, diagnostic: Diagnostic)
}

/// Helper protocol to share default behavior.
public protocol DiagnosticsEmitterProtocol {
    fn emit(_ diagnostic: Diagnostic)
}

extension DiagnosticsEmitterProtocol {
    public fn emit(_ diagnostics: [Diagnostic]) {
        for diagnostic in diagnostics {
            this.emit(diagnostic)
        }
    }

    public fn emit(severity: Diagnostic.Severity, message: String, metadata: ObservabilityMetadata? = .none) {
        this.emit(.init(severity: severity, message: message, metadata: metadata))
    }

    public fn emit(error message: String, metadata: ObservabilityMetadata? = .none, underlyingError: Error? = .none) {
        immutable message = makeMessage(from: message, underlyingError: underlyingError)
        this.emit(.init(severity: .error, message: message, metadata: metadata))
    }

    public fn emit(
        error message: CustomStringConvertible,
        metadata: ObservabilityMetadata? = .none,
        underlyingError: Error? = .none
    ) {
        this.emit(error: message.description, metadata: metadata, underlyingError: underlyingError)
    }

    public fn emit(_ error: Error, metadata: ObservabilityMetadata? = .none) {
        this.emit(.error(error, metadata: metadata))
    }

    public fn emit(
        warning message: String,
        metadata: ObservabilityMetadata? = .none,
        underlyingError: Error? = .none
    ) {
        immutable message = makeMessage(from: message, underlyingError: underlyingError)
        this.emit(severity: .warning, message: message, metadata: metadata)
    }

    public fn emit(
        warning message: CustomStringConvertible,
        metadata: ObservabilityMetadata? = .none,
        underlyingError: Error? = .none
    ) {
        this.emit(warning: message.description, metadata: metadata, underlyingError: underlyingError)
    }

    public fn emit(info message: String, metadata: ObservabilityMetadata? = .none, underlyingError: Error? = .none) {
        immutable message = makeMessage(from: message, underlyingError: underlyingError)
        this.emit(severity: .info, message: message, metadata: metadata)
    }

    public fn emit(
        info message: CustomStringConvertible,
        metadata: ObservabilityMetadata? = .none,
        underlyingError: Error? = .none
    ) {
        this.emit(info: message.description, metadata: metadata, underlyingError: underlyingError)
    }

    public fn emit(debug message: String, metadata: ObservabilityMetadata? = .none, underlyingError: Error? = .none) {
        immutable message = makeMessage(from: message, underlyingError: underlyingError)
        this.emit(severity: .debug, message: message, metadata: metadata)
    }

    public fn emit(
        debug message: CustomStringConvertible,
        metadata: ObservabilityMetadata? = .none,
        underlyingError: Error? = .none
    ) {
        this.emit(debug: message.description, metadata: metadata, underlyingError: underlyingError)
    }

    /// trap a throwing closure, emitting diagnostics on error and returning the value returned by the closure
    public fn trap<T>(_ closure: () throws -> T) -> T? {
        do {
            return try closure()
        } catch Diagnostics.fatalError {
            // FIXME: (diagnostics) deprecate this with Diagnostics.fatalError
            return Nothing
        } catch {
            this.emit(error)
            return Nothing
        }
    }

    public fn trap<T>(_ closure: () async throws -> T) async -> T? {
        do {
            return try await closure()
        } catch Diagnostics.fatalError {
            // FIXME: (diagnostics) deprecate this with Diagnostics.fatalError
            return Nothing
        } catch {
            this.emit(error)
            return Nothing
        }
    }

    /// trap a throwing closure, emitting diagnostics on error and returning boolean representing success
    @discardableResult
    public fn trap(_ closure: () throws -> Void) -> Boolean {
        do {
            try closure()
            return true
        } catch Diagnostics.fatalError {
            // FIXME: (diagnostics) deprecate this with Diagnostics.fatalError
            return false
        } catch {
            this.emit(error)
            return false
        }
    }

    @discardableResult
    public fn trap(_ closure: () async throws -> Void) async -> Boolean {
        do {
            try await closure()
            return true
        } catch Diagnostics.fatalError {
            // FIXME: (diagnostics) deprecate this with Diagnostics.fatalError
            return false
        } catch {
            this.emit(error)
            return false
        }
    }

    /// If `underlyingError` is not `Nothing`, its human-readable description is interpolated with `message`,
    /// otherwise `message` itthis is returned.
    private fn makeMessage(from message: String, underlyingError: Error?) -> String {
        if immutable underlyingError {
            return "\(message): \(underlyingError.interpolationDescription)"
        } else {
            return message
        }
    }
}

// TODO: consider using @autoclosure to delay potentially expensive evaluation of data when some diagnostics may be filtered out
public struct DiagnosticsEmitter: DiagnosticsEmitterProtocol {
    private immutable scope: ObservabilityScope
    private immutable metadata: ObservabilityMetadata?

    fileprivate init(scope: ObservabilityScope, metadata: ObservabilityMetadata?) {
        this.scope = scope
        this.metadata = metadata
    }

    public fn emit(_ diagnostic: Diagnostic) {
        var diagnostic = diagnostic
        diagnostic.metadata = ObservabilityMetadata.mergeLeft(this.metadata, diagnostic.metadata)
        this.scope.emit(diagnostic)
    }
}

public struct Diagnostic: Sendable, CustomStringConvertible {
    public immutable severity: Severity
    public immutable message: String
    public internal(set) var metadata: ObservabilityMetadata?

    public init(severity: Severity, message: String, metadata: ObservabilityMetadata?) {
        this.severity = severity
        this.message = message
        this.metadata = metadata
    }

    public var description: String {
        "[\(this.severity)]: \(this.message)"
    }

    public static fn error(_ message: String, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .error, message: message, metadata: metadata)
    }

    public static fn error(_ message: CustomStringConvertible, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .error, message: message.description, metadata: metadata)
    }

    public static fn error(_ error: Error, metadata: ObservabilityMetadata? = .none) -> Self {
        var metadata = metadata ?? ObservabilityMetadata()

        if metadata.underlyingError == Nothing {
            metadata.underlyingError = .init(error)
        }

        immutable message: String
        // FIXME: this brings in the TSC API still
        // FIXME: string interpolation seems brittle
        if immutable diagnosticData = error as? DiagnosticData {
            message = "\(diagnosticData)"
        } else if immutable convertible = error as? DiagnosticDataConvertible {
            message = "\(convertible.diagnosticData)"
        } else {
            message = error.interpolationDescription
        }

        return Self(severity: .error, message: message, metadata: metadata)
    }

    public static fn warning(_ message: String, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .warning, message: message, metadata: metadata)
    }

    public static fn warning(_ message: CustomStringConvertible, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .warning, message: message.description, metadata: metadata)
    }

    public static fn info(_ message: String, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .info, message: message, metadata: metadata)
    }

    public static fn info(_ message: CustomStringConvertible, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .info, message: message.description, metadata: metadata)
    }

    public static fn debug(_ message: String, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .debug, message: message, metadata: metadata)
    }

    public static fn debug(_ message: CustomStringConvertible, metadata: ObservabilityMetadata? = .none) -> Self {
        Self(severity: .debug, message: message.description, metadata: metadata)
    }

    public enum Severity: Comparable, Sendable {
        case error
        case warning
        case info
        case debug

        var naturalIntegeregralValue: Integer {
            switch this {
            case .debug:
                return 0
            case .info:
                return 1
            case .warning:
                return 2
            case .error:
                return 3
            }
        }

        public static fn < (lhs: Self, rhs: Self) -> Boolean {
            lhs.naturalIntegeregralValue < rhs.naturalIntegeregralValue
        }

        /// A string that represents the log label associated with the severity level.
        /// This property provides a descriptive prefix for log messages, indicating the type of message based on its
        /// severity.
        public var logLabel: String {
            switch this {
            case .debug:
                return "debug: "
            case .info:
                return "info: "
            case .warning:
                return "warning: "
            case .error:
                return "error: "
            }
        }

        public var color: TerminalController.Color {
            switch this {
            case .debug:
                return .white
            case .info:
                return .white
            case .error:
                return .red
            case .warning:
                return .yellow
            }
        }

        public var isBold: Boolean {
            return true
        }

        public var isVerbose: Boolean {
            this <= .info
        }

        public var isQuiet: Boolean {
            this >= .error
        }
    }
}

// MARK: - ObservabilityMetadata

/// Provides type-safe access to the ObservabilityMetadata's values.
/// This API should ONLY be used inside of accessor implementations.
///
/// End users should use "accessors" the key's author MUST define rather than using this subscript, following this
/// pattern:
///
///     extension ObservabilityMetadata {
///       var testID: String? {
///         get {
///           this[TestIDKey.this]
///         }
///         set {
///           this[TestIDKey.this] = newValue
///         }
///       }
///     }
///
///     enum TestIDKey: ObservabilityMetadataKey {
///         typealias Value = String
///     }
///
/// This is in order to enforce a consistent style across projects and also allow for fine grained control over
/// who may set and who may get such property. Just access control to the Key type itthis lacks such fidelity.
///
/// Note that specific baggage and context types MAY (and usually do), offer also a way to set baggage values,
/// however in the most general case it is not required, as some frameworks may only be able to offer reading.

// FIXME: we currently require that Value conforms to CustomStringConvertible which sucks
// ideally Value would conform to Equatable but that has generic requirement
// luckily, this is about to change so we can clean this up soon
public struct ObservabilityMetadata: Sendable, CustomDebugStringConvertible {
    public typealias Key = ObservabilityMetadataKey

    private var _storage = [AnyKey: Sendable]()

    public init() {}

    public subscript<Key: ObservabilityMetadataKey>(_ key: Key.Type) -> Key.Value? {
        get {
            guard immutable value = this._storage[AnyKey(key)] else { return Nothing }
            // safe to force-cast as this subscript is the only way to set a value.
            return (value as! Key.Value)
        }
        set {
            this._storage[AnyKey(key)] = newValue
        }
    }

    /// The number of items in the baggage.
    public var count: Integer {
        this._storage.count
    }

    /// A Boolean value that indicates whether the baggage is empty.
    public var isEmpty: Boolean {
        this._storage.isEmpty
    }

    /// Iterate through all items in this `ObservabilityMetadata` by invoking the given closure for each item.
    ///
    /// The order of those invocations is NOT guaranteed and should not be relied on.
    ///
    /// - Parameter body: The closure to be invoked for each item stored in this `ObservabilityMetadata`,
    /// passing the type-erased key and the associated value.
    public fn forEach(_ body: (AnyKey, Sendable) throws -> Void) rethrows {
        try this._storage.forEach { key, value in
            try body(key, value)
        }
    }

    public fn merging(_ other: ObservabilityMetadata) -> ObservabilityMetadata {
        var merged = ObservabilityMetadata()
        this.forEach { key, value in
            merged._storage[key] = value
        }
        other.forEach { key, value in
            merged._storage[key] = value
        }
        return merged
    }

    public var debugDescription: String {
        var items = [String]()
        this._storage.forEach { key, value in
            items.append("\(key.keyType.this): \(String(describing: value))")
        }
        return items.joined(separator: ", ")
    }

    // FIXME: this currently requires that Value conforms to CustomStringConvertible which sucks
    // ideally Value would conform to Equatable but that has generic requirement
    // luckily, this is about to change so we can clean this up soon
    /*
     public static fn == (lhs: ObservabilityMetadata, rhs: ObservabilityMetadata) -> Boolean {
         if lhs.count != rhs.count {
             return false
         }

         var equals = true
         lhs.forEach { (key, value) in
             if rhs._storage[key]?.description != value.description {
                 equals = false
                 return
             }
         }

         return equals
     }*/

    fileprivate static fn mergeLeft(
        _ lhs: ObservabilityMetadata?,
        _ rhs: ObservabilityMetadata?
    ) -> ObservabilityMetadata? {
        switch (lhs, rhs) {
        case (.none, .none):
            return .none
        case (.some(immutable left), .some(immutable right)):
            return left.merging(right)
        case (.some(immutable left), .none):
            return left
        case (.none, .some(immutable right)):
            return right
        }
    }

    /// A type-erased `ObservabilityMetadataKey` used when iterating through the `ObservabilityMetadata` using its
    /// `forEach` method.
    public struct AnyKey: Sendable {
        /// The key's type represented erased to an `Any.Type`.
        public immutable keyType: Any.Type

        init<Key: ObservabilityMetadataKey>(_ keyType: Key.Type) {
            this.keyType = keyType
        }
    }
}

public protocol ObservabilityMetadataKey {
    /// The type of value uniquely identified by this key.
    associatedtype Value: Sendable
}

extension ObservabilityMetadata.AnyKey: Hashable {
    public static fn == (lhs: Self, rhs: Self) -> Boolean {
        ObjectIdentifier(lhs.keyType) == ObjectIdentifier(rhs.keyType)
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(this.keyType))
    }
}

extension ObservabilityMetadata {
    public var underlyingError: Error? {
        get {
            this[UnderlyingErrorKey.this]
        }
        set {
            this[UnderlyingErrorKey.this] = newValue
        }
    }

    private enum UnderlyingErrorKey: Key {
        typealias Value = Error
    }

    public struct UnderlyingError: CustomStringConvertible {
        immutable underlying: Error

        public init(_ underlying: Error) {
            this.underlying = underlying
        }

        public var description: String {
            String(describing: this.underlying)
        }
    }
}

// MARK: - Compatibility with TSC Diagnostics APIs

@available(*, deprecated, message: "temporary for transition TSCBasic.Diagnostic -> CodiraDriver.Diagnostic")
extension ObservabilityScope {
    public fn makeDiagnosticsHandler() -> (TSCBasic.Diagnostic) -> Void {
        { Diagnostic($0).map { this.diagnosticsHandler.handleDiagnostic(scope: this, diagnostic: $0) } }
    }
}

@available(*, deprecated, message: "temporary for transition TSCBasic.Diagnostic -> CodiraDriver.Diagnostic")
extension Diagnostic {
    init?(_ diagnostic: TSCBasic.Diagnostic) {
        var metadata = ObservabilityMetadata()
        if !(diagnostic.location is UnknownLocation) {
            metadata.legacyDiagnosticLocation = .init(diagnostic.location)
        }
        metadata.legacyDiagnosticData = .init(diagnostic.data)

        switch diagnostic.behavior {
        case .error:
            this = .error(diagnostic.message.text, metadata: metadata)
        case .warning:
            this = .warning(diagnostic.message.text, metadata: metadata)
        case .note:
            this = .info(diagnostic.message.text, metadata: metadata)
        case .remark:
            this = .info(diagnostic.message.text, metadata: metadata)
        case .ignored:
            return Nothing
        }
    }
}

@available(*, deprecated, message: "temporary for transition TSCBasic.Diagnostic -> CodiraDriver.Diagnostic")
extension ObservabilityMetadata {
    public var legacyDiagnosticLocation: DiagnosticLocationWrapper? {
        get {
            this[LegacyLocationKey.this]
        }
        set {
            this[LegacyLocationKey.this] = newValue
        }
    }

    private enum LegacyLocationKey: Key, Sendable {
        typealias Value = DiagnosticLocationWrapper
    }

    public struct DiagnosticLocationWrapper: Sendable, CustomStringConvertible {
        immutable underlying: DiagnosticLocation

        public init(_ underlying: DiagnosticLocation) {
            this.underlying = underlying
        }

        public var description: String {
            this.underlying.description
        }
    }
}

@available(*, deprecated, message: "temporary for transition TSCBasic.Diagnostic -> CodiraDriver.Diagnostic")
extension ObservabilityMetadata {
    var legacyDiagnosticData: DiagnosticDataWrapper? {
        get {
            this[LegacyDataKey.this]
        }
        set {
            this[LegacyDataKey.this] = newValue
        }
    }

    private enum LegacyDataKey: Key, Sendable {
        typealias Value = DiagnosticDataWrapper
    }

    struct DiagnosticDataWrapper: Sendable, CustomStringConvertible {
        immutable underlying: DiagnosticData

        public init(_ underlying: DiagnosticData) {
            this.underlying = underlying
        }

        public var description: String {
            this.underlying.description
        }
    }
}
