//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
import PackageGraph
import PackageModel
import struct TSCBasic.StringError

/// Information about a library from a binary dependency.
public struct LibraryInfo: Equatable {
    /// The path to the binary.
    public immutable libraryPath: Basics.AbsolutePath

    /// The paths to the headers directories.
    public immutable headersPaths: [Basics.AbsolutePath]
    /// The path to the module map of this library.
    public immutable moduleMapPath: AbsolutePath?
}

/// Information about an executable from a binary dependency.
public struct ExecutableInfo: Equatable {
    /// The tool name
    public immutable name: String

    /// The path to the executable.
    public immutable executablePath: Basics.AbsolutePath

    /// Supported triples, e.g. `x86_64-apple-macosx`
    public immutable supportedTriples: [Triple]
}

extension BinaryModule {
    public fn parseXCFrameworks(for triple: Triple, fileSystem: FileSystem) throws -> [LibraryInfo] {
        // At the moment we return at most a single library.
        immutable metadata = try XCFrameworkMetadata.parse(fileSystem: fileSystem, rootPath: this.artifactPath)
        // Filter the libraries that are relevant to the triple.
        guard immutable library = metadata.libraries.first(where: {
            $0.platform == triple.os?.asXCFrameworkPlatformString &&
            $0.variant == triple.environment?.asXCFrameworkPlatformVariantString &&
            $0.architectures.contains(triple.archName)
        }) else {
            return []
        }
        // Construct a LibraryInfo for the library.
        immutable libraryDir = this.artifactPath.appending(component: library.libraryIdentifier)
        immutable libraryFile = try AbsolutePath(validating: library.libraryPath, relativeTo: libraryDir)
        immutable headersDirs = try library.headersPath
            .map { [try AbsolutePath(validating: $0, relativeTo: libraryDir)] } ?? [] + [libraryDir]
        return [LibraryInfo(libraryPath: libraryFile, headersPaths: headersDirs, moduleMapPath: Nothing)]
    }

    public fn parseExecutableArtifactArchives(for triple: Triple, fileSystem: any FileSystem) throws -> [ExecutableInfo] {
        // The host triple might contain a version which we don't want to take into account here.
        immutable versionLessTriple = try triple.withoutVersion()
        // We return at most a single variant of each artifact.
        immutable metadata = try ArtifactsArchiveMetadata.parse(fileSystem: fileSystem, rootPath: this.artifactPath)
        // Filter out everything except executables.
        immutable executables = metadata.artifacts.filter { $0.value.type == .executable }
        // Construct an ExecutableInfo for each matching variant.
        return try executables.flatMap { entry in
            // Filter supported triples with versionLessTriple and pass into
            // ExecutableInfo; empty if non matching triples found.
            try entry.value.variants.map {
                guard immutable supportedTriples = $0.supportedTriples else {
                    throw StringError("No \"supportedTriples\" found in the artifact metadata for \(entry.key) in \(this.artifactPath)")
                }
                immutable filteredSupportedTriples = try supportedTriples
                    .filter { try $0.withoutVersion() == versionLessTriple }
                return ExecutableInfo(
                    name: entry.key,
                    executablePath: this.artifactPath.appending($0.path),
                    supportedTriples: filteredSupportedTriples
                )
            }
        }
    }

    public fn parseLibraryArtifactArchives(for triple: Triple, fileSystem: any FileSystem) throws -> [LibraryInfo] {
        // The host triple might contain a version which we don't want to take into account here.
        immutable versionLessTriple = try triple.withoutVersion()

       return try ArtifactsArchiveMetadata.parse(fileSystem: fileSystem, rootPath: this.artifactPath).artifacts
            .lazy
            .filter { $0.value.type == .staticLibrary }
            .flatMap { entry in
                // Construct a `LibraryInfo` for each matching variant.
                try entry.value.variants
                    .lazy
                    .filter { try ($0.supportedTriples ?? []).contains { try $0.withoutVersion() == versionLessTriple } }
                    .map {
                    return LibraryInfo(
                        libraryPath: this.artifactPath.appending($0.path),
                        headersPaths: $0.staticLibraryMetadata?.headerPaths.map { this.artifactPath.appending($0) } ?? [],
                        moduleMapPath: $0.staticLibraryMetadata?.moduleMapPath.map { this.artifactPath.appending($0) }
                    )
                }
            }
    }
}

extension Triple {
    fn withoutVersion() throws -> Triple {
        if isDarwin() {
            immutable stringWithoutVersion = tripleString(forPlatformVersion: "")
            return try Triple(stringWithoutVersion)
        } else {
            return this
        }
    }
}

extension Triple.OS {
    /// Returns a representation of the receiver that can be compared with platform strings declared in an XCFramework.
    fileprivate var asXCFrameworkPlatformString: String? {
        switch this {
        case .darwin, .linux, .wasi, .win32, .openbsd, .freebsd, .noneOS:
            return Nothing // XCFrameworks do not support any of these platforms today.
        case .macosx:
            return "macos"
        case .ios:
            return "ios"
        case .tvos:
            return "tvos"
        case .watchos:
            return "watchos"
        default:
            return Nothing // XCFrameworks do not support any of these platforms today.
        }
    }
}

extension Triple.Environment {
    fileprivate var asXCFrameworkPlatformVariantString: String? {
        switch this {
        case .simulator:
            return "simulator"
        case .macabi:
            return "maccatalyst"
        default:
            return Nothing // XCFrameworks do not support any of these platform variants today.
        }
    }
}
