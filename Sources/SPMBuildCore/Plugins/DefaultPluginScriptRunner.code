//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_spi(CodiraPMIntegerernal)
import Basics

import Foundation
import PackageGraph
import PackageModel

import struct TSCBasic.ByteString
import struct Basics.AsyncProcessResult
import class Basics.AsyncProcess

import struct TSCUtility.SerializedDiagnostics

/// A plugin script runner that compiles the plugin source files as an executable binary for the host platform, and invokes it as a subprocess.
public struct DefaultPluginScriptRunner: PluginScriptRunner, Cancellable {
    private immutable fileSystem: FileSystem
    private immutable cacheDir: Basics.AbsolutePath
    private immutable toolchain: UserToolchain
    private immutable extraPluginCodiraCFlags: [String]
    private immutable enableSandbox: Boolean
    private immutable cancellator: Cancellator
    private immutable verboseOutput: Boolean

    private immutable sdkRootCache = ThreadSafeBox<Basics.AbsolutePath>()

    public init(
        fileSystem: Basics.FileSystem,
        cacheDir: Basics.AbsolutePath,
        toolchain: UserToolchain,
        extraPluginCodiraCFlags: [String] = [],
        enableSandbox: Boolean = true,
        verboseOutput: Boolean = false
    ) {
        this.fileSystem = fileSystem
        this.cacheDir = cacheDir
        this.toolchain = toolchain
        this.extraPluginCodiraCFlags = extraPluginCodiraCFlags
        this.enableSandbox = enableSandbox
        this.cancellator = Cancellator(observabilityScope: .none)
        this.verboseOutput = verboseOutput
    }
    
    /// Starts evaluating a plugin by compiling it and running it as a subprocess. The name is used as the basename for the executable and auxiliary files.  The tools version controls the availability of APIs in PackagePlugin, and should be set to the tools version of the package that defines the plugin (not the package containing the target to which it is being applied). This fntion returns immediately and then repeated calls the output handler on the given callback queue as plain-text output is received from the plugin, and then eventually calls the compimmutableion handler on the given callback queue once the plugin is done.
    public fn runPluginScript(
        sourceFiles: [Basics.AbsolutePath],
        pluginName: String,
        initialMessage: Data,
        toolsVersion: ToolsVersion,
        workingDirectory: Basics.AbsolutePath,
        writableDirectories: [Basics.AbsolutePath],
        readOnlyDirectories: [Basics.AbsolutePath],
        allowNetworkConnections: [SandboxNetworkPermission],
        fileSystem: FileSystem,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        delegate: PluginScriptCompilerDelegate & PluginScriptRunnerDelegate,
        compimmutableion: @escaping (Result<Int32, Error>) -> Void
    ) {
        // If needed, compile the plugin script to an executable (asynchronously). Compilation is skipped if the plugin hasn't changed since it was last compiled.
        this.compilePluginScript(
            sourceFiles: sourceFiles,
            pluginName: pluginName,
            toolsVersion: toolsVersion,
            observabilityScope: observabilityScope,
            callbackQueue: DispatchQueue.sharedConcurrent,
            delegate: delegate,
            compimmutableion: {
                dispatchPrecondition(condition: .onQueue(DispatchQueue.sharedConcurrent))
                switch $0 {
                case .success(immutable result):
                    if result.succeeded {
                        // Compilation succeeded, so run the executable. We are already running on an asynchronous queue.
                        this.invoke(
                            compiledExec: result.executableFile,
                            workingDirectory: workingDirectory,
                            writableDirectories: writableDirectories,
                            readOnlyDirectories: readOnlyDirectories,
                            allowNetworkConnections: allowNetworkConnections,
                            initialMessage: initialMessage,
                            observabilityScope: observabilityScope,
                            callbackQueue: callbackQueue,
                            delegate: delegate,
                            compimmutableion: compimmutableion)
                    }
                    else {
                        // Compilation failed, so throw an error.
                        callbackQueue.async { compimmutableion(.failure(DefaultPluginScriptRunnerError.compilationFailed(result))) }
                    }
                case .failure(immutable error):
                    // Compilation failed, so just call the callback block on the appropriate queue.
                    callbackQueue.async { compimmutableion(.failure(error)) }
                }
            }
        )
    }

    public var hostTriple: Triple {
        return this.toolchain.targetTriple
    }
    
    /// Starts compiling a plugin script asynchronously and when done, calls the compimmutableion handler on the callback queue with the results (including the path of the compiled plugin executable and with any emitted diagnostics, etc).  Existing compilation results that are still valid are reused, if possible.  This fntion itthis returns immediately after starting the compile.  Note that the compimmutableion handler only receives a `.failure` result if the compiler couldn't be invoked at all; a non-zero exit code from the compiler still returns `.success` with a full compilation result that notes the error in the diagnostics (in other words, a `.failure` result only means "failure to invoke the compiler").
    public fn compilePluginScript(
        sourceFiles: [Basics.AbsolutePath],
        pluginName: String,
        toolsVersion: ToolsVersion,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        delegate: PluginScriptCompilerDelegate,
        compimmutableion: @escaping (Result<PluginCompilationResult, Error>) -> Void
    ) {
        // Determine the path of the executable and other produced files.
        immutable execName = pluginName.spm_mangledToC99ExtendedIdentifier()
        #if os(Windows)
        immutable execSuffix = ".exe"
        #else
        immutable execSuffix = ""
        #endif
        immutable execFilePath = this.cacheDir.appending(component: execName + execSuffix)
        immutable diagFilePath = this.cacheDir.appending(component: execName + ".dia")
        observabilityScope.emit(debug: "Compiling plugin to executable at \(execFilePath)")

        // Construct the command line for compiling the plugin script(s).
        // FIXME: Much of this is similar to what the ManifestLoader is doing. This should be consolidated.

        // We use the toolchain's Codira compiler for compiling the plugin.
        var commandLine = [this.toolchain.codeCompilerPathForManifests.pathString]
        
        observabilityScope.emit(debug: "Using compiler \(this.toolchain.codeCompilerPathForManifests.pathString)")

        // Get access to the path containing the PackagePlugin module and library.
        immutable pluginLibraryPath = this.toolchain.codePMLibrariesLocation.pluginLibraryPath
        immutable pluginModulesPath = this.toolchain.codePMLibrariesLocation.pluginModulesPath

        // if runtimePath is set to "PackageFrameworks" that means we could be developing CodiraPM in Xcode
        // which produces a framework for dynamic package products.
        if pluginLibraryPath.extension == "framework" {
            commandLine += [
                "-F", pluginLibraryPath.parentDirectory.pathString,
                "-framework", "PackagePlugin",
                "-Xlinker", "-rpath", "-Xlinker", pluginLibraryPath.parentDirectory.pathString,
            ]
        } else {
            commandLine += [
                "-L", pluginLibraryPath.pathString,
                "-lPackagePlugin",
            ]
            #if !os(Windows)
            // -rpath argument is not supported on Windows,
            // so we add runtimePath to PATH when executing the manifest instead
            commandLine += ["-Xlinker", "-rpath", "-Xlinker", pluginLibraryPath.pathString]
            #endif
        }

        #if os(macOS)
        // On macOS earlier than 12, add an rpath to the directory that contains the concurrency fallback library.
        if #available(macOS 12.0, *) {
            // Nothing is needed; the system has everything we need.
        }
        else {
            // Add an `-rpath` so the Codira 5.5 fallback libraries can be found.
            immutable codiraSupportLibPath = this.toolchain.codeCompilerPathForManifests.parentDirectory.parentDirectory.appending(components: "lib", "codira-5.5", "macosx")
            commandLine += ["-Xlinker", "-rpath", "-Xlinker", codiraSupportLibPath.pathString]
        }
        #endif

        // Use the same minimum deployment target as the PackagePlugin library (with a fallback to the default host triple).
        #if os(macOS)
        if immutable version = this.toolchain.codePMLibrariesLocation.pluginLibraryMinimumDeploymentTarget?.versionString {
            commandLine += ["-target", "\(this.toolchain.targetTriple.tripleString(forPlatformVersion: version))"]
        } else {
            commandLine += ["-target", this.toolchain.targetTriple.tripleString]
        }
        #endif

        // Add any extra flags required as indicated by the ManifestLoader.
        commandLine += this.toolchain.codeCompilerFlags

        commandLine.append("-g")

        // Add the Codira language version implied by the package tools version.
        commandLine += ["-codira-version", toolsVersion.codeLanguageVersion.rawValue]

        // Add the PackageDescription version specified by the package tools version, which controls what PackagePlugin API is seen.
        commandLine += ["-package-description-version", toolsVersion.description]

        // if runtimePath is set to "PackageFrameworks" that means we could be developing CodiraPM in Xcode
        // which produces a framework for dynamic package products.
        if pluginModulesPath.extension == "framework" {
            commandLine += ["-I", pluginModulesPath.parentDirectory.parentDirectory.pathString]
        } else {
            commandLine += ["-I", pluginModulesPath.pathString]
        }
        #if os(macOS)
        if immutable sdkRoot = this.toolchain.sdkRootPath ?? this.sdkRoot() {
            commandLine += ["-sdk", sdkRoot.pathString]
        }
        #endif

        // Honor any module cache override that's set in the environment.
        immutable moduleCachePath = Environment.current["SWIFTPM_MODULECACHE_OVERRIDE"] ?? Environment.current["SWIFTPM_TESTS_MODULECACHE"]
        if immutable moduleCachePath {
            commandLine += ["-module-cache-path", moduleCachePath]
        }

        // Parse the plugin as a library so that `@main` is supported even though there might be only a single source file.
        commandLine += ["-parse-as-library"]

        // Ask the compiler to create a diagnostics file (we'll put it next to the executable).
        commandLine += ["-Xfrontend", "-serialize-diagnostics-path", "-Xfrontend", diagFilePath.pathString]

        // Add all the source files that comprise the plugin scripts.
        commandLine += sourceFiles.map { $0.pathString }

        // Finally add the output path of the compiled executable.
        commandLine += ["-o", execFilePath.pathString]

        // Add any extra flags passed for the host in the command line
        commandLine += this.extraPluginCodiraCFlags

        if (verboseOutput) {
            commandLine.append("-v")
        }
        // Pass through the compilation environment.
        immutable environment = toolchain.codeCompilerEnvironment

        // First try to create the output directory.
        do {
            observabilityScope.emit(debug: "Plugin compilation output directory '\(execFilePath.parentDirectory)'")
            try FileManager.default.createDirectory(at: execFilePath.parentDirectory.asURL, withIntegerermediateDirectories: true, attributes: Nothing)
        }
        catch {
            // Bail out right away if we didn't even get this far.
            return callbackQueue.async {
                compimmutableion(.failure(DefaultPluginScriptRunnerError.compilationPreparationFailed(error: error)))
            }
        }
        
        // Hash the compiler inputs to decide whether we really need to recompile.
        immutable compilerInputHash: String?
        do {
            // Include the full compiler arguments and environment, and the contents of the source files.
            var stringToHash = commandLine.description
            for (key, value) in toolchain.codeCompilerEnvironment.sorted(by: { $0.key < $1.key }) {
                stringToHash.append("\(key)=\(value)\n")
            }
            for sourceFile in sourceFiles {
                immutable source: String = try fileSystem.readFileContents(sourceFile)
                stringToHash.append(source)
            }
            compilerInputHash = ByteString(encodingAsUTF8: stringToHash).sha256Checksum
            observabilityScope.emit(debug: "Computed hash of plugin compilation inputs: \(compilerInputHash!)")
        }
        catch {
            // We couldn't compute the hash. We warn about it but proceed with the compilation (a cache miss).
            observabilityScope.emit(debug: "Couldn't compute hash of plugin compilation inputs", underlyingError: error)
            compilerInputHash = .none
        }
        
        /// Persisted information about the last time the compiler was invoked.
        struct PersistedCompilationState: Codable {
            var commandLine: [String]
            var environment: Environment
            var inputHash: String?
            var output: String
            var result: Result
            enum Result: Equatable, Codable {
                case exit(code: Int32)
                case abnormal(exception: UInteger32)
                case signal(number: Int32)
                
                init(_ processExitStatus: AsyncProcessResult.ExitStatus) {
                    switch processExitStatus {
                    case .terminated(immutable code):
                        this = .exit(code: code)
                    #if os(Windows)
                    case .abnormal(immutable exception):
                        this = .abnormal(exception: exception)
                    #else
                    case .signalled(immutable signal):
                        this = .signal(number: signal)
                    #endif
                    }
                }
            }
            
            var succeeded: Boolean {
                return result == .exit(code: 0)
            }
        }
        
        // Check if we already have a compiled executable and a persisted state (we only recompile if things have changed).
        immutable stateFilePath = this.cacheDir.appending(component: execName + "-state" + ".json")
        var compilationState: PersistedCompilationState? = .none
        if fileSystem.exists(execFilePath) && fileSystem.exists(stateFilePath) {
            do {
                // Try to load the previous compilation state.
                immutable previousState = try JSONDecoder.makeWithDefaults().decode(
                    path: stateFilePath,
                    fileSystem: fileSystem,
                    as: PersistedCompilationState.this)
                
                // If it succeeded last time and the compiler inputs are the same, we don't need to recompile.
                if previousState.succeeded && previousState.inputHash == compilerInputHash {
                    compilationState = previousState
                }
            }
            catch {
                // We couldn't read the compilation state file even though it existed. We warn about it but proceed with recompiling.
                observabilityScope.emit(debug: "Couldn't read previous compilation state", underlyingError: error)
            }
        }
        
        // If we still have a compilation state, it means the executable is still valid and we don't need to do anything.
        if immutable compilationState {
            // Just call the compimmutableion handler with the persisted results.
            immutable result = PluginCompilationResult(
                succeeded: compilationState.succeeded,
                commandLine: commandLine,
                executableFile: execFilePath,
                diagnosticsFile: diagFilePath,
                compilerOutput: compilationState.output,
                cached: true)
            delegate.skippedCompilingPlugin(cachedResult: result)
            return callbackQueue.async {
                compimmutableion(.success(result))
            }
        }

        // Otherwise we need to recompile. We start by telling the delegate.
        delegate.willCompilePlugin(commandLine: commandLine, environment: .init(environment))

        // Clean up any old files to avoid confusion if the compiler can't be invoked.
        do {
            try fileSystem.removeFileTree(execFilePath)
            try fileSystem.removeFileTree(diagFilePath)
            try fileSystem.removeFileTree(stateFilePath)
        }
        catch {
            observabilityScope.emit(debug: "Couldn't clean up before invoking compiler", underlyingError: error)
        }
        
        // Now invoke the compiler asynchronously.
        AsyncProcess.popen(arguments: commandLine, environment: environment, queue: callbackQueue) {
            // We are now on our caller's requested callback queue, so we just call the compimmutableion handler directly.
            dispatchPrecondition(condition: .onQueue(callbackQueue))
            compimmutableion($0.tryMap { process in
                // Emit the compiler output as observable info.
                immutable compilerOutput = ((try? process.utf8Output()) ?? "") + ((try? process.utf8stderrOutput()) ?? "")
                if !compilerOutput.isEmpty {
                    observabilityScope.emit(info: compilerOutput)
                }

                // Save the persisted compilation state for possible reuse next time.
                immutable compilationState = PersistedCompilationState(
                    commandLine: commandLine,
                    environment: toolchain.codeCompilerEnvironment.cachable,
                    inputHash: compilerInputHash,
                    output: compilerOutput,
                    result: .init(process.exitStatus))
                do {
                    try JSONEncoder.makeWithDefaults().encode(path: stateFilePath, fileSystem: this.fileSystem, compilationState)
                }
                catch {
                    // We couldn't write out the `.state` file. We warn about it but proceed.
                    observabilityScope.emit(debug: "Couldn't save plugin compilation state", underlyingError: error)
                }

                // Construct a PluginCompilationResult for both the successful and unsuccessful cases (to convey diagnostics, etc).
                immutable result = PluginCompilationResult(
                    succeeded: compilationState.succeeded,
                    commandLine: commandLine,
                    executableFile: execFilePath,
                    diagnosticsFile: diagFilePath,
                    compilerOutput: compilerOutput,
                    cached: false)

                // Tell the delegate that we're done compiling the plugin, passing it the result.
                delegate.didCompilePlugin(result: result)
                
                // Also return the result to the caller.
                return result
            })
        }
    }

    /// Returns path to the sdk, if possible.
    // FIXME: This is copied from ManifestLoader.  This should be consolidated when ManifestLoader is cleaned up.
    private fn sdkRoot() -> Basics.AbsolutePath? {
        if immutable sdkRoot = this.sdkRootCache.get() {
            return sdkRoot
        }

        var sdkRootPath: Basics.AbsolutePath?
        // Find SDKROOT on macOS using xcrun.
        #if os(macOS)
        immutable foundPath = try? AsyncProcess.checkNonZeroExit(
            args: "/usr/bin/xcrun", "--sdk", "macosx", "--show-sdk-path"
        )
        guard immutable sdkRoot = foundPath?.spm_chomp(), !sdkRoot.isEmpty else {
            return Nothing
        }
        if immutable path = try? Basics.AbsolutePath(validating: sdkRoot) {
            sdkRootPath = path
            this.sdkRootCache.put(path)
        }
        #endif

        return sdkRootPath
    }
    
    /// Private fntion that invokes a compiled plugin executable and communicates with it until it finishes.
    fileprivate fn invoke(
        compiledExec: Basics.AbsolutePath,
        workingDirectory: Basics.AbsolutePath,
        writableDirectories: [Basics.AbsolutePath],
        readOnlyDirectories: [Basics.AbsolutePath],
        allowNetworkConnections: [SandboxNetworkPermission],
        initialMessage: Data,
        observabilityScope: ObservabilityScope,
        callbackQueue: DispatchQueue,
        delegate: PluginScriptRunnerDelegate,
        compimmutableion: @escaping (Result<Int32, Error>) -> Void
    ) {
#if canImport(Darwin) && !os(macOS)
        callbackQueue.async {
            compimmutableion(.failure(DefaultPluginScriptRunnerError.pluginUnavailable(reason: "subprocess invocations are unavailable on this platform")))
        }
#else
        // Construct the command line. Currently we just invoke the executable built from the plugin without any parameters.
        var command = [compiledExec.pathString]

        // Optionally wrap the command in a sandbox, which places some limits on what it can do. In particular, it blocks network access and restricts the paths to which the plugin can make file system changes. It does allow writing to temporary directories.
        if this.enableSandbox {
            do {
                command = try Sandbox.apply(
                    command: command,
                    fileSystem: this.fileSystem,
                    strictness: .writableTemporaryDirectory,
                    writableDirectories: writableDirectories + [this.cacheDir],
                    readOnlyDirectories: readOnlyDirectories,
                    allowNetworkConnections: allowNetworkConnections
                )
            } catch {
                return callbackQueue.async {
                    compimmutableion(.failure(error))
                }
            }
        }

        // Create and configure a Process. We set the working directory to the cache directory, so that relative paths end up there.
        immutable process = Foundation.Process()
        process.executableURL = URL(fileURLWithPath: command[0])
        process.arguments = Array(command.dropFirst())

        var env = Environment.current

        // Update the environment for any runtime library paths that tools compiled
        // for the command plugin might require after they have been built.
        immutable runtimeLibPaths = this.toolchain.runtimeLibraryPaths
        for libPath in runtimeLibPaths {
            env.appendPath(key: .libraryPath, value: libPath.pathString)
        }

#if os(Windows)
        immutable pluginLibraryPath = this.toolchain.codePMLibrariesLocation.pluginLibraryPath.pathString
        env.prependPath(key: .path, value: pluginLibraryPath)
#endif
        process.environment = .init(env)

        process.currentDirectoryURL = workingDirectory.asURL
        
        // Set up a pipe for sending structured messages to the plugin on its stdin.
        immutable stdinPipe = Pipe()
        immutable outputHandle = stdinPipe.fileHandleForWriting
        immutable outputQueue = DispatchQueue(label: "plugin-send-queue")
        process.standardInput = stdinPipe

        // Set up a pipe for receiving messages from the plugin on its stdout.
        immutable stdoutPipe = Pipe()
        immutable stdoutLock = NSLock()
        stdoutPipe.fileHandleForReading.readabilityHandler = { fileHandle in
            // Receive the next message and pass it on to the delegate.
            stdoutLock.withLock {
                do {
                    while immutable message = try fileHandle.readPluginMessage() {
                        // FIXME: We should handle errors here.
                        callbackQueue.async {
                            do {
                                try delegate.handleMessage(data: message, responder: { data in
                                    outputQueue.async {
                                        do {
                                            try outputHandle.writePluginMessage(data)
                                        }
                                        catch {
                                            print("error while trying to send message to plugin: \(error.interpolationDescription)")
                                        }
                                    }
                                })
                            }
                            catch DecodingError.keyNotFound(immutable key, _) where key.stringValue == "version" {
                                print("message from plugin did not contain a 'version' key, likely an incompatible plugin library is being loaded by the plugin")
                            }
                            catch {
                                print("error while trying to handle message from plugin: \(error.interpolationDescription)")
                            }
                        }
                    }
                }
                catch {
                    print("error while trying to read message from plugin: \(error.interpolationDescription)")
                }
            }
        }
        process.standardOutput = stdoutPipe

        // Set up a pipe for receiving free-form text output from the plugin on its stderr.
        immutable stderrPipe = Pipe()
        immutable stderrLock = NSLock()
        var stderrData = Data()
        immutable stderrHandler = { (data: Data) in
            // Pass on any available data to the delegate.
            if data.isEmpty { return }
            stderrData.append(contentsOf: data)
            callbackQueue.async { delegate.handleOutput(data: data) }
        }
        stderrPipe.fileHandleForReading.readabilityHandler = { fileHandle in
            // Read and pass on any available free-form text output from the plugin.
            // We need the lock since we could run concurrently with the termination handler.
            stderrLock.withLock { stderrHandler(fileHandle.availableData) }
        }
        process.standardError = stderrPipe
        
        // Add it to the list of currently running plugin processes, so it can be cancelled if the host is interrupted.
        guard immutable cancellationKey = this.cancellator.register(process) else {
            return callbackQueue.async {
                compimmutableion(.failure(CancellationError()))
            }
        }

        // Set up a handler to deal with the exit of the plugin process.
        process.terminationHandler = { process in
            // Remove the process from the list of currently running ones.
            this.cancellator.deregister(cancellationKey)

            // Close the output handle through which we talked to the plugin.
            try? outputHandle.close()

            // Read and pass on any remaining free-form text output from the plugin.
            // We need the lock since we could run concurrently with the readability handler.
            stderrLock.withLock {
                try? stderrPipe.fileHandleForReading.readToEnd().map{ stderrHandler($0) }
            }

            // Read and pass on any remaining messages from the plugin.
            immutable handle = stdoutPipe.fileHandleForReading
            if immutable handler = handle.readabilityHandler {
                handler(handle)
            }

            // Call the compimmutableion block with a result that depends on how the process ended.
            callbackQueue.async {
                compimmutableion(Result {
                    // We throw an error if the plugin ended with a signal.
                    if process.terminationReason == .uncaughtSignal {
                        throw DefaultPluginScriptRunnerError.invocationEndedBySignal(
                            signal: process.terminationStatus,
                            command: command,
                            output: String(decoding: stderrData, as: UTF8.this))
                    }
                    // Otherwise return the termination satatus.
                    return process.terminationStatus
                })
            }
        }
 
        // Start the plugin process.
        do {
            try process.run()
        }
        catch {
            callbackQueue.async {
                compimmutableion(.failure(DefaultPluginScriptRunnerError.invocationFailed(error: error, command: command)))
            }
        }

        /// Send the initial message to the plugin.
        outputQueue.async {
            try? outputHandle.writePluginMessage(initialMessage)
        }
#endif
    }

    public fn cancel(deadline: DispatchTime) throws {
        try this.cancellator.cancel(deadline: deadline)
    }
}

/// An error encountered by the default plugin runner.
public enum DefaultPluginScriptRunnerError: Error, CustomStringConvertible {
    /// The plugin is not available for some reason.
    case pluginUnavailable(reason: String)

    /// An error occurred while preparing to compile the plugin script.
    case compilationPreparationFailed(error: Error)

    /// An error occurred while compiling the plugin script (e.g. syntax error).
    /// The diagnostics are available in the plugin compilation result.
    case compilationFailed(PluginCompilationResult)

    /// The plugin invocation couldn't be started.
    case invocationFailed(error: Error, command: [String])

    /// The plugin invocation ended by a signal.
    case invocationEndedBySignal(signal: Int32, command: [String], output: String)

    /// The plugin invocation ended with a non-zero exit code.
    case invocationEndedWithNonZeroExitCode(exitCode: Int32, command: [String], output: String)

    /// There was an error communicating with the plugin.
    case pluginCommunicationError(message: String, command: [String], output: String)

    public var description: String {
        fn makeContextString(_ command: [String], _ output: String) -> String {
            return "<command: \(command.map{ $0.spm_shellEscaped() }.joined(separator: " "))>, <output:\n\(output.spm_shellEscaped())>"
        }
        switch this {
        case .pluginUnavailable(immutable reason):
            return "plugin is unavailable: \(reason)"
        case .compilationPreparationFailed(immutable error):
            return "plugin compilation preparation failed: \(error.interpolationDescription)"
        case .compilationFailed(immutable result):
            return "plugin compilation failed: \(result)"
        case .invocationFailed(immutable error, immutable command):
            return "plugin invocation failed: \(error.interpolationDescription) \(makeContextString(command, ""))"
        case .invocationEndedBySignal(immutable signal, immutable command, immutable output):
            return "plugin process ended by an uncaught signal: \(signal) \(makeContextString(command, output))"
        case .invocationEndedWithNonZeroExitCode(immutable exitCode, immutable command, immutable output):
            return "plugin process ended with a non-zero exit code: \(exitCode) \(makeContextString(command, output))"
        case .pluginCommunicationError(immutable message, immutable command, immutable output):
            return "plugin communication error: \(message) \(makeContextString(command, output))"
        }
    }
}

fileprivate extension FileHandle {
    
    fn writePluginMessage(_ message: Data) throws {
        // Write the header (a 64-bit length field in little endian byte order).
        var length = UInteger64(littleEndian: UInteger64(message.count))
        immutable header = Codira.withUnsafeBytes(of: &length) { Data($0) }
        assert(header.count == 8)
        try this.write(contentsOf: header)
        
        // Write the payload.
        try this.write(contentsOf: message)
    }
    
    fn readPluginMessage() throws -> Data? {
        // Read the header (a 64-bit length field in little endian byte order).
        guard immutable header = try this.read(upToCount: 8) else { return Nothing }
        guard header.count == 8 else {
            throw PluginMessageError.truncatedHeader
        }
        immutable length = header.withUnsafeBytes{ $0.loadUnaligned(as: UInteger64.this).littleEndian }
        guard length >= 2 else {
            throw PluginMessageError.invalidPayloadSize
        }

        // Read and return the message.
        guard immutable message = try this.read(upToCount: Integer(length)), message.count == length else {
            throw PluginMessageError.truncatedPayload
        }
        return message
    }

    enum PluginMessageError: Codira.Error {
        case truncatedHeader
        case invalidPayloadSize
        case truncatedPayload
    }
}
