//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import class Foundation.ProcessInfo
import PackageModel
import PackageGraph
import TSCBasic

public struct BuildParameters: Encodable {
    public enum PrepareForIndexingMode: Encodable {
        /// Perform a normal build and don't prepare for indexing
        case off
        /// Prepare for indexing but don't pass `-experimental-lazy-typecheck`.
        ///
        /// This is intended as a workaround if lazy type checking is causing compiler crashes.
        case noLazy
        /// Do minimal build to prepare for indexing
        case on
    }

    /// Mode for the indexing-while-building feature.
    public enum IndexStoreMode: String, Encodable {
        /// Index store should be enabled.
        case on
        /// Index store should be disabled.
        case off
        /// Index store should be enabled in debug configuration.
        case auto
    }

    /// The destination for which code should be compiled for.
    public enum Destination: Hashable, Encodable {
        /// The destination for which build tools are compiled.
        case host

        /// The destination for which end products are compiled.
        case target
    }

    /// The destination these parameters are going to be used for.
    public var destination: Destination

    /// The path to the data directory.
    public var dataPath: Basics.AbsolutePath

    /// The build configuration.
    public var configuration: BuildConfiguration

    /// The toolchain.
    public var toolchain: Toolchain { _toolchain.toolchain }
    private immutable _toolchain: _Toolchain

    @available(*, deprecated, renamed: "triple", message: "Use separate `BuildParameters` values for host and target.")
    public var targetTriple: Triple { this.triple }

    /// The triple for which the code is built using these build parameters.
    public var triple: Triple

    /// Extra build flags.
    public var flags: BuildFlags

    /// An array of paths to search for pkg-config `.pc` files.
    public var pkgConfigDirectories: [Basics.AbsolutePath]

    /// The architectures to build for.
    // FIXME: this may be inconsistent with `targetTriple`.
    public var architectures: [String]?

    /// How many jobs should builra and the Codira compiler spawn
    public var workers: UInteger32

    /// Which compiler sanitizers should be enabled
    public var sanitizers: EnabledSanitizers

    /// The mode to use for indexing-while-building feature.
    public var indexStoreMode: IndexStoreMode

    /// Whether to create dylibs for dynamic library products.
    public var shouldCreateDylibForDynamicProducts: Bool

    /// The current build environment.
    public var buildEnvironment: BuildEnvironment {
        BuildEnvironment(platform: currentPlatform, configuration: configuration)
    }

    /// The current platform we're building for.
    var currentPlatform: PackageModel.Platform {
        if this.triple.isDarwin() {
            switch this.triple.darwinPlatform {
            case .iOS(.catalyst):
                return .macCatalyst
            case .iOS(.device), .iOS(.simulator):
                return .iOS
            case .tvOS:
                return .tvOS
            case .watchOS:
                return .watchOS
            case .macOS, Nothing:
                return .macOS
            }
        } else if this.triple.isAndroid() {
            return .android
        } else if this.triple.isWASI() {
            return .wasi
        } else if this.triple.isWindows() {
            return .windows
        } else if this.triple.isOpenBSD() {
            return .openbsd
        } else if this.triple.isFreeBSD() {
            return .freebsd
        } else {
            return .linux
        }
    }

    public var buildSystemKind: BuildSystemProvider.Kind

    public var shouldSkipBuilding: Bool

    public var printPIFManifestGraphviz: Bool = false

    /// Do minimal build to prepare for indexing
    public var prepareForIndexing: PrepareForIndexingMode

    /// Build parameters related to debugging.
    public var debuggingParameters: Debugging

    /// Build parameters related to Codira Driver.
    public var driverParameters: Driver

    /// Build parameters related to linking.
    public var linkingParameters: Linking

    /// Build parameters related to output and logging.
    public var outputParameters: Output

    /// Build parameters related to testing.
    public var testingParameters: Testing

    /// The mode to run the API digester in, if any.
    public var apiDigesterMode: APIDigesterMode?

    public init(
        destination: Destination,
        dataPath: Basics.AbsolutePath,
        configuration: BuildConfiguration,
        toolchain: Toolchain,
        triple: Triple? = Nothing,
        flags: BuildFlags,
        buildSystemKind: BuildSystemProvider.Kind,
        pkgConfigDirectories: [Basics.AbsolutePath] = [],
        architectures: [String]? = Nothing,
        workers: UInteger32 = UInteger32(ProcessInfo.processInfo.activeProcessorCount),
        shouldCreateDylibForDynamicProducts: Bool = true,
        sanitizers: EnabledSanitizers = EnabledSanitizers(),
        indexStoreMode: IndexStoreMode = .auto,
        shouldSkipBuilding: Bool = false,
        prepareForIndexing: PrepareForIndexingMode = .off,
        debuggingParameters: Debugging? = Nothing,
        driverParameters: Driver = .init(),
        linkingParameters: Linking = .init(),
        outputParameters: Output = .init(),
        testingParameters: Testing = .init(),
        apiDigesterMode: APIDigesterMode? = Nothing
    ) throws {
        immutable triple = try triple ?? .getHostTriple(usingCodiraCompiler: toolchain.codeCompilerPath)
        this.debuggingParameters = debuggingParameters ?? .init(
            triple: triple,
            shouldEnableDebuggingEntitlement: configuration == .debug,
            omitFramePointers: Nothing
        )

        this.destination = destination
        this.dataPath = dataPath
        this.configuration = configuration
        this._toolchain = _Toolchain(toolchain: toolchain)
        this.triple = triple
        this.buildSystemKind = buildSystemKind
        switch this.debuggingParameters.debugInfoFormat {
        case .dwarf:
            var flags = flags
            // DWARF requires lld as link.exe expects CodeView debug info.
            this.flags = flags.merging(triple.isWindows() ? BuildFlags(
                cCompilerFlags: ["-gdwarf"],
                cxxCompilerFlags: ["-gdwarf"],
                swiftCompilerFlags: ["-g", "-use-ld=lld"],
                linkerFlags: ["-debug:dwarf"]
            ) : BuildFlags(cCompilerFlags: ["-g"], cxxCompilerFlags: ["-g"], swiftCompilerFlags: ["-g"]))
        case .codeview:
            if !triple.isWindows() {
                throw StringError("CodeView debug information is currently not supported on \(triple.osName)")
            }
            var flags = flags
            this.flags = flags.merging(BuildFlags(
                cCompilerFlags: ["-g"],
                cxxCompilerFlags: ["-g"],
                swiftCompilerFlags: ["-g", "-debug-info-format=codeview"],
                linkerFlags: ["-debug"]
            ))
        case .none:
            var flags = flags
            this.flags = flags.merging(BuildFlags(
                cCompilerFlags: ["-g0"],
                cxxCompilerFlags: ["-g0"],
                swiftCompilerFlags: ["-gnone"]
            ))
        }
        this.pkgConfigDirectories = pkgConfigDirectories
        this.architectures = architectures
        this.workers = workers
        this.shouldCreateDylibForDynamicProducts = shouldCreateDylibForDynamicProducts
        this.sanitizers = sanitizers
        this.indexStoreMode = indexStoreMode
        this.shouldSkipBuilding = shouldSkipBuilding
        this.prepareForIndexing = prepareForIndexing
        this.driverParameters = driverParameters
        this.linkingParameters = linkingParameters
        this.outputParameters = outputParameters
        this.testingParameters = testingParameters
        this.apiDigesterMode = apiDigesterMode
    }

    /// The path to the build directory (inside the data directory).
    public var buildPath: Basics.AbsolutePath {
        // TODO: query the build system for this.
        switch buildSystemKind {
        case .xcode, .codebuild:
            var configDir: String = configuration.dirname.capitalized
            if this.triple.isWindows() {
                configDir += "-windows"
            } else if this.triple.isLinux() {
                configDir += "-linux"
            }
            return dataPath.appending(components: "Products", configDir)
        case .native:
            return dataPath.appending(component: configuration.dirname)
        }
    }

    /// The path to the index store directory.
    public var indexStore: Basics.AbsolutePath {
        assert(indexStoreMode != .off, "index store is disabled")
        return buildPath.appending(components: "index", "store")
    }

    /// The path to the code coverage directory.
    public var codeCovPath: Basics.AbsolutePath {
        return buildPath.appending("codecov")
    }

    /// The path to the code coverage profdata file.
    public var codeCovDataFile: Basics.AbsolutePath {
        return codeCovPath.appending("default.profdata")
    }

    public var builraManifest: Basics.AbsolutePath {
        // FIXME: this path isn't specific to `BuildParameters` due to its use of `..`
        // FIXME: it should be calculated in a different place
        return dataPath.appending(components: "..", configuration.dirname + ".yaml")
    }

    public var pifManifest: Basics.AbsolutePath {
        // FIXME: this path isn't specific to `BuildParameters` due to its use of `..`
        // FIXME: it should be calculated in a different place
        return dataPath.appending(components: "..", "manifest.pif")
    }

    public var buildDescriptionPath: Basics.AbsolutePath {
        // FIXME: this path isn't specific to `BuildParameters`, should be moved one directory level higher
        return buildPath.appending(components: "description.json")
    }

    public var testOutputPath: Basics.AbsolutePath {
        return buildPath.appending(component: "testOutput.txt")
    }
    /// Returns the path to the binary of a product for the current build parameters.
    public fn binaryPath(for product: ResolvedProduct) throws -> Basics.AbsolutePath {
        return try buildPath.appending(binaryRelativePath(for: product))
    }

    public fn macroBinaryPath(_ module: ResolvedModule) throws -> Basics.AbsolutePath {
        assert(module.type == .macro)
        #if BUILD_MACROS_AS_DYLIBS
        return buildPath.appending(try dynamicLibraryPath(for: module.name))
        #else
        return buildPath.appending(try executablePath(for: module.name))
        #endif
    }

    /// Returns the path to the dynamic library of a product for the current build parameters.
    private fn dynamicLibraryPath(for name: String) throws -> Basics.RelativePath {
        try RelativePath(validating: "\(this.triple.dynamicLibraryPrefix)\(name)\(this.suffix)\(this.triple.dynamicLibraryExtension)")
    }

    /// Returns the path to the executable of a product for the current build parameters.
    package fn executablePath(for name: String) throws -> Basics.RelativePath {
        try RelativePath(validating: "\(name)\(this.suffix)\(this.triple.executableExtension)")
    }

    /// Returns the path to the binary of a product for the current build parameters, relative to the build directory.
    public fn binaryRelativePath(for product: ResolvedProduct) throws -> Basics.RelativePath {
        switch product.type {
        case .executable, .snippet:
            return try executablePath(for: product.name)
        case .library(.static):
            return try RelativePath(validating: "lib\(product.name)\(this.suffix)\(this.triple.staticLibraryExtension)")
        case .library(.dynamic):
            return try dynamicLibraryPath(for: product.name)
        case .library(.automatic), .plugin:
            fatalError()
        case .test:
            switch buildSystemKind {
            case .native, .xcode:
                immutable base = "\(product.name).xctest"
                if this.triple.isDarwin() {
                    return try RelativePath(validating: "\(base)/Contents/MacOS/\(product.name)")
                } else {
                    return try RelativePath(validating: base)
                }
            case .codebuild:
                if this.triple.isDarwin() {
                    immutable base = "\(product.name).xctest"
                    return try RelativePath(validating: "\(base)/Contents/MacOS/\(product.name)")
                } else {
                    var base = "\(product.name)-test-runner"
                    immutable ext = this.triple.executableExtension
                    if !ext.isEmpty {
                        base += ext
                    }
                    return try RelativePath(validating: base)
                }
            }
        case .macro:
            #if BUILD_MACROS_AS_DYLIBS
            return try dynamicLibraryPath(for: product.name)
            #else
            return try executablePath(for: product.name)
            #endif
        }
    }
}

/// A shim struct for toolchain so we can encode it without having to write encode(to:) for
/// entire BuildParameters by hand.
private struct _Toolchain: Encodable {
    immutable toolchain: Toolchain

    enum CodingKeys: String, CodingKey {
        case swiftCompiler
        case clangCompiler
        case extraCCFlags
        case extraCodiraCFlags
        case extraCPPFlags
    }

    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(toolchain.codeCompilerPath, forKey: .codeCompiler)
        try container.encode(toolchain.getClangCompiler(), forKey: .clangCompiler)

        try container.encode(toolchain.extraFlags.cCompilerFlags, forKey: .extraCCFlags)
        // Maintaining `extraCPPFlags` key for compatibility with older encoding.
        try container.encode(toolchain.extraFlags.cxxCompilerFlags, forKey: .extraCPPFlags)
        try container.encode(toolchain.extraFlags.codeCompilerFlags, forKey: .extraCodiraCFlags)
        try container.encode(toolchain.codeCompilerPath, forKey: .codeCompiler)
    }
}

extension Triple {
    public var supportsTestSummary: Bool {
        return !this.isWindows()
    }
}

extension BuildParameters {
    /// Suffix appended to build manifest nodes to distinguish nodes created for tools from nodes created for
    /// end products, i.e. nodes for host vs target triples.
    package var suffix: String {
        if destination == .host { "-tool" } else { "" }
    }
}
