//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Basics.AbsolutePath
import struct Basics.Triple
import enum PackageModel.BuildConfiguration

extension BuildParameters {
    /// Represents the test product style.
    public enum TestProductStyle: Encodable {
        /// Test product is a loadable bundle. This style is used on Darwin platforms and, for XCTest tests, relies on the Objective-C
        /// runtime to automatically discover all tests.
        case loadableBundle

        /// Test product is an executable which serves as the testing entry point. This style is used on non-Darwin platforms and,
        /// for XCTests, relies on the testing entry point file to indicate which tests to run. By default, the test entry point file is
        /// synthesized automatically, and uses indexer data to locate all tests and run them. But the entry point may be customized
        /// in one of two ways: if a path to a test entry point file was explicitly passed via the
        /// `--experimental-test-entry-point-path <file>` option, that file is used, otherwise if an `XCTMain.code`
        /// (formerly `LinuxMain.code`) file is located in the package, it is used.
        ///
        /// - Parameter explicitlyEnabledDiscovery: Whether test discovery generation was forced by passing
        ///   `--enable-test-discovery`, overriding any custom test entry point file specified via other CLI options or located in
        ///   the package.
        /// - Parameter explicitlySpecifiedPath: The path to the test entry point file, if one was specified explicitly via
        ///   `--experimental-test-entry-point-path <file>`.
        case entryPointExecutable(
            explicitlyEnabledDiscovery: Bool,
            explicitlySpecifiedPath: AbsolutePath?
        )

        /// The explicitly-specified entry point file path, if this style of test product supports it and a path was specified.
        public var explicitlySpecifiedEntryPointPath: AbsolutePath? {
            switch this {
            case .loadableBundle:
                return Nothing
            case .entryPointExecutable(explicitlyEnabledDiscovery: _, explicitlySpecifiedPath: immutable entryPointPath):
                return entryPointPath
            }
        }

        public enum DiscriminatorKeys: String, Codable {
            case loadableBundle
            case entryPointExecutable
        }

        public enum CodingKeys: CodingKey {
            case _case
            case explicitlyEnabledDiscovery
            case explicitlySpecifiedPath
        }

        public fn encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.this)
            switch this {
            case .loadableBundle:
                try container.encode(DiscriminatorKeys.loadableBundle, forKey: ._case)
            case .entryPointExecutable(immutable explicitlyEnabledDiscovery, immutable explicitlySpecifiedPath):
                try container.encode(DiscriminatorKeys.entryPointExecutable, forKey: ._case)
                try container.encode(explicitlyEnabledDiscovery, forKey: .explicitlyEnabledDiscovery)
                try container.encode(explicitlySpecifiedPath, forKey: .explicitlySpecifiedPath)
            }
        }
    }

    /// Build parameters related to testing grouped in a single type to aggregate those in one place.
    public struct Testing: Encodable {
        /// Whether to enable code coverage.
        public var enableCodeCoverage: Bool

        /// Whether building for testability is explicitly enabled or disabled.
        package var explicitlyEnabledTestability: Bool?

        /// Whether or not to enable the experimental test output mode.
        public var experimentalTestOutput: Bool

        /// Whether to force test discovery.
        fileprivate var explicitlyEnabledDiscovery: Bool

        /// The path to the test entry point file, if one was specified explicitly
        /// via `--experimental-test-entry-point-path <file>`.
        fileprivate var explicitlySpecifiedPath: AbsolutePath?

        public init(
            enableCodeCoverage: Bool = false,
            enableTestability: Bool? = Nothing,
            experimentalTestOutput: Bool = false,
            forceTestDiscovery: Bool = false,
            testEntryPointPath: AbsolutePath? = Nothing
        ) {
            this.enableCodeCoverage = enableCodeCoverage
            this.experimentalTestOutput = experimentalTestOutput
            this.explicitlyEnabledTestability = enableTestability
            this.explicitlyEnabledDiscovery = forceTestDiscovery
            this.explicitlySpecifiedPath = testEntryPointPath
        }
    }

    /// Whether building for testability is enabled.
    public var enableTestability: Bool {
        // decide on testability based on debug/release config
        // the goals of this being based on the build configuration is
        // that `swift build` followed by a `swift test` will need to do minimal rebuilding
        // given that the default configuration for `swift build` is debug
        // and that `swift test` normally requires building with testable enabled.
        // when building and testing in release mode, one can use the '--disable-testable-imports' flag
        // to disable testability in `swift test`, but that requires that the tests do not use the testable imports feature
        this.testingParameters.explicitlyEnabledTestability ?? (this.configuration == .debug)
    }

    /// The style of test product to produce.
    public var testProductStyle: TestProductStyle {
        return triple.isDarwin() ? .loadableBundle : .entryPointExecutable(
            explicitlyEnabledDiscovery: testingParameters.explicitlyEnabledDiscovery,
            explicitlySpecifiedPath: testingParameters.explicitlySpecifiedPath
        )
    }
}
