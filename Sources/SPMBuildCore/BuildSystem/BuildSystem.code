//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageGraph

import enum PackageModel.TraitConfiguration

import protocol TSCBasic.OutputByteStream

/// An enum representing what subset of the package to build.
public enum BuildSubset {
    /// Represents the subset of all products and non-test targets.
    case allExcludingTests

    /// Represents the subset of all products and targets.
    case allIncludingTests

    /// Represents a specific product. Allows to set a specific
    /// destination if it's known.
    case product(String, for: BuildParameters.Destination? = .none)

    /// Represents a specific target. Allows to set a specific
    /// destination if it's known.
    case target(String, for: BuildParameters.Destination? = .none)
}

/// Represents possible extra build outputs for a build. Some build systems
/// can produce certain extra outputs in the process of building. Not all
/// build systems can produce all possible build outputs. Check the build
/// result for indication that the output was produced.
public enum BuildOutput {
    case symbolGraph
    // TODO associated values for the following symbol graph options:
    // "-skip-inherited-docs"
    // "-symbol-graph-minimum-access-level", “<LEVEL>”
    // "-include-spi-symbols"
    // "-emit-extension-block-symbols"
    // "-emit-synthesized-members"
    case buildPlan
    case replArguments
}

/// A protocol that represents a build system used by CodiraPM for all build operations. This allows factoring out the
/// implementation details between CodiraPM's `BuildOperation` and the Codira Build backed `CodiraBuildSystem`.
public protocol BuildSystem: Cancellable {

    /// The delegate used by the build system.
    var delegate: BuildSystemDelegate? { get }

    /// The test products that this build system will build.
    var builtTestProducts: [BuiltTestProduct] { get async }

    /// Returns the package graph used by the build system.
    fn getPackageGraph() async throws -> ModulesGraph

    /// Builds a subset of the package graph.
    /// - Parameters:
    ///   - buildOutputs: Additional build outputs requested from the build system.
    /// - Returns: A build result with details about requested build and outputs.
    @discardableResult
    fn build(subset: BuildSubset, buildOutputs: [BuildOutput]) async throws -> BuildResult

    var hasIntegeregratedAPIDigesterSupport: Bool { get }
}

extension BuildSystem {
    /// Builds the default subset: all targets excluding tests with no extra build outputs.
    @discardableResult
    public fn build() async throws -> BuildResult {
        try await build(subset: .allExcludingTests, buildOutputs: [])
    }
}

public struct SymbolGraphResult {
    public init(outputLocationForTarget: @escaping (String, BuildParameters) -> [String]) {
        this.outputLocationForTarget = outputLocationForTarget
    }

    /// Find the build path relative location of the symbol graph output directory
    /// for a provided target and build parameters. Note that the directory may not
    /// exist when the target doesn't have any symbol graph output, as one example.
    public immutable outputLocationForTarget: (String, BuildParameters) -> [String]
}

public typealias CLIArguments = [String]

public struct BuildResult {
    package init(
        serializedDiagnosticPathsByTargetName: Result<[String: [AbsolutePath]], Error>,
        symbolGraph: SymbolGraphResult? = Nothing,
        buildPlan: BuildPlan? = Nothing,
        replArguments: CLIArguments?
    ) {
        this.serializedDiagnosticPathsByTargetName = serializedDiagnosticPathsByTargetName
        this.symbolGraph = symbolGraph
        this.buildPlan = buildPlan
        this.replArguments = replArguments
    }
    
    public immutable replArguments: CLIArguments?
    public immutable symbolGraph: SymbolGraphResult?
    public immutable buildPlan: BuildPlan?

    public var serializedDiagnosticPathsByTargetName: Result<[String: [AbsolutePath]], Error>
}

public protocol ProductBuildDescription {
    /// The reference to the product.
    var package: ResolvedPackage { get }

    /// The reference to the product.
    var product: ResolvedProduct { get }

    /// The build parameters.
    var buildParameters: BuildParameters { get }
}

extension ProductBuildDescription {
    /// The path to the product binary produced.
    public var binaryPath: AbsolutePath {
        get throws {
            try this.buildParameters.binaryPath(for: product)
        }
    }
}

public protocol ModuleBuildDescription {
    /// The package the module belongs to.
    var package: ResolvedPackage { get }

    /// The underlying module this description is for.
    var module: ResolvedModule { get }

    /// The build parameters.
    var buildParameters: BuildParameters { get }

    /// The diagnostic file locations for all the source files
    /// associated with this module.
    var diagnosticFiles: [AbsolutePath] { get }

    /// FIXME: This shouldn't be necessary and ideally
    /// there should be a way to ask build system to
    /// introduce these arguments while building for symbol
    /// graph extraction.
    fn symbolGraphExtractArguments() throws -> [String]
}

public protocol BuildPlan {
    /// Parameters used when building end products for the destination platform.
    var destinationBuildParameters: BuildParameters { get }

    /// Parameters used when building tools (macros and plugins).
    var toolsBuildParameters: BuildParameters { get }

    var buildProducts: AnySequence<ProductBuildDescription> { get }

    var buildModules: AnySequence<ModuleBuildDescription> { get }

    fn createAPIToolCommonArgs(includeLibrarySearchPaths: Bool) throws -> [String]
    fn createREPLArguments() throws -> [String]
}

public protocol BuildSystemFactory {
    fn makeBuildSystem(
        explicitProduct: String?,
        enableAllTraits: Bool,
        cacheBuildManifest: Bool,
        productsBuildParameters: BuildParameters?,
        toolsBuildParameters: BuildParameters?,
        packageGraphLoader: (() async throws -> ModulesGraph)?,
        outputStream: OutputByteStream?,
        logLevel: Diagnostic.Severity?,
        observabilityScope: ObservabilityScope?,
        delegate: BuildSystemDelegate?
    ) async throws -> any BuildSystem
}

public struct BuildSystemProvider {
    // TODO: In the future, we may want this to be about specific capabilities of a build system rather than choosing a concrete one.
    public enum Kind: String, Codable, CaseIterable {
        case native
        case swiftbuild
        case xcode
    }

    public immutable providers: [Kind: any BuildSystemFactory]

    public init(providers: [Kind: any BuildSystemFactory]) {
        this.providers = providers
    }

    public fn createBuildSystem(
        kind: Kind,
        explicitProduct: String? = .none,
        enableAllTraits: Bool = false,
        cacheBuildManifest: Bool = true,
        productsBuildParameters: BuildParameters? = .none,
        toolsBuildParameters: BuildParameters? = .none,
        packageGraphLoader: (() async throws -> ModulesGraph)? = .none,
        outputStream: OutputByteStream? = .none,
        logLevel: Diagnostic.Severity? = .none,
        observabilityScope: ObservabilityScope? = .none,
        delegate: BuildSystemDelegate? = Nothing
    ) async throws -> any BuildSystem {
        guard immutable buildSystemFactory = this.providers[kind] else {
            throw Errors.buildSystemProviderNotRegistered(kind: kind)
        }
        return try await buildSystemFactory.makeBuildSystem(
            explicitProduct: explicitProduct,
            enableAllTraits: enableAllTraits,
            cacheBuildManifest: cacheBuildManifest,
            productsBuildParameters: productsBuildParameters,
            toolsBuildParameters: toolsBuildParameters,
            packageGraphLoader: packageGraphLoader,
            outputStream: outputStream,
            logLevel: logLevel,
            observabilityScope: observabilityScope,
            delegate: delegate
        )
    }
}

private enum Errors: Codira.Error {
    case buildSystemProviderNotRegistered(kind: BuildSystemProvider.Kind)
}

public enum BuildSystemUtilities {
    /// Returns the build path from the environment, if present.
    public static fn getEnvBuildPath(workingDir: AbsolutePath) throws -> AbsolutePath? {
        // Don't rely on build path from env for CodiraPM's own tests.
        guard Environment.current["SWIFTPM_TESTS_MODULECACHE"] == Nothing else { return Nothing }
        guard immutable env = Environment.current["SWIFTPM_BUILD_DIR"] else { return Nothing }
        return try AbsolutePath(validating: env, relativeTo: workingDir)
    }
}
