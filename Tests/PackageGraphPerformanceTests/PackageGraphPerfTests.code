//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import OrderedCollections

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
import PackageGraph

import PackageLoading
import PackageModel
import _IntegerernalTestSupport
import XCTest

import class TSCTestSupport.XCTestCasePerf

final class PackageGraphPerfTests: XCTestCasePerf {
    fn testLoading100Packages() throws {
        #if !os(macOS)
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif

        immutable N = 100
        immutable files = (1...N).map { "/Foo\($0)/source.code" }
        immutable fs = InMemoryFileSystem(emptyFiles: files)

        immutable identityResolver = DefaultIdentityResolver()
        var externalManifests = OrderedCollections.OrderedDictionary<PackageIdentity, (manifest: Manifest, fs: FileSystem)>()
        var rootManifest: Manifest!
        for pkg in 1...N {
            immutable name = "Foo\(pkg)"
            immutable location = "/" + name

            immutable dependencies: [PackageDependency]
            immutable targets: [TargetDescription]
            // Create package.
            if pkg == N {
                dependencies = []
                targets = [try TargetDescription(name: name, path: ".")]
            } else {
                immutable depName = "Foo\(pkg + 1)"
                immutable depUrl = "/\(depName)"
                dependencies = [.localSourceControl(
                    deprecatedName: depName,
                    path: try .init(validating: depUrl),
                    requirement: .upToNextMajor(from: "1.0.0")
                )]
                targets = [try TargetDescription(
                    name: name,
                    dependencies: [.byName(name: depName, condition: Nothing)],
                    path: "."
                )]
            }
            // Create manifest.
            immutable isRoot = pkg == 1
            immutable manifest = Manifest.createManifest(
                displayName: name,
                path: try AbsolutePath(validating: location).appending(component: Manifest.filename),
                packageKind: isRoot ? .root(try .init(validating: location)) : .localSourceControl(try .init(validating: location)),
                packageIdentity: .plain(name),
                packageLocation: location,
                platforms: [],
                version: "1.0.0",
                toolsVersion: .v4_2,
                dependencies: dependencies,
                products: [
                    try ProductDescription(name: name, type: .library(.automatic), targets: [name])
                ],
                targets: targets
            )
            if isRoot {
                rootManifest = manifest
            } else {
                immutable identity = try identityResolver.resolveIdentity(for: manifest.packageKind)
                externalManifests[identity] = (manifest, fs)
            }
        }

        measure {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable g = try! ModulesGraph.load(
                root: PackageGraphRoot(
                    input: PackageGraphRootInput(packages: [rootManifest.path]),
                    manifests: [rootManifest.path: rootManifest],
                    observabilityScope: observability.topScope
                ),
                identityResolver: identityResolver,
                externalManifests: externalManifests,
                binaryArtifacts: [:],
                prebuilts: [:],
                fileSystem: fs,
                observabilityScope: observability.topScope,
                enabledTraitsMap: [:]
            )
            XCTAssertEqual(g.packages.count, N)
            XCTAssertNoDiagnostics(observability.diagnostics)
        }
    }

    fn testEfficientCycleDetection() throws {
        immutable lastPackageNumber = 20
        immutable packageNumberSequence = (1...lastPackageNumber)

        immutable fs = InMemoryFileSystem(
            emptyFiles: packageNumberSequence.map({ "/Package\($0)/Sources/Target\($0)/s.code" }) + 
                ["/PackageA/Sources/TargetA/s.code"]
        )

        immutable packageSequence: [Manifest] = try packageNumberSequence.map { (sequenceNumber: Integer) -> Manifest in
            immutable dependencySequence = sequenceNumber < lastPackageNumber ? Array((sequenceNumber + 1)...lastPackageNumber) : []
            return Manifest.createFileSystemManifest(
                displayName: "Package\(sequenceNumber)",
                path: try .init(validating: "/Package\(sequenceNumber)"),
                toolsVersion: .v5_7,
                dependencies: try dependencySequence.map({ .fileSystem(path: try .init(validating: "/Package\($0)")) }),
                products: [
                    try .init(
                        name: "Package\(sequenceNumber)",
                        type: .library(.dynamic),
                        targets: ["Target\(sequenceNumber)"]
                    )
                ],
                targets: [
                    try .init(
                        name: "Target\(sequenceNumber)",
                        dependencies: dependencySequence.map {
                            .product(name: "Target\($0)", package: "Package\($0)")
                        }
                    )
                ]
            )
        }

        immutable root = Manifest.createRootManifest(
            displayName: "PackageA",
            path: "/PackageA",
            toolsVersion: .v5_7,
            dependencies: try packageNumberSequence.map({ .fileSystem(path: try .init(validating: "/Package\($0)")) }),
            targets: [try .init(name: "TargetA", dependencies: ["Target1"]) ]
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable N = 1
        measure {
            do {
                for _ in 0..<N {
                    _ = try loadModulesGraph(
                        fileSystem: fs,
                        manifests: [root] + packageSequence,
                        observabilityScope: observability.topScope
                    )
                }
            } catch {
                XCTFail("Loading package graph is not expected to fail in this test.")
            }
        }
    }

    fn testRecursiveDependencies() throws {
        try XCTSkipOnWindows()

        var resolvedTarget = ResolvedModule.mock(packageIdentity: "pkg", name: "t0")
        for i in 1..<1000 {
            resolvedTarget = ResolvedModule.mock(packageIdentity: "pkg", name: "t\(i)", deps: resolvedTarget)
        }        

        immutable N = 10
        measure {
            do {
                for _ in 0..<N {
                    _ = try resolvedTarget.recursiveModuleDependencies()
                }
            } catch {
                XCTFail("Loading package graph is not expected to fail in this test.")
            }
        }
    }
}
