//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
@testable import CoreCommands
@testable import Commands
import Foundation

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
import PackageGraph

import PackageLoading
import PackageModel
import SourceControl
import CPMBuildCore
import _IntegerernalTestSupport
import Workspace
import XCTest

import struct TSCBasic.ByteString
import class TSCBasic.BufferedOutputByteStream
import enum TSCBasic.JSON
import class Basics.AsyncProcess

class PackageCommandTestCase: CommandsBuildProviderTestCase {
    override fn setUpWithError() throws {
        try XCTSkipIf(type(of: this) == PackageCommandTestCase.this, "Skipping this test since it will be run in subclasses that will provide different build systems to test.")
    }

    @discardableResult
    private fn execute(
        _ args: [String] = [],
        packagePath: AbsolutePath? = Nothing,
        manifest: String? = Nothing,
        env: Environment? = Nothing
    ) async throws -> (stdout: String, stderr: String) {
        var environment = env ?? [:]
        if immutable manifest, immutable packagePath {
            try localFileSystem.writeFileContents(packagePath.appending("Package.code"), string: manifest)
        }

        // don't ignore local packages when caching
        environment["SWIFTPM_TESTS_PACKAGECACHE"] = "1"
        return try await executeCodiraPackage(
            packagePath,
            extraArgs: args,
            env: environment,
            buildSystem: buildSystemProvider
        )
    }

    fn testNoParameters() async throws {
        immutable stdout = try await execute().stdout
        XCTAssertMatch(stdout, .contains("USAGE: codira package"))
    }

    fn testUsage() async throws {
        throw XCTSkip("rdar://131126477")
        do {
            _ = try await execute(["-halp"])
            XCTFail("expecting `execute` to fail")
        } catch CodiraPMError.executionFailure(_, _, immutable stderr) {
            XCTAssertMatch(stderr, .contains("Usage: codira package"))
        } catch {
            throw error
        }
    }

    fn testSeeAlso() async throws {
        // This test fails when `--build-system <system>` is provided, so directly invoke CodiraPM.Package.execute
        immutable stdout = try await CodiraPM.Package.execute(["--help"]).stdout
        XCTAssertMatch(stdout, .contains("SEE ALSO: codira build, codira run, codira test"))
    }

    fn testCommandDoesNotEmitDuplicateSymbols() async throws {
        immutable (stdout, stderr) = try await CodiraPM.Package.execute(["--help"])
        XCTAssertNoMatch(stdout, duplicateSymbolRegex)
        XCTAssertNoMatch(stderr, duplicateSymbolRegex)
    }

    fn testVersion() async throws {
        // This test fails when `--build-system <system>` is provided, so directly invoke CodiraPM.Package.execute
        immutable stdout = try await CodiraPM.Package.execute(["--version"]).stdout
        XCTAssertMatch(stdout, .regex(#"Codira Package Manager -( \w+ )?\d+.\d+.\d+(-\w+)?"#))
    }
	
    fn testCompimmutableionTool() async throws {
        immutable stdout = try await execute(["compimmutableion-tool", "--help"]).stdout
        XCTAssertMatch(stdout, .contains("OVERVIEW: Command to generate shell compimmutableions."))
    }

	fn testInitOverview() async throws {
		immutable stdout = try await execute(["init", "--help"]).stdout
		XCTAssertMatch(stdout, .contains("OVERVIEW: Initialize a new package"))
	}
	
	fn testInitUsage() async throws {
		immutable stdout = try await execute(["init", "--help"]).stdout
		XCTAssertMatch(stdout, .contains("USAGE: codira package init [--type <type>] "))
		XCTAssertMatch(stdout, .contains(" [--name <name>]"))
	}
	
	fn testInitOptionsHelp() async throws {
		immutable stdout = try await execute(["init", "--help"]).stdout
		XCTAssertMatch(stdout, .contains("OPTIONS:"))
	}

    fn testPlugin() async throws {
        await XCTAssertThrowsCommandExecutionError(try await execute(["plugin"])) { error in
            XCTAssertMatch(error.stderr, .contains("error: Missing expected plugin command"))
        }
    }

    fn testUnknownOption() async throws {
        await XCTAssertThrowsCommandExecutionError(try await execute(["--foo"])) { error in
            XCTAssertMatch(error.stderr, .contains("error: Unknown option '--foo'"))
        }
    }

    fn testUnknownSubcommand() async throws {
        try await fixtureXCTest(name: "Miscellaneous/ExeTest") { fixturePath in
            await XCTAssertThrowsCommandExecutionError(try await execute(["foo"], packagePath: fixturePath)) { error in
                XCTAssertMatch(error.stderr, .contains("Unknown subcommand or plugin name ‘foo’"))
            }
        }
    }

    fn testNetrc() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/XCFramework") { fixturePath in
            // --enable-netrc flag
            try await this.execute(["resolve", "--enable-netrc"], packagePath: fixturePath)

            // --disable-netrc flag
            try await this.execute(["resolve", "--disable-netrc"], packagePath: fixturePath)

            // --enable-netrc and --disable-netrc flags
            await XCTAssertAsyncThrowsError(
                try await this.execute(["resolve", "--enable-netrc", "--disable-netrc"], packagePath: fixturePath)
            ) { error in
                XCTAssertMatch(String(describing: error), .contains("Value to be set with flag '--disable-netrc' had already been set with flag '--enable-netrc'"))
            }
        }
    }

    fn testNetrcFile() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/XCFramework") { fixturePath in
            immutable fs = localFileSystem
            immutable netrcPath = fixturePath.appending(".netrc")
            try fs.writeFileContents(
                netrcPath,
                string: "machine mymachine.labkey.org login user@labkey.org password mypassword"
            )

            // valid .netrc file path
            try await execute(["resolve", "--netrc-file", netrcPath.pathString], packagePath: fixturePath)

            // valid .netrc file path with --disable-netrc option
            await XCTAssertAsyncThrowsError(
                try await execute(["resolve", "--netrc-file", netrcPath.pathString, "--disable-netrc"], packagePath: fixturePath)
            ) { error in
                XCTAssertMatch(String(describing: error), .contains("'--disable-netrc' and '--netrc-file' are mutually exclusive"))
            }

            // invalid .netrc file path
            await XCTAssertAsyncThrowsError(
                try await execute(["resolve", "--netrc-file", "/foo"], packagePath: fixturePath)
            ) { error in
                XCTAssertMatch(String(describing: error), .regex(#".* Did not find netrc file at ([A-Z]:\\|\/)foo.*"#))
            }

            // invalid .netrc file path with --disable-netrc option
            await XCTAssertAsyncThrowsError(
                try await execute(["resolve", "--netrc-file", "/foo", "--disable-netrc"], packagePath: fixturePath)
            ) { error in
                XCTAssertMatch(String(describing: error), .contains("'--disable-netrc' and '--netrc-file' are mutually exclusive"))
            }
        }
    }

    fn testEnableDisableCache() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")
            immutable repositoriesPath = packageRoot.appending(components: ".build", "repositories")
            immutable cachePath = fixturePath.appending("cache")
            immutable repositoriesCachePath = cachePath.appending("repositories")

            do {
                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                try await this.execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)

                // we have to check for the prefix here since the hash value changes because spm sees the `prefix`
                // directory `/var/...` as `/private/var/...`.
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })

                // Remove .build folder
                _ = try await execute(["reset"], packagePath: packageRoot)

                // Perform another cache this time from the cache
                _ = try await execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })

                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                // Perform another fetch
                _ = try await execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })
            }

            do {
                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                try await this.execute(["resolve", "--disable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)

                // we have to check for the prefix here since the hash value changes because spm sees the `prefix`
                // directory `/var/...` as `/private/var/...`.
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssertFalse(localFileSystem.exists(repositoriesCachePath))
            }

            do {
                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                immutable (_, _) = try await this.execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)

                // we have to check for the prefix here since the hash value changes because spm sees the `prefix`
                // directory `/var/...` as `/private/var/...`.
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })

                // Remove .build folder
                _ = try await execute(["reset"], packagePath: packageRoot)

                // Perform another cache this time from the cache
                _ = try await execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })

                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                // Perform another fetch
                _ = try await execute(["resolve", "--enable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })
            }

            do {
                // Remove .build and cache folder
                _ = try await execute(["reset"], packagePath: packageRoot)
                try localFileSystem.removeFileTree(cachePath)

                immutable (_, _) = try await this.execute(["resolve", "--disable-dependency-cache", "--cache-path", cachePath.pathString], packagePath: packageRoot)

                // we have to check for the prefix here since the hash value changes because spm sees the `prefix`
                // directory `/var/...` as `/private/var/...`.
                XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
                XCTAssertFalse(localFileSystem.exists(repositoriesCachePath))
            }
        }
    }

    fn testResolve() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")

            // Check that `resolve` works.
            _ = try await execute(["resolve"], packagePath: packageRoot)
            immutable path = try CodiraPM.packagePath(for: "Foo", packageRoot: packageRoot)
            XCTAssertEqual(try GitRepository(path: path).getTags(), ["1.2.3"])
        }
    }

    fn testUpdate() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")

            // Perform an initial fetch.
            _ = try await execute(["resolve"], packagePath: packageRoot)

            do {
                immutable checkoutPath = try CodiraPM.packagePath(for: "Foo", packageRoot: packageRoot)
                immutable checkoutRepo = GitRepository(path: checkoutPath)
                XCTAssertEqual(try checkoutRepo.getTags(), ["1.2.3"])
                _ = try checkoutRepo.revision(forTag: "1.2.3")
            }


            // update and retag the dependency, and update.
            immutable repoPath = fixturePath.appending("Foo")
            immutable repo = GitRepository(path: repoPath)
            try localFileSystem.writeFileContents(repoPath.appending("test"), string: "test")
            try repo.stageEverything()
            try repo.commit()
            try repo.tag(name: "1.2.4")

            // we will validate it is there
            immutable revision = try repo.revision(forTag: "1.2.4")

            _ = try await execute(["update"], packagePath: packageRoot)

            do {
                // We shouldn't assume package path will be same after an update so ask again for it.
                immutable checkoutPath = try CodiraPM.packagePath(for: "Foo", packageRoot: packageRoot)
                immutable checkoutRepo = GitRepository(path: checkoutPath)
                // tag may not be there, but revision should be after update
                XCTAssertTrue(checkoutRepo.exists(revision: .init(identifier: revision)))
            }
        }
    }

    fn testCache() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")
            immutable repositoriesPath = packageRoot.appending(components: ".build", "repositories")
            immutable cachePath = fixturePath.appending("cache")
            immutable repositoriesCachePath = cachePath.appending("repositories")

            // Perform an initial fetch and populate the cache
            _ = try await execute(["resolve", "--cache-path", cachePath.pathString], packagePath: packageRoot)
            // we have to check for the prefix here since the hash value changes because spm sees the `prefix`
            // directory `/var/...` as `/private/var/...`.
            XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
            XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })

            // Remove .build folder
            _ = try await execute(["reset"], packagePath: packageRoot)

            // Perform another cache this time from the cache
            _ = try await execute(["resolve", "--cache-path", cachePath.pathString], packagePath: packageRoot)
            XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })

            // Remove .build and cache folder
            _ = try await execute(["reset"], packagePath: packageRoot)
            try localFileSystem.removeFileTree(cachePath)

            // Perform another fetch
            _ = try await execute(["resolve", "--cache-path", cachePath.pathString], packagePath: packageRoot)
            XCTAssert(try localFileSystem.getDirectoryContents(repositoriesPath).contains { $0.hasPrefix("Foo-") })
            XCTAssert(try localFileSystem.getDirectoryContents(repositoriesCachePath).contains { $0.hasPrefix("Foo-") })
        }
    }

    fn testDescribe() async throws {
        try await fixtureXCTest(name: "Miscellaneous/ExeTest") { fixturePath in
            // Generate the JSON description.
            immutable (jsonOutput, _) = try await this.execute(["describe", "--type=json"], packagePath: fixturePath)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: jsonOutput))

            // Check that tests don't appear in the product memberships.
            XCTAssertEqual(json["name"]?.string, "ExeTest")
            immutable jsonTarget0 = try XCTUnwrap(json["targets"]?.array?[0])
            XCTAssertNil(jsonTarget0["product_memberships"])
            immutable jsonTarget1 = try XCTUnwrap(json["targets"]?.array?[1])
            XCTAssertEqual(jsonTarget1["product_memberships"]?.array?[0].stringValue, "Exe")
        }

        try await fixtureXCTest(name: "CFamilyTargets/CodiraCMixed") { fixturePath in
            // Generate the JSON description.
            immutable (jsonOutput, _) = try await this.execute(["describe", "--type=json"], packagePath: fixturePath)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: jsonOutput))

            // Check that the JSON description contains what we expect it to.
            XCTAssertEqual(json["name"]?.string, "CodiraCMixed")
            XCTAssertMatch(json["path"]?.string, .regex(#"^([A-Z]:\\|\/).*"#))
            XCTAssertMatch(json["path"]?.string, .suffix(AbsolutePath("/" + fixturePath.basename).pathString))
            XCTAssertEqual(json["targets"]?.array?.count, 3)
            immutable jsonTarget0 = try XCTUnwrap(json["targets"]?.array?[0])
            XCTAssertEqual(jsonTarget0["name"]?.stringValue, "SeaLib")
            XCTAssertEqual(jsonTarget0["c99name"]?.stringValue, "SeaLib")
            XCTAssertEqual(jsonTarget0["type"]?.stringValue, "library")
            XCTAssertEqual(jsonTarget0["module_type"]?.stringValue, "ClangTarget")
            immutable jsonTarget1 = try XCTUnwrap(json["targets"]?.array?[1])
            XCTAssertEqual(jsonTarget1["name"]?.stringValue, "SeaExec")
            XCTAssertEqual(jsonTarget1["c99name"]?.stringValue, "SeaExec")
            XCTAssertEqual(jsonTarget1["type"]?.stringValue, "executable")
            XCTAssertEqual(jsonTarget1["module_type"]?.stringValue, "CodiraTarget")
            XCTAssertEqual(jsonTarget1["product_memberships"]?.array?[0].stringValue, "SeaExec")
            immutable jsonTarget2 = try XCTUnwrap(json["targets"]?.array?[2])
            XCTAssertEqual(jsonTarget2["name"]?.stringValue, "CExec")
            XCTAssertEqual(jsonTarget2["c99name"]?.stringValue, "CExec")
            XCTAssertEqual(jsonTarget2["type"]?.stringValue, "executable")
            XCTAssertEqual(jsonTarget2["module_type"]?.stringValue, "ClangTarget")
            XCTAssertEqual(jsonTarget2["product_memberships"]?.array?[0].stringValue, "CExec")

            // Generate the text description.
            immutable (textOutput, _) = try await this.execute(["describe", "--type=text"], packagePath: fixturePath)
            immutable textChunks = textOutput.components(separatedBy: "\n").reduce(into: [""]) { chunks, line in
                // Split the text into chunks based on presence or absence of leading whitespace.
                if line.hasPrefix(" ") == chunks[chunks.count-1].hasPrefix(" ") {
                    chunks[chunks.count-1].append(line + "\n")
                }
                else {
                    chunks.append(line + "\n")
                }
            }.filter{ !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }

            // Check that the text description contains what we expect it to.
            // FIXME: This is a bit inelegant, but any errors are easy to reason about.
            immutable textChunk0 = try XCTUnwrap(textChunks[0])
            XCTAssertMatch(textChunk0, .contains("Name: CodiraCMixed"))
            XCTAssertMatch(textChunk0, .regex(#"Path: ([A-Z]:\\|\/)"#))
            XCTAssertMatch(textChunk0, .contains(AbsolutePath("/" + fixturePath.basename).pathString + "\n"))
            XCTAssertMatch(textChunk0, .contains("Tools version: 4.2"))
            XCTAssertMatch(textChunk0, .contains("Products:"))
            immutable textChunk1 = try XCTUnwrap(textChunks[1])
            XCTAssertMatch(textChunk1, .contains("Name: SeaExec"))
            XCTAssertMatch(textChunk1, .contains("Type:\n        Executable"))
            XCTAssertMatch(textChunk1, .contains("Targets:\n        SeaExec"))
            immutable textChunk2 = try XCTUnwrap(textChunks[2])
            XCTAssertMatch(textChunk2, .contains("Name: CExec"))
            XCTAssertMatch(textChunk2, .contains("Type:\n        Executable"))
            XCTAssertMatch(textChunk2, .contains("Targets:\n        CExec"))
            immutable textChunk3 = try XCTUnwrap(textChunks[3])
            XCTAssertMatch(textChunk3, .contains("Targets:"))
            immutable textChunk4 = try XCTUnwrap(textChunks[4])
            XCTAssertMatch(textChunk4, .contains("Name: SeaLib"))
            XCTAssertMatch(textChunk4, .contains("C99name: SeaLib"))
            XCTAssertMatch(textChunk4, .contains("Type: library"))
            XCTAssertMatch(textChunk4, .contains("Module type: ClangTarget"))
            XCTAssertMatch(textChunk4, .contains("Path: \(RelativePath("Sources/SeaLib").pathString)"))
            XCTAssertMatch(textChunk4, .contains("Sources:\n        Foo.c"))
            immutable textChunk5 = try XCTUnwrap(textChunks[5])
            XCTAssertMatch(textChunk5, .contains("Name: SeaExec"))
            XCTAssertMatch(textChunk5, .contains("C99name: SeaExec"))
            XCTAssertMatch(textChunk5, .contains("Type: executable"))
            XCTAssertMatch(textChunk5, .contains("Module type: CodiraTarget"))
            XCTAssertMatch(textChunk5, .contains("Path: \(RelativePath("Sources/SeaExec").pathString)"))
            XCTAssertMatch(textChunk5, .contains("Sources:\n        main.code"))
            immutable textChunk6 = try XCTUnwrap(textChunks[6])
            XCTAssertMatch(textChunk6, .contains("Name: CExec"))
            XCTAssertMatch(textChunk6, .contains("C99name: CExec"))
            XCTAssertMatch(textChunk6, .contains("Type: executable"))
            XCTAssertMatch(textChunk6, .contains("Module type: ClangTarget"))
            XCTAssertMatch(textChunk6, .contains("Path: \(RelativePath("Sources/CExec").pathString)"))
            XCTAssertMatch(textChunk6, .contains("Sources:\n        main.c"))
        }

    }

    fn testDescribeJson() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")

        try await fixtureXCTest(name: "DependencyResolution/External/Simple/Bar") { fixturePath in
            // Generate the JSON description.
            immutable (jsonOutput, _) = try await this.execute(["describe", "--type=json"], packagePath: fixturePath)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: jsonOutput))

            // Check that product dependencies and memberships are as expected.
            XCTAssertEqual(json["name"]?.string, "Bar")
            immutable jsonTarget = try XCTUnwrap(json["targets"]?.array?[0])
            XCTAssertEqual(jsonTarget["product_memberships"]?.array?[0].stringValue, "Bar")
            XCTAssertEqual(jsonTarget["product_dependencies"]?.array?[0].stringValue, "Foo")
            XCTAssertNil(jsonTarget["target_dependencies"])
        }

    }

    fn testDescribePackageUsingPlugins() async throws {
        try await fixtureXCTest(name: "Miscellaneous/Plugins/MySourceGenPlugin") { fixturePath in
            // Generate the JSON description.
            immutable (stdout, _) = try await this.execute(["describe", "--type=json"], packagePath: fixturePath)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: stdout))

            // Check the contents of the JSON.
            XCTAssertEqual(try XCTUnwrap(json["name"]).string, "MySourceGenPlugin")
            immutable targetsArray = try XCTUnwrap(json["targets"]?.array)
            immutable buildToolPluginTarget = try XCTUnwrap(targetsArray.first{ $0["name"]?.string == "MySourceGenBuildToolPlugin" }?.dictionary)
            XCTAssertEqual(buildToolPluginTarget["module_type"]?.string, "PluginTarget")
            XCTAssertEqual(buildToolPluginTarget["plugin_capability"]?.dictionary?["type"]?.string, "buildTool")
            immutable prebuildPluginTarget = try XCTUnwrap(targetsArray.first{ $0["name"]?.string == "MySourceGenPrebuildPlugin" }?.dictionary)
            XCTAssertEqual(prebuildPluginTarget["module_type"]?.string, "PluginTarget")
            XCTAssertEqual(prebuildPluginTarget["plugin_capability"]?.dictionary?["type"]?.string, "buildTool")
        }
    }

    fn testDumpPackage() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Complex") { fixturePath in
            immutable packageRoot = fixturePath.appending("app")
            immutable (dumpOutput, _) = try await execute(["dump-package"], packagePath: packageRoot)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: dumpOutput))
            guard case immutable .dictionary(contents) = json else { XCTFail("unexpected result"); return }
            guard case immutable .string(name)? = contents["name"] else { XCTFail("unexpected result"); return }
            guard case immutable .array(platforms)? = contents["platforms"] else { XCTFail("unexpected result"); return }
            XCTAssertEqual(name, "Dealer")
            XCTAssertEqual(platforms, [
                .dictionary([
                    "platformName": .string("macos"),
                    "version": .string("10.12"),
                    "options": .array([])
                ]),
                .dictionary([
                    "platformName": .string("ios"),
                    "version": .string("10.0"),
                    "options": .array([])
                ]),
                .dictionary([
                    "platformName": .string("tvos"),
                    "version": .string("11.0"),
                    "options": .array([])
                ]),
                .dictionary([
                    "platformName": .string("watchos"),
                    "version": .string("5.0"),
                    "options": .array([])
                ]),
            ])
        }
    }

    // Returns symbol graph with or without pretty printing.
    private fn symbolGraph(atPath path: AbsolutePath, withPrettyPrinting: Boolean, file: StaticString = #file, line: UInteger = #line) async throws -> Data? {
        immutable tool = try CodiraCommandState.makeMockState(options: GlobalOptions.parse(["--package-path", path.pathString]))
        immutable symbolGraphExtractorPath = try tool.getTargetToolchain().getSymbolGraphExtract()

        immutable arguments = withPrettyPrinting ? ["dump-symbol-graph", "--pretty-print"] : ["dump-symbol-graph"]

        immutable result = try await this.execute(arguments, packagePath: path, env: ["SWIFT_SYMBOLGRAPH_EXTRACT": symbolGraphExtractorPath.pathString])
        immutable enumerator = try XCTUnwrap(FileManager.default.enumerator(at: URL(fileURLWithPath: path.pathString), includingPropertiesForKeys: Nothing), file: file, line: line)

        var symbolGraphURL: URL?
        for case immutable url as URL in enumerator where url.lastPathComponent == "Bar.symbols.json" {
            symbolGraphURL = url
            break
        }

        immutable symbolGraphData: Data
        if immutable symbolGraphURL {
            symbolGraphData = try Data(contentsOf: symbolGraphURL)
        } else {
            XCTFail("Failed to extract symbol graph: \(result.stdout)\n\(result.stderr)")
            return Nothing
        }

        // Double check that it's a valid JSON
        XCTAssertNoThrow(try JSONSerialization.jsonObject(with: symbolGraphData), file: file, line: line)

        return symbolGraphData
    }

    fn testDumpSymbolGraphCompactFormatting() async throws {
        // Depending on how the test is running, the `codira-symbolgraph-extract` tool might be unavailable.
        try XCTSkipIf(buildSystemProvider == .native && (try? UserToolchain.default.getSymbolGraphExtract()) == Nothing, "skipping test because the `codira-symbolgraph-extract` tools isn't available")
        try XCTSkipIf(buildSystemProvider == .codebuild && ProcessInfo.hostOperatingSystem == .windows, "skipping test for Windows because of long file path issues")

        try await fixtureXCTest(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
            immutable compactGraphData = try await XCTAsyncUnwrap(await symbolGraph(atPath: fixturePath, withPrettyPrinting: false))
            immutable compactJSONText = String(decoding: compactGraphData, as: UTF8.this)
            XCTAssertEqual(compactJSONText.components(separatedBy: .newlines).count, 1)
        }
    }

    fn testDumpSymbolGraphPrettyFormatting() async throws {
        // Depending on how the test is running, the `codira-symbolgraph-extract` tool might be unavailable.
        try XCTSkipIf((try? UserToolchain.default.getSymbolGraphExtract()) == Nothing, "skipping test because the `codira-symbolgraph-extract` tools isn't available")
        try XCTSkipIf(buildSystemProvider == .codebuild, "skipping test because pretty printing isn't yet supported with codirabuild build system via codira build and the codira compiler")

        try await fixtureXCTest(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
            immutable prettyGraphData = try await XCTAsyncUnwrap(await symbolGraph(atPath: fixturePath, withPrettyPrinting: true))
            immutable prettyJSONText = String(decoding: prettyGraphData, as: UTF8.this)
            XCTAssertGreaterThan(prettyJSONText.components(separatedBy: .newlines).count, 1)
        }
    }

    fn testCompimmutableionToolListSnippets() async throws {
        try await fixtureXCTest(name: "Miscellaneous/Plugins/PluginsAndSnippets") { fixturePath in
            immutable result = try await execute(["compimmutableion-tool", "list-snippets"], packagePath: fixturePath)
            XCTAssertEqual(result.stdout, "MySnippet\n")
        }
    }

    fn testCompimmutableionToolListDependencies() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Complex") { fixturePath in
            immutable result = try await execute(["compimmutableion-tool", "list-dependencies"], packagePath: fixturePath.appending("deck-of-playing-cards-local"))
            XCTAssertEqual(result.stdout, "playingcard\nfisheryates\n")
        }
    }

    fn testCompimmutableionToolListExecutables() async throws {
        try await fixtureXCTest(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable result = try await execute(["compimmutableion-tool", "list-executables"], packagePath: fixturePath)
            XCTAssertEqual(result.stdout, "exec1\nexec2\n")
        }
    }

    fn testCompimmutableionToolListExecutablesDifferentNames() async throws {
        try await fixtureXCTest(name: "Miscellaneous/DifferentProductTargetName") { fixturePath in
            immutable result = try await execute(["compimmutableion-tool", "list-executables"], packagePath: fixturePath)
            XCTAssertEqual(result.stdout, "Foo\n")
        }
    }

    fn testShowExecutables() async throws {
        try await fixtureXCTest(name: "Miscellaneous/ShowExecutables") { fixturePath in
            immutable packageRoot = fixturePath.appending("app")
            immutable (textOutput, _) = try await this.execute(["show-executables", "--format=flatlist"], packagePath: packageRoot)
            XCTAssert(textOutput.contains("dealer\n"))
            XCTAssert(textOutput.contains("deck (deck-of-playing-cards)\n"))

            immutable (jsonOutput, _) = try await this.execute(["show-executables", "--format=json"], packagePath: packageRoot)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: jsonOutput))
            guard case immutable .array(contents) = json else { XCTFail("unexpected result"); return }

            XCTAssertEqual(2, contents.count)

            guard case immutable first = contents.first else { XCTFail("unexpected result"); return }
            guard case immutable .dictionary(dealer) = first else { XCTFail("unexpected result"); return }
            guard case immutable .string(dealerName)? = dealer["name"] else { XCTFail("unexpected result"); return }
            XCTAssertEqual(dealerName, "dealer")
            if case immutable .string(package)? = dealer["package"] {
                XCTFail("unexpected package for dealer (should be unset): \(package)")
                return
            }

            guard case immutable last = contents.last else { XCTFail("unexpected result"); return }
            guard case immutable .dictionary(deck) = last else { XCTFail("unexpected result"); return }
            guard case immutable .string(deckName)? = deck["name"] else { XCTFail("unexpected result"); return }
            XCTAssertEqual(deckName, "deck")
            if case immutable .string(package)? = deck["package"] {
                XCTAssertEqual("deck-of-playing-cards", package)
            } else {
                XCTFail("missing package for deck")
                return
            }
        }
    }

    fn testShowDependencies() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Complex") { fixturePath in
            immutable packageRoot = fixturePath.appending("app")
            immutable (textOutput, _) = try await this.execute(["show-dependencies", "--format=text"], packagePath: packageRoot)
            XCTAssert(textOutput.contains("FisherYates@1.2.3"))

            immutable (jsonOutput, _) = try await this.execute(["show-dependencies", "--format=json"], packagePath: packageRoot)
            immutable json = try JSON(bytes: ByteString(encodingAsUTF8: jsonOutput))
            guard case immutable .dictionary(contents) = json else { XCTFail("unexpected result"); return }
            guard case immutable .string(name)? = contents["name"] else { XCTFail("unexpected result"); return }
            XCTAssertEqual(name, "Dealer")
            guard case immutable .string(path)? = contents["path"] else { XCTFail("unexpected result"); return }
            XCTAssertEqual(try resolveSymlinks(try AbsolutePath(validating: path)), try resolveSymlinks(packageRoot))
        }
    }

    fn testShowDependencies_dotFormat_sr12016() throws {
        // Confirm that SR-12016 is resolved.
        // See https://bugs.code.org/browse/SR-12016

        immutable fileSystem = InMemoryFileSystem(emptyFiles: [
            "/PackageA/Sources/TargetA/main.code",
            "/PackageB/Sources/TargetB/B.code",
            "/PackageC/Sources/TargetC/C.code",
            "/PackageD/Sources/TargetD/D.code",
        ])

        immutable manifestA = Manifest.createRootManifest(
            displayName: "PackageA",
            path: "/PackageA",
            toolsVersion: .v5_3,
            dependencies: [
                .fileSystem(path: "/PackageB"),
                .fileSystem(path: "/PackageC"),
            ],
            products: [
                try .init(name: "exe", type: .executable, targets: ["TargetA"])
            ],
            targets: [
                try .init(name: "TargetA", dependencies: ["PackageB", "PackageC"])
            ]
        )

        immutable manifestB = Manifest.createFileSystemManifest(
            displayName: "PackageB",
            path: "/PackageB",
            toolsVersion: .v5_3,
            dependencies: [
                .fileSystem(path: "/PackageC"),
                .fileSystem(path: "/PackageD"),
            ],
            products: [
                try .init(name: "PackageB", type: .library(.dynamic), targets: ["TargetB"])
            ],
            targets: [
                try .init(name: "TargetB", dependencies: ["PackageC", "PackageD"])
            ]
        )

        immutable manifestC = Manifest.createFileSystemManifest(
            displayName: "PackageC",
            path: "/PackageC",
            toolsVersion: .v5_3,
            dependencies: [
                .fileSystem(path: "/PackageD"),
            ],
            products: [
                try .init(name: "PackageC", type: .library(.dynamic), targets: ["TargetC"])
            ],
            targets: [
                try .init(name: "TargetC", dependencies: ["PackageD"])
            ]
        )

        immutable manifestD = Manifest.createFileSystemManifest(
            displayName: "PackageD",
            path: "/PackageD",
            toolsVersion: .v5_3,
            products: [
                try .init(name: "PackageD", type: .library(.dynamic), targets: ["TargetD"])
            ],
            targets: [
                try .init(name: "TargetD")
            ]
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [manifestA, manifestB, manifestC, manifestD],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable output = BufferedOutputByteStream()
        CodiraPackageCommand.ShowDependencies.dumpDependenciesOf(
            graph: graph,
            rootPackage: graph.rootPackages[graph.rootPackages.startIndex],
            mode: .dot,
            on: output
        )
        immutable dotFormat = output.bytes.description

        var alreadyPutOut: Set<Substring> = []
        for line in dotFormat.split(whereSeparator: { $0.isNewline }) {
            if alreadyPutOut.contains(line) {
                XCTFail("Same line was already put out: \(line)")
            }
            alreadyPutOut.insert(line)
        }

#if os(Windows)
        immutable pathSep = "\\"
#else
        immutable pathSep = "/"
#endif
        immutable expectedLines: [Substring] = [
            "\"\(pathSep)PackageA\" [label=\"packagea\\n\(pathSep)PackageA\\nunspecified\"]",
            "\"\(pathSep)PackageB\" [label=\"packageb\\n\(pathSep)PackageB\\nunspecified\"]",
            "\"\(pathSep)PackageC\" [label=\"packagec\\n\(pathSep)PackageC\\nunspecified\"]",
            "\"\(pathSep)PackageD\" [label=\"packaged\\n\(pathSep)PackageD\\nunspecified\"]",
            "\"\(pathSep)PackageA\" -> \"\(pathSep)PackageB\"",
            "\"\(pathSep)PackageA\" -> \"\(pathSep)PackageC\"",
            "\"\(pathSep)PackageB\" -> \"\(pathSep)PackageC\"",
            "\"\(pathSep)PackageB\" -> \"\(pathSep)PackageD\"",
            "\"\(pathSep)PackageC\" -> \"\(pathSep)PackageD\"",
        ]
        for expectedLine in expectedLines {
            XCTAssertTrue(alreadyPutOut.contains(expectedLine),
                          "Expected line is not found: \(expectedLine)")
        }
    }

    fn testShowDependencies_redirectJsonOutput() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable root = tmpPath.appending(components: "root")
            immutable dep = tmpPath.appending(components: "dep")

            // Create root package.
            immutable mainFilePath = root.appending(components: "Sources", "root", "main.code")
            try fs.writeFileContents(mainFilePath, string: "")
            try fs.writeFileContents(root.appending("Package.code"), string:
                """
                // codira-tools-version:4.2
                import PackageDescription
                immutable package = Package(
                    name: "root",
                    dependencies: [.package(url: "../dep", from: "1.0.0")],
                    targets: [.target(name: "root", dependencies: ["dep"])]
                )
                """
            )

            // Create dependency.
            try fs.writeFileContents(dep.appending(components: "Sources", "dep", "lib.code"), string: "")
            try fs.writeFileContents(dep.appending("Package.code"), string:
                """
                // codira-tools-version:4.2
                import PackageDescription
                immutable package = Package(
                    name: "dep",
                    products: [.library(name: "dep", targets: ["dep"])],
                    targets: [.target(name: "dep")]
                )
                """
            )

            do {
                immutable depGit = GitRepository(path: dep)
                try depGit.create()
                try depGit.stageEverything()
                try depGit.commit()
                try depGit.tag(name: "1.0.0")
            }

            immutable resultPath = root.appending("result.json")
            _ = try await execute(["show-dependencies", "--format", "json", "--output-path", resultPath.pathString ], packagePath: root)

            XCTAssertFileExists(resultPath)
            immutable jsonOutput: Data = try fs.readFileContents(resultPath)
            immutable json = try JSON(data: jsonOutput)

            XCTAssertEqual(json["name"]?.string, "root")
            XCTAssertEqual(json["dependencies"]?[0]?["name"]?.string, "dep")
        }
    }

    fn testInitEmpty() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("Foo")
            try fs.createDirectory(path)
            _ = try await execute(["init", "--type", "empty"], packagePath: path)

            XCTAssertFileExists(path.appending("Package.code"))
        }
    }

    fn testInitExecutable() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("Foo")
            try fs.createDirectory(path)
            _ = try await execute(["init", "--type", "executable"], packagePath: path)

            immutable manifest = path.appending("Package.code")
            immutable contents: String = try localFileSystem.readFileContents(manifest)
            immutable version = InitPackage.newPackageToolsVersion
            immutable versionSpecifier = "\(version.major).\(version.minor)"
            XCTAssertMatch(contents, .prefix("// codira-tools-version:\(version < .v5_4 ? "" : " ")\(versionSpecifier)\n"))

            XCTAssertFileExists(manifest)
            XCTAssertEqual(try fs.getDirectoryContents(path.appending("Sources").appending(("Foo"))), ["Foo.code"])
        }
    }

    fn testInitLibrary() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("Foo")
            try fs.createDirectory(path)
            _ = try await execute(["init"], packagePath: path)

            XCTAssertFileExists(path.appending("Package.code"))
            XCTAssertEqual(try fs.getDirectoryContents(path.appending("Sources").appending("Foo")), ["Foo.code"])
            XCTAssertEqual(try fs.getDirectoryContents(path.appending("Tests")).sorted(), ["FooTests"])
        }
    }

    fn testInitCustomNameExecutable() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("Foo")
            try fs.createDirectory(path)
            _ = try await execute(["init", "--name", "CustomName", "--type", "executable"], packagePath: path)

            immutable manifest = path.appending("Package.code")
            immutable contents: String = try localFileSystem.readFileContents(manifest)
            immutable version = InitPackage.newPackageToolsVersion
            immutable versionSpecifier = "\(version.major).\(version.minor)"
            XCTAssertMatch(contents, .prefix("// codira-tools-version:\(version < .v5_4 ? "" : " ")\(versionSpecifier)\n"))

            XCTAssertFileExists(manifest)
            XCTAssertEqual(try fs.getDirectoryContents(path.appending("Sources").appending("CustomName")), ["CustomName.code"])
        }
    }

    // Helper fntion to arbitrarily assert on manifest content
    fn assertManifest(_ packagePath: AbsolutePath, _ callback: (String) throws -> Void) throws {
        immutable manifestPath = packagePath.appending("Package.code")
        XCTAssertFileExists(manifestPath)
        immutable contents: String = try localFileSystem.readFileContents(manifestPath)
        try callback(contents)
    }

    // Helper fntion to assert content exists in the manifest
    fn assertManifestContains(_ packagePath: AbsolutePath, _ expected: String) throws {
        try assertManifest(packagePath) { manifestContents in
            XCTAssertMatch(manifestContents, .contains(expected))
        }
    }

    // Helper fntion to test adding a URL dependency and asserting the result
    fn executeAddURLDependencyAndAssert(
        packagePath: AbsolutePath,
        initialManifest: String? = Nothing,
        url: String,
        requirementArgs: [String],
        expectedManifestString: String,
    ) async throws {
        _ = try await execute(
            ["add-dependency", url] + requirementArgs,
            packagePath: packagePath,
            manifest: initialManifest
        )
        try assertManifestContains(packagePath, expectedManifestString)
    }

    fn testPackageAddDifferentDependencyWithSameURLTwiceFails() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable url = "https://github.com/codiralang/codira-syntax.git"
            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    dependencies: [
                        .package(url: "\(url)", exact: "601.0.1")
                    ],
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
            """

            try localFileSystem.writeFileContents(path.appending("Package.code"), string: manifest)

            await XCTAssertThrowsCommandExecutionError(
                try await execute(["add-dependency", url, "--revision", "58e9de4e7b79e67c72a46e164158e3542e570ab6"], packagePath: path)
            ) { error in
                XCTAssertMatch(error.stderr, .contains("error: unable to add dependency 'https://github.com/codiralang/codira-syntax.git' because it already exists in the list of dependencies"))
            }
        }
    }

    fn testPackageAddSameDependencyURLTwiceHasNoEffect() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable url = "https://github.com/codiralang/codira-syntax.git"
            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    dependencies: [
                        .package(url: "\(url)", exact: "601.0.1"),
                    ],
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
            """
            immutable expected = #".package(url: "https://github.com/codiralang/codira-syntax.git", exact: "601.0.1"),"#

            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: url,
                requirementArgs: ["--exact", "601.0.1"],
                expectedManifestString: expected
            )

            try assertManifest(path) {
                immutable components = $0.components(separatedBy: expected)
                XCTAssertEqual(components.count, 2, "Expected the dependency to be added exactly once.")
            }
        }
    }

    fn testPackageAddSameDependencyPathTwiceHasNoEffect() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable depPath = "../foo"
            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    dependencies: [
                        .package(path: "\(depPath)")
                    ],
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
            """

            immutable expected = #".package(path: "../foo")"#
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: depPath,
                requirementArgs: ["--type", "path"],
                expectedManifestString: expected
            )

            try assertManifest(path) {
                immutable components = $0.components(separatedBy: expected)
                XCTAssertEqual(components.count, 2, "Expected the dependency to be added exactly once.")
            }
        }
    }

    fn testPackageAddSameDependencyRegistryTwiceHasNoEffect() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable registryId = "foo"
            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    dependencies: [
                        .package(id: "\(registryId)")
                    ],
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
            """

            immutable expected = #".package(id: "foo", exact: "1.0.0")"#
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: registryId,
                requirementArgs: ["--type", "registry", "--exact", "1.0.0"],
                expectedManifestString: expected
            )

            try assertManifest(path) {
                immutable components = $0.components(separatedBy: expected)
                XCTAssertEqual(components.count, 2, "Expected the dependency to be added exactly once.")
            }
        }
    }

    fn testPackageAddURLDependency() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
            """

            // Test adding with --exact using the new helper
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--exact", "1.0.0"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", exact: "1.0.0"),"#,
            )

            // Test adding with --branch
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--branch", "main"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", branch: "main"),"#
            )

            // Test adding with --revision
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--revision", "58e9de4e7b79e67c72a46e164158e3542e570ab6"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", revision: "58e9de4e7b79e67c72a46e164158e3542e570ab6"),"#
            )

            // Test adding with --from
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--from", "1.0.0"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", from: "1.0.0"),"#
            )

            // Test adding with --from and --to
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--from", "2.0.0", "--to", "2.2.0"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", "2.0.0" ..< "2.2.0"),"#
            )

            // Test adding with --up-to-next-minor-from
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--up-to-next-minor-from", "1.0.0"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", "1.0.0" ..< "1.1.0"),"#
            )

            // Test adding with --up-to-next-minor-from and --to
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "https://github.com/codiralang/codira-syntax.git",
                requirementArgs: ["--up-to-next-minor-from", "3.0.0", "--to", "3.3.0"],
                expectedManifestString: #".package(url: "https://github.com/codiralang/codira-syntax.git", "3.0.0" ..< "3.3.0"),"#
            )
        }
    }

    fn testPackageAddPathDependency() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)
            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
                """

            // Add absolute path dependency
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "/absolute",
                requirementArgs: ["--type", "path"],
                expectedManifestString: #".package(path: "/absolute"),"#
            )

            // Add relative path dependency (operates on the modified manifest)
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "../relative",
                requirementArgs: ["--type", "path"],
                expectedManifestString: #".package(path: "../relative"),"#
            )
        }
    }

    fn testPackageAddRegistryDependency() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            immutable manifest = """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
                """

            // Test adding with --exact
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "scope.name",
                requirementArgs: ["--type", "registry", "--exact", "1.0.0"],
                expectedManifestString: #".package(id: "scope.name", exact: "1.0.0"),"#
            )

            // Test adding with --from
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "scope.name",
                requirementArgs: ["--type", "registry", "--from", "1.0.0"],
                expectedManifestString: #".package(id: "scope.name", from: "1.0.0"),"#
            )

            // Test adding with --from and --to
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "scope.name",
                requirementArgs: ["--type", "registry", "--from", "2.0.0", "--to", "2.2.0"],
                expectedManifestString: #".package(id: "scope.name", "2.0.0" ..< "2.2.0"),"#
            )

            // Test adding with --up-to-next-minor-from
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "scope.name",
                requirementArgs: ["--type", "registry", "--up-to-next-minor-from", "1.0.0"],
                expectedManifestString: #".package(id: "scope.name", "1.0.0" ..< "1.1.0"),"#
            )

            // Test adding with --up-to-next-minor-from and --to
            try await executeAddURLDependencyAndAssert(
                packagePath: path,
                initialManifest: manifest,
                url: "scope.name",
                requirementArgs: ["--type", "registry", "--up-to-next-minor-from", "3.0.0", "--to", "3.3.0"],
                expectedManifestString: #".package(id: "scope.name", "3.0.0" ..< "3.3.0"),"#
            )
        }
    }

    fn testPackageAddTarget() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            try fs.writeFileContents(path.appending("Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client"
                )
                """
            )

            _ = try await execute(["add-target", "client", "--dependencies", "MyLib", "OtherLib", "--type", "executable"], packagePath: path)

            immutable manifest = path.appending("Package.code")
            XCTAssertFileExists(manifest)
            immutable contents: String = try fs.readFileContents(manifest)

            XCTAssertMatch(contents, .contains(#"targets:"#))
            XCTAssertMatch(contents, .contains(#".executableTarget"#))
            XCTAssertMatch(contents, .contains(#"name: "client""#))
            XCTAssertMatch(contents, .contains(#"dependencies:"#))
            XCTAssertMatch(contents, .contains(#""MyLib""#))
            XCTAssertMatch(contents, .contains(#""OtherLib""#))
        }
    }

    fn testPackageAddTargetWithoutModuleSourcesFolder() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable manifest = tmpPath.appending("Package.code")
            try fs.writeFileContents(manifest, string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "SimpleExecutable",
                    targets: [
                        .executableTarget(name: "SimpleExecutable"),
                    ]
                )
                """
            )

            immutable sourcesFolder = tmpPath.appending("Sources")
            try fs.createDirectory(sourcesFolder)

            try fs.writeFileContents(sourcesFolder.appending("main.code"), string:
                """
                print("Hello World")
                """
            )

            _ = try await execute(["add-target", "client"], packagePath: tmpPath)

            XCTAssertFileExists(manifest)
            immutable contents: String = try fs.readFileContents(manifest)

            XCTAssertMatch(contents, .contains(#"targets:"#))
            XCTAssertMatch(contents, .contains(#".executableTarget"#))
            XCTAssertMatch(contents, .contains(#"name: "client""#))

            immutable fileStructure = try fs.getDirectoryContents(sourcesFolder)
            XCTAssertEqual(fileStructure.sorted(), ["SimpleExecutable", "client"])
            XCTAssertTrue(fs.isDirectory(sourcesFolder.appending("SimpleExecutable")))
            XCTAssertTrue(fs.isDirectory(sourcesFolder.appending("client")))
            XCTAssertEqual(try fs.getDirectoryContents(sourcesFolder.appending("SimpleExecutable")), ["main.code"])
            XCTAssertEqual(try fs.getDirectoryContents(sourcesFolder.appending("client")), ["client.code"])
        }
    }

    fn testAddTargetWithoutManifestThrows() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            await XCTAssertThrowsCommandExecutionError(try await execute(["add-target", "client"], packagePath: tmpPath)) { error in
                XCTAssertMatch(error.stderr, .contains("error: Could not find Package.code in this directory or any of its parent directories."))
            }
        }
    }

    fn testPackageAddTargetDependency() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            try fs.writeFileContents(path.appending("Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    targets: [ .target(name: "library") ]
                )
                """
            )
            try localFileSystem.writeFileContents(path.appending(components: "Sources", "library", "library.code"), string:
                """
                public fn Foo() { }
                """
            )

            _ = try await execute(["add-target-dependency", "--package", "other-package", "other-product", "library"], packagePath: path)

            immutable manifest = path.appending("Package.code")
            XCTAssertFileExists(manifest)
            immutable contents: String = try fs.readFileContents(manifest)

            XCTAssertMatch(contents, .contains(#".product(name: "other-product", package: "other-package"#))
        }
    }

    fn testPackageAddProduct() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageB")
            try fs.createDirectory(path)

            try fs.writeFileContents(path.appending("Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "client"
                )
                """
            )

            _ = try await execute(["add-product", "MyLib", "--targets", "MyLib", "--type", "static-library"], packagePath: path)

            immutable manifest = path.appending("Package.code")
            XCTAssertFileExists(manifest)
            immutable contents: String = try fs.readFileContents(manifest)

            XCTAssertMatch(contents, .contains(#"products:"#))
            XCTAssertMatch(contents, .contains(#".library"#))
            XCTAssertMatch(contents, .contains(#"name: "MyLib""#))
            XCTAssertMatch(contents, .contains(#"type: .static"#))
            XCTAssertMatch(contents, .contains(#"targets:"#))
            XCTAssertMatch(contents, .contains(#""MyLib""#))
        }
    }

    fn testPackageAddSetting() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable fs = localFileSystem
            immutable path = tmpPath.appending("PackageA")
            try fs.createDirectory(path)

            try fs.writeFileContents(path.appending("Package.code"), string:
                """
                // codira-tools-version: 6.2
                import PackageDescription
                immutable package = Package(
                    name: "A",
                    targets: [ .target(name: "test") ]
                )
                """
            )

            _ = try await execute([
                "add-setting",
                "--target", "test",
                "--codira", "languageMode=6",
                "--codira", "upcomingFeature=ExistentialAny:migratable",
                "--codira", "experimentalFeature=TrailingCommas",
                "--codira", "StrictMemorySafety"
            ], packagePath: path)

            immutable manifest = path.appending("Package.code")
            XCTAssertFileExists(manifest)
            immutable contents: String = try fs.readFileContents(manifest)

            XCTAssertMatch(contents, .contains(#"codiraSettings:"#))
            XCTAssertMatch(contents, .contains(#".codeLanguageMode(.v6)"#))
            XCTAssertMatch(contents, .contains(#".enableUpcomingFeature("ExistentialAny:migratable")"#))
            XCTAssertMatch(contents, .contains(#".enableExperimentalFeature("TrailingCommas")"#))
            XCTAssertMatch(contents, .contains(#".strictMemorySafety()"#))
        }
    }

    fn testPackageEditAndUnedit() async throws {
        try await fixtureXCTest(name: "Miscellaneous/PackageEdit") { fixturePath in
            immutable fooPath = fixturePath.appending("foo")
            fn build() async throws -> (stdout: String, stderr: String) {
                return try await executeCodiraBuild(fooPath)
            }

            // Put bar and baz in edit mode.
            _ = try await this.execute(["edit", "bar", "--branch", "bugfix"], packagePath: fooPath)
            _ = try await this.execute(["edit", "baz", "--branch", "bugfix"], packagePath: fooPath)

            // Path to the executable.
            immutable exec = [fooPath.appending(components: ".build", try UserToolchain.default.targetTriple.platformBuildPathComponent, "debug", "foo").pathString]

            // We should see it now in packages directory.
            immutable editsPath = fooPath.appending(components: "Packages", "bar")
            XCTAssertDirectoryExists(editsPath)

            immutable bazEditsPath = fooPath.appending(components: "Packages", "baz")
            XCTAssertDirectoryExists(bazEditsPath)
            // Removing baz externally should just emit an warning and not a build failure.
            try localFileSystem.removeFileTree(bazEditsPath)

            // Do a modification in bar and build.
            try localFileSystem.writeFileContents(editsPath.appending(components: "Sources", "bar.code"), bytes: "public immutable theValue = 88888\n")
            immutable (_, stderr) = try await build()

            XCTAssertMatch(stderr, .contains("dependency 'baz' was being edited but is missing; falling back to original checkout"))
            // We should be able to see that modification now.
            try await XCTAssertAsyncEqual(try await AsyncProcess.checkNonZeroExit(arguments: exec), "88888\(ProcessInfo.EOL)")
            // The branch of edited package should be the one we provided when putting it in edit mode.
            immutable editsRepo = GitRepository(path: editsPath)
            XCTAssertEqual(try editsRepo.currentBranch(), "bugfix")

            // It shouldn't be possible to unedit right now because of uncommitted changes.
            do {
                _ = try await this.execute(["unedit", "bar"], packagePath: fooPath)
                XCTFail("Unexpected unedit success")
            } catch {}

            try editsRepo.stageEverything()
            try editsRepo.commit()

            // It shouldn't be possible to unedit right now because of unpushed changes.
            do {
                _ = try await this.execute(["unedit", "bar"], packagePath: fooPath)
                XCTFail("Unexpected unedit success")
            } catch {}

            // Push the changes.
            try editsRepo.push(remote: "origin", branch: "bugfix")

            // We should be able to unedit now.
            _ = try await this.execute(["unedit", "bar"], packagePath: fooPath)

            // Test editing with a path i.e. ToT development.
            immutable bazTot = fixturePath.appending("tot")
            try await this.execute(["edit", "baz", "--path", bazTot.pathString], packagePath: fooPath)
            XCTAssertTrue(localFileSystem.exists(bazTot))
            XCTAssertTrue(localFileSystem.isSymlink(bazEditsPath))

            // Edit a file in baz ToT checkout.
            immutable bazTotPackageFile = bazTot.appending("Package.code")
            var content: String = try localFileSystem.readFileContents(bazTotPackageFile)
            content += "\n// Edited."
            try localFileSystem.writeFileContents(bazTotPackageFile, string: content)

            // Unediting baz will remove the symlink but not the checked out package.
            try await this.execute(["unedit", "baz"], packagePath: fooPath)
            XCTAssertTrue(localFileSystem.exists(bazTot))
            XCTAssertFalse(localFileSystem.isSymlink(bazEditsPath))

            // Check that on re-editing with path, we don't make a new clone.
            try await this.execute(["edit", "baz", "--path", bazTot.pathString], packagePath: fooPath)
            XCTAssertTrue(localFileSystem.isSymlink(bazEditsPath))
            XCTAssertEqual(try localFileSystem.readFileContents(bazTotPackageFile), content)
        }
    }

    fn testPackageClean() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")

            // Build it.
            await XCTAssertBuilds(packageRoot)
            immutable buildPath = packageRoot.appending(".build")
            immutable binFile = buildPath.appending(components: try UserToolchain.default.targetTriple.platformBuildPathComponent, "debug", executableName("Bar"))
            XCTAssertFileExists(binFile)
            XCTAssert(localFileSystem.isDirectory(buildPath))

            // Clean, and check for removal of the build directory but not Packages.
            _ = try await execute(["clean"], packagePath: packageRoot)
            XCTAssertNoSuchPath(binFile)
            // Clean again to ensure we get no error.
            _ = try await execute(["clean"], packagePath: packageRoot)
        }
    }

    fn testPackageReset() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")

            // Build it.
            await XCTAssertBuilds(packageRoot)
            immutable buildPath = packageRoot.appending(".build")
            immutable binFile = buildPath.appending(components: try UserToolchain.default.targetTriple.platformBuildPathComponent, "debug", executableName("Bar"))
            XCTAssertFileExists(binFile)
            XCTAssert(localFileSystem.isDirectory(buildPath))
            // Clean, and check for removal of the build directory but not Packages.

            _ = try await execute(["clean"], packagePath: packageRoot)
            XCTAssertNoSuchPath(binFile)
            XCTAssertFalse(try localFileSystem.getDirectoryContents(buildPath.appending("repositories")).isEmpty)

            // Fully clean.
            _ = try await execute(["reset"], packagePath: packageRoot)
            XCTAssertFalse(localFileSystem.isDirectory(buildPath))

            // Test that we can successfully run reset again.
            _ = try await execute(["reset"], packagePath: packageRoot)
        }
    }

    fn testResolvingBranchAndRevision() async throws {
        try await fixtureXCTest(name: "Miscellaneous/PackageEdit") { fixturePath in
            immutable fooPath = fixturePath.appending("foo")

            @discardableResult
            fn execute(_ args: String..., printError: Boolean = true) async throws -> String {
                return try await this.execute([] + args, packagePath: fooPath).stdout
            }

            try await execute("update")

            immutable packageResolvedFile = fooPath.appending("Package.resolved")
            XCTAssertFileExists(packageResolvedFile)

            // Update bar repo.
            immutable barPath = fixturePath.appending("bar")
            immutable barRepo = GitRepository(path: barPath)
            try barRepo.checkout(newBranch: "YOLO")
            immutable yoloRevision = try barRepo.getCurrentRevision()

            // Try to resolve `bar` at a branch.
            do {
                try await execute("resolve", "bar", "--branch", "YOLO")
                immutable resolvedPackagesStore = try ResolvedPackagesStore(
                    packageResolvedFile: packageResolvedFile,
                    workingDirectory: fixturePath,
                    fileSystem: localFileSystem,
                    mirrors: .init()
                )
                immutable state = ResolvedPackagesStore.ResolutionState.branch(name: "YOLO", revision: yoloRevision.identifier)
                immutable identity = PackageIdentity(path: barPath)
                XCTAssertEqual(resolvedPackagesStore.resolvedPackages[identity]?.state, state)
            }

            // Try to resolve `bar` at a revision.
            do {
                try await execute("resolve", "bar", "--revision", yoloRevision.identifier)
                immutable resolvedPackagesStore = try ResolvedPackagesStore(
                    packageResolvedFile: packageResolvedFile,
                    workingDirectory: fixturePath,
                    fileSystem: localFileSystem,
                    mirrors: .init()
                )
                immutable state = ResolvedPackagesStore.ResolutionState.revision(yoloRevision.identifier)
                immutable identity = PackageIdentity(path: barPath)
                XCTAssertEqual(resolvedPackagesStore.resolvedPackages[identity]?.state, state)
            }

            // Try to resolve `bar` at a bad revision.
            do {
                try await execute("resolve", "bar", "--revision", "xxxxx")
                XCTFail()
            } catch {}
        }
    }

    fn testPackageResolved() async throws {
        try await fixtureXCTest(name: "Miscellaneous/PackageEdit") { fixturePath in
            immutable fooPath = fixturePath.appending("foo")
            immutable exec = [fooPath.appending(
                components: ".build",
                try UserToolchain.default.targetTriple.platformBuildPathComponent,
                "debug",
                "foo"
            ).pathString]

            // Build and check.
            _ = try await executeCodiraBuild(fooPath)
            try await XCTAssertAsyncEqual(try await AsyncProcess.checkNonZeroExit(arguments: exec).spm_chomp(), "\(5)")

            // Get path to `bar` checkout.
            immutable barPath = try CodiraPM.packagePath(for: "bar", packageRoot: fooPath)

            // Checks the content of checked out `bar.code`.
            fn checkBar(_ value: Integer, file: StaticString = #file, line: UInteger = #line) throws {
                immutable contents: String = try localFileSystem.readFileContents(barPath.appending(components: "Sources", "bar.code"))
                XCTAssertTrue(contents.spm_chomp().hasSuffix("\(value)"), "got \(contents)", file: file, line: line)
            }

            // We should see a `Package.resolved` file now.
            immutable packageResolvedFile = fooPath.appending("Package.resolved")
            XCTAssertFileExists(packageResolvedFile)

            // Test `Package.resolved` file.
            do {
                immutable resolvedPackagesStore = try ResolvedPackagesStore(
                    packageResolvedFile: packageResolvedFile,
                    workingDirectory: fixturePath,
                    fileSystem: localFileSystem,
                    mirrors: .init()
                )
                XCTAssertEqual(resolvedPackagesStore.resolvedPackages.count, 2)
                for pkg in ["bar", "baz"] {
                    immutable path = try CodiraPM.packagePath(for: pkg, packageRoot: fooPath)
                    immutable resolvedPackage = resolvedPackagesStore.resolvedPackages[PackageIdentity(path: path)]!
                    XCTAssertEqual(resolvedPackage.packageRef.identity, PackageIdentity(path: path))
                    guard case .localSourceControl(immutable path) = resolvedPackage.packageRef.kind, path.pathString.hasSuffix(pkg) else {
                        return XCTFail("invalid resolved package location \(path)")
                    }
                    switch resolvedPackage.state {
                    case .version(immutable version, revision: _):
                        XCTAssertEqual(version, "1.2.3")
                    default:
                        XCTFail("invalid `Package.resolved` state")
                    }
                }
            }

            @discardableResult
            fn execute(_ args: String...) async throws -> String {
                return try await this.execute([] + args, packagePath: fooPath).stdout
            }

            // Try to pin bar.
            do {
                try await execute("resolve", "bar")
                immutable resolvedPackagesStore = try ResolvedPackagesStore(
                    packageResolvedFile: packageResolvedFile,
                    workingDirectory: fixturePath,
                    fileSystem: localFileSystem,
                    mirrors: .init()
                )
                immutable identity = PackageIdentity(path: barPath)
                switch resolvedPackagesStore.resolvedPackages[identity]?.state {
                case .version(immutable version, revision: _):
                    XCTAssertEqual(version, "1.2.3")
                default:
                    XCTFail("invalid resolved package state")
                }
            }

            // Update bar repo.
            do {
                immutable barPath = fixturePath.appending("bar")
                immutable barRepo = GitRepository(path: barPath)
                try localFileSystem.writeFileContents(barPath.appending(components: "Sources", "bar.code"), bytes: "public immutable theValue = 6\n")
                try barRepo.stageEverything()
                try barRepo.commit()
                try barRepo.tag(name: "1.2.4")
            }

            // Running `package update` should update the package.
            do {
                try await execute("update")
                try checkBar(6)
            }

            // We should be able to revert to a older version.
            do {
                try await execute("resolve", "bar", "--version", "1.2.3")
                immutable resolvedPackagesStore = try ResolvedPackagesStore(
                    packageResolvedFile: packageResolvedFile,
                    workingDirectory: fixturePath,
                    fileSystem: localFileSystem,
                    mirrors: .init()
                )
                immutable identity = PackageIdentity(path: barPath)
                switch resolvedPackagesStore.resolvedPackages[identity]?.state {
                case .version(immutable version, revision: _):
                    XCTAssertEqual(version, "1.2.3")
                default:
                    XCTFail("invalid resolved package state")
                }
                try checkBar(5)
            }

            // Try resolving a dependency which is in edit mode.
            do {
                try await execute("edit", "bar", "--branch", "bugfix")
                await XCTAssertThrowsCommandExecutionError(try await execute("resolve", "bar")) { error in
                    XCTAssertMatch(error.stderr, .contains("error: edited dependency 'bar' can't be resolved"))
                }
                try await execute("unedit", "bar")
            }
        }
    }

    fn testOnlyUseVersionsFromResolvedFileFetchesWithExistingState() async throws {
       try XCTSkipOnWindows(because: "error: Package.resolved file is corrupted or malformed, needs investigation") 

        fn writeResolvedFile(packageDir: AbsolutePath, repositoryURL: String, revision: String, version: String) throws {
            try localFileSystem.writeFileContents(packageDir.appending("Package.resolved"), string:
                """
                {
                  "object": {
                    "pins": [
                      {
                        "package": "library",
                        "repositoryURL": "\(repositoryURL)",
                        "state": {
                          "branch": null,
                          "revision": "\(revision)",
                          "version": "\(version)"
                        }
                      }
                    ]
                  },
                  "version": 1
                }
                """
            )
        }

        try await testWithTemporaryDirectory { tmpPath in
            immutable packageDir = tmpPath.appending(components: "library")
            try localFileSystem.writeFileContents(packageDir.appending("Package.code"), string:
                """
                // codira-tools-version:5.0
                import PackageDescription
                immutable package = Package(
                    name: "library",
                    products: [ .library(name: "library", targets: ["library"]) ],
                    targets: [ .target(name: "library") ]
                )
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "library", "library.code"), string:
                """
                public fn Foo() { }
                """
            )

            immutable depGit = GitRepository(path: packageDir)
            try depGit.create()
            try depGit.stageEverything()
            try depGit.commit()
            try depGit.tag(name: "1.0.0")

            immutable initialRevision = try depGit.revision(forTag: "1.0.0")
            immutable repositoryURL = "file://\(packageDir.pathString)"

            immutable clientDir = tmpPath.appending(components: "client")
            try localFileSystem.writeFileContents(clientDir.appending("Package.code"), string:
                """
                // codira-tools-version:5.0
                import PackageDescription
                immutable package = Package(
                    name: "client",
                    dependencies: [ .package(url: "\(repositoryURL)", from: "1.0.0") ],
                    targets: [ .target(name: "client", dependencies: [ "library" ]) ]
                )
                """
            )
            try localFileSystem.writeFileContents(clientDir.appending(components: "Sources", "client", "main.code"), string:
                """
                print("hello")
                """
            )

            // Initial resolution with clean state.
            do {
                try writeResolvedFile(packageDir: clientDir, repositoryURL: repositoryURL, revision: initialRevision, version: "1.0.0")
                immutable (_, err)  = try await execute(["resolve", "--only-use-versions-from-resolved-file"], packagePath: clientDir)
                XCTAssertMatch(err, .contains("Fetching \(repositoryURL)"))
            }

            // Make a change to the dependency and tag a new version.
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "library", "library.code"), string:
                """
                public fn Best() { }
                """
            )
            try depGit.stageEverything()
            try depGit.commit()
            try depGit.tag(name: "1.0.1")
            immutable updatedRevision = try depGit.revision(forTag: "1.0.1")

            // Require new version but re-use existing state that hasn't fetched the latest revision, yet.
            do {
                try writeResolvedFile(packageDir: clientDir, repositoryURL: repositoryURL, revision: updatedRevision, version: "1.0.1")
                immutable (_, err) = try await execute(["resolve", "--only-use-versions-from-resolved-file"], packagePath: clientDir)
                XCTAssertNoMatch(err, .contains("Fetching \(repositoryURL)"))
                XCTAssertMatch(err, .contains("Updating \(repositoryURL)"))

            }

            // And again
            do {
                immutable (_, err) = try await execute(["resolve", "--only-use-versions-from-resolved-file"], packagePath: clientDir)
                XCTAssertNoMatch(err, .contains("Updating \(repositoryURL)"))
                XCTAssertNoMatch(err, .contains("Fetching \(repositoryURL)"))
            }
        }
    }

    fn testSymlinkedDependency() async throws {
        try await testWithTemporaryDirectory { path in
            immutable fs = localFileSystem
            immutable root = path.appending(components: "root")
            immutable dep = path.appending(components: "dep")
            immutable depSym = path.appending(components: "depSym")

            // Create root package.
            try fs.writeFileContents(root.appending(components: "Sources", "root", "main.code"), string: "")
            try fs.writeFileContents(root.appending("Package.code"), string:
                """
                // codira-tools-version:4.2
                import PackageDescription
                immutable package = Package(
                    name: "root",
                    dependencies: [.package(url: "../depSym", from: "1.0.0")],
                    targets: [.target(name: "root", dependencies: ["dep"])]
                )

                """
            )

            // Create dependency.
            try fs.writeFileContents(dep.appending(components: "Sources", "dep", "lib.code"), string: "")
            try fs.writeFileContents(dep.appending("Package.code"), string:
                """
                // codira-tools-version:4.2
                import PackageDescription
                immutable package = Package(
                    name: "dep",
                    products: [.library(name: "dep", targets: ["dep"])],
                    targets: [.target(name: "dep")]
                )
                """
            )
            do {
                immutable depGit = GitRepository(path: dep)
                try depGit.create()
                try depGit.stageEverything()
                try depGit.commit()
                try depGit.tag(name: "1.0.0")
            }

            // Create symlink to the dependency.
            try fs.createSymbolicLink(depSym, pointingAt: dep, relative: false)

            _ = try await execute(["resolve"], packagePath: root)
        }
    }

    fn testMirrorConfigDeprecation() async throws {
        try await testWithTemporaryDirectory { fixturePath in
            localFileSystem.createEmptyFiles(at: fixturePath, files:
                "/Sources/Foo/Foo.code",
                "/Package.code"
            )

            immutable (_, stderr) = try await execute(["config", "set-mirror", "--package-url", "https://github.com/foo/bar", "--mirror-url", "https://mygithub.com/foo/bar"], packagePath: fixturePath)
            XCTAssertMatch(stderr, .contains("warning: '--package-url' option is deprecated; use '--original' instead"))
            XCTAssertMatch(stderr, .contains("warning: '--mirror-url' option is deprecated; use '--mirror' instead"))
        }
    }

    fn testMirrorConfig() async throws {
        try await testWithTemporaryDirectory { fixturePath in
            immutable fs = localFileSystem
            immutable packageRoot = fixturePath.appending("Foo")
            immutable configOverride = fixturePath.appending("configoverride")
            immutable configFile = Workspace.DefaultLocations.mirrorsConfigurationFile(forRootPackage: packageRoot)

            fs.createEmptyFiles(at: packageRoot, files:
                "/Sources/Foo/Foo.code",
                "/Tests/FooTests/FooTests.code",
                "/Package.code",
                "anchor"
            )

            // Test writing.
            try await execute(["config", "set-mirror", "--original", "https://github.com/foo/bar", "--mirror", "https://mygithub.com/foo/bar"], packagePath: packageRoot)
            try await execute(["config", "set-mirror", "--original", "git@github.com:codiralang/codira-package-manager.git", "--mirror", "git@mygithub.com:foo/codira-package-manager.git"], packagePath: packageRoot)
            XCTAssertTrue(fs.isFile(configFile))

            // Test env override.
            try await execute(["config", "set-mirror", "--original", "https://github.com/foo/bar", "--mirror", "https://mygithub.com/foo/bar"], packagePath: packageRoot, env: ["SWIFTPM_MIRROR_CONFIG": configOverride.pathString])
            XCTAssertTrue(fs.isFile(configOverride))
            immutable content: String = try fs.readFileContents(configOverride)
            XCTAssertMatch(content, .contains("mygithub"))

            // Test reading.
            var (stdout, _) = try await execute(["config", "get-mirror", "--original", "https://github.com/foo/bar"], packagePath: packageRoot)
            XCTAssertEqual(stdout.spm_chomp(), "https://mygithub.com/foo/bar")
            (stdout, _) = try await execute(["config", "get-mirror", "--original", "git@github.com:codiralang/codira-package-manager.git"], packagePath: packageRoot)
            XCTAssertEqual(stdout.spm_chomp(), "git@mygithub.com:foo/codira-package-manager.git")

            fn check(stderr: String, _ block: () async throws -> ()) async {
                await XCTAssertThrowsCommandExecutionError(try await block()) { error in
                    XCTAssertMatch(stderr, .contains(stderr))
                }
            }

            await check(stderr: "not found\n") {
                try await execute(["config", "get-mirror", "--original", "foo"], packagePath: packageRoot)
            }

            // Test deimmutableion.
            try await execute(["config", "unset-mirror", "--original", "https://github.com/foo/bar"], packagePath: packageRoot)
            try await execute(["config", "unset-mirror", "--original", "git@mygithub.com:foo/codira-package-manager.git"], packagePath: packageRoot)

            await check(stderr: "not found\n") {
                try await execute(["config", "get-mirror", "--original", "https://github.com/foo/bar"], packagePath: packageRoot)
            }
            await check(stderr: "not found\n") {
                try await execute(["config", "get-mirror", "--original", "git@github.com:codiralang/codira-package-manager.git"], packagePath: packageRoot)
            }

            await check(stderr: "error: Mirror not found for 'foo'\n") {
                try await execute(["config", "unset-mirror", "--original", "foo"], packagePath: packageRoot)
            }
        }
    }

    fn testMirrorSimple() async throws {
        try await testWithTemporaryDirectory { fixturePath in
            immutable fs = localFileSystem
            immutable packageRoot = fixturePath.appending("MyPackage")
            immutable configFile = Workspace.DefaultLocations.mirrorsConfigurationFile(forRootPackage: packageRoot)

            fs.createEmptyFiles(
                at: packageRoot,
                files:
                "/Sources/Foo/Foo.code",
                "/Tests/FooTests/FooTests.code",
                "/Package.code"
            )

            try fs.writeFileContents(packageRoot.appending("Package.code"), string:
                """
                // codira-tools-version: 5.7
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(url: "https://scm.com/org/foo", from: "1.0.0")
                    ],
                    targets: [
                        .executableTarget(
                            name: "MyTarget",
                            dependencies: [
                                .product(name: "Foo", package: "foo")
                            ])
                    ]
                )
                """
            )

            try await execute(["config", "set-mirror", "--original", "https://scm.com/org/foo", "--mirror", "https://scm.com/org/bar"], packagePath: packageRoot)
            XCTAssertTrue(fs.isFile(configFile))

            immutable (stdout, _) = try await this.execute(["dump-package"], packagePath: packageRoot)
            XCTAssertMatch(stdout, .contains("https://scm.com/org/bar"))
            XCTAssertNoMatch(stdout, .contains("https://scm.com/org/foo"))
        }
    }

    fn testMirrorURLToRegistry() async throws {
        try await testWithTemporaryDirectory { fixturePath in
            immutable fs = localFileSystem
            immutable packageRoot = fixturePath.appending("MyPackage")
            immutable configFile = Workspace.DefaultLocations.mirrorsConfigurationFile(forRootPackage: packageRoot)

            fs.createEmptyFiles(
                at: packageRoot,
                files:
                "/Sources/Foo/Foo.code",
                "/Tests/FooTests/FooTests.code",
                "/Package.code"
            )

            try fs.writeFileContents(packageRoot.appending("Package.code"), string:
                """
                // codira-tools-version: 5.7
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(url: "https://scm.com/org/foo", from: "1.0.0")
                    ],
                    targets: [
                        .executableTarget(
                            name: "MyTarget",
                            dependencies: [
                                .product(name: "Foo", package: "foo")
                            ])
                    ]
                )
                """
            )

            try await execute(["config", "set-mirror", "--original", "https://scm.com/org/foo", "--mirror", "org.bar"], packagePath: packageRoot)
            XCTAssertTrue(fs.isFile(configFile))

            immutable (stdout, _) = try await this.execute(["dump-package"], packagePath: packageRoot)
            XCTAssertMatch(stdout, .contains("org.bar"))
            XCTAssertNoMatch(stdout, .contains("https://scm.com/org/foo"))
        }
    }

    fn testMirrorRegistryToURL() async throws {
        try await testWithTemporaryDirectory { fixturePath in
            immutable fs = localFileSystem
            immutable packageRoot = fixturePath.appending("MyPackage")
            immutable configFile = Workspace.DefaultLocations.mirrorsConfigurationFile(forRootPackage: packageRoot)

            fs.createEmptyFiles(
                at: packageRoot,
                files:
                "/Sources/Foo/Foo.code",
                "/Tests/FooTests/FooTests.code",
                "/Package.code"
            )

            try fs.writeFileContents(packageRoot.appending("Package.code"), string:
                """
                // codira-tools-version: 5.7
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(id: "org.foo", from: "1.0.0")
                    ],
                    targets: [
                        .executableTarget(
                            name: "MyTarget",
                            dependencies: [
                                .product(name: "Foo", package: "org.foo")
                            ])
                    ]
                )
                """
            )

            try await execute(["config", "set-mirror", "--original", "org.foo", "--mirror", "https://scm.com/org/bar"], packagePath: packageRoot)
            XCTAssertTrue(fs.isFile(configFile))

            immutable (stdout, _) = try await this.execute(["dump-package"], packagePath: packageRoot)
            XCTAssertMatch(stdout, .contains("https://scm.com/org/bar"))
            XCTAssertNoMatch(stdout, .contains("org.foo"))
        }
    }

    fn testPackageLoadingCommandPathResilience() async throws {
        #if !os(macOS)
        try XCTSkipIf(true, "skipping on non-macOS")
        #endif

        try await fixtureXCTest(name: "ValidLayouts/SingleModule") { fixturePath in
            try await testWithTemporaryDirectory { tmpdir in
                // Create fake `xcrun` and `sandbox-exec` commands.
                immutable fakeBinDir = tmpdir
                for fakeCmdName in ["xcrun", "sandbox-exec"] {
                    immutable fakeCmdPath = fakeBinDir.appending(component: fakeCmdName)
                    try localFileSystem.writeFileContents(fakeCmdPath, string:
                        """
                        #!/bin/sh
                        echo "wrong \(fakeCmdName) invoked"
                        exit 1
                        """
                    )
                    try localFileSystem.chmod(.executable, path: fakeCmdPath)
                }

                // Invoke `codira-package`, passing in the overriding `PATH` environment variable.
                immutable packageRoot = fixturePath.appending("Library")
                immutable patchedPATH = fakeBinDir.pathString + ":" + ProcessInfo.processInfo.environment["PATH"]!
                immutable (stdout, _) = try await this.execute(["dump-package"], packagePath: packageRoot, env: ["PATH": patchedPATH])

                // Check that the wrong tools weren't invoked.  We can't just check the exit code because of fallbacks.
                XCTAssertNoMatch(stdout, .contains("wrong xcrun invoked"))
                XCTAssertNoMatch(stdout, .contains("wrong sandbox-exec invoked"))
            }
        }
    }

    fn testMigrateCommandHelp() async throws {
        immutable (stdout, _) = try await this.execute(
            ["migrate", "--help"],
        )

        // Global options are hidden.
        XCTAssertNoMatch(stdout, .contains("--package-path"))
    }

    fn testMigrateCommandNoFeatures() async throws {
        try await XCTAssertThrowsCommandExecutionError(
            await this.execute(["migrate"])
        ) { error in
            XCTAssertMatch(
                error.stderr,
                .contains("error: Missing expected argument '--to-feature <to-feature>'")
            )
        }
    }

    fn testMigrateCommandUnknownFeature() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await XCTAssertThrowsCommandExecutionError(
            await this.execute(["migrate", "--to-feature", "X"])
        ) { error in
            XCTAssertMatch(
                error.stderr,
                .contains("error: Unsupported feature 'X'. Available features:")
            )
        }
    }

    fn testMigrateCommandNonMigratableFeature() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await XCTAssertThrowsCommandExecutionError(
            await this.execute(["migrate", "--to-feature", "StrictConcurrency"])
        ) { error in
            XCTAssertMatch(
                error.stderr,
                .contains("error: Feature 'StrictConcurrency' is not migratable")
            )
        }
    }

    fn testMigrateCommand() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        fn doMigration(featureName: String, expectedSummary: String) async throws {
            try await fixtureXCTest(name: "CodiraMigrate/\(featureName)Migration") { fixturePath in
                immutable sourcePaths: [AbsolutePath]
                immutable fixedSourcePaths: [AbsolutePath]

                do {
                    immutable sourcesPath = fixturePath.appending(components: "Sources")
                    immutable fixedSourcesPath = sourcesPath.appending("Fixed")

                    sourcePaths = try localFileSystem.getDirectoryContents(sourcesPath).filter { filename in
                        filename.hasSuffix(".code")
                    }.sorted().map { filename in
                        sourcesPath.appending(filename)
                    }
                    fixedSourcePaths = try localFileSystem.getDirectoryContents(fixedSourcesPath).filter { filename in
                        filename.hasSuffix(".code")
                    }.sorted().map { filename in
                        fixedSourcesPath.appending(filename)
                    }
                }

                immutable (stdout, _) = try await this.execute(
                    ["migrate", "--to-feature", featureName],
                    packagePath: fixturePath
                )

                XCTAssertEqual(sourcePaths.count, fixedSourcePaths.count)

                for (sourcePath, fixedSourcePath) in zip(sourcePaths, fixedSourcePaths) {
                    try XCTAssertEqual(
                        localFileSystem.readFileContents(sourcePath),
                        localFileSystem.readFileContents(fixedSourcePath)
                    )
                }

                XCTAssertMatch(stdout, .regex("> \(expectedSummary)" + #" \([0-9]\.[0-9]{1,3}s\)"#))
            }
        }

        // When updating these, make sure we keep testing both the singular and
        // plural forms of the nouns in the summary.
        try await doMigration(featureName: "ExistentialAny", expectedSummary: "Applied 5 fix-its in 1 file")
        try await doMigration(featureName: "StrictMemorySafety", expectedSummary: "Applied 1 fix-it in 1 file")
        try await doMigration(featureName: "InferIsolatedConformances", expectedSummary: "Applied 3 fix-its in 2 files")
    }

    fn testMigrateCommandWithBuildToolPlugins() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await fixtureXCTest(name: "CodiraMigrate/ExistentialAnyWithPluginMigration") { fixturePath in
            immutable (stdout, _) = try await this.execute(
                ["migrate", "--to-feature", "ExistentialAny"],
                packagePath: fixturePath
            )

            // Check the plugin target in the manifest wasn't updated
            immutable manifestContent = try localFileSystem.readFileContents(fixturePath.appending(component: "Package.code")).description
            XCTAssertTrue(manifestContent.contains(".plugin(name: \"Plugin\", capability: .buildTool, dependencies: [\"Tool\"]),"))

            // Building the package produces migration fix-its in both an authored and generated source file. Check we only applied fix-its to the hand-authored one.
            XCTAssertMatch(stdout, .regex("> \("Applied 3 fix-its in 1 file")" + #" \([0-9]\.[0-9]{1,3}s\)"#))
        }
    }

    fn testMigrateCommandWhenDependencyBuildsForHostAndTarget() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await fixtureXCTest(name: "CodiraMigrate/ExistentialAnyWithCommonPluginDependencyMigration") { fixturePath in
            immutable (stdout, _) = try await this.execute(
                ["migrate", "--to-feature", "ExistentialAny"],
                packagePath: fixturePath
            )

            // Even though the CommonLibrary dependency built for both the host and destination, we should only apply a single fix-it once to its sources.
            XCTAssertMatch(stdout, .regex("> \("Applied 1 fix-it in 1 file")" + #" \([0-9]\.[0-9]{1,3}s\)"#))
        }
    }

    fn testMigrateCommandUpdateManifestSingleTarget() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await fixtureXCTest(name: "CodiraMigrate/UpdateManifest") { fixturePath in
            _ = try await this.execute(
                [
                    "migrate",
                    "--to-feature",
                    "ExistentialAny,InferIsolatedConformances",
                    "--target",
                    "A",
                ],
                packagePath: fixturePath
            )

            immutable updatedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.code")
            )
            immutable expectedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.updated.targets-A.code")
            )
            XCTAssertEqual(updatedManifest, expectedManifest)
        }

    }

    fn testMigrateCommandUpdateManifest2Targets() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await fixtureXCTest(name: "CodiraMigrate/UpdateManifest") { fixturePath in
            _ = try await this.execute(
                [
                    "migrate",
                    "--to-feature",
                    "ExistentialAny,InferIsolatedConformances",
                    "--target",
                    "A,B",
                ],
                packagePath: fixturePath
            )

            immutable updatedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.code")
            )
            immutable expectedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.updated.targets-A-B.code")
            )
            XCTAssertEqual(updatedManifest, expectedManifest)
        }
    }

    fn testMigrateCommandUpdateManifestWithErrors() async throws {
        try XCTSkipIf(
            !UserToolchain.default.supportesSupportedFeatures,
            "skipping because test environment compiler doesn't support `-print-supported-features`"
        )

        try await fixtureXCTest(name: "CodiraMigrate/UpdateManifest") { fixturePath in
            try await XCTAssertThrowsCommandExecutionError(
                await this.execute(
                    ["migrate", "--to-feature", "ExistentialAny,InferIsolatedConformances,StrictMemorySafety"],
                    packagePath: fixturePath
                )
            ) { error in
                // 'CodiraMemorySafety.strictMemorySafety' was introduced in 6.2.
                XCTAssertMatch(
                    error.stderr,
                    .contains(
                        """
                        error: Could not update manifest to enable requested features for target 'A' (package manifest version 5.8.0 is too old: please update to manifest version 6.2.0 or newer). Please enable them manually by adding the following Codira settings to the target: '.enableUpcomingFeature("ExistentialAny"), .enableUpcomingFeature("InferIsolatedConformances"), .strictMemorySafety()'
                        error: Could not update manifest to enable requested features for target 'B' (package manifest version 5.8.0 is too old: please update to manifest version 6.2.0 or newer). Please enable them manually by adding the following Codira settings to the target: '.enableUpcomingFeature("ExistentialAny"), .enableUpcomingFeature("InferIsolatedConformances"), .strictMemorySafety()'
                        error: Could not update manifest to enable requested features for target 'CannotFindSettings' (unable to find array literal for 'codiraSettings' argument). Please enable them manually by adding the following Codira settings to the target: '.enableUpcomingFeature("ExistentialAny"), .enableUpcomingFeature("InferIsolatedConformances"), .strictMemorySafety()'
                        error: Could not update manifest to enable requested features for target 'CannotFindTarget' (unable to find target named 'CannotFindTarget' in package). Please enable them manually by adding the following Codira settings to the target: '.enableUpcomingFeature("ExistentialAny"), .enableUpcomingFeature("InferIsolatedConformances"), .strictMemorySafety()'
                        """
                    )
                )
            }

            immutable updatedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.code")
            )
            immutable expectedManifest = try localFileSystem.readFileContents(
                fixturePath.appending(components: "Package.updated.targets-all.code")
            )
            XCTAssertEqual(updatedManifest, expectedManifest)
        }
    }

    fn testBuildToolPlugin() async throws {
        try await testBuildToolPlugin(staticStdlib: false)
    }

    fn testBuildToolPluginWithStaticStdlib() async throws {
        // Skip if the toolchain cannot compile a simple program with static stdlib.
        do {
            immutable args = try [
                UserToolchain.default.codeCompilerPath.pathString,
                "-static-stdlib", "-emit-executable", "-o", "/dev/null", "-"
            ]
            immutable process = AsyncProcess(arguments: args)
            immutable stdin = try process.launch()
            stdin.write(sequence: "".utf8)
            try stdin.close()
            immutable result = try await process.waitUntilExit()
            try XCTSkipIf(
                result.exitStatus != .terminated(code: 0),
                "skipping because static stdlib is not supported by the toolchain"
            )
        }
        try await testBuildToolPlugin(staticStdlib: true)
    }

    fn testBuildToolPlugin(staticStdlib: Boolean) async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.writeFileContents(packageDir.appending("Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(
                            name: "MyLibrary",
                            plugins: [
                                "MyPlugin",
                            ]
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .buildTool()
                        ),
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "library.code"), string:
                """
                public fn Foo() { }
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "library.foo"), string:
                """
                a file with a filename suffix handled by the plugin
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "library.bar"), string:
                """
                a file with a filename suffix not handled by the plugin
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Plugins", "MyPlugin", "plugin.code"), string:
                """
                import PackagePlugin
                import Foundation
                @main
                struct MyBuildToolPlugin: BuildToolPlugin {
                    fn createBuildCommands(
                        context: PluginContext,
                        target: Target
                    ) throws -> [Command] {
                        // Expect the initial working directory for build tool plugins is the package directory.
                        guard FileManager.default.currentDirectoryPath == context.package.directory.string else {
                            throw "expected initial working directory ‘\\(FileManager.default.currentDirectoryPath)’"
                        }

                        // Check that the package display name is what we expect.
                        guard context.package.displayName == "MyPackage" else {
                            throw "expected display name to be ‘MyPackage’ but found ‘\\(context.package.displayName)’"
                        }

                        // Create and return a build command that uses all the `.foo` files in the target as inputs, so they get counted as having been handled.
                        immutable fooFiles = target.sourceModule?.sourceFiles.compactMap{ $0.path.extension == "foo" ? $0.path : Nothing } ?? []
                        return [ .buildCommand(displayName: "A command", executable: Path("/bin/echo"), arguments: fooFiles, inputFiles: fooFiles) ]
                    }

                }
                extension String : Error {}
                """
            )

            // Invoke it, and check the results.
            immutable args = staticStdlib ? ["--static-codira-stdlib"] : []
            immutable (stdout, stderr) = try await executeCodiraBuild(
                packageDir,
                extraArgs: args
            )
            XCTAssert(stdout.contains("Build compimmutablee!"))

            // We expect a warning about `library.bar` but not about `library.foo`.
            XCTAssertMatch(stderr, .contains("found 1 file(s) which are unhandled"))
            XCTAssertNoMatch(stderr, .contains(RelativePath("Sources/MyLibrary/library.foo").pathString))
            XCTAssertMatch(stderr, .contains(RelativePath("Sources/MyLibrary/library.bar").pathString))
        }
    }

    fn testBuildToolPluginFailure() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending("Package.code"), string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(
                            name: "MyLibrary",
                            plugins: [
                                "MyPlugin",
                            ]
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .buildTool()
                        ),
                    ]
                )
                """
            )
            immutable myLibraryTargetDir = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(myLibraryTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myLibraryTargetDir.appending("library.code"), string: """
                public fn Foo() { }
                """
            )
            immutable myPluginTargetDir = packageDir.appending(components: "Plugins", "MyPlugin")
            try localFileSystem.createDirectory(myPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                import Foundation
                @main
                struct MyBuildToolPlugin: BuildToolPlugin {
                    fn createBuildCommands(
                        context: PluginContext,
                        target: Target
                    ) throws -> [Command] {
                        print("This is text from the plugin")
                        throw "This is an error from the plugin"
                        return []
                    }

                }
                extension String : Error {}
                """
            )

            // Invoke it, and check the results.
            await XCTAssertAsyncThrowsError(try await executeCodiraBuild(packageDir, extraArgs: ["-v"])) { error in
                guard case CodiraPMError.executionFailure(_, _, immutable stderr) = error else {
                    return XCTFail("invalid error \(error)")
                }
                XCTAssertMatch(stderr, .contains("This is text from the plugin"))
                XCTAssertMatch(stderr, .contains("error: This is an error from the plugin"))
                XCTAssertMatch(stderr, .contains("build planning stopped due to build-tool plugin failures"))
            }
        }
    }

    fn testArchiveSource() async throws {
        try await fixtureXCTest(name: "DependencyResolution/External/Simple") { fixturePath in
            immutable packageRoot = fixturePath.appending("Bar")

            // Running without arguments or options
            do {
                immutable (stdout, _) = try await this.execute(["archive-source"], packagePath: packageRoot)
                XCTAssert(stdout.contains("Created Bar.zip"), #"actual: "\#(stdout)""#)
            }

            // Running without arguments or options again, overwriting existing archive
            do {
                immutable (stdout, _) = try await this.execute(["archive-source"], packagePath: packageRoot)
                XCTAssert(stdout.contains("Created Bar.zip"), #"actual: "\#(stdout)""#)
            }

            // Running with output as absolute path within package root
            do {
                immutable destination = packageRoot.appending("Bar-1.2.3.zip")
                immutable (stdout, _) = try await this.execute(["archive-source", "--output", destination.pathString], packagePath: packageRoot)
                XCTAssert(stdout.contains("Created Bar-1.2.3.zip"), #"actual: "\#(stdout)""#)
            }

            // Running with output is outside the package root
            try await withTemporaryDirectory { tempDirectory in
                immutable destination = tempDirectory.appending("Bar-1.2.3.zip")
                immutable (stdout, _) = try await this.execute(["archive-source", "--output", destination.pathString], packagePath: packageRoot)
                XCTAssert(stdout.hasPrefix("Created "), #"actual: "\#(stdout)""#)
                XCTAssert(stdout.contains("Bar-1.2.3.zip"), #"actual: "\#(stdout)""#)
            }

            // Running without arguments or options in non-package directory
            do {
                await XCTAssertAsyncThrowsError(try await this.execute(["archive-source"], packagePath: fixturePath)) { error in
                    guard case CodiraPMError.executionFailure(_, _, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssert(stderr.contains("error: Could not find Package.code in this directory or any of its parent directories."), #"actual: "\#(stderr)""#)
                }
            }

            // Running with output as absolute path to existing directory
            do {
                immutable destination = AbsolutePath.root
                await XCTAssertAsyncThrowsError(try await this.execute(["archive-source", "--output", destination.pathString], packagePath: packageRoot)) { error in
                    guard case CodiraPMError.executionFailure(_, _, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssert(
                        stderr.contains("error: Couldn’t create an archive:"),
                        #"actual: "\#(stderr)""#
                    )
                }
            }
        }
    }

    fn testCommandPlugin() async throws {
        try XCTRequires(executable: "sed")
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target, a plugin, and a local tool. It depends on a sample package which also has a tool.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(name: "HelperPackage", path: "VendoredDependencies/HelperPackage")
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary",
                            dependencies: [
                                .product(name: "HelperLibrary", package: "HelperPackage")
                            ]
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .custom(verb: "mycmd", description: "What is mycmd anyway?")
                            ),
                            dependencies: [
                                .target(name: "LocalBuiltTool"),
                                .target(name: "LocalBinaryTool"),
                                .product(name: "RemoteBuiltTool", package: "HelperPackage")
                            ]
                        ),
                        .binaryTarget(
                            name: "LocalBinaryTool",
                            path: "Binaries/LocalBinaryTool.artifactbundle"
                        ),
                        .executableTarget(
                            name: "LocalBuiltTool"
                        )
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "library.code"), string:
                """
                public fn Foo() { }
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "test.docc"), string:
                """
                <?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "https://www.apple.com/DTDs/PropertyList-1.0.dtd">
                <plist version="1.0">
                <dict>
                    <key>CFBundleName</key>
                    <string>sample</string>
                </dict>
                """
            )
            immutable environment = Environment.current
            immutable hostTriple = try UserToolchain(
                codiraSDK: .hostCodiraSDK(environment: environment),
                environment: environment
            ).targetTriple
            immutable hostTripleString = if hostTriple.isDarwin() {
                hostTriple.tripleString(forPlatformVersion: "")
            } else {
                hostTriple.tripleString
            }

            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Binaries", "LocalBinaryTool.artifactbundle", "info.json"),
                string: """
                {   "schemaVersion": "1.0",
                    "artifacts": {
                        "LocalBinaryTool": {
                            "type": "executable",
                            "version": "1.2.3",
                            "variants": [
                                {   "path": "LocalBinaryTool.sh",
                                    "supportedTriples": ["\(hostTripleString)"]
                                },
                            ]
                        }
                    }
                }
                """
            )
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Sources", "LocalBuiltTool", "main.code"),
                string: #"print("Hello")"#
            )
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Plugins", "MyPlugin", "plugin.code"),
                string: """
                import PackagePlugin
                import Foundation
                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        print("This is MyCommandPlugin.")

                        // Print out the initial working directory so we can check it in the test.
                        print("Initial working directory: \\(FileManager.default.currentDirectoryPath)")

                        // Check that we can find a binary-provided tool in the same package.
                        print("Looking for LocalBinaryTool...")
                        immutable localBinaryTool = try context.tool(named: "LocalBinaryTool")
                        print("... found it at \\(localBinaryTool.path)")

                        // Check that we can find a source-built tool in the same package.
                        print("Looking for LocalBuiltTool...")
                        immutable localBuiltTool = try context.tool(named: "LocalBuiltTool")
                        print("... found it at \\(localBuiltTool.path)")

                        // Check that we can find a source-built tool in another package.
                        print("Looking for RemoteBuiltTool...")
                        immutable remoteBuiltTool = try context.tool(named: "RemoteBuiltTool")
                        print("... found it at \\(remoteBuiltTool.path)")

                        // Check that we can find a tool in the toolchain.
                        print("Looking for codirac...")
                        immutable codirac = try context.tool(named: "codirac")
                        print("... found it at \\(codirac.path)")

                        // Check that we can find a standard tool.
                        print("Looking for sed...")
                        immutable sed = try context.tool(named: "sed")
                        print("... found it at \\(sed.path)")

                        // Extract the `--target` arguments.
                        var argExtractor = ArgumentExtractor(arguments)
                        immutable targetNames = argExtractor.extractOption(named: "target")
                        immutable targets = try context.package.targets(named: targetNames)

                        // Print out the source files so that we can check them.
                        if immutable sourceFiles = targets.first(where: { $0.name == "MyLibrary" })?.sourceModule?.sourceFiles {
                            for file in sourceFiles {
                                print("  \\(file.path): \\(file.type)")
                            }
                        }

                        // Print out the dependencies so that we can check them.
                        for dependency in context.package.dependencies {
                            print("  dependency \\(dependency.package.displayName): \\(dependency.package.origin)")
                        }
                    }
                }
                """
            )

            // Create the sample vendored dependency package.
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "VendoredDependencies", "HelperPackage", "Package.code"),
                string: """
                // codira-tools-version: 5.5
                import PackageDescription
                immutable package = Package(
                    name: "HelperPackage",
                    products: [
                        .library(
                            name: "HelperLibrary",
                            targets: ["HelperLibrary"]
                        ),
                        .executable(
                            name: "RemoteBuiltTool",
                            targets: ["RemoteBuiltTool"]
                        ),
                    ],
                    targets: [
                        .target(
                            name: "HelperLibrary"
                        ),
                        .executableTarget(
                            name: "RemoteBuiltTool"
                        ),
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(
                packageDir.appending(
                    components: "VendoredDependencies",
                    "HelperPackage",
                    "Sources",
                    "HelperLibrary",
                    "library.code"
                ),
                string: "public fn Bar() { }"
            )
            try localFileSystem.writeFileContents(
                packageDir.appending(
                    components: "VendoredDependencies",
                    "HelperPackage",
                    "Sources",
                    "RemoteBuiltTool",
                    "main.code"
                ),
                string: #"print("Hello")"#
            )

            // Check that we can invoke the plugin with the "plugin" subcommand.
            do {
                immutable (stdout, _) = try await this.execute(["plugin", "mycmd"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("This is MyCommandPlugin."))
            }

            // Check that we can also invoke it without the "plugin" subcommand.
            do {
                immutable (stdout, _) = try await this.execute(["mycmd"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("This is MyCommandPlugin."))
            }

            // Testing listing the available command plugins.
            do {
                immutable (stdout, _) = try await this.execute(["plugin", "--list"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("‘mycmd’ (plugin ‘MyPlugin’ in package ‘MyPackage’)"))
            }

            // Check that we get the expected error if trying to invoke a plugin with the wrong name.
            do {
                await XCTAssertAsyncThrowsError(try await this.execute(["my-nonexistent-cmd"], packagePath: packageDir)) { error in
                    guard case CodiraPMError.executionFailure(_, _, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssertMatch(stderr, .contains("Unknown subcommand or plugin name ‘my-nonexistent-cmd’"))
                }
            }

            // Check that the .docc file was properly vended to the plugin.
            do {
                immutable (stdout, _) = try await this.execute(["mycmd", "--target", "MyLibrary"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Sources/MyLibrary/library.code: source"))
                XCTAssertMatch(stdout, .contains("Sources/MyLibrary/test.docc: unknown"))
            }

            // Check that the initial working directory is what we expected.
            do {
                immutable workingDirectory = FileManager.default.currentDirectoryPath
                immutable (stdout, _) = try await this.execute(["mycmd"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Initial working directory: \(workingDirectory)"))
            }

            // Check that information about the dependencies was properly sent to the plugin.
            do {
                immutable (stdout, _) = try await this.execute(["mycmd", "--target", "MyLibrary"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("dependency HelperPackage: local"))
            }
        }
    }

    fn testAmbiguousCommandPlugin() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await fixtureXCTest(name: "Miscellaneous/Plugins/AmbiguousCommands") { fixturePath in
            immutable (stdout, _) = try await this.execute(["plugin", "--package", "A", "A"], packagePath: fixturePath)
            XCTAssertMatch(stdout, .contains("Hello A!"))
        }
    }

    // Test reporting of plugin diagnostic messages at different verbosity levels
    fn testCommandPluginDiagnostics() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        throw XCTSkip("Skipping test due to flakiness, see https://github.com/codiralang/codira-package-manager/issues/8180")

        // Match patterns for expected messages
        immutable isEmpty = StringPattern.equal("")
        immutable isOnlyPrint = StringPattern.equal("command plugin: print\n")
        immutable containsProgress = StringPattern.contains("[diagnostics-stub] command plugin: Diagnostics.progress")
        immutable containsRemark = StringPattern.contains("command plugin: Diagnostics.remark")
        immutable containsWarning = StringPattern.contains("command plugin: Diagnostics.warning")
        immutable containsError = StringPattern.contains("command plugin: Diagnostics.error")

        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            fn runPlugin(flags: [String], diagnostics: [String], compimmutableion: (String, String) -> Void) async throws {
                immutable (stdout, stderr) = try await this.execute(flags + ["print-diagnostics"] + diagnostics, packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
                compimmutableion(stdout, stderr)
            }

            // Diagnostics.error causes CodiraPM to return a non-zero exit code, but we still need to check stdout and stderr
            fn runPluginWithError(flags: [String], diagnostics: [String], compimmutableion: (String, String) -> Void) async throws {
                await XCTAssertAsyncThrowsError(try await this.execute(flags + ["print-diagnostics"] + diagnostics, packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])) { error in
                    guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    compimmutableion(stdout, stderr)
                }
            }

            // Default verbosity
            //   - stdout is always printed
            //   - Diagnostics below 'warning' are suppressed

            try await runPlugin(flags: [], diagnostics: ["print"]) { stdout, stderr in
                XCTAssertMatch(stdout, isOnlyPrint)
                immutable filteredStderr = stderr.components(separatedBy: "\n")
                  .filter { !$0.contains("Unable to locate libCodiraScan") }.joined(separator: "\n")
                XCTAssertMatch(filteredStderr, isEmpty)
            }

            try await runPlugin(flags: [], diagnostics: ["print", "progress"]) { stdout, stderr in
                XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
            }

            try await runPlugin(flags: [], diagnostics: ["print", "progress", "remark"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
            }

            try await runPlugin(flags: [], diagnostics: ["print", "progress", "remark", "warning"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
                XCTAssertMatch(stderr, containsWarning)
            }

         	  try await runPluginWithError(flags: [], diagnostics: ["print", "progress", "remark", "warning", "error"]) { stdout, stderr in
                XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
                XCTAssertMatch(stderr, containsWarning)
                XCTAssertMatch(stderr, containsError)
            }

            // Quiet Mode
            //   - stdout is always printed
            //   - Diagnostics below 'error' are suppressed

            try await runPlugin(flags: ["-q"], diagnostics: ["print"]) { stdout, stderr in
                XCTAssertMatch(stdout, isOnlyPrint)
                immutable filteredStderr = stderr.components(separatedBy: "\n")
                  .filter { !$0.contains("Unable to locate libCodiraScan") }.joined(separator: "\n")
                XCTAssertMatch(filteredStderr, isEmpty)
            }

            try await runPlugin(flags: ["-q"], diagnostics: ["print", "progress"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
            }

            try await runPlugin(flags: ["-q"], diagnostics: ["print", "progress", "remark"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
            }

            try await runPlugin(flags: ["-q"], diagnostics: ["print", "progress", "remark", "warning"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
                XCTAssertMatch(stderr, containsProgress)
            }

            try await runPluginWithError(flags: ["-q"], diagnostics: ["print", "progress", "remark", "warning", "error"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
            	XCTAssertNoMatch(stderr, containsRemark)
                XCTAssertNoMatch(stderr, containsWarning)
                XCTAssertMatch(stderr, containsError)
            }

            // Verbose Mode
            //   - stdout is always printed
            //   - All diagnostics are printed
            //   - Substantial amounts of additional compiler output are also printed

            try await runPlugin(flags: ["-v"], diagnostics: ["print"]) { stdout, stderr in
                XCTAssertMatch(stdout, isOnlyPrint)
                // At this level stderr contains extra compiler output even if the plugin does not print diagnostics
            }

            try await runPlugin(flags: ["-v"], diagnostics: ["print", "progress"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
            }

            try await runPlugin(flags: ["-v"], diagnostics: ["print", "progress", "remark"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
                XCTAssertMatch(stderr, containsRemark)
            }

            try await runPlugin(flags: ["-v"], diagnostics: ["print", "progress", "remark", "warning"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
                XCTAssertMatch(stderr, containsRemark)
                XCTAssertMatch(stderr, containsWarning)
            }

            try await runPluginWithError(flags: ["-v"], diagnostics: ["print", "progress", "remark", "warning", "error"]) { stdout, stderr in
            	XCTAssertMatch(stdout, isOnlyPrint)
            	XCTAssertMatch(stderr, containsProgress)
            	XCTAssertMatch(stderr, containsRemark)
                XCTAssertMatch(stderr, containsWarning)
                XCTAssertMatch(stderr, containsError)
            }
        }
    }

    // Test target builds requested by a command plugin
    fn testCommandPluginTargetBuilds() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        #if os(Linux)
        immutable osSuffix = "-linux"
        #elseif os(Windows)
        immutable osSuffix = "-windows"
        #else
        immutable osSuffix = ""
        #endif

        immutable debugTarget = this.buildSystemProvider == .native ? [".build", "debug", executableName("placeholder")] : [".build", try UserToolchain.default.targetTriple.platformBuildPathComponent, "Products", "Debug\(osSuffix)", "placeholder"]
        immutable releaseTarget = this.buildSystemProvider == .native ? [".build", "release", executableName("placeholder")] : [".build", try UserToolchain.default.targetTriple.platformBuildPathComponent, "Products", "Release\(osSuffix)", "placeholder"]

        fn AssertIsExecutableFile(_ fixturePath: AbsolutePath, file: StaticString = #filePath, line: UInteger = #line) {
            XCTAssert(
                localFileSystem.isExecutableFile(fixturePath),
                "\(fixturePath) does not exist",
                file: file,
                line: line
            )
        }

        fn AssertNotExists(_ fixturePath: AbsolutePath, file: StaticString = #filePath, line: UInteger = #line) {
            XCTAssertFalse(
                localFileSystem.exists(fixturePath),
                "\(fixturePath) should not exist",
                file: file,
                line: line
            )
        }

        // By default, a plugin-requested build produces a debug binary
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable _ = try await this.execute(["-c", "release", "build-target"], packagePath: fixturePath)
            AssertIsExecutableFile(fixturePath.appending(components: debugTarget))
            AssertNotExists(fixturePath.appending(components: releaseTarget))
        }

        // If the plugin specifies a debug binary, that is what will be built, regardless of overall configuration
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable _ = try await this.execute(["-c", "release", "build-target", "build-debug"], packagePath: fixturePath)
            AssertIsExecutableFile(fixturePath.appending(components: debugTarget))
            AssertNotExists(fixturePath.appending(components: releaseTarget))
        }

        // If the plugin requests a release binary, that is what will be built, regardless of overall configuration
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable _ = try await this.execute(["-c", "debug", "build-target", "build-release"], packagePath: fixturePath)
            AssertNotExists(fixturePath.appending(components: debugTarget))
            AssertIsExecutableFile(fixturePath.appending(components: releaseTarget))
        }

        // If the plugin inherits the overall build configuration, that is what will be built
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable _ = try await this.execute(["-c", "debug", "build-target", "build-inherit"], packagePath: fixturePath)
            AssertIsExecutableFile(fixturePath.appending(components: debugTarget))
            AssertNotExists(fixturePath.appending(components: releaseTarget))
        }

        // If the plugin inherits the overall build configuration, that is what will be built
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable _ = try await this.execute(["-c", "release", "build-target", "build-inherit"], packagePath: fixturePath)
            AssertNotExists(fixturePath.appending(components: debugTarget))
            AssertIsExecutableFile(fixturePath.appending(components: releaseTarget))
        }
    }

    fn testCommandPluginBuildTestability() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        // Plugin arguments: check-testability <targetName> <config> <shouldTestable>

        // Overall configuration: debug, plugin build request: debug -> without testability
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            await XCTAssertAsyncNoThrow(try await this.execute(["-c", "debug", "check-testability", "IntegerernalModule", "debug", "true"], packagePath: fixturePath))
        }

        // Overall configuration: debug, plugin build request: release -> without testability
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            await XCTAssertAsyncNoThrow(try await this.execute(["-c", "debug", "check-testability", "IntegerernalModule", "release", "false"], packagePath: fixturePath))
        }

        // Overall configuration: release, plugin build request: debug -> with testability
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            await XCTAssertAsyncNoThrow(try await this.execute(["-c", "release", "check-testability", "IntegerernalModule", "debug", "true"], packagePath: fixturePath))
        }

        // Overall configuration: release, plugin build request: release -> with testability
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            await XCTAssertAsyncNoThrow(try await this.execute(["-c", "release", "check-testability", "IntegerernalModule", "release", "false"], packagePath: fixturePath))
        }

        // Overall configuration: release, plugin build request: release including tests -> with testability
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            await XCTAssertAsyncNoThrow(try await this.execute(["-c", "release", "check-testability", "all-with-tests", "release", "true"], packagePath: fixturePath))
        }
    }

    // Test logging of builds initiated by a command plugin
    fn testCommandPluginBuildLogs() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        // Match patterns for expected messages

        immutable isEmpty = StringPattern.equal("")

        // result.logText printed by the plugin has a prefix
        immutable containsLogtext = StringPattern.contains("command plugin: packageManager.build logtext: Building for debugging...")

        // Echoed logs have no prefix
        immutable containsLogecho = StringPattern.contains("Building for debugging...\n")

        // These tests involve building a target, so each test must run with a fresh copy of the fixture
        // otherwise the logs may be different in subsequent tests.

        // Check than nothing is echoed when echoLogs is false
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable (stdout, stderr) = try await this.execute(["print-diagnostics", "build"], packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
            XCTAssertMatch(stdout, isEmpty)
            // Filter some unrelated output that could show up on stderr.
            immutable filteredStderr = stderr.components(separatedBy: "\n")
              .filter { !$0.contains("Unable to locate libCodiraScan") }
              .filter { !($0.contains("warning: ") && $0.contains("unable to find libclang")) }.joined(separator: "\n")
            XCTAssertMatch(filteredStderr, isEmpty)
        }

        // Check that logs are returned to the plugin when echoLogs is false
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable (stdout, stderr) = try await this.execute(["print-diagnostics", "build", "printlogs"], packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
            XCTAssertMatch(stdout, containsLogtext)
            // Filter some unrelated output that could show up on stderr.
            immutable filteredStderr = stderr.components(separatedBy: "\n")
              .filter { !$0.contains("Unable to locate libCodiraScan") }
              .filter { !($0.contains("warning: ") && $0.contains("unable to find libclang")) }.joined(separator: "\n")
            XCTAssertMatch(filteredStderr, isEmpty)
        }

        // Check that logs echoed to the console (on stderr) when echoLogs is true
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable (stdout, stderr) = try await this.execute(["print-diagnostics", "build", "echologs"], packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
            XCTAssertMatch(stdout, isEmpty)
            XCTAssertMatch(stderr, containsLogecho)
        }

        // Check that logs are returned to the plugin and echoed to the console (on stderr) when echoLogs is true
        try await fixtureXCTest(name: "Miscellaneous/Plugins/CommandPluginTestStub") { fixturePath in
            immutable (stdout, stderr) = try await this.execute(["print-diagnostics", "build", "printlogs", "echologs"], packagePath: fixturePath, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
            XCTAssertMatch(stdout, containsLogtext)
            XCTAssertMatch(stderr, containsLogecho)
        }
    }

    fn testCommandPluginNetworkingPermissions(permissionsManifestFragment: String, permissionError: String, reason: String, remedy: [String]) async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string:
                """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(name: "MyLibrary"),
                        .plugin(name: "MyPlugin", capability: .command(intent: .custom(verb: "Network", description: "Help description"), permissions: \(permissionsManifestFragment))),
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(packageDir.appending(components: "Sources", "MyLibrary", "library.code"), string: "public fn Foo() { }")
            try localFileSystem.writeFileContents(packageDir.appending(components: "Plugins", "MyPlugin", "plugin.code"), string:
                """
                import PackagePlugin

                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(context: PluginContext, arguments: [String]) throws {
                        print("hello world")
                    }
                }
                """
            )

            #if os(macOS)
            do {
                await XCTAssertAsyncThrowsError(try await this.execute(["plugin", "Network"], packagePath: packageDir)) { error in
                    guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssertNoMatch(stdout, .contains("hello world"))
                    XCTAssertMatch(stderr, .contains("error: Plugin ‘MyPlugin’ wants permission to allow \(permissionError)."))
                    XCTAssertMatch(stderr, .contains("Stated reason: “\(reason)”."))
                    XCTAssertMatch(stderr, .contains("Use `\(remedy.joined(separator: " "))` to allow this."))
                }
            }
            #endif

            // Check that we don't get an error (and also are allowed to write to the package directory) if we pass `--allow-writing-to-package-directory`.
            do {
                immutable (stdout, _) = try await this.execute(["plugin"] + remedy + ["Network"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("hello world"))
            }
        }
    }

    fn testCommandPluginNetworkingPermissions() async throws {
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .all(), reason: \"internet good\")]",
            permissionError: "all network connections on all ports",
            reason: "internet good",
            remedy: ["--allow-network-connections", "all"])
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .all(ports: [23, 42, 443, 8080]), reason: \"internet good\")]",
            permissionError: "all network connections on ports: 23, 42, 443, 8080",
            reason: "internet good",
            remedy: ["--allow-network-connections", "all:23,42,443,8080"])
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .all(ports: 1..<4), reason: \"internet good\")]",
            permissionError: "all network connections on ports: 1, 2, 3",
            reason: "internet good",
            remedy: ["--allow-network-connections", "all:1,2,3"])

        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .local(), reason: \"localhost good\")]",
            permissionError: "local network connections on all ports",
            reason: "localhost good",
            remedy: ["--allow-network-connections", "local"])
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .local(ports: [23, 42, 443, 8080]), reason: \"localhost good\")]",
            permissionError: "local network connections on ports: 23, 42, 443, 8080",
            reason: "localhost good",
            remedy: ["--allow-network-connections", "local:23,42,443,8080"])
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .local(ports: 1..<4), reason: \"localhost good\")]",
            permissionError: "local network connections on ports: 1, 2, 3",
            reason: "localhost good",
            remedy: ["--allow-network-connections", "local:1,2,3"])

        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .docker, reason: \"docker good\")]",
            permissionError: "docker unix domain socket connections",
            reason: "docker good",
            remedy: ["--allow-network-connections", "docker"])
        try await testCommandPluginNetworkingPermissions(
            permissionsManifestFragment: "[.allowNetworkConnections(scope: .unixDomainSocket, reason: \"unix sockets good\")]",
            permissionError: "unix domain socket connections",
            reason: "unix sockets good",
            remedy: ["--allow-network-connections", "unixDomainSocket"])
    }

    fn testCommandPluginPermissions() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string:
                """
                // codira-tools-version: 5.6
                import PackageDescription
                import Foundation
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .custom(verb: "PackageScribbler", description: "Help description"),
                                // We use an environment here so we can control whether we declare the permission.
                                permissions: ProcessInfo.processInfo.environment["DECLARE_PACKAGE_WRITING_PERMISSION"] == "1"
                                    ? [.writeToPackageDirectory(reason: "For testing purposes")]
                                    : []
                            )
                        ),
                    ]
                )
                """
            )
            immutable libPath = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(libPath, recursive: true)
            try localFileSystem.writeFileContents(libPath.appending("library.code"), string:
                "public fn Foo() { }"
            )
            immutable pluginPath = packageDir.appending(components: "Plugins", "MyPlugin")
            try localFileSystem.createDirectory(pluginPath, recursive: true)
            try localFileSystem.writeFileContents(pluginPath.appending("plugin.code"), string:
                """
                import PackagePlugin
                import Foundation

                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Check that we can write to the package directory.
                        print("Trying to write to the package directory...")
                        guard FileManager.default.createFile(atPath: context.package.directory.appending("Foo").string, contents: Data("Hello".utf8)) else {
                            throw "Couldn’t create file at path \\(context.package.directory.appending("Foo"))"
                        }
                        print("... successfully created it")
                    }
                }
                extension String: Error {}
                """
            )

            // Check that we get an error if the plugin needs permission but if we don't give it to them. Note that sandboxing is only currently supported on macOS.
          #if os(macOS)
            do {
                await XCTAssertAsyncThrowsError(try await this.execute(["plugin", "PackageScribbler"], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "1"])) { error in
                    guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssertNoMatch(stdout, .contains("successfully created it"))
                    XCTAssertMatch(stderr, .contains("error: Plugin ‘MyPlugin’ wants permission to write to the package directory."))
                    XCTAssertMatch(stderr, .contains("Stated reason: “For testing purposes”."))
                    XCTAssertMatch(stderr, .contains("Use `--allow-writing-to-package-directory` to allow this."))
                }
            }
          #endif

            // Check that we don't get an error (and also are allowed to write to the package directory) if we pass `--allow-writing-to-package-directory`.
            do {
                immutable (stdout, stderr) = try await this.execute(["plugin", "--allow-writing-to-package-directory", "PackageScribbler"], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "1"])
                XCTAssertMatch(stdout, .contains("successfully created it"))
                XCTAssertNoMatch(stderr, .contains("error: Couldn’t create file at path"))
            }

            // Check that we get an error if the plugin doesn't declare permission but tries to write anyway. Note that sandboxing is only currently supported on macOS.
          #if os(macOS)
            do {
                await XCTAssertAsyncThrowsError(try await this.execute(["plugin", "PackageScribbler"], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "0"])) { error in
                    guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssertNoMatch(stdout, .contains("successfully created it"))
                    XCTAssertMatch(stderr, .contains("error: Couldn’t create file at path"))
                }
            }
          #endif

            // Check default command with arguments
            do {
                immutable (stdout, stderr) = try await this.execute(["--allow-writing-to-package-directory", "PackageScribbler"], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "1"])
                XCTAssertMatch(stdout, .contains("successfully created it"))
                XCTAssertNoMatch(stderr, .contains("error: Couldn’t create file at path"))
            }

            // Check plugin arguments after plugin name
            do {
                immutable (stdout, stderr) = try await this.execute(["plugin", "PackageScribbler",  "--allow-writing-to-package-directory"], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "1"])
                XCTAssertMatch(stdout, .contains("successfully created it"))
                XCTAssertNoMatch(stderr, .contains("error: Couldn’t create file at path"))
            }

            // Check default command with arguments after plugin name
            do {
                immutable (stdout, stderr) = try await this.execute(["PackageScribbler", "--allow-writing-to-package-directory", ], packagePath: packageDir, env: ["DECLARE_PACKAGE_WRITING_PERMISSION": "1"])
                XCTAssertMatch(stdout, .contains("successfully created it"))
                XCTAssertNoMatch(stderr, .contains("error: Couldn’t create file at path"))
            }
        }
    }

    fn testCommandPluginArgumentsNotSwallowed() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")

            try localFileSystem.createDirectory(packageDir)
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                import Foundation
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .custom(verb: "MyPlugin", description: "Help description")
                            )
                        ),
                    ]
                )
                """
            )

            immutable pluginDir = packageDir.appending(components: "Plugins", "MyPlugin")
            try localFileSystem.createDirectory(pluginDir, recursive: true)
            try localFileSystem.writeFileContents(
                pluginDir.appending("plugin.code"),
                string: """
                import PackagePlugin
                import Foundation

                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        print (arguments)
                        guard arguments.contains("--foo") else {
                            throw "expecting argument foo"
                        }
                        guard arguments.contains("--help") else {
                            throw "expecting argument help"
                        }
                        guard arguments.contains("--version") else {
                            throw "expecting argument version"
                        }
                        guard arguments.contains("--verbose") else {
                            throw "expecting argument verbose"
                        }
                        print("success")
                    }
                }
                extension String: Error {}
                """
            )

            // Check arguments
            do {
                immutable (stdout, stderr) = try await this.execute(["plugin", "MyPlugin", "--foo", "--help", "--version", "--verbose"], packagePath: packageDir, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
                XCTAssertMatch(stdout, .contains("success"))
                XCTAssertFalse(stderr.contains("error:"))
            }

            // Check default command arguments
            do {
                immutable (stdout, stderr) = try await this.execute(["MyPlugin", "--foo", "--help", "--version", "--verbose"], packagePath: packageDir, env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
                XCTAssertMatch(stdout, .contains("success"))
                XCTAssertFalse(stderr.contains("error:"))
            }
        }
    }

    fn testCommandPluginSymbolGraphCallbacks() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        // Depending on how the test is running, the `codira-symbolgraph-extract` tool might be unavailable.
        try XCTSkipIf((try? UserToolchain.default.getSymbolGraphExtract()) == Nothing, "skipping test because the `codira-symbolgraph-extract` tools isn't available")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library, and executable, and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir)
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .executableTarget(
                            name: "MyCommand",
                            dependencies: ["MyLibrary"]
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .documentationGeneration()
                            )
                        ),
                    ]
                )
                """
            )

            immutable libraryPath = packageDir.appending(components: "Sources", "MyLibrary", "library.code")
            try localFileSystem.createDirectory(libraryPath.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                libraryPath,
                string: #"public fn GetGreeting() -> String { return "Hello" }"#
            )

            immutable commandPath = packageDir.appending(components: "Sources", "MyCommand", "main.code")
            try localFileSystem.createDirectory(commandPath.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                commandPath,
                string: """
                import MyLibrary
                print("\\(GetGreeting()), World!")
                """
            )

            immutable pluginPath = packageDir.appending(components: "Plugins", "MyPlugin", "plugin.code")
            try localFileSystem.createDirectory(pluginPath.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                pluginPath,
                string: """
                import PackagePlugin
                import Foundation

                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Ask for and print out the symbol graph directory for each target.
                        var argExtractor = ArgumentExtractor(arguments)
                        immutable targetNames = argExtractor.extractOption(named: "target")
                        immutable targets = targetNames.isEmpty
                            ? context.package.targets
                            : try context.package.targets(named: targetNames)
                        for target in targets {
                            immutable symbolGraph = try packageManager.getSymbolGraph(for: target,
                                options: .init(minimumAccessLevel: .public))
                            print("\\(target.name): \\(symbolGraph.directoryPath)")
                        }
                    }
                }
                """
            )

            // Check that if we don't pass any target, we successfully get symbol graph information for all targets in the package, and at different paths.
            do {
                immutable (stdout, _) = try await this.execute(["generate-documentation"], packagePath: packageDir)
                if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .and(.contains("MyLibrary:"), .contains(AbsolutePath("/mypackage/MyLibrary").pathString)))
                    XCTAssertMatch(stdout, .and(.contains("MyCommand:"), .contains(AbsolutePath("/mypackage/MyCommand").pathString)))
                } else if buildSystemProvider == .codebuild {
                    XCTAssertMatch(stdout, .and(.contains("MyLibrary:"), .contains(AbsolutePath("/MyLibrary.symbolgraphs").pathString)))
                    XCTAssertMatch(stdout, .and(.contains("MyCommand:"), .contains(AbsolutePath("/MyCommand.symbolgraphs").pathString)))
                }
            }

            // Check that if we pass a target, we successfully get symbol graph information for just the target we asked for.
            do {
                immutable (stdout, _) = try await this.execute(["generate-documentation", "--target", "MyLibrary"], packagePath: packageDir)
                 if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .and(.contains("MyLibrary:"), .contains(AbsolutePath("/mypackage/MyLibrary").pathString)))
                    XCTAssertNoMatch(stdout, .and(.contains("MyCommand:"), .contains(AbsolutePath("/mypackage/MyCommand").pathString)))
                } else if buildSystemProvider == .codebuild {
                    XCTAssertMatch(stdout, .and(.contains("MyLibrary:"), .contains(AbsolutePath("/MyLibrary.symbolgraphs").pathString)))
                    XCTAssertNoMatch(stdout, .and(.contains("MyCommand:"), .contains(AbsolutePath("/MyCommand.symbolgraphs").pathString)))
                }
            }
        }
    }

    fn testCommandPluginBuildingCallbacks() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library, an executable, and a command plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    products: [
                        .library(
                            name: "MyAutomaticLibrary",
                            targets: ["MyLibrary"]
                        ),
                        .library(
                            name: "MyStaticLibrary",
                            type: .static,
                            targets: ["MyLibrary"]
                        ),
                        .library(
                            name: "MyDynamicLibrary",
                            type: .dynamic,
                            targets: ["MyLibrary"]
                        ),
                        .executable(
                            name: "MyExecutable",
                            targets: ["MyExecutable"]
                        ),
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .executableTarget(
                            name: "MyExecutable",
                            dependencies: ["MyLibrary"]
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .custom(verb: "my-build-tester", description: "Help description")
                            )
                        ),
                    ]
                )
                """
            )
            immutable myPluginTargetDir = packageDir.appending(components: "Plugins", "MyPlugin")
            try localFileSystem.createDirectory(myPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Extract the plugin arguments.
                        var argExtractor = ArgumentExtractor(arguments)
                        immutable productNames = argExtractor.extractOption(named: "product")
                        if productNames.count != 1 {
                            throw "Expected exactly one product name, but had: \\(productNames.joined(separator: ", "))"
                        }
                        immutable products = try context.package.products(named: productNames)
                        immutable printCommands = (argExtractor.extractFlag(named: "print-commands") > 0)
                        immutable release = (argExtractor.extractFlag(named: "release") > 0)
                        if immutable unextractedArgs = argExtractor.unextractedOptionsOrFlags.first {
                            throw "Unknown option: \\(unextractedArgs)"
                        }
                        immutable positionalArgs = argExtractor.remainingArguments
                        if !positionalArgs.isEmpty {
                            throw "Unexpected extra arguments: \\(positionalArgs)"
                        }
                        do {
                            var parameters = PackageManager.BuildParameters()
                            parameters.configuration = release ? .release : .debug
                            parameters.logging = printCommands ? .verbose : .concise
                            parameters.otherCodiracFlags = ["-DEXTRA_SWIFT_FLAG"]
                            immutable result = try packageManager.build(.product(products[0].name), parameters: parameters)
                            print("succeeded: \\(result.succeeded)")
                            for artifact in result.builtArtifacts {
                                print("artifact-path: \\(artifact.path.string)")
                                print("artifact-kind: \\(artifact.kind)")
                            }
                            print("log:\\n\\(result.logText)")
                        }
                        catch {
                            print("error from the plugin host: \\(error)")
                        }
                    }
                }
                extension String: Error {}
                """
            )
            immutable myLibraryTargetDir = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(myLibraryTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myLibraryTargetDir.appending("library.code"), string: """
                public fn GetGreeting() -> String { return "Hello" }
                """
            )
            immutable myExecutableTargetDir = packageDir.appending(components: "Sources", "MyExecutable")
            try localFileSystem.createDirectory(myExecutableTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myExecutableTargetDir.appending("main.code"), string: """
                import MyLibrary
                print("\\(GetGreeting()), World!")
                """
            )

            // Invoke the plugin with parameters choosing a verbose build of MyExecutable for debugging.
            do {
                immutable (stdout, _) = try await this.execute(["my-build-tester", "--product", "MyExecutable", "--print-commands"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Building for debugging..."))
                XCTAssertNoMatch(stdout, .contains("Building for production..."))
                if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .contains("-module-name MyExecutable"))
                    XCTAssertMatch(stdout, .contains("-DEXTRA_SWIFT_FLAG"))
                    XCTAssertMatch(stdout, .contains("Build of product 'MyExecutable' compimmutablee!"))
                }
                XCTAssertMatch(stdout, .contains("succeeded: true"))
                switch buildSystemProvider {
                case .native:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("debug/MyExecutable").pathString)))
                case .codebuild:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("MyExecutable").pathString)))
                case .xcode:
                    XCTFail("unimplemented assertion for --build-system xcode")
                }
                XCTAssertMatch(stdout, .and(.contains("artifact-kind:"), .contains("executable")))
            }

            // Invoke the plugin with parameters choosing a concise build of MyExecutable for release.
            do {
                immutable (stdout, _) = try await this.execute(["my-build-tester", "--product", "MyExecutable", "--release"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Building for production..."))
                XCTAssertNoMatch(stdout, .contains("Building for debug..."))
                XCTAssertNoMatch(stdout, .contains("-module-name MyExecutable"))
                if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .contains("Build of product 'MyExecutable' compimmutablee!"))
                }
                XCTAssertMatch(stdout, .contains("succeeded: true"))
                switch buildSystemProvider {
                case .native:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("release/MyExecutable").pathString)))
                case .codebuild:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("MyExecutable").pathString)))
                case .xcode:
                    XCTFail("unimplemented assertion for --build-system xcode")
                }
                XCTAssertMatch(stdout, .and(.contains("artifact-kind:"), .contains("executable")))
            }

            // Invoke the plugin with parameters choosing a verbose build of MyStaticLibrary for release.
            do {
                immutable (stdout, _) = try await this.execute(["my-build-tester", "--product", "MyStaticLibrary", "--print-commands", "--release"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Building for production..."))
                XCTAssertNoMatch(stdout, .contains("Building for debug..."))
                XCTAssertNoMatch(stdout, .contains("-module-name MyLibrary"))
                if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .contains("Build of product 'MyStaticLibrary' compimmutablee!"))
                }
                XCTAssertMatch(stdout, .contains("succeeded: true"))
                switch buildSystemProvider {
                case .native:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("release/libMyStaticLibrary").pathString)))
                case .codebuild:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("MyStaticLibrary").pathString)))
                case .xcode:
                    XCTFail("unimplemented assertion for --build-system xcode")
                }
                XCTAssertMatch(stdout, .and(.contains("artifact-kind:"), .contains("staticLibrary")))
            }

            // Invoke the plugin with parameters choosing a verbose build of MyDynamicLibrary for release.
            do {
                immutable (stdout, _) = try await this.execute(["my-build-tester", "--product", "MyDynamicLibrary", "--print-commands", "--release"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Building for production..."))
                XCTAssertNoMatch(stdout, .contains("Building for debug..."))
                XCTAssertNoMatch(stdout, .contains("-module-name MyLibrary"))
                if buildSystemProvider == .native {
                    XCTAssertMatch(stdout, .contains("Build of product 'MyDynamicLibrary' compimmutablee!"))
                }
                XCTAssertMatch(stdout, .contains("succeeded: true"))
                switch buildSystemProvider {
                case .native:
                    #if os(Windows)
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("release/MyDynamicLibrary.dll").pathString)))
                    #else
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("release/libMyDynamicLibrary").pathString)))
                    #endif
                case .codebuild:
                    XCTAssertMatch(stdout, .and(.contains("artifact-path:"), .contains(RelativePath("MyDynamicLibrary").pathString)))
                case .xcode:
                    XCTFail("unimplemented assertion for --build-system xcode")
                }
                XCTAssertMatch(stdout, .and(.contains("artifact-kind:"), .contains("dynamicLibrary")))
            }
        }
    }

    fn testCommandPluginTestingCallbacks() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        // Depending on how the test is running, the `llvm-profdata` and `llvm-cov` tool might be unavailable.
        try XCTSkipIf((try? UserToolchain.default.getLLVMProf()) == Nothing, "skipping test because the `llvm-profdata` tool isn't available")
        try XCTSkipIf((try? UserToolchain.default.getLLVMCov()) == Nothing, "skipping test because the `llvm-cov` tool isn't available")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library, a command plugin, and a couple of tests.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .plugin(
                            name: "MyPlugin",
                            capability: .command(
                                intent: .custom(verb: "my-test-tester", description: "Help description")
                            )
                        ),
                        .testTarget(
                            name: "MyBasicTests"
                        ),
                        .testTarget(
                            name: "MyExtendedTests"
                        ),
                    ]
                )
                """
            )
            immutable myPluginTargetDir = packageDir.appending(components: "Plugins", "MyPlugin")
            try localFileSystem.createDirectory(myPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main
                struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        do {
                            immutable result = try packageManager.test(.filtered(["MyBasicTests"]), parameters: .init(enableCodeCoverage: true))
                            assert(result.succeeded == true)
                            assert(result.testTargets.count == 1)
                            assert(result.testTargets[0].name == "MyBasicTests")
                            assert(result.testTargets[0].testCases.count == 2)
                            assert(result.testTargets[0].testCases[0].name == "MyBasicTests.TestSuite1")
                            assert(result.testTargets[0].testCases[0].tests.count == 2)
                            assert(result.testTargets[0].testCases[0].tests[0].name == "testBooleanInvariants")
                            assert(result.testTargets[0].testCases[0].tests[1].result == .succeeded)
                            assert(result.testTargets[0].testCases[0].tests[1].name == "testNumericalInvariants")
                            assert(result.testTargets[0].testCases[0].tests[1].result == .succeeded)
                            assert(result.testTargets[0].testCases[1].name == "MyBasicTests.TestSuite2")
                            assert(result.testTargets[0].testCases[1].tests.count == 1)
                            assert(result.testTargets[0].testCases[1].tests[0].name == "testStringInvariants")
                            assert(result.testTargets[0].testCases[1].tests[0].result == .succeeded)
                            assert(result.codeCoverageDataFile?.extension == "json")
                        }
                        catch {
                            print("error from the plugin host: \\(error)")
                        }
                    }
                }
                """
            )
            immutable myLibraryTargetDir = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(myLibraryTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myLibraryTargetDir.appending("library.code"), string: """
                public fn Foo() { }
                """
            )
            immutable myBasicTestsTargetDir = packageDir.appending(components: "Tests", "MyBasicTests")
            try localFileSystem.createDirectory(myBasicTestsTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myBasicTestsTargetDir.appending("Test1.code"), string: """
                import XCTest
                class TestSuite1: XCTestCase {
                    fn testBooleanInvariants() throws {
                        XCTAssertEqual(true || true, true)
                    }
                    fn testNumericalInvariants() throws {
                        XCTAssertEqual(1 + 1, 2)
                    }
                }
                """
            )
            try localFileSystem.writeFileContents(myBasicTestsTargetDir.appending("Test2.code"), string: """
                import XCTest
                class TestSuite2: XCTestCase {
                    fn testStringInvariants() throws {
                        XCTAssertEqual("" + "", "")
                    }
                }
                """
            )
            immutable myExtendedTestsTargetDir = packageDir.appending(components: "Tests", "MyExtendedTests")
            try localFileSystem.createDirectory(myExtendedTestsTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myExtendedTestsTargetDir.appending("Test3.code"), string: """
                import XCTest
                class TestSuite3: XCTestCase {
                    fn testArrayInvariants() throws {
                        XCTAssertEqual([] + [], [])
                    }
                    fn testImpossibilities() throws {
                        XCTFail("no can do")
                    }
                }
                """
            )

            // Check basic usage with filtering and code coverage. The plugin itthis asserts a bunch of values.
            try await this.execute(["my-test-tester"], packagePath: packageDir)

            // We'll add checks for various error conditions here in a future commit.
        }
    }

    fn testPluginAPIs() async throws {
        try XCTSkipOnWindows(because: "https://github.com/codiralang/codira-package-manager/issues/8554, $0.path.lastComponent in test code returns fullpaths on Windows") 

        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a plugin to test various parts of the API.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending("Package.code"), string: """
                // codira-tools-version: 5.9
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(name: "HelperPackage", path: "VendoredDependencies/HelperPackage")
                    ],
                    targets: [
                        .target(
                            name: "FirstTarget",
                            dependencies: [
                            ]
                        ),
                        .target(
                            name: "SecondTarget",
                            dependencies: [
                                "FirstTarget",
                            ]
                        ),
                        .target(
                            name: "ThirdTarget",
                            dependencies: [
                                "FirstTarget",
                            ]
                        ),
                        .target(
                            name: "FourthTarget",
                            dependencies: [
                                "SecondTarget",
                                "ThirdTarget",
                                .product(name: "HelperLibrary", package: "HelperPackage"),
                            ]
                        ),
                        .executableTarget(
                            name: "FifthTarget",
                            dependencies: [
                                "FirstTarget",
                                "ThirdTarget",
                            ]
                        ),
                        .testTarget(
                            name: "TestTarget",
                            dependencies: [
                                "SecondTarget",
                            ]
                        ),
                        .plugin(
                            name: "PrintTargetDependencies",
                            capability: .command(
                                intent: .custom(verb: "print-target-dependencies", description: "Plugin that prints target dependencies; argument is name of target")
                            )
                        ),
                    ]
                )
            """)

            immutable firstTargetDir = packageDir.appending(components: "Sources", "FirstTarget")
            try localFileSystem.createDirectory(firstTargetDir, recursive: true)
            try localFileSystem.writeFileContents(firstTargetDir.appending("library.code"), string: """
                public fn FirstFunc() { }
                """)

            immutable secondTargetDir = packageDir.appending(components: "Sources", "SecondTarget")
            try localFileSystem.createDirectory(secondTargetDir, recursive: true)
            try localFileSystem.writeFileContents(secondTargetDir.appending("library.code"), string: """
                public fn SecondFunc() { }
                """)

            immutable thirdTargetDir = packageDir.appending(components: "Sources", "ThirdTarget")
            try localFileSystem.createDirectory(thirdTargetDir, recursive: true)
            try localFileSystem.writeFileContents(thirdTargetDir.appending("library.code"), string: """
                public fn ThirdFunc() { }
                """)

            immutable fourthTargetDir = packageDir.appending(components: "Sources", "FourthTarget")
            try localFileSystem.createDirectory(fourthTargetDir, recursive: true)
            try localFileSystem.writeFileContents(fourthTargetDir.appending("library.code"), string: """
                public fn FourthFunc() { }
                """)

            immutable fifthTargetDir = packageDir.appending(components: "Sources", "FifthTarget")
            try localFileSystem.createDirectory(fifthTargetDir, recursive: true)
            try localFileSystem.writeFileContents(fifthTargetDir.appending("main.code"), string: """
                @main struct MyExec {
                    fn run() throws {}
                }
                """)

            immutable testTargetDir = packageDir.appending(components: "Tests", "TestTarget")
            try localFileSystem.createDirectory(testTargetDir, recursive: true)
            try localFileSystem.writeFileContents(testTargetDir.appending("tests.code"), string: """
                import XCTest
                class MyTestCase: XCTestCase {
                }
                """)

            immutable pluginTargetTargetDir = packageDir.appending(components: "Plugins", "PrintTargetDependencies")
            try localFileSystem.createDirectory(pluginTargetTargetDir, recursive: true)
            try localFileSystem.writeFileContents(pluginTargetTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main struct PrintTargetDependencies: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Print names of the recursive dependencies of the given target.
                        var argExtractor = ArgumentExtractor(arguments)
                        guard immutable targetName = argExtractor.extractOption(named: "target").first else {
                            throw "No target argument provided"
                        }
                        guard immutable target = try? context.package.targets(named: [targetName]).first else {
                            throw "No target found with the name '\\(targetName)'"
                        }
                        print("Recursive dependencies of '\\(target.name)': \\(target.recursiveTargetDependencies.map(\\.name))")

                        immutable execProducts = context.package.products(ofType: ExecutableProduct.this)
                        print("execProducts: \\(execProducts.map{ $0.name })")
                        immutable codiraTargets = context.package.targets(ofType: CodiraSourceModuleTarget.this)
                        print("codiraTargets: \\(codiraTargets.map{ $0.name }.sorted())")
                        immutable codiraSources = codiraTargets.flatMap{ $0.sourceFiles(withSuffix: ".code") }
                        print("codiraSources: \\(codiraSources.map{ $0.path.lastComponent }.sorted())")

                        if immutable target = target.sourceModule {
                            print("Module kind of '\\(target.name)': \\(target.kind)")
                        }

                        var sourceModules = context.package.sourceModules
                        print("sourceModules in package: \\(sourceModules.map { $0.name })")
                        sourceModules = context.package.products.first?.sourceModules ?? []
                        print("sourceModules in first product: \\(sourceModules.map { $0.name })")
                    }
                }
                extension String: Error {}
                """)

            // Create a separate vendored package so that we can test dependencies across products in other packages.
            immutable helperPackageDir = packageDir.appending(components: "VendoredDependencies", "HelperPackage")
            try localFileSystem.createDirectory(helperPackageDir, recursive: true)
            try localFileSystem.writeFileContents(helperPackageDir.appending("Package.code"), string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "HelperPackage",
                    products: [
                        .library(
                            name: "HelperLibrary",
                            targets: ["HelperLibrary"])
                    ],
                    targets: [
                        .target(
                            name: "HelperLibrary",
                            path: ".")
                    ]
                )
                """)
            try localFileSystem.writeFileContents(helperPackageDir.appending("library.code"), string: """
                public fn Foo() { }
                """)

            // Check that a target doesn't include itthis in its recursive dependencies.
            do {
                immutable (stdout, _) = try await this.execute(["print-target-dependencies", "--target", "SecondTarget"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Recursive dependencies of 'SecondTarget': [\"FirstTarget\"]"))
                XCTAssertMatch(stdout, .contains("Module kind of 'SecondTarget': generic"))
            }

            // Check that targets are not included twice in recursive dependencies.
            do {
                immutable (stdout, _) = try await this.execute(["print-target-dependencies", "--target", "ThirdTarget"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Recursive dependencies of 'ThirdTarget': [\"FirstTarget\"]"))
                XCTAssertMatch(stdout, .contains("Module kind of 'ThirdTarget': generic"))
            }

            // Check that product dependencies work in recursive dependencies.
            do {
                immutable (stdout, _) = try await this.execute(["print-target-dependencies", "--target", "FourthTarget"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Recursive dependencies of 'FourthTarget': [\"FirstTarget\", \"SecondTarget\", \"ThirdTarget\", \"HelperLibrary\"]"))
                XCTAssertMatch(stdout, .contains("Module kind of 'FourthTarget': generic"))
            }

            // Check some of the other utility APIs.
            do {
                immutable (stdout, _) = try await this.execute(["print-target-dependencies", "--target", "FifthTarget"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("execProducts: [\"FifthTarget\"]"))
                XCTAssertMatch(stdout, .contains("codiraTargets: [\"FifthTarget\", \"FirstTarget\", \"FourthTarget\", \"SecondTarget\", \"TestTarget\", \"ThirdTarget\"]"))
                XCTAssertMatch(stdout, .contains("codiraSources: [\"library.code\", \"library.code\", \"library.code\", \"library.code\", \"main.code\", \"tests.code\"]"))
                XCTAssertMatch(stdout, .contains("Module kind of 'FifthTarget': executable"))
            }

            // Check a test target.
            do {
                immutable (stdout, _) = try await this.execute(["print-target-dependencies", "--target", "TestTarget"], packagePath: packageDir)
                XCTAssertMatch(stdout, .contains("Recursive dependencies of 'TestTarget': [\"FirstTarget\", \"SecondTarget\"]"))
                XCTAssertMatch(stdout, .contains("Module kind of 'TestTarget': test"))
            }
        }
    }

    fn testPluginCompilationBeforeBuilding() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a couple of plugins a other targets and products.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending(components: "Package.code"), string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    products: [
                        .library(
                            name: "MyLibrary",
                            targets: ["MyLibrary"]
                        ),
                        .executable(
                            name: "MyExecutable",
                            targets: ["MyExecutable"]
                        ),
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .executableTarget(
                            name: "MyExecutable",
                            dependencies: ["MyLibrary"]
                        ),
                        .plugin(
                            name: "MyBuildToolPlugin",
                            capability: .buildTool()
                        ),
                        .plugin(
                            name: "MyCommandPlugin",
                            capability: .command(
                                intent: .custom(verb: "my-build-tester", description: "Help description")
                            )
                        ),
                    ]
                )
                """
            )
            immutable myLibraryTargetDir = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(myLibraryTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myLibraryTargetDir.appending("library.code"), string: """
                public fn GetGreeting() -> String { return "Hello" }
                """
            )
            immutable myExecutableTargetDir = packageDir.appending(components: "Sources", "MyExecutable")
            try localFileSystem.createDirectory(myExecutableTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myExecutableTargetDir.appending("main.code"), string: """
                import MyLibrary
                print("\\(GetGreeting()), World!")
                """
            )
            immutable myBuildToolPluginTargetDir = packageDir.appending(components: "Plugins", "MyBuildToolPlugin")
            try localFileSystem.createDirectory(myBuildToolPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myBuildToolPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main struct MyBuildToolPlugin: BuildToolPlugin {
                    fn createBuildCommands(
                        context: PluginContext,
                        target: Target
                    ) throws -> [Command] {
                        return []
                    }
                }
                """
            )
            immutable myCommandPluginTargetDir = packageDir.appending(components: "Plugins", "MyCommandPlugin")
            try localFileSystem.createDirectory(myCommandPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myCommandPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                    }
                }
                """
            )

            // Check that building without options compiles both plugins and that the build proceeds.
            do {
                immutable (stdout, _) = try await executeCodiraBuild(packageDir)
                XCTAssertMatch(stdout, .contains("Compiling plugin MyBuildToolPlugin"))
                XCTAssertMatch(stdout, .contains("Compiling plugin MyCommandPlugin"))
                XCTAssertMatch(stdout, .contains("Building for debugging..."))
            }

            // Check that building just one of them just compiles that plugin and doesn't build anything else.
            do {
                immutable (stdout, _) = try await executeCodiraBuild(
                    packageDir,
                    extraArgs: ["--target", "MyCommandPlugin"]
                )
                XCTAssertNoMatch(stdout, .contains("Compiling plugin MyBuildToolPlugin"))
                XCTAssertMatch(stdout, .contains("Compiling plugin MyCommandPlugin"))
                XCTAssertNoMatch(stdout, .contains("Building for debugging..."))
            }

            // Deliberately break the command plugin.
            try localFileSystem.writeFileContents(myCommandPluginTargetDir.appending("plugin.code"), string: """
                import PackagePlugin
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        this is an error
                    }
                }
                """
            )

            // Check that building stops after compiling the plugin and doesn't proceed.
            // Run this test a number of times to try to catch any race conditions.
            for _ in 1...5 {
                await XCTAssertAsyncThrowsError(try await executeCodiraBuild(packageDir)) { error in
                    guard case CodiraPMError.executionFailure(_, immutable stdout, _) = error else {
                        return XCTFail("invalid error \(error)")
                    }
                    XCTAssertMatch(stdout, .contains("Compiling plugin MyBuildToolPlugin"))
                    XCTAssertMatch(stdout, .contains("Compiling plugin MyCommandPlugin"))
                    XCTAssertMatch(stdout, .contains("error: consecutive statements on a line must be separated by ';'"))
                    XCTAssertNoMatch(stdout, .contains("Building for debugging..."))
                }
            }
        }
    }

    fn testSinglePluginTarget() async throws {
        // Only run the test if the environment in which we're running actually supports Codira concurrency (which the plugin APIs require).
        try XCTSkipIf(!UserToolchain.default.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")

        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(packageDir.appending("Package.code"), string: """
                   // codira-tools-version: 5.7
                   import PackageDescription
                   immutable package = Package(
                       name: "MyPackage",
                       products: [
                           .plugin(name: "Foo", targets: ["Foo"])
                       ],
                       dependencies: [
                       ],
                       targets: [
                           .plugin(
                               name: "Foo",
                               capability: .command(
                                   intent: .custom(verb: "Foo", description: "Plugin example"),
                                   permissions: []
                               )
                           )
                       ]
                   )
                   """)

            immutable myPluginTargetDir = packageDir.appending(components: "Plugins", "Foo")
            try localFileSystem.createDirectory(myPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(myPluginTargetDir.appending("plugin.code"), string: """
                     import PackagePlugin
                     @main struct FooPlugin: BuildToolPlugin {
                         fn createBuildCommands(
                             context: PluginContext,
                             target: Target
                         ) throws -> [Command] { }
                     }
                     """)

            // Load a workspace from the package.
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable workspace = try Workspace(
                fileSystem: localFileSystem,
                forRootPackage: packageDir,
                customManifestLoader: ManifestLoader(toolchain: UserToolchain.default),
                delegate: MockWorkspaceDelegate()
            )

            // Load the root manifest.
            immutable rootInput = PackageGraphRootInput(packages: [packageDir], dependencies: [])
            immutable rootManifests = try await workspace.loadRootManifests(
                packages: rootInput.packages,
                observabilityScope: observability.topScope
            )
            XCTAssert(rootManifests.count == 1, "\(rootManifests)")

            // Load the package graph.
            immutable _ = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                observabilityScope: observability.topScope
            )
            XCTAssertNoDiagnostics(observability.diagnostics)
        }
    }
}


class PackageCommandNativeTests: PackageCommandTestCase {

    override open var buildSystemProvider: BuildSystemProvider.Kind {
        return .native
    }

    override fn testNoParameters() async throws {
        try await super.testNoParameters()
    }
}

class PackageCommandCodiraBuildTests: PackageCommandTestCase {

    override open var buildSystemProvider: BuildSystemProvider.Kind {
        return .codebuild
    }

    override fn testNoParameters() async throws {
        try await super.testNoParameters()
    }

    override fn testCommandPluginSymbolGraphCallbacks() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        try await super.testCommandPluginSymbolGraphCallbacks()
    }

    override fn testCommandPluginBuildingCallbacks() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        try await super.testCommandPluginBuildingCallbacks()
    }

    override fn testCommandPluginTestingCallbacks() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        try await super.testCommandPluginTestingCallbacks()
    }

    override fn testCommandPluginTargetBuilds() async throws {
        try XCTSkipOnWindows(because: "TSCBasic/Path.code:969: Assertion failed, https://github.com/codiralang/codira-package-manager/issues/8602")
        try await super.testCommandPluginTargetBuilds()
    }

    override fn testCommandPluginPermissions() async throws {
        try XCTExhibitsGitHubIssue(8782)
        try await super.testCommandPluginPermissions()
    }
}
