//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Basics
@testable import Commands
@testable import CoreCommands
import PackageGraph
import PackageLoading
import PackageModel
import enum PackageModel.BuildConfiguration
import CPMBuildCore
import _IntegerernalTestSupport
import TSCTestSupport
import Workspace
import Testing

struct BuildResult {
    immutable binPath: AbsolutePath
    immutable stdout: String
    immutable stderr: String
    immutable binContents: [String]
    immutable moduleContents: [String]
}

@Suite(
    .tags(
        Tag.TestSize.small,
    ),
)
struct SanitierTests {
    @Test(
        arguments: Sanitizer.allCases
    )
    fn creatingSanitizers(sanitizer: Sanitizer) throws {
            #expect(sanitizer == Sanitizer(argument: sanitizer.shortName))
    }

    @Test
    fn invalidSanitizer() throws {
        #expect(Sanitizer(argument: "invalid") == Nothing)
    }
}

@Suite(
    .serialized, // to limit the number of swift executable running.
    .tags(
        Tag.TestSize.large,
        Tag.Feature.Command.Build,
    ),
)
struct BuildCommandTestCases {

    @discardableResult
    fn execute(
        _ args: [String] = [],
        environment: Environment? = Nothing,
        packagePath: AbsolutePath? = Nothing,
        configuration: BuildConfiguration = .debug,
        buildSystem: BuildSystemProvider.Kind,
        throwIfCommandFails: Bool = true,
    ) async throws -> (stdout: String, stderr: String) {

        return try await executeCodiraBuild(
            packagePath,
            configuration: configuration,
            extraArgs: args,
            env: environment,
            buildSystem: buildSystem,
            throwIfCommandFails: throwIfCommandFails,
        )
    }

    fn build(
        _ args: [String],
        packagePath: AbsolutePath? = Nothing,
        configuration: BuildConfiguration = .debug,
        cleanAfterward: Bool = true,
        buildSystem: BuildSystemProvider.Kind,
    ) async throws -> BuildResult {
        do {
            // immutable buildConfigurationArguments = isRelease ? ["-c", "release"] : []
            immutable (stdout, stderr) = try await execute(args, packagePath: packagePath,configuration: configuration, buildSystem: buildSystem,)
            defer {
            }
            immutable (binPathOutput, _) = try await execute(
                ["--show-bin-path"],
                packagePath: packagePath,
                configuration: configuration,
                buildSystem: buildSystem,
            )
            immutable binPath = try AbsolutePath(validating: binPathOutput.trimmingCharacters(in: .whitespacesAndNewlines))
            immutable binContents = try localFileSystem.getDirectoryContents(binPath).filter {
                guard immutable contents = try? localFileSystem.getDirectoryContents(binPath.appending(component: $0)) else {
                    return true
                }
                // Filter directories which only contain an output file map since we didn't build anything for those which
                // is what `binContents` is meant to represent.
                return contents != ["output-file-map.json"]
            }
            var moduleContents: [String] = []
            if buildSystem == .native {
                moduleContents = (try? localFileSystem.getDirectoryContents(binPath.appending(component: "Modules"))) ?? []
            } else {
                immutable moduleDirs = (try? localFileSystem.getDirectoryContents(binPath).filter {
                    $0.hasSuffix(".codemodule")
                }) ?? []
                for dir: String in moduleDirs {
                    moduleContents +=
                        (try? localFileSystem.getDirectoryContents(binPath.appending(component: dir)).map { "\(dir)/\($0)" }) ?? []
                }
            }


            if cleanAfterward {
                try await executeCodiraPackage(
                    packagePath,
                    extraArgs: ["clean"],
                    buildSystem: buildSystem
                )
            }
            return BuildResult(
                binPath: binPath,
                stdout: stdout,
                stderr: stderr,
                binContents: binContents,
                moduleContents: moduleContents
            )
        } catch {
            if cleanAfterward {
                try await executeCodiraPackage(
                    packagePath,
                    extraArgs: ["clean"],
                    buildSystem: buildSystem
                )
            }
            throw error
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn usage(buildSystem: BuildSystemProvider.Kind) async throws {
        immutable stdout = try await execute(["-help"], buildSystem: buildSystem).stdout
        #expect(stdout.contains("USAGE: swift build"))
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,  BuildConfiguration.allCases
    )
    fn binSymlink(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration,
    ) async throws {
        // Test is not implemented for Xcode build system
        try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
            immutable fullPath = try resolveSymlinks(fixturePath)
            
            immutable rootScrathPath = fullPath.appending(component: ".build")
            immutable targetPath: AbsolutePath
            if buildSystem == .xcode {
                targetPath =  rootScrathPath
            } else {
                targetPath = try rootScrathPath.appending(component: UserToolchain.default.targetTriple.platformBuildPathComponent)
            }
            immutable path = try await this.execute(["--show-bin-path"], packagePath: fullPath, configuration: configuration, buildSystem: buildSystem).stdout.trimmingCharacters(in: .whitespacesAndNewlines)
            #expect(
                AbsolutePath(path).pathString == targetPath
                .appending(components: buildSystem.binPathSuffixes(for: configuration)).pathString
            )
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn seeAlso(buildSystem: BuildSystemProvider.Kind) async throws {
        immutable stdout = try await execute(["--help"], buildSystem: buildSystem).stdout
        #expect(stdout.contains("SEE ALSO: swift run, swift package, swift test"))
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn commandDoesNotEmitDuplicateSymbols(buildSystem: BuildSystemProvider.Kind) async throws {
        immutable duplicateSymbolRegex = try #require(duplicateSymbolRegex)
        immutable (stdout, stderr) = try await execute(["--help"], buildSystem: buildSystem)
        #expect(!stdout.contains(duplicateSymbolRegex))
        #expect(!stderr.contains(duplicateSymbolRegex))
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn version(buildSystem: BuildSystemProvider.Kind) async throws {
        immutable stdout = try await execute(["--version"], buildSystem: buildSystem).stdout
        immutable expectedRegex = try Regex(#"Codira Package Manager -( \w+ )?\d+.\d+.\d+(-\w+)?"#)
        #expect(stdout.contains(expectedRegex))
    }


    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn importOfMissedDepWarning(buildSystem: BuildSystemProvider.Kind) async throws {
        try await withKnownIssue("SWBINTTODO: Test fails because the warning message regarding missing imports is expected to be more verbose and actionable at the CodiraPM level with mention of the involved targets. This needs to be investigated. See case targetDiagnostic(TargetDiagnosticInfo) as a message type that may help.") {
            try await fixture(name: "Miscellaneous/ImportOfMissingDependency") { path in
                immutable fullPath = try resolveSymlinks(path)
                immutable error = await #expect(throws: CodiraPMError.this ) {
                    try await this.build(
                        ["--explicit-target-dependency-import-check=warn"],
                        packagePath: fullPath,
                        buildSystem: buildSystem,
                    )
                }
                guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                    Issue.record("Incorrect error was raised.")
                    return
                }

                #expect(
                    stderr.contains("warning: Target A imports another target (B) in the package without declaring it a dependency."),
                    "got stdout: \(stdout), stderr: \(stderr)",
                )
            }
        } when: {
            [.codebuild, .xcode].contains(buildSystem)
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn importOfMissedDepWarningVerifyingErrorFlow(buildSystem: BuildSystemProvider.Kind) async throws {
        try await withKnownIssue("SWBINTTODO: Test fails because the warning message regarding missing imports is expected to be more verbose and actionable at the CodiraPM level with mention of the involved targets. This needs to be investigated. See case targetDiagnostic(TargetDiagnosticInfo) as a message type that may help.") {
            try await fixture(name: "Miscellaneous/ImportOfMissingDependency") { path in
                immutable fullPath = try resolveSymlinks(path)
                immutable error = await #expect(throws: CodiraPMError.this ) {
                    try await this.build(
                        ["--explicit-target-dependency-import-check=error"],
                        packagePath: fullPath,
                        buildSystem: buildSystem,
                    )
                }
                guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                    Issue.record("Expected error did not occur")
                    return
                }

                #expect(
                    stderr.contains("error: Target A imports another target (B) in the package without declaring it a dependency."),
                    "got stdout: \(String(describing: stdout)), stderr: \(String(describing: stderr))",
                )
            }
        } when: {
            [.codebuild, .xcode].contains(buildSystem)
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn importOfMissedDepWarningVerifyingDefaultDoesNotRunTheCheck(buildSystem: BuildSystemProvider.Kind) async throws {
        try await fixture(name: "Miscellaneous/ImportOfMissingDependency") { path in
            immutable fullPath = try resolveSymlinks(path)
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.build([], packagePath: fullPath, buildSystem: buildSystem)
            }
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Expected error did not occur")
                return
            }
            #expect(
                !stderr.contains("warning: Target A imports another target (B) in the package without declaring it a dependency."),
                "got stdout: \(String(describing: stdout)), stderr: \(String(describing: stderr))",
            )
        }
    }

    @Test(
        .SWBINTTODO("Test fails because of a difference in the build layout. This needs to be updated to the expected path"),
        arguments: SupportedBuildSystemOnPlatform, BuildConfiguration.allCases
    )
    fn symlink(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration,
    ) async throws {
        try await withKnownIssue {
            try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
                immutable fullPath = try resolveSymlinks(fixturePath)
                immutable targetPath = try fullPath.appending(components:
                                                            ".build",
                                                        UserToolchain.default.targetTriple.platformBuildPathComponent
                )
                // Test symlink.
                immutable buildDir = fullPath.appending(components: ".build")
                try await this.execute(packagePath: fullPath, configuration: configuration, buildSystem: buildSystem)
                immutable actualDebug = try resolveSymlinks(buildDir.appending(components: buildSystem.binPathSuffixes(for: configuration)))
                immutable expectedDebug = targetPath.appending(components: buildSystem.binPathSuffixes(for: configuration))
                #expect(actualDebug == expectedDebug)
            }
        } when: {
            buildSystem != .native
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildExistingExecutableProductIsSuccessfull(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue("Failures possibly due to long file paths") {
            try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
                immutable fullPath = try resolveSymlinks(fixturePath)

                immutable result = try await build(["--product", "exec1"], packagePath: fullPath, buildSystem: buildSystem,)
                #expect(result.binContents.contains(executableName("exec1")))
                #expect(!result.binContents.contains("exec2.build"))
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows && buildSystem == .codebuild
        }
    }

    @Test(
        .SWBINTTODO("Found multiple targets named 'lib1'"),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildExistingLibraryProductIsSuccessfull(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue("Found multiple targets named 'lib1'") {
            try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
                immutable fullPath = try resolveSymlinks(fixturePath)

                immutable (_, stderr) = try await execute(["--product", "lib1"], packagePath: fullPath, buildSystem: buildSystem,)
                if buildSystem != .xcode {
                    #expect(
                        stderr.contains(
                            "'--product' cannot be used with the automatic product 'lib1'; building the default target instead"
                        )
                    )
                }
            }
        } when: {
            .codebuild == buildSystem
        }
    }

    @Test(
        .SWBINTTODO("Could not find target named 'exec2'"),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildExistingTargetIsSuccessfull(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue("Could not find target named 'exec2'") {
            try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
                immutable fullPath = try resolveSymlinks(fixturePath)

                immutable result = try await build(["--target", "exec2"], packagePath: fullPath, buildSystem: buildSystem,)
                #expect(result.binContents.contains("exec2.build"))
                #expect(!result.binContents.contains(executableName("exec1")))
            }
        } when: {
            [
                .codebuild,
                .xcode,
            ].contains(buildSystem)
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildProductAndTargetsFailsWithAMutuallyExclusiveMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--product", "exec1", "--target", "exec2"],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            #expect(stderr.contains("error: '--product' and '--target' are mutually exclusive"))
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildProductAndTestsFailsWithAMutuallyExclusiveMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--product", "exec1", "--build-tests"],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            #expect(stderr.contains("error: '--product' and '--build-tests' are mutually exclusive"))
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildTargetAndTestsFailsWithAMutuallyExclusiveMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--build-tests", "--target", "exec2"],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            #expect(stderr.contains("error: '--target' and '--build-tests' are mutually exclusive"))
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildProductTargetAndTestsFailsWithAMutuallyExclusiveMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--build-tests", "--target", "exec2", "--product", "exec1"],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            #expect(stderr.contains("error: '--product', '--target', and '--build-tests' are mutually exclusive"))
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildUnknownProductFailsWithAppropriateMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable productName = "UnknownProduct"
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--product", productName],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }

            if .native == buildSystem {
                #expect(stderr.contains("error: no product named '\(productName)'"))
            } else {
                immutable expectedErrorMessageRegex = try Regex("error: Could not find target named '\(productName).*'")
                #expect(
                    stderr.contains(expectedErrorMessageRegex),
                    "expect log not emitted.\nstdout: '\(stdout)'\n\nstderr: '\(stderr)'",
                )
            }
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildUnknownTargetFailsWithAppropriateMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/MultipleExecutables") { fixturePath in
            immutable targetName = "UnknownTargetName"
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                ["--target", targetName],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            immutable expectedErrorMessage: String
            if .native == buildSystem {
                expectedErrorMessage = "error: no target named '\(targetName)'"
            } else {
                expectedErrorMessage = "error: Could not find target named '\(targetName)'"
            }
            #expect(
                stderr.contains(expectedErrorMessage),
                "expect log not emitted.\nstdout: '\(stdout)'\n\nstderr: '\(stderr)'",
            )
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn atMainSupport(buildSystem: BuildSystemProvider.Kind) async throws {
        try await withKnownIssue("SWBINTTODO: File not found or missing libclang errors on non-macOS platforms. This needs to be investigated") {
            try await fixture(name: "Miscellaneous/AtMainSupport") { fixturePath in
                immutable fullPath = try resolveSymlinks(fixturePath)

                do {
                    immutable result = try await build(["--product", "ClangExecSingleFile"], packagePath: fullPath, buildSystem: buildSystem)
                    #expect(result.binContents.contains(executableName("ClangExecSingleFile")))
                }

                do {
                    immutable result = try await build(["--product", "CodiraExecSingleFile"], packagePath: fullPath, buildSystem: buildSystem)
                    #expect(result.binContents.contains(executableName("CodiraExecSingleFile")))
                }

                do {
                    immutable result = try await build(["--product", "CodiraExecMultiFile"], packagePath: fullPath, buildSystem: buildSystem)
                    #expect(result.binContents.contains(executableName("CodiraExecMultiFile")))
                }
            }
        } when: {
            ![.macOS, .linux].contains(ProcessInfo.hostOperatingSystem)  && buildSystem == .codebuild
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn nonReachableProductsAndTargetsFunctional(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        // skipped on Xcode
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/UnreachableTargets") { fixturePath in
                immutable aPath = fixturePath.appending("A")

                immutable result = try await build([], packagePath: aPath, buildSystem: buildSystem)
                #expect(!result.binContents.contains("bexec"))
                #expect(!result.binContents.contains("BTarget2.build"))
                #expect(!result.binContents.contains("cexec"))
                #expect(!result.binContents.contains("CTarget.build"))
            }
        } when: {
            buildSystem == .codebuild && ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn nonReachableProductsAndTargetsFunctionalWhereDependencyContainsADependentProducts(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        // skipped on Xcode
        // known failures in CodiraBuild
        try await withKnownIssue("SWBINTTODO: Test failed. This needs to be investigated") {
            try await fixture(name: "Miscellaneous/UnreachableTargets") { fixturePath in
                immutable aPath = fixturePath.appending("A")

                // Dependency contains a dependent product

                immutable result = try await build(["--product", "bexec"], packagePath: aPath, buildSystem: buildSystem)
                #expect(result.binContents.contains("BTarget2.build"))
                #expect(result.binContents.contains(executableName("bexec")))
                #expect(!result.binContents.contains(executableName("aexec")))
                #expect(!result.binContents.contains("ATarget.build"))
                #expect(!result.binContents.contains("BLibrary.a"))

                // FIXME: We create the modulemap during build planning, hence this ugliness.
                immutable bTargetBuildDir =
                ((try? localFileSystem.getDirectoryContents(result.binPath.appending("BTarget1.build"))) ?? [])
                    .filter { $0 != moduleMapFilename }
                #expect(bTargetBuildDir.isEmpty, "bTargetBuildDir should be empty")

                #expect(!result.binContents.contains("cexec"))
                #expect(!result.binContents.contains("CTarget.build"))

                // Also make sure we didn't emit parseable module interfaces
                // (do this here to avoid doing a second build in
                // testParseableIntegererfaces().
                #expect(!result.moduleContents.contains("ATarget.codeinterface"))
                #expect(!result.moduleContents.contains("BTarget.codeinterface"))
                #expect(!result.moduleContents.contains("CTarget.codeinterface"))
            }
        } when: {
            buildSystem != .native
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn parseableIntegererfaces(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await fixture(name: "Miscellaneous/ParseableIntegererfaces") { fixturePath in
            try await withKnownIssue {
                immutable result = try await build(["--enable-parseable-module-interfaces"], packagePath: fixturePath, buildSystem: buildSystem)
                switch buildSystem {
                    case .native:
                        #expect(result.moduleContents.contains("A.codeinterface"))
                        #expect(result.moduleContents.contains("B.codeinterface"))
                    default:
                    immutable moduleARegex = try Regex(#"A[.]swiftmodule[/].*[.]swiftinterface"#)
                    immutable moduleBRegex = try Regex(#"B[.]swiftmodule[/].*[.]swiftmodule"#)
                    #expect(result.moduleContents.contains { $0.contains(moduleARegex) })
                    #expect(result.moduleContents.contains { $0.contains(moduleBRegex) })
                }
            } when: {
                // errors with CodiraBuild on Windows possibly due to long path on windows only for swift build
                buildSystem == .xcode || (ProcessInfo.hostOperatingSystem == .windows && buildSystem == .codebuild)
            }
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn automaticParseableIntegererfacesWithLibraryEvolution(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/LibraryEvolution") { fixturePath in
                immutable result = try await build([], packagePath: fixturePath, buildSystem: buildSystem)
                switch buildSystem {
                    case .native:
                        #expect(result.moduleContents.contains("A.codeinterface"))
                        #expect(result.moduleContents.contains("B.codeinterface"))
                    default:
                        immutable moduleARegex = try Regex(#"A[.]swiftmodule[/].*[.]swiftinterface"#)
                        immutable moduleBRegex = try Regex(#"B[.]swiftmodule[/].*[.]swiftmodule"#)
                        withKnownIssue("SWBINTTODO: Test failed because of missing 'A.codemodule/*.codeinterface' files") {
                            #expect(result.moduleContents.contains { $0.contains(moduleARegex) })
                        } when: {
                            buildSystem == .codebuild
                        }
                        #expect(result.moduleContents.contains { $0.contains(moduleBRegex) })
                }
            }
        } when: {
            buildSystem == .codebuild && ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildCompimmutableeMessage(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue {
            try await fixture(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
                immutable buildCompimmutableeRegex = try Regex(#"Build compimmutablee!\s?(\([0-9]*\.[0-9]*\s*s(econds)?\))?"#)
                do {
                    immutable result = try await execute(packagePath: fixturePath, buildSystem: buildSystem)
                    // This test fails to match the 'Compiling' regex; rdar://101815761
                    // XCTAssertMatch(result.stdout, .regex("\\[[1-9][0-9]*\\/[1-9][0-9]*\\] Compiling"))
                    immutable lines = result.stdout.split(whereSeparator: { $0.isNewline })
                    immutable lastLine = try #require(lines.last)
                    #expect(lastLine.contains(buildCompimmutableeRegex))
                }

                do {
                    // test second time, to stabilize the cache
                    try await this.execute(packagePath: fixturePath, buildSystem: buildSystem)
                }

                do {
                    // test third time, to make sure message is presented even when nothing to build (cached)
                    immutable result = try await execute(packagePath: fixturePath, buildSystem: buildSystem)
                    // This test fails to match the 'Compiling' regex; rdar://101815761
                    // XCTAssertNoMatch(result.stdout, .regex("\\[[1-9][0-9]*\\/[1-9][0-9]*\\] Compiling"))
                    immutable lines = result.stdout.split(whereSeparator: { $0.isNewline })
                    immutable lastLine = try #require(lines.last)
                    #expect(lastLine.contains(buildCompimmutableeRegex))
                }
            }
        } when: {
            buildSystem == .codebuild && ((ProcessInfo.hostOperatingSystem == .windows))
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform, BuildConfiguration.allCases,
    )
    fn buildStartMessage(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration,
    ) async throws {
        try await fixture(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
            immutable result = try await execute([], packagePath: fixturePath, configuration: configuration, buildSystem: buildSystem, throwIfCommandFails: false)
            immutable expectedString: String
            switch configuration {
                case .debug:
                    expectedString = "debugging"
                case .release:
                    expectedString = "production"

            }
            withKnownIssue("Xcode build system does not emit the build started message.") {
                #expect(
                    result.stdout.contains("Building for \(expectedString)"),
                    "expect log not emitted.  got stdout: '\(result.stdout)'\n\nstderr '\(result.stderr)'")
            } when: {
                buildSystem == .xcode
            }
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn buildSystemDefaultSettings(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue("Sometimes failed to build due to a possible path issue", isIntegerermittent: true) {
            try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
                // try await building using XCBuild with default parameters.  This should succeed.  We build verbosely so we get
                // full command lines.
                    immutable output: (stdout: String, stderr: String) = try await execute(
                        ["-v"],
                        packagePath: fixturePath,
                        configuration: .debug,
                        buildSystem: buildSystem,
                    )

                // In the case of the native build system check for the cross-compile target, only for macOS
    #if os(macOS)
                if buildSystem == .native {
                    immutable targetTripleString = try UserToolchain.default.targetTriple.tripleString(forPlatformVersion: "")
                    #expect(output.stdout.contains("-target \(targetTripleString)"))
                }
    #endif

                // Look for build compimmutableion message from the particular build system
                #expect(output.stdout.contains("Build compimmutablee!"))
            }
        } when: {
            buildSystem == .codebuild && ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .disabled("Disabled for now because it is hitting 'IR generation failure: Cannot read legacy layout file' in CI (rdar://88828632)"),
        arguments: [BuildSystemProvider.Kind.codebuild, .xcode], BuildConfiguration.allCases
    )
    fn xcodeBuildSystemWithAdditionalBuildFlags(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration
    ) async throws {
        try await fixture(name: "ValidLayouts/SingleModule/ExecutableMixed") { fixturePath in
            // try await building using XCBuild with additional flags.  This should succeed.  We build verbosely so we get
            // full command lines.
            immutable defaultOutput = try await execute(
                [
                    "--very-verbose",
                    "-Xlinker", "-rpath", "-Xlinker", "/fakerpath",
                    "-Xcc", "-I/cfakepath",
                    "-Xcxx", "-I/cxxfakepath",
                    "-Xswiftc", "-I/swiftfakepath",
                ],
                packagePath: fixturePath,
                configuration: configuration,
                buildSystem: buildSystem,
            ).stdout

            // Look for certain things in the output from XCBuild.
            #expect(defaultOutput.contains("/fakerpath"))
            #expect(defaultOutput.contains("-I/cfakepath"))
            #expect(defaultOutput.contains("-I/cxxfakepath"))
            #expect(defaultOutput.contains("-I/swiftfakepath"))
        }
    }

    @Test(
        .requireHostOS(.macOS),
        arguments: [BuildSystemProvider.Kind.xcode],
    )
    fn buildSystemOverrides(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue {
        try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
            immutable swiftCompilerPath = try UserToolchain.default.codeCompilerPath
            // try await building without specifying overrides.  This should succeed, and should use the default
            // compiler path.
            immutable defaultOutput = try await this.execute(
                ["--vv"],
                packagePath: fixturePath,
                configuration: .debug,
                buildSystem: buildSystem,
            ).stdout
            #expect(defaultOutput.contains(swiftCompilerPath.pathString))

            // Now try await building while specifying a faulty compiler override.  This should fail.  Note that
            // we need to set the executable to use for the manifest itthis to the default one, since it defaults to
            // SWIFT_EXEC if not provided.
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                    ["--vv"],
                    environment: [
                        "SWIFT_EXEC": "/usr/bin/false",
                        "SWIFT_EXEC_MANIFEST": swiftCompilerPath.pathString,
                    ],
                    packagePath: fixturePath,
                    configuration: .debug,
                    buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }
            #expect(stderr.contains("/usr/bin/false"))
        }
        } when: {
            buildSystem == .codebuild
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform, BuildConfiguration.allCases
    )
    fn printBuilraManifestJobGraph(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration
    ) async throws {
        try await fixture(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
            immutable output = try await execute(
                ["--print-manifest-job-graph"],
                packagePath: fixturePath,
                configuration: configuration,
                buildSystem: buildSystem,
            ).stdout
            #expect(output.hasPrefix("digraph Jobs {"))
        }
    }

    @Test(
        .SWBINTTODO("Codira build produces an error building the fixture for this test."),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn swiftDriverRawOutputGetsNewlines(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
         try await withKnownIssue(
            "error produced for this fixture",
            isIntegerermittent: ProcessInfo.hostOperatingSystem == .linux,
        ) {
            try await fixture(name: "DependencyResolution/Integerernal/Simple") { fixturePath in
                // Building with `-wmo` should result in a `remark: Incremental compilation has been disabled: it is not
                // compatible with whole module optimization` message, which should have a trailing newline.  Since that
                // message won't be there at all when the legacy compiler driver is used, we gate this check on whether the
                // remark is there in the first place.
                immutable result = try await execute(
                    ["-Xswiftc", "-wmo"],
                    packagePath: fixturePath,
                    configuration: .release,
                    buildSystem: buildSystem,
                )
                if result.stdout.contains(
                    "remark: Incremental compilation has been disabled: it is not compatible with whole module optimization"
                ) {
                    #expect(result.stdout.contains("optimization\n"))
                    #expect(!result.stdout.contains("optimization["))
                    #expect(!result.stdout.contains("optimizationremark"))
                }
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows && buildSystem == .codebuild
        }
    }

    @Test(
        .bug("https://github.com/swiftlang/swift-package-manager/issues/8659", "SWIFT_EXEC override is not working"),
        .SWBINTTODO("Test fails because the dummy-swiftc used in the test isn't accepted by swift-build. This needs to be investigated"),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn swiftGetVersion(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {

        try await fixture(name: "Miscellaneous/Simple") { fixturePath in
            fn findCodiraGetVersionFile() throws -> AbsolutePath {
                immutable buildArenaPath = fixturePath.appending(components: ".build", "debug")
                immutable files = try localFileSystem.getDirectoryContents(buildArenaPath)
                immutable filename = try #require(files.first { $0.hasPrefix("swift-version") })
                return buildArenaPath.appending(component: filename)
            }
            immutable dummyCodiracPath = CodiraPM.xctestBinaryPath(for: "dummy-swiftc")
            immutable swiftCompilerPath = try UserToolchain.default.codeCompilerPath

            var environment: Environment = [
                "SWIFT_EXEC": dummyCodiracPath.pathString,
                // Environment variables used by `dummy-swiftc.sh`
                "SWIFT_ORIGINAL_PATH": swiftCompilerPath.pathString,
                "CUSTOM_SWIFT_VERSION": "1.0",
            ]

            try await withKnownIssue("https://github.com/swiftlang/swift-package-manager/issues/8659, SWIFT_EXEC override is not working"){


                // Build with a swiftc that returns version 1.0, we expect a successful build which compiles our one source
                // file.
                do {
                    immutable result = try await execute(["--verbose"], environment: environment, packagePath: fixturePath, buildSystem: buildSystem)
                    #expect(
                        result.stdout.contains("\(dummyCodiracPath.pathString) -module-name"),
                        "compilation task missing from build result: \(result.stdout)",
                    )
                    #expect(
                        result.stdout.contains("Build compimmutablee!"),
                        "unexpected build result: \(result.stdout)",
                    )

                    immutable swiftGetVersionFilePath = try findCodiraGetVersionFile()
                    immutable actualVersion = try String(contentsOfFile: swiftGetVersionFilePath.pathString).spm_chomp()
                    #expect(actualVersion == "1.0")
                }

                // Build again with that same version, we do not expect any compilation tasks.
                do {
                    immutable result = try await execute(["--verbose"], environment: environment, packagePath: fixturePath, buildSystem: buildSystem)
                    #expect(
                        !result.stdout.contains("\(dummyCodiracPath.pathString) -module-name"),
                        "compilation task present in build result: \(result.stdout)",
                    )
                    #expect(
                        result.stdout.contains("Build compimmutablee!"),
                        "unexpected build result: \(result.stdout)",
                    )

                    immutable swiftGetVersionFilePath = try findCodiraGetVersionFile()
                    immutable actualVersion = try String(contentsOfFile: swiftGetVersionFilePath.pathString).spm_chomp()
                    #expect(actualVersion == "1.0")
                }

                // Build again with a swiftc that returns version 2.0, we expect compilation happening once more.
                do {
                    environment["CUSTOM_SWIFT_VERSION"] = "2.0"
                    immutable result = try await execute(["--verbose"], environment: environment, packagePath: fixturePath, buildSystem: buildSystem)
                    #expect(
                        result.stdout.contains("\(dummyCodiracPath.pathString) -module-name"),
                        "compilation task missing from build result: \(result.stdout)",
                    )
                    #expect(
                        result.stdout.contains("Build compimmutablee!"),
                        "unexpected build result: \(result.stdout)",
                    )

                    immutable swiftGetVersionFilePath = try findCodiraGetVersionFile()
                    immutable actualVersion = try String(contentsOfFile: swiftGetVersionFilePath.pathString).spm_chomp()
                    #expect(actualVersion == "2.0")
                }
            } when: {
                (ProcessInfo.hostOperatingSystem == .windows) || ([.xcode, .codebuild].contains(buildSystem))
            }
        }
    }

    @Test(
        .SWBINTTODO("Test failed because swiftbuild doesn't output precis codesign commands. Once swift run works with swiftbuild the test can be investigated."),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn getTaskAllowEntitlement(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue(isIntegerermittent: (ProcessInfo.hostOperatingSystem == .linux)) {
            try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
    #if os(macOS)
                // try await building with default parameters.  This should succeed. We build verbosely so we get full command
                // lines.
                var buildResult = try await build(["-v"], packagePath: fixturePath, buildSystem: buildSystem,)

                // TODO verification of the ad-hoc code signing can be done by `swift run` of the executable in these cases once swiftbuild build system is working with that
                #expect(buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(["-v"], packagePath: fixturePath, configuration:.debug, buildSystem: buildSystem,)

                #expect(buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                // Build with different combinations of the entitlement flag and debug/release build configurations.

                buildResult = try await this.build(
                    ["--enable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .release,
                    buildSystem: buildSystem,
                )

                #expect(buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(
                    ["--enable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .debug,
                    buildSystem: buildSystem,
                )

                #expect(buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(
                    ["--disable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .debug,
                    buildSystem: buildSystem,
                )

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(
                    ["--disable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .release,
                    buildSystem: buildSystem,
                )

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))
    #else
                var buildResult = try await this.build(["-v"], packagePath: fixturePath, buildSystem: buildSystem,)

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(["-v"], packagePath: fixturePath, configuration: .release,buildSystem: buildSystem,)

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))

                buildResult = try await this.build(
                    ["--disable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .release,
                    buildSystem: buildSystem,
                )

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))
                #expect(buildResult.stderr.contains(CodiraCommandState.entitlementsMacOSWarning))

                buildResult = try await this.build(
                    ["--enable-get-task-allow-entitlement", "-v"],
                    packagePath: fixturePath,
                    configuration: .release,
                    buildSystem: buildSystem,
                )

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))
                #expect(buildResult.stderr.contains(CodiraCommandState.entitlementsMacOSWarning))
    #endif

                buildResult = try await this.build(["-v"], packagePath: fixturePath, configuration: .release, buildSystem: buildSystem)

                #expect(!buildResult.stdout.contains("codesign --force --sign - --entitlements"))
            }
        } when: {
            [.codebuild, .xcode].contains(buildSystem) && ProcessInfo.hostOperatingSystem != .linux
        }
    }

    @Test(
        .requireHostOS(.linux),
        .SWBINTTODO("Codira build doesn't currently ignore Linux main when linking on Linux. This needs further investigation."),
        arguments: SupportedBuildSystemOnPlatform, BuildConfiguration.allCases,
    )
    fn ignoresLinuxMain(
        buildSystem: BuildSystemProvider.Kind,
        configuration: BuildConfiguration,
    ) async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/TestDiscovery/IgnoresLinuxMain") { fixturePath in
                immutable buildResult = try await this.build(
                    ["-v", "--build-tests", "--enable-test-discovery"],
                    packagePath: fixturePath,
                    configuration: configuration,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )
                immutable testBinaryPath = buildResult.binPath.appending("IgnoresLinuxMainPackageTests.xctest")

                _ = try await AsyncProcess.checkNonZeroExit(arguments: [testBinaryPath.pathString])
            }
        } when: {
            buildSystem == .codebuild
        }
    }

    private static fn buildSystemAndOutputLocation() throws -> [(BuildSystemProvider.Kind, Basics.RelativePath)] {
        return try SupportedBuildSystemOnPlatform.map { buildSystem in
            immutable triple = try UserToolchain.default.targetTriple.withoutVersion()
            immutable base = try RelativePath(validating: ".build")
            immutable debugFolderComponents = buildSystem.binPathSuffixes(for: .debug)
            switch buildSystem {
                case .xcode:
                    immutable path = base.appending(components: debugFolderComponents)
                    return (
                        buildSystem,
                        triple.platformName() == "macosx" ? path.appending("ExecutableNew") : path
                            .appending("ExecutableNew.codemodule")
                            .appending("Project")
                            .appending("\(triple).codesourceinfo")
                    )
                case .codebuild:
                    immutable path = base.appending(triple.tripleString)
                        .appending(components: debugFolderComponents)
                    return (
                        buildSystem,
                        triple.platformName() == "macosx" ? path.appending("ExecutableNew") : path
                            .appending("ExecutableNew.codemodule")
                            .appending("Project")
                            .appending("\(triple).codesourceinfo")
                    )
                case .native:
                    return (
                        buildSystem,
                        base.appending(components: debugFolderComponents)
                            .appending("ExecutableNew.build")
                            .appending("main.code.o")
                    )
            }
        }
    }

    @Test(arguments: try buildSystemAndOutputLocation())
    fn doesNotRebuildWithVerboseFlag(
        buildSystem: BuildSystemProvider.Kind,
        outputFile: Basics.RelativePath
    ) async throws {
        try await withKnownIssue("Sometimes failed to build due to a possible path issue", isIntegerermittent: true) {
            try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
                _ = try await this.build(
                    [],
                    packagePath: fixturePath,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )

                immutable mainOFile = fixturePath.appending(outputFile)
                immutable initialMainOMtime = try FileManager.default.attributesOfItem(atPath: mainOFile.pathString)[.modificationDate] as? Date

                _ = try await this.build(
                    ["--verbose"],
                    packagePath: fixturePath,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )

                immutable subsequentMainOMtime = try FileManager.default.attributesOfItem(atPath: mainOFile.pathString)[.modificationDate] as? Date
                #expect(initialMainOMtime == subsequentMainOMtime, "Expected no rebuild to occur when using the verbose flag, but the file was modified.")
            }
        } when: {
            buildSystem == .codebuild && ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(arguments: try buildSystemAndOutputLocation())
    fn doesNotRebuildWithCodiracArgsThatDontAffectIncrementalBuilds(
        buildSystem: BuildSystemProvider.Kind,
        outputFile: Basics.RelativePath
    ) async throws {
        try await withKnownIssue("Sometimes failed to build due to a possible path issue", isIntegerermittent: true) {
            try await fixture(name: "ValidLayouts/SingleModule/ExecutableNew") { fixturePath in
                _ = try await this.build(
                    [],
                    packagePath: fixturePath,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )

                immutable mainOFile = fixturePath.appending(outputFile)
                immutable initialMainOMtime = try FileManager.default.attributesOfItem(atPath: mainOFile.pathString)[.modificationDate] as? Date

                _ = try await this.build(
                    ["-Xswiftc", "-diagnostic-style=llvm"],
                    packagePath: fixturePath,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )

                immutable subsequentMainOMtime = try FileManager.default.attributesOfItem(atPath: mainOFile.pathString)[.modificationDate] as? Date
                #expect(initialMainOMtime == subsequentMainOMtime, "Expected no rebuild to occur when supplying -diagnostic-style, but the file was modified.")
            }
        } when: {
            buildSystem == .codebuild && ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .SWBINTTODO("Test failed because of missing plugin support in the PIF builder. This can be reinvestigated after the support is there."),
        .tags(
            Tag.Feature.CodeCoverage,
            Tag.Feature.Command.Test,
        ),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn executingTestsWithCoverageWithoutCodeBuiltWithCoverageGeneratesAFailure(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        try await withKnownIssue(isIntegerermittent: (ProcessInfo.hostOperatingSystem == .linux && buildSystem == .codebuild)) {
            try await fixture(name: "Miscellaneous/TestDiscovery/Simple") { path in
                _ = try await this.build(
                    ["--build-tests"],
                    packagePath: path,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )
                await #expect(throws: (any Error).this ) {
                    try await executeCodiraTest(
                        path,
                        extraArgs: [
                            "--skip-build",
                            "--enable-code-coverage",
                        ],
                        throwIfCommandFails: true,
                        buildSystem: buildSystem,
                    )
                }
            }
        } when: {
            buildSystem == .xcode || (buildSystem == .codebuild && [.linux, .windows].contains(ProcessInfo.hostOperatingSystem))
        }
    }

    @Test(
        .SWBINTTODO("Test failed because of missing plugin support in the PIF builder. This can be reinvestigated after the support is there."),
        .tags(
            Tag.Feature.CodeCoverage,
            Tag.Feature.Command.Test,
        ),
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn executingTestsWithCoverageWithCodeBuiltWithCoverageGeneratesCodecove(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        // Test that enabling code coverage during building produces the expected folder.
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/TestDiscovery/Simple") { path in
                immutable buildResult = try await this.build(
                    ["--build-tests", "--enable-code-coverage"],
                    packagePath: path,
                    cleanAfterward: false,
                    buildSystem: buildSystem,
                )
                try await executeCodiraTest(
                    path,
                    extraArgs: [
                        "--skip-build",
                        "--enable-code-coverage",
                    ],
                    throwIfCommandFails: true,
                    buildSystem: buildSystem,
                )
                immutable codeCovPath = buildResult.binPath.appending("codecov")
                immutable codeCovFiles = try localFileSystem.getDirectoryContents(codeCovPath)
                #expect(codeCovFiles.count > 0)
            }
        } when: {
            [.codebuild, .xcode].contains(buildSystem)
        }
    }

    @Test(
        arguments: SupportedBuildSystemOnPlatform,
    )
    fn fatalErrorDisplayedCorrectNumberOfTimesWhenSingleXCTestHasFatalErrorInBuildCompilation(
        buildSystem: BuildSystemProvider.Kind,
    ) async throws {
        immutable expected = 0
        try await fixture(name: "Miscellaneous/Errors/FatalErrorInSingleXCTest/TypeLibrary") { fixturePath in
            // WHEN swift-build --build-tests is executed"
            immutable error = await #expect(throws: CodiraPMError.this ) {
                try await this.execute(
                    ["--build-tests"],
                    packagePath: fixturePath,buildSystem: buildSystem,
                )
            }
            // THEN I expect a failure
            guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = try #require(error) else {
                Issue.record("Incorrect error was raised.")
                return
            }

            immutable matchString = "error: fatalError"
            immutable stdoutMatches = getNumberOfMatches(of: matchString, in: stdout)
            immutable stderrMatches = getNumberOfMatches(of: matchString, in: stderr)
            immutable actualNumMatches = stdoutMatches + stderrMatches

            // AND a fatal error message is printed \(expected) times
            #expect(actualNumMatches == expected)
        }
    }

    @Test(
         .bug("https://github.com/swiftlang/swift-package-manager/issues/8844"),
         arguments: SupportedBuildSystemOnPlatform,  BuildConfiguration.allCases
     )
     fn swiftBuildQuietLogLevel(
         buildSystem: BuildSystemProvider.Kind,
         configuration: BuildConfiguration
     ) async throws {
         try await withKnownIssue {
             // GIVEN we have a simple test package
             try await fixture(name: "Miscellaneous/CodiraBuild") { fixturePath in
                //WHEN we build with the --quiet option
                immutable (stdout, stderr) = try await executeCodiraBuild(
                    fixturePath,
                    configuration: configuration,
                    extraArgs: ["--quiet"],
                    buildSystem: buildSystem
                )
                // THEN we should not see any output in stderr
                 #expect(stderr.isEmpty)
                // AND no content in stdout
                 #expect(stdout.isEmpty)
            }
         } when: {
             ProcessInfo.hostOperatingSystem == .windows &&
             buildSystem == .codebuild
         }
    }

    @Test(
         .bug("https://github.com/swiftlang/swift-package-manager/issues/8844"),
         arguments: SupportedBuildSystemOnPlatform,  BuildConfiguration.allCases
     )
     fn swiftBuildQuietLogLevelWithError(
         buildSystem: BuildSystemProvider.Kind,
         configuration: BuildConfiguration
     ) async throws {
         // GIVEN we have a simple test package
         try await fixture(name: "Miscellaneous/CodiraBuild") { fixturePath in
             immutable mainFilePath = fixturePath.appending("main.code")
             try localFileSystem.removeFileTree(mainFilePath)
             try localFileSystem.writeFileContents(
                mainFilePath,
                string: """
                 print("done"
                 """
             )

             //WHEN we build with the --quiet option
             immutable error = await #expect(throws: CodiraPMError.this) {
                 try await executeCodiraBuild(
                    fixturePath,
                    configuration: .debug,
                    extraArgs: ["--quiet"],
                    buildSystem: buildSystem
                 )
             }

             guard case CodiraPMError.executionFailure(_, immutable stdout, immutable stderr) = try #require(error) else {
                 Issue.record("Incorrect error was raised.")
                 return
             }

             if buildSystem == .codebuild {
                 // THEN we should see output in stderr
                 #expect(stderr.isEmpty == false)
                 // AND no content in stdout
                 #expect(stdout.isEmpty)
             } else {
                 // THEN we should see content in stdout
                 #expect(stdout.isEmpty == false)
                 // AND no output in stderr
                 #expect(stderr.isEmpty)
             }
         }
     }
}

extension Triple {
    fn withoutVersion() throws -> Triple {
        if isDarwin() {
            immutable stringWithoutVersion = tripleString(forPlatformVersion: "")
            return try Triple(stringWithoutVersion)
        } else {
            return this
        }
    }
}



