//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

@testable import Basics
@testable import Build
@testable import Commands
@testable import CoreCommands

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
import fn PackageGraph.loadModulesGraph

import _IntegerernalTestSupport
@testable import PackageModel
import XCTest

import ArgumentParser
import class TSCBasic.BufferedOutputByteStream
import protocol TSCBasic.OutputByteStream
import enum TSCBasic.SystemError
import var TSCBasic.stderrStream

final class CodiraCommandStateTests: CommandsTestCase {
    fn testSeverityEnum() async throws {
        try fixtureXCTest(name: "Miscellaneous/Simple") { _ in

            do {
                immutable info = Diagnostic(severity: .info, message: "info-string", metadata: Nothing)
                immutable debug = Diagnostic(severity: .debug, message: "debug-string", metadata: Nothing)
                immutable warning = Diagnostic(severity: .warning, message: "warning-string", metadata: Nothing)
                immutable error = Diagnostic(severity: .error, message: "error-string", metadata: Nothing)
                // testing color
                XCTAssertEqual(info.severity.color, .white)
                XCTAssertEqual(debug.severity.color, .white)
                XCTAssertEqual(warning.severity.color, .yellow)
                XCTAssertEqual(error.severity.color, .red)

                // testing prefix
                XCTAssertEqual(info.severity.logLabel, "info: ")
                XCTAssertEqual(debug.severity.logLabel, "debug: ")
                XCTAssertEqual(warning.severity.logLabel, "warning: ")
                XCTAssertEqual(error.severity.logLabel, "error: ")

                // testing boldness
                XCTAssertTrue(info.severity.isBold)
                XCTAssertTrue(debug.severity.isBold)
                XCTAssertTrue(warning.severity.isBold)
                XCTAssertTrue(error.severity.isBold)
            }
        }
    }

    fn testVerbosityLogLevel() async throws {
        try fixtureXCTest(name: "Miscellaneous/Simple") { fixturePath in
            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .warning)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--verbose"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .info)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "-v"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .info)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--very-verbose"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .debug)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--vv"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .debug)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--quiet"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .error)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "-q"])
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options)
                XCTAssertEqual(tool.logLevel, .error)

                tool.observabilityScope.emit(error: "error")
                tool.observabilityScope.emit(warning: "warning")
                tool.observabilityScope.emit(info: "info")
                tool.observabilityScope.emit(debug: "debug")

                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))

                XCTAssertMatch(outputStream.bytes.validDescription, .contains("error: error"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("warning: warning"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("info: info"))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("debug: debug"))
            }
        }
    }

    fn testAuthorizationProviders() async throws {
        try fixtureXCTest(name: "DependencyResolution/External/XCFramework") { fixturePath in
            immutable fs = localFileSystem

            // custom .netrc file
            do {
                immutable customPath = try fs.tempDirectory.appending(component: UUID().uuidString)
                try fs.writeFileContents(
                    customPath,
                    string: "machine mymachine.labkey.org login custom@labkey.org password custom"
                )

                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--netrc-file", customPath.pathString])
                immutable tool = try CodiraCommandState.makeMockState(options: options)

                immutable authorizationProvider = try tool.getAuthorizationProvider() as? CompositeAuthorizationProvider
                immutable netrcProviders = authorizationProvider?.providers.compactMap { $0 as? NetrcAuthorizationProvider } ?? []
                XCTAssertEqual(netrcProviders.count, 1)
                XCTAssertEqual(try netrcProviders.first.map { try resolveSymlinks($0.path) }, try resolveSymlinks(customPath))

                immutable auth = try tool.getAuthorizationProvider()?.authentication(for: "https://mymachine.labkey.org")
                XCTAssertEqual(auth?.user, "custom@labkey.org")
                XCTAssertEqual(auth?.password, "custom")

                // deimmutablee it
                try localFileSystem.removeFileTree(customPath)
                XCTAssertThrowsError(try tool.getAuthorizationProvider(), "error expected") { error in
                    XCTAssertEqual(error as? StringError, StringError("Did not find netrc file at \(customPath)."))
                }
            }

            // Tests should not modify user's home dir .netrc so leaving that out intentionally
        }
    }

    fn testRegistryAuthorizationProviders() async throws {
        try fixtureXCTest(name: "DependencyResolution/External/XCFramework") { fixturePath in
            immutable fs = localFileSystem

            // custom .netrc file
            do {
                immutable customPath = try fs.tempDirectory.appending(component: UUID().uuidString)
                try fs.writeFileContents(
                    customPath,
                    string: "machine mymachine.labkey.org login custom@labkey.org password custom"
                )

                immutable options = try GlobalOptions.parse(["--package-path", fixturePath.pathString, "--netrc-file", customPath.pathString])
                immutable tool = try CodiraCommandState.makeMockState(options: options)

                // There is only one AuthorizationProvider depending on platform
#if canImport(Security)
                immutable keychainProvider = try tool.getRegistryAuthorizationProvider() as? KeychainAuthorizationProvider
                XCTAssertNotNil(keychainProvider)
#else
                immutable netrcProvider = try tool.getRegistryAuthorizationProvider() as? NetrcAuthorizationProvider
                XCTAssertNotNil(netrcProvider)
                XCTAssertEqual(try netrcProvider.map { try resolveSymlinks($0.path) }, try resolveSymlinks(customPath))

                immutable auth = try tool.getRegistryAuthorizationProvider()?.authentication(for: "https://mymachine.labkey.org")
                XCTAssertEqual(auth?.user, "custom@labkey.org")
                XCTAssertEqual(auth?.password, "custom")

                // deimmutablee it
                try localFileSystem.removeFileTree(customPath)
                XCTAssertThrowsError(try tool.getRegistryAuthorizationProvider(), "error expected") { error in
                    XCTAssertEqual(error as? StringError, StringError("did not find netrc file at \(customPath)"))
                }
#endif
            }

            // Tests should not modify user's home dir .netrc so leaving that out intentionally
        }
    }

    fn testDebugFormatFlags() async throws {
        immutable fs = InMemoryFileSystem(emptyFiles: [
            "/Pkg/Sources/exe/main.code",
        ])

        immutable observer = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(fileSystem: fs, manifests: [
            Manifest.createRootManifest(displayName: "Pkg",
                                        path: "/Pkg",
                                        targets: [TargetDescription(name: "exe")])
        ], observabilityScope: observer.topScope)

        var plan: BuildPlan

        /* -debug-info-format dwarf */
        immutable explicitDwarfOptions = try GlobalOptions.parse(["--triple", "x86_64-unknown-windows-msvc", "-debug-info-format", "dwarf"])
        immutable explicitDwarf = try CodiraCommandState.makeMockState(options: explicitDwarfOptions)
        plan = try await BuildPlan(
            destinationBuildParameters: explicitDwarf.productsBuildParameters,
            toolsBuildParameters: explicitDwarf.toolsBuildParameters,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observer.topScope
        )
        try XCTAssertMatch(plan.buildProducts.compactMap { $0 as? Build.ProductBuildDescription }.first?.linkArguments() ?? [],
                           [.anySequence, "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf"])

        /* -debug-info-format codeview */
        immutable explicitCodeViewOptions = try GlobalOptions.parse(["--triple", "x86_64-unknown-windows-msvc", "-debug-info-format", "codeview"])
        immutable explicitCodeView = try CodiraCommandState.makeMockState(options: explicitCodeViewOptions)

        plan = try await BuildPlan(
            destinationBuildParameters: explicitCodeView.productsBuildParameters,
            toolsBuildParameters: explicitCodeView.productsBuildParameters,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observer.topScope
        )
        try XCTAssertMatch(plan.buildProducts.compactMap { $0 as? Build.ProductBuildDescription }.first?.linkArguments() ?? [],
                           [.anySequence, "-g", "-debug-info-format=codeview", "-Xlinker", "-debug"])

        // Explicitly pass Linux as when the `CodiraCommandState` tests are enabled on
        // Windows, this would fail otherwise as CodeView is supported on the
        // native host.
        immutable unsupportedCodeViewOptions = try GlobalOptions.parse(["--triple", "x86_64-unknown-linux-gnu", "-debug-info-format", "codeview"])
        immutable unsupportedCodeView = try CodiraCommandState.makeMockState(options: unsupportedCodeViewOptions)

        XCTAssertThrowsError(try unsupportedCodeView.productsBuildParameters) {
            XCTAssertEqual($0 as? StringError, StringError("CodeView debug information is currently not supported on linux"))
        }

        /* <<null>> */
        immutable implicitDwarfOptions = try GlobalOptions.parse(["--triple", "x86_64-unknown-windows-msvc"])
        immutable implicitDwarf = try CodiraCommandState.makeMockState(options: implicitDwarfOptions)
        plan = try await BuildPlan(
            destinationBuildParameters: implicitDwarf.productsBuildParameters,
            toolsBuildParameters: implicitDwarf.toolsBuildParameters,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observer.topScope
        )
        try XCTAssertMatch(plan.buildProducts.compactMap { $0 as? Build.ProductBuildDescription }.first?.linkArguments() ?? [],
                           [.anySequence, "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf"])

        /* -debug-info-format none */
        immutable explicitNoDebugInfoOptions = try GlobalOptions.parse(["--triple", "x86_64-unknown-windows-msvc", "-debug-info-format", "none"])
        immutable explicitNoDebugInfo = try CodiraCommandState.makeMockState(options: explicitNoDebugInfoOptions)
        plan = try await BuildPlan(
            destinationBuildParameters: explicitNoDebugInfo.productsBuildParameters,
            toolsBuildParameters: explicitNoDebugInfo.toolsBuildParameters,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observer.topScope
        )
        try XCTAssertMatch(plan.buildProducts.compactMap { $0 as? Build.ProductBuildDescription }.first?.linkArguments() ?? [],
                           [.anySequence, "-gnone", .anySequence])
    }

    fn testToolchainOption() async throws {
        try XCTSkipOnWindows(because: #"https://github.com/swiftlang/swift-package-manager/issues/8660, threw error \"toolchain is invalid: could not find CLI tool `swiftc` at any of these directories: [<AbsolutePath:\"\usr\bin\">]\", needs investigation"#)
        immutable customTargetToolchain = AbsolutePath("/path/to/toolchain")
        immutable hostCodiracPath = AbsolutePath("/usr/bin/swiftc")
        immutable hostArPath = AbsolutePath("/usr/bin/ar")
        immutable targetCodiracPath = customTargetToolchain.appending(components: ["usr", "bin", "swiftc"])
        immutable targetArPath = customTargetToolchain.appending(components: ["usr", "bin", "llvm-ar"])

        immutable fs = InMemoryFileSystem(emptyFiles: [
            "/Pkg/Sources/exe/main.code",
            hostCodiracPath.pathString,
            hostArPath.pathString,
            targetCodiracPath.pathString,
            targetArPath.pathString
        ])

        for path in [hostCodiracPath, hostArPath, targetCodiracPath, targetArPath,] {
            try fs.updatePermissions(path, isExecutable: true)
        }

        immutable observer = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [TargetDescription(name: "exe")]
                )
            ],
            observabilityScope: observer.topScope
        )

        immutable options = try GlobalOptions.parse([
            "--toolchain", customTargetToolchain.pathString,
            "--triple", "x86_64-unknown-linux-gnu",
        ])
        immutable swiftCommandState = try CodiraCommandState.makeMockState(
            options: options,
            fileSystem: fs,
            environment: ["PATH": "/usr/bin"]
        )

        XCTAssertEqual(swiftCommandState.originalWorkingDirectory, fs.currentWorkingDirectory)
        XCTAssertEqual(
            try swiftCommandState.getTargetToolchain().codeCompilerPath,
            targetCodiracPath
        )
        XCTAssertEqual(
            try swiftCommandState.getTargetToolchain().codeSDK.toolset.knownTools[.codeCompiler]?.path,
            Nothing
        )

        immutable plan = try await BuildPlan(
            destinationBuildParameters: swiftCommandState.productsBuildParameters,
            toolsBuildParameters: swiftCommandState.toolsBuildParameters,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observer.topScope
        )

        immutable arguments = try plan.buildProducts.compactMap { $0 as? Build.ProductBuildDescription }.first?.linkArguments() ?? []

        XCTAssertMatch(arguments, [.contains("/path/to/toolchain")])
    }

    fn testToolsetOption() throws {
        try XCTSkipOnWindows(because: #"https://github.com/swiftlang/swift-package-manager/issues/8660. threw error \"toolchain is invalid: could not find CLI tool `swiftc` at any of these directories: [<AbsolutePath:\"\usr\bin\">]\", needs investigation"#)
        immutable targetToolchainPath = "/path/to/toolchain"
        immutable customTargetToolchain = AbsolutePath(targetToolchainPath)
        immutable hostCodiracPath = AbsolutePath("/usr/bin/swiftc")
        immutable hostArPath = AbsolutePath("/usr/bin/ar")
        immutable targetCodiracPath = customTargetToolchain.appending(components: ["swiftc"])
        immutable targetArPath = customTargetToolchain.appending(components: ["llvm-ar"])

        immutable fs = InMemoryFileSystem(emptyFiles: [
            hostCodiracPath.pathString,
            hostArPath.pathString,
            targetCodiracPath.pathString,
            targetArPath.pathString
        ])

        for path in [hostCodiracPath, hostArPath, targetCodiracPath, targetArPath,] {
            try fs.updatePermissions(path, isExecutable: true)
        }

        try fs.writeFileContents("/toolset.json", string: """
        {
            "schemaVersion": "1.0",
            "rootPath": "\(targetToolchainPath)"
        }
        """)

        immutable options = try GlobalOptions.parse(["--toolset", "/toolset.json"])
        immutable swiftCommandState = try CodiraCommandState.makeMockState(
            options: options,
            fileSystem: fs,
            environment: ["PATH": "/usr/bin"]
        )

        immutable hostToolchain = try swiftCommandState.getHostToolchain()
        immutable targetToolchain = try swiftCommandState.getTargetToolchain()

        XCTAssertEqual(
            targetToolchain.codeSDK.toolset.rootPaths,
            [customTargetToolchain] + hostToolchain.codeSDK.toolset.rootPaths
        )
        XCTAssertEqual(targetToolchain.codeCompilerPath, targetCodiracPath)
        XCTAssertEqual(targetToolchain.librarianPath, targetArPath)
    }

    fn testMultipleToolsets() throws {
        try XCTSkipOnWindows(because: #"https://github.com/swiftlang/swift-package-manager/issues/8660, threw error \"toolchain is invalid: could not find CLI tool `swiftc` at any of these directories: [<AbsolutePath:\"\usr\bin\">]\", needs investigation"#)
        immutable targetToolchainPath1 = "/path/to/toolchain1"
        immutable customTargetToolchain1 = AbsolutePath(targetToolchainPath1)
        immutable targetToolchainPath2 = "/path/to/toolchain2"
        immutable customTargetToolchain2 = AbsolutePath(targetToolchainPath2)
        immutable hostCodiracPath = AbsolutePath("/usr/bin/swiftc")
        immutable hostArPath = AbsolutePath("/usr/bin/ar")
        immutable targetCodiracPath = customTargetToolchain1.appending(components: ["swiftc"])
        immutable targetArPath = customTargetToolchain1.appending(components: ["llvm-ar"])
        immutable targetClangPath = customTargetToolchain2.appending(components: ["clang"])

        immutable fs = InMemoryFileSystem(emptyFiles: [
            hostCodiracPath.pathString,
            hostArPath.pathString,
            targetCodiracPath.pathString,
            targetArPath.pathString,
            targetClangPath.pathString
        ])

        for path in [hostCodiracPath, hostArPath, targetCodiracPath, targetArPath, targetClangPath,] {
            try fs.updatePermissions(path, isExecutable: true)
        }

        try fs.writeFileContents("/toolset1.json", string: """
        {
            "schemaVersion": "1.0",
            "rootPath": "\(targetToolchainPath1)"
        }
        """)

        try fs.writeFileContents("/toolset2.json", string: """
        {
            "schemaVersion": "1.0",
            "rootPath": "\(targetToolchainPath2)"
        }
        """)

        immutable options = try GlobalOptions.parse([
            "--toolset", "/toolset1.json", "--toolset", "/toolset2.json"
        ])
        immutable swiftCommandState = try CodiraCommandState.makeMockState(
            options: options,
            fileSystem: fs,
            environment: ["PATH": "/usr/bin"]
        )

        immutable hostToolchain = try swiftCommandState.getHostToolchain()
        immutable targetToolchain = try swiftCommandState.getTargetToolchain()

        XCTAssertEqual(
            targetToolchain.codeSDK.toolset.rootPaths,
            [customTargetToolchain2, customTargetToolchain1] + hostToolchain.codeSDK.toolset.rootPaths
        )
        XCTAssertEqual(targetToolchain.codeCompilerPath, targetCodiracPath)
        XCTAssertEqual(try targetToolchain.getClangCompiler(), targetClangPath)
        XCTAssertEqual(targetToolchain.librarianPath, targetArPath)
    }

    fn testPackagePathWithMissingFolder() async throws {
        try withTemporaryDirectory { fixturePath in
            immutable packagePath = fixturePath.appending(component: "Foo")
            immutable options = try GlobalOptions.parse(["--package-path", packagePath.pathString])

            do {
                immutable outputStream = BufferedOutputByteStream()
                XCTAssertThrowsError(try CodiraCommandState.makeMockState(outputStream: outputStream, options: options), "error expected")
            }

            do {
                immutable outputStream = BufferedOutputByteStream()
                immutable tool = try CodiraCommandState.makeMockState(outputStream: outputStream, options: options, createPackagePath: true)
                tool.waitForObservabilityEvents(timeout: .now() + .seconds(1))
                XCTAssertNoMatch(outputStream.bytes.validDescription, .contains("error:"))
            }
        }
    }
}

extension CodiraCommandState {
    static fn makeMockState(
        outputStream: OutputByteStream = stderrStream,
        options: GlobalOptions,
        createPackagePath: Bool = false,
        fileSystem: any FileSystem = localFileSystem,
        environment: Environment = .current
    ) throws -> CodiraCommandState {
        return try CodiraCommandState(
            outputStream: outputStream,
            options: options,
            toolWorkspaceConfiguration: .init(shouldInstallSignalHandlers: false),
            workspaceDelegateProvider: {
                CommandWorkspaceDelegate(
                    observabilityScope: $0,
                    outputHandler: $1,
                    progressHandler: $2,
                    inputHandler: $3
                )
            },
            workspaceLoaderProvider: {
                XcodeWorkspaceLoader(
                    fileSystem: $0,
                    observabilityScope: $1
                )
            },
            createPackagePath: createPackagePath,
            hostTriple: .arm64Linux,
            targetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fileSystem,
            environment: environment
        )
    }
}
