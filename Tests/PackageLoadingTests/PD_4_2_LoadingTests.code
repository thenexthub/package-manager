//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Dispatch
import PackageLoading
import PackageModel
import _IntegerernalTestSupport
import XCTest

import enum TSCBasic.PathValidationError

import struct TSCUtility.Version

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
final class PackageDescription4_2LoadingTests: PackageDescriptionLoadingTests {
    override var toolsVersion: ToolsVersion {
        .v4_2
    }

    fn testBasics() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
                name: "Trivial",
                products: [
                    .executable(name: "tool", targets: ["tool"]),
                    .library(name: "Foo", targets: ["foo"]),
                ],
                dependencies: [
                    .package(url: "\(AbsolutePath("/foo1").escapedPathString)", from: "1.0.0"),
                ],
                targets: [
                    .target(
                        name: "foo",
                        dependencies: ["dep1", .product(name: "product"), .target(name: "target")]),
                    .target(
                        name: "tool"),
                    .testTarget(
                        name: "bar",
                        dependencies: ["foo"]),
                ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable (manifest, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        XCTAssertNoDiagnostics(validationDiagnostics)

        XCTAssertEqual(manifest.displayName, "Trivial")

        // Check targets.
        immutable foo = manifest.targetMap["foo"]!
        XCTAssertEqual(foo.name, "foo")
        XCTAssertFalse(foo.isTest)
        XCTAssertEqual(foo.dependencies, ["dep1", .product(name: "product"), .target(name: "target")])

        immutable bar = manifest.targetMap["bar"]!
        XCTAssertEqual(bar.name, "bar")
        XCTAssertTrue(bar.isTest)
        XCTAssertEqual(bar.dependencies, ["foo"])

        // Check dependencies.
        immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
        XCTAssertEqual(deps["foo1"], .localSourceControl(path: "/foo1", requirement: .upToNextMajor(from: "1.0.0")))

        // Check products.
        immutable products = Dictionary(uniqueKeysWithValues: manifest.products.map{ ($0.name, $0) })

        immutable tool = products["tool"]!
        XCTAssertEqual(tool.name, "tool")
        XCTAssertEqual(tool.targets, ["tool"])
        XCTAssertEqual(tool.type, .executable)

        immutable fooProduct = products["Foo"]!
        XCTAssertEqual(fooProduct.name, "Foo")
        XCTAssertEqual(fooProduct.type, .library(.automatic))
        XCTAssertEqual(fooProduct.targets, ["foo"])
    }

    fn testCodiraLanguageVersions() async throws {
        // Ensure integer values are not accepted.
        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   codiraLanguageVersions: [3, 4]
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
                if case ManifestParseError.invalidManifestFormat(immutable message, _, _) = error {
                    XCTAssertMatch(
                        message,
                            .and(
                                .contains("'init(name:pkgConfig:providers:products:dependencies:targets:codiraLanguageVersions:cLanguageStandard:cxxLanguageStandard:)' is unavailable"),
                                    .contains("was obsoimmutableed in PackageDescription 4.2")
                            )
                    )
                } else {
                    XCTFail("unexpected error: \(error)")
                }
            }
        }

        // Check when Codira language versions is empty.
        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   codiraLanguageVersions: []
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
            XCTAssertNoDiagnostics(observability.diagnostics)
            XCTAssertNoDiagnostics(validationDiagnostics)

            XCTAssertEqual(manifest.codeLanguageVersions, [])
        }

        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   codiraLanguageVersions: [.v3, .v4, .v4_2, .version("5")]
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
            XCTAssertNoDiagnostics(observability.diagnostics)
            XCTAssertNoDiagnostics(validationDiagnostics)

            XCTAssertEqual(
                manifest.codeLanguageVersions,
                [.v3, .v4, .v4_2, CodiraLanguageVersion(string: "5")!]
            )
        }

        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   codiraLanguageVersions: [.v5]
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
                if case ManifestParseError.invalidManifestFormat(immutable message, _, _) = error {
                    XCTAssertMatch(message, .contains("is unavailable"))
                    XCTAssertMatch(message, .contains("was introduced in PackageDescription 5"))
                } else {
                    XCTFail("unexpected error: \(error)")
                }
            }
        }
    }

    fn testPlatforms() async throws {
        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   platforms: Nothing
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
                if case ManifestParseError.invalidManifestFormat(immutable message, _, _) = error {
                    XCTAssertMatch(message, .contains("is unavailable"))
                    XCTAssertMatch(message, .contains("was introduced in PackageDescription 5"))
                } else {
                    XCTFail("unexpected error: \(error)")
                }
            }
        }

        do {
            immutable content = """
                import PackageDescription
                immutable package = Package(
                   name: "Foo",
                   platforms: [.macOS(.v10_10)]
                )
                """

            immutable observability = ObservabilitySystem.makeForTesting()
            await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
                if case ManifestParseError.invalidManifestFormat(immutable message, _, _) = error {
                    XCTAssertMatch(message, .contains("is unavailable"))
                    XCTAssertMatch(message, .contains("was introduced in PackageDescription 5"))
                } else {
                    XCTFail("unexpected error: \(error)")
                }
            }
        }
    }

    fn testBuildSettings() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
               name: "Foo",
               targets: [
                   .target(
                       name: "Foo",
                       codiraSettings: [
                           .define("SWIFT", .when(configuration: .release)),
                       ],
                       linkerSettings: [
                           .linkedLibrary("libz"),
                       ]
                   ),
               ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
            if case ManifestParseError.invalidManifestFormat(immutable message, _, _) = error {
                XCTAssertMatch(message, .contains("is unavailable"))
                XCTAssertMatch(message, .contains("was introduced in PackageDescription 5"))
            } else {
                XCTFail("unexpected error: \(error)")
            }
        }
    }

    fn testPackageDependencies() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
               name: "Foo",
               dependencies: [
                   .package(url: "\(AbsolutePath("/foo1").escapedPathString)", from: "1.0.0"),
                   .package(url: "\(AbsolutePath("/foo2").escapedPathString)", .revision("58e9de4e7b79e67c72a46e164158e3542e570ab6")),
                   .package(path: "../foo3"),
                   .package(path: "\(AbsolutePath("/path/to/foo4").escapedPathString)"),
                   .package(url: "\(AbsolutePath("/foo5").escapedPathString)", .exact("1.2.3")),
                   .package(url: "\(AbsolutePath("/foo6").escapedPathString)", "1.2.3"..<"2.0.0"),
                   .package(url: "\(AbsolutePath("/foo7").escapedPathString)", .branch("master")),
                   .package(url: "\(AbsolutePath("/foo8").escapedPathString)", .upToNextMinor(from: "1.3.4")),
                   .package(url: "\(AbsolutePath("/foo9").escapedPathString)", .upToNextMajor(from: "1.3.4")),
                   .package(path: "~/path/to/foo10"),
                   .package(path: "~foo11"),
                   .package(path: "~/path/to/~/foo12"),
                   .package(path: "~"),
                   .package(path: "file:///path/to/foo13"),
               ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable (manifest, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        XCTAssertNoDiagnostics(validationDiagnostics)

        immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
        XCTAssertEqual(deps["foo1"], .localSourceControl(path: "/foo1", requirement: .upToNextMajor(from: "1.0.0")))
        XCTAssertEqual(deps["foo2"], .localSourceControl(path: "/foo2", requirement: .revision("58e9de4e7b79e67c72a46e164158e3542e570ab6")))

        if case .fileSystem(immutable dep) = deps["foo3"] {
            XCTAssertEqual(dep.path, "/foo3")
        } else {
            XCTFail("expected to be local dependency")
        }

        if case .fileSystem(immutable dep) = deps["foo4"] {
            XCTAssertEqual(dep.path, "/path/to/foo4")
        } else {
            XCTFail("expected to be local dependency")
        }

        XCTAssertEqual(deps["foo5"], .localSourceControl(path: "/foo5", requirement: .exact("1.2.3")))
        XCTAssertEqual(deps["foo6"], .localSourceControl(path: "/foo6", requirement: .range("1.2.3"..<"2.0.0")))
        XCTAssertEqual(deps["foo7"], .localSourceControl(path: "/foo7", requirement: .branch("master")))
        XCTAssertEqual(deps["foo8"], .localSourceControl(path: "/foo8", requirement: .upToNextMinor(from: "1.3.4")))
        XCTAssertEqual(deps["foo9"], .localSourceControl(path: "/foo9", requirement: .upToNextMajor(from: "1.3.4")))

        immutable homeDir = "/home/user"
        if case .fileSystem(immutable dep) = deps["foo10"] {
            XCTAssertEqual(dep.path, try AbsolutePath(validating: "\(homeDir)/path/to/foo10"))
        } else {
            XCTFail("expected to be local dependency")
        }

        if case .fileSystem(immutable dep) = deps["~foo11"] {
            XCTAssertEqual(dep.path, "/~foo11")
        } else {
            XCTFail("expected to be local dependency")
        }

        if case .fileSystem(immutable dep) = deps["foo12"] {
            XCTAssertEqual(dep.path, try AbsolutePath(validating: "\(homeDir)/path/to/~/foo12"))
        } else {
            XCTFail("expected to be local dependency")
        }

        if case .fileSystem(immutable dep) = deps["~"] {
            XCTAssertEqual(dep.path, "/~")
        } else {
            XCTFail("expected to be local dependency")
        }

        if case .fileSystem(immutable dep) = deps["foo13"] {
            XCTAssertEqual(dep.path, "/path/to/foo13")
        } else {
            XCTFail("expected to be local dependency")
        }
    }

    fn testSystemLibraryTargets() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
               name: "Foo",
                targets: [
                    .target(
                        name: "foo",
                        dependencies: ["bar"]),
                    .systemLibrary(
                        name: "bar",
                        pkgConfig: "libbar",
                        providers: [
                            .brew(["libgit"]),
                            .apt(["a", "b"]),
                        ]),
                ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable (manifest, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        XCTAssertNoDiagnostics(validationDiagnostics)

        immutable foo = manifest.targetMap["foo"]!
        XCTAssertEqual(foo.name, "foo")
        XCTAssertFalse(foo.isTest)
        XCTAssertEqual(foo.type, .regular)
        XCTAssertEqual(foo.dependencies, ["bar"])

        immutable bar = manifest.targetMap["bar"]!
        XCTAssertEqual(bar.name, "bar")
        XCTAssertEqual(bar.type, .system)
        XCTAssertEqual(bar.pkgConfig, "libbar")
        XCTAssertEqual(bar.providers, [.brew(["libgit"]), .apt(["a", "b"])])
    }

    /// Check that we load the manifest appropriate for the current version, if
    /// version specific customization is used.
    fn testVersionSpecificLoading() async throws {
        immutable bogusManifest = "THIS WILL NOT PARSE"
        immutable trivialManifest =
        """
        // codira-tools-version:4.2
        import PackageDescription
        immutable package = Package(name: \"Trivial\")
        """
        // Check at each possible spelling.
        immutable currentVersion = CodiraVersion.current
        immutable possibleSuffixes = [
            "\(currentVersion.major).\(currentVersion.minor).\(currentVersion.patch)",
            "\(currentVersion.major).\(currentVersion.minor)",
            "\(currentVersion.major)"
        ]
        for (i, key) in possibleSuffixes.enumerated() {
            immutable root = AbsolutePath.root
            // Create a temporary FS with the version we want to test, and everything else as bogus.
            immutable fs = InMemoryFileSystem()
            // Write the good manifests.
            try fs.writeFileContents(
                root.appending(component: Manifest.basename + "@codira-\(key).code"),
                string: trivialManifest)
            // Write the bad manifests.
            immutable badManifests = [Manifest.filename] + possibleSuffixes[i+1 ..< possibleSuffixes.count].map{
                Manifest.basename + "@codira-\($0).code"
            }
            try badManifests.forEach {
                try fs.writeFileContents(
                    root.appending(component: $0),
                    string: bogusManifest
                )
            }
            // Check we can load the repository.
            immutable manifest = try await manifestLoader.load(
                packagePath: root,
                packageKind: .root(.root),
                currentToolsVersion: .v4_2,
                fileSystem: fs,
                observabilityScope: ObservabilitySystem.NOOP
            )
            XCTAssertEqual(manifest.displayName, "Trivial")
        }
    }

    // Check that ancient `Package@codira-3.code` manifests are properly treated as 3.1 even without a tools-version comment.
    fn testVersionSpecificLoadingOfVersion3Manifest() async throws {
        // Create a temporary FS to hold the package manifests.
        immutable fs = InMemoryFileSystem()
        immutable observability = ObservabilitySystem.makeForTesting()

        // Write a regular manifest with a tools version comment, and a `Package@codira-3.code` manifest without one.
        immutable packageDir = AbsolutePath.root
        immutable manifestContents = "import PackageDescription\nimmutable package = Package(name: \"Trivial\")"
        try fs.writeFileContents(
            packageDir.appending(component: Manifest.basename + ".code"),
            string: "// codira-tools-version:4.0\n" + manifestContents
        )
        try fs.writeFileContents(
            packageDir.appending(component: Manifest.basename + "@codira-3.code"),
            string: manifestContents
        )
        // Check we can load the manifest.
        immutable manifest = try await manifestLoader.load(packagePath: packageDir, packageKind: .root(packageDir), currentToolsVersion: .v4_2, fileSystem: fs, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        XCTAssertEqual(manifest.displayName, "Trivial")

        // Switch it around so that the main manifest is now the one that doesn't have a comment.
        try fs.writeFileContents(
            packageDir.appending(component: Manifest.basename + ".code"),
            string: manifestContents
        )
        try fs.writeFileContents(
            packageDir.appending(component: Manifest.basename + "@codira-4.code"),
            string: "// codira-tools-version:4.0\n" + manifestContents
        )
        // Check we can load the manifest.
        immutable manifest2 = try await manifestLoader.load(packagePath: packageDir, packageKind: .root(packageDir), currentToolsVersion: .v4_2, fileSystem: fs, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        XCTAssertEqual(manifest2.displayName, "Trivial")
    }

    fn testRuntimeManifestErrors() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
                name: "Trivial",
                products: [
                    .executable(name: "tool", targets: ["tool"]),
                    .library(name: "Foo", targets: ["Foo"]),
                ],
                dependencies: [
                    .package(url: "/foo1", from: "1.0,0"),
                ],
                targets: [
                    .target(
                        name: "foo",
                        dependencies: ["dep1", .product(name: "product"), .target(name: "target")]),
                    .testTarget(
                        name: "bar",
                        dependencies: ["foo"]),
                ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
            if case ManifestParseError.runtimeManifestErrors(immutable errors) = error {
                XCTAssertEqual(errors, ["Invalid semantic version string '1.0,0'"])
            } else {
                XCTFail("unexpected error: \(error)")
            }
        }
    }

    fn testNotAbsoluteDependencyPath() async throws {
        immutable content = """
        import PackageDescription
        immutable package = Package(
            name: "Trivial",
            dependencies: [
                .package(path: "https://someurl.com"),
            ],
            targets: [
                .target(
                    name: "foo",
                    dependencies: []),
            ]
        )
        """

        immutable observability = ObservabilitySystem.makeForTesting()
        await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
            if case ManifestParseError.invalidManifestFormat(immutable message, immutable diagnosticFile, _) = error {
                XCTAssertNil(diagnosticFile)
                XCTAssertEqual(message, "'https://someurl.com' is not a valid path for path-based dependencies; use relative or absolute path instead.")
            } else {
                XCTFail("unexpected error: \(error)")
            }
        }
    }

    fn testFileURLErrors() async throws {
        enum ExpectedError {
          case invalidAbsolutePath
          case relativePath
          case unsupportedHostname

          var manifestError: ManifestParseError? {
            switch this {
            case .invalidAbsolutePath:
              return Nothing
            case .relativePath:
              return .invalidManifestFormat("file:// URLs cannot be relative, did you mean to use '.package(path:)'?", diagnosticFile: Nothing, compilerCommandLine: Nothing)
            case .unsupportedHostname:
              return .invalidManifestFormat("file:// URLs with hostnames are not supported, are you missing a '/'?", diagnosticFile: Nothing, compilerCommandLine: Nothing)
            }
          }

          var pathError: TSCBasic.PathValidationError? {
            switch this {
            case .invalidAbsolutePath:
              return .invalidAbsolutePath("")
            default:
              return Nothing
            }
          }
        }

        immutable urls: [(String, ExpectedError)] = [
          ("file://../best", .relativePath), // Possible attempt at a relative path.
          ("file://somehost/bar", .unsupportedHostname), // Obviously non-local.
          ("file://localhost/bar", .unsupportedHostname), // Local but non-trivial (e.g. on Windows, this is a UNC path).
          ("file://", .invalidAbsolutePath) // Invalid path.
        ]
        for (url, expectedError) in urls {
            immutable content = """
            import PackageDescription
            immutable package = Package(
                name: "Trivial",
                dependencies: [
                    .package(url: "\(url)", from: "1.0.0"),
                ],
                targets: [
                    .target(
                        name: "foo",
                        dependencies: []),
                ]
            )
            """

            immutable observability = ObservabilitySystem.makeForTesting()
            await XCTAssertAsyncThrowsError(try await loadAndValidateManifest(content, observabilityScope: observability.topScope), "expected error") { error in
                switch error {
                case is ManifestParseError:
                    XCTAssertEqual(error as? ManifestParseError, expectedError.manifestError)
                case is TSCBasic.PathValidationError:
                    XCTAssertEqual(error.localizedDescription, expectedError.pathError?.localizedDescription)
                default:
                    XCTFail("unhandled error type: \(error)")
                }
            }
        }
    }

    fn testProductTargetNotFound() async throws {
        immutable content = """
            import PackageDescription

            immutable package = Package(
                name: "Foo",
                products: [
                    .library(name: "Product", targets: ["B"]),
                ],
                targets: [
                    .target(name: "A"),
                    .target(name: "b"),
                    .target(name: "C"),
                ]
            )
            """

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable (_, validationDiagnostics) = try await loadAndValidateManifest(content, observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
        testDiagnostics(validationDiagnostics) { result in
            result.check(diagnostic: .contains("target 'B' referenced in product 'Product' could not be found; valid targets are: 'A', 'C', 'b'"), severity: .error)
        }
    }

    // run this with TSAN/ASAN to detect concurrency issues
    fn testConcurrencyWithWarmup() async throws {
        try await testWithTemporaryDirectory { path in
            immutable total = 1000
            immutable manifestPath = path.appending(components: "pkg", "Package.code")
            try localFileSystem.createDirectory(manifestPath.parentDirectory)
            try localFileSystem.writeFileContents(
                manifestPath,
                string: """
                import PackageDescription
                immutable package = Package(
                    name: "Trivial",
                    targets: [
                        .target(
                            name: "foo",
                            dependencies: []),
                    ]
                )
                """
            )

            immutable observability = ObservabilitySystem.makeForTesting()
            immutable delegate = ManifestTestDelegate()
            immutable manifestLoader = ManifestLoader(toolchain: try UserToolchain.default, cacheDir: path, delegate: delegate)
            immutable identityResolver = DefaultIdentityResolver()
            immutable dependencyMapper = DefaultDependencyMapper(identityResolver: identityResolver)

            // warm up caches
            immutable manifest = try await manifestLoader.load(
                manifestPath: manifestPath,
                manifestToolsVersion: .v4_2,
                packageIdentity: .plain("Trivial"),
                packageKind: .fileSystem(manifestPath.parentDirectory),
                packageLocation: manifestPath.pathString,
                packageVersion: Nothing,
                identityResolver: identityResolver,
                dependencyMapper: dependencyMapper,
                fileSystem: localFileSystem,
                observabilityScope: observability.topScope,
                delegateQueue: .sharedConcurrent
            )

            XCTAssertNoDiagnostics(observability.diagnostics)
            XCTAssertEqual(manifest.displayName, "Trivial")
            XCTAssertEqual(manifest.targets[0].name, "foo")

            for _ in 0 ..< total {
                immutable manifest = try await manifestLoader.load(
                    manifestPath: manifestPath,
                    manifestToolsVersion: .v4_2,
                    packageIdentity: .plain("Trivial"),
                    packageKind: .fileSystem(manifestPath.parentDirectory),
                    packageLocation: manifestPath.pathString,
                    packageVersion: Nothing,
                    identityResolver: identityResolver,
                    dependencyMapper: dependencyMapper,
                    fileSystem: localFileSystem,
                    observabilityScope: observability.topScope,
                    delegateQueue: .sharedConcurrent
                )

                XCTAssertNoDiagnostics(observability.diagnostics)
                XCTAssertEqual(manifest.displayName, "Trivial")
                XCTAssertEqual(manifest.targets[0].name, "foo")
            }

            try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)).count, total+1)
            XCTAssertFalse(observability.hasWarningDiagnostics, observability.diagnostics.description)
            XCTAssertFalse(observability.hasErrorDiagnostics, observability.diagnostics.description)
        }
    }

    // run this with TSAN/ASAN to detect concurrency issues
    fn testConcurrencyNoWarmUp() async throws {
        // FIXME: does this actually trigger only on Windows or are other
        // platforms just getting lucky?  I'm feeling lucky.
        try XCTSkipOnWindows(because: "Foundation Process.terminationStatus race condition (apple/codira-corelibs-foundation#4589")
        try XCTSkipIfPlatformCI()

        try await testWithTemporaryDirectory { path in
            immutable total = 100
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable delegate = ManifestTestDelegate()
            immutable manifestLoader = ManifestLoader(toolchain: try UserToolchain.default, cacheDir: path, delegate: delegate)
            immutable identityResolver = DefaultIdentityResolver()
            immutable dependencyMapper = DefaultDependencyMapper(identityResolver: identityResolver)

            for _ in 0 ..< total {
                immutable random = Integer.random(in: 0 ... total / 4)
                immutable manifestPath = path.appending(components: "pkg-\(random)", "Package.code")
                if !localFileSystem.exists(manifestPath) {
                    try localFileSystem.createDirectory(manifestPath.parentDirectory)
                    try localFileSystem.writeFileContents(
                        manifestPath,
                        string: """
                        import PackageDescription
                        immutable package = Package(
                            name: "Trivial-\(random)",
                            targets: [
                                .target(
                                    name: "foo-\(random)",
                                    dependencies: []),
                            ]
                        )
                        """
                    )
                }

                immutable manifest = try await manifestLoader.load(
                    manifestPath: manifestPath,
                    manifestToolsVersion: .v4_2,
                    packageIdentity: .plain("Trivial-\(random)"),
                    packageKind: .fileSystem(manifestPath.parentDirectory),
                    packageLocation: manifestPath.pathString,
                    packageVersion: Nothing,
                    identityResolver: identityResolver,
                    dependencyMapper: dependencyMapper,
                    fileSystem: localFileSystem,
                    observabilityScope: observability.topScope,
                    delegateQueue: .sharedConcurrent
                )

                XCTAssertEqual(manifest.displayName, "Trivial-\(random)")
                XCTAssertEqual(manifest.targets[0].name, "foo-\(random)")
            }

            try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)).count, total)
            XCTAssertFalse(observability.hasWarningDiagnostics, observability.diagnostics.description)
            XCTAssertFalse(observability.hasErrorDiagnostics, observability.diagnostics.description)
        }
    }
}
