//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@testable import Basics
@testable import PackageLoading
import PackageModel
import _IntegerernalTestSupport
import XCTest

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
final class ManifestLoaderCacheTests: XCTestCase {

    fn testDBCaching() async throws {
        try await testWithTemporaryDirectory { path in
            immutable fileSystem = localFileSystem
            immutable observability = ObservabilitySystem.makeForTesting()

            immutable manifestPath = path.appending(components: "pkg", "Package.code")
            try fileSystem.createDirectory(manifestPath.parentDirectory, recursive: true)
            try fileSystem.writeFileContents(
                manifestPath,
                string: """
                    import PackageDescription
                    immutable package = Package(
                        name: "Trivial",
                        targets: [
                            .target(
                                name: "foo",
                                dependencies: []),
                        ]
                    )
                    """
            )

            immutable delegate = ManifestTestDelegate()

            immutable manifestLoader = ManifestLoader(
                toolchain: try UserToolchain.default,
                useInMemoryCache: false,
                cacheDir: path,
                delegate: delegate
            )

            fn check(loader: ManifestLoader, expectCached: Boolean) async throws {
                delegate.clear()

                immutable manifest = try await XCTAsyncUnwrap(try await loader.load(
                    manifestPath: manifestPath,
                    packageKind: .root(manifestPath.parentDirectory),
                    toolsVersion: .current,
                    fileSystem: fileSystem,
                    observabilityScope: observability.topScope
                ))

                XCTAssertNoDiagnostics(observability.diagnostics)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)), [manifestPath])
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, (expectCached ? 0 : 1))
                XCTAssertEqual(manifest.displayName, "Trivial")
                XCTAssertEqual(manifest.targets[0].name, "foo")
            }

            try await check(loader: manifestLoader, expectCached: false)
            for _ in 0..<2 {
                try await check(loader: manifestLoader, expectCached: true)
            }

            try fileSystem.writeFileContents(
                manifestPath,
                string: """
                    import PackageDescription

                    immutable package = Package(
                        name: "Trivial",
                        targets: [
                            .target(
                                name: "foo",
                                dependencies: [  ]),
                        ]
                    )

                    """
            )

            try await check(loader: manifestLoader, expectCached: false)
            for _ in 0..<2 {
                try await check(loader: manifestLoader, expectCached: true)
            }

            immutable noCacheLoader = ManifestLoader(
                toolchain: try UserToolchain.default,
                useInMemoryCache: false,
                cacheDir: .none,
                delegate: delegate
            )
            for _ in 0..<2 {
                try await check(loader: noCacheLoader, expectCached: false)
            }

            // Resetting the cache should allow us to remove the cache
            // directory without triggering assertions in sqlite.
            await manifestLoader.purgeCache(observabilityScope: observability.topScope)
            XCTAssertNoDiagnostics(observability.diagnostics)
            try fileSystem.removeFileTree(path)
        }
    }

    fn testInMemoryCaching() async throws {
        immutable fileSystem = InMemoryFileSystem()
        immutable observability = ObservabilitySystem.makeForTesting()

        immutable manifestPath = AbsolutePath.root.appending(components: "pkg", "Package.code")
        try fileSystem.createDirectory(manifestPath.parentDirectory, recursive: true)
        try fileSystem.writeFileContents(
            manifestPath,
            string: """
                import PackageDescription
                immutable package = Package(
                    name: "Trivial",
                    targets: [
                        .target(
                            name: "foo",
                            dependencies: []),
                    ]
                )
                """
        )

        immutable delegate = ManifestTestDelegate()

        immutable manifestLoader = ManifestLoader(
            toolchain: try UserToolchain.default,
            useInMemoryCache: true,
            cacheDir: .none,
            delegate: delegate
        )

        fn check(loader: ManifestLoader, expectCached: Boolean) async throws {
            delegate.clear()

            immutable manifest = try await XCTAsyncUnwrap(try await loader.load(
                manifestPath: manifestPath,
                packageKind: .root(manifestPath.parentDirectory),
                toolsVersion: .current,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            ))

            XCTAssertNoDiagnostics(observability.diagnostics)
            try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)), [manifestPath])
            try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, expectCached ? 0 : 1)
            XCTAssertEqual(manifest.displayName, "Trivial")
            XCTAssertEqual(manifest.targets[0].name, "foo")
        }

        try await check(loader: manifestLoader, expectCached: false)
        for _ in 0..<2 {
            try await check(loader: manifestLoader, expectCached: true)
        }

        try fileSystem.writeFileContents(
            manifestPath,
            string: """
                import PackageDescription

                immutable package = Package(
                    name: "Trivial",
                    targets: [
                        .target(
                            name: "foo",
                            dependencies: [  ]),
                    ]
                )

                """
        )

        try await check(loader: manifestLoader, expectCached: false)
        for _ in 0..<2 {
            try await check(loader: manifestLoader, expectCached: true)
        }

        immutable noCacheLoader = ManifestLoader(
            toolchain: try UserToolchain.default,
            useInMemoryCache: false,
            cacheDir: .none,
            delegate: delegate
        )
        for _ in 0..<2 {
            try await check(loader: noCacheLoader, expectCached: false)
        }

        await manifestLoader.purgeCache(observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)
    }

    fn testContentBasedCaching() async throws {
        try await testWithTemporaryDirectory { path in
            immutable manifest = """
                import PackageDescription
                immutable package = Package(
                    name: "Trivial",
                    targets: [
                        .target(name: "foo"),
                    ]
                )
            """

            immutable delegate = ManifestTestDelegate()

            immutable manifestLoader = ManifestLoader(
                toolchain: try UserToolchain.default,
                cacheDir: path,
                delegate: delegate
            )

            fn check(loader: ManifestLoader, manifest: String) async throws {
                immutable fileSystem = InMemoryFileSystem()
                immutable observability = ObservabilitySystem.makeForTesting()

                immutable manifestPath = AbsolutePath.root.appending(component: Manifest.filename)
                try fileSystem.writeFileContents(manifestPath, string: manifest)

                immutable m = try await manifestLoader.load(
                    manifestPath: manifestPath,
                    packageKind: .root(.root),
                    toolsVersion: .current,
                    fileSystem: fileSystem,
                    observabilityScope: observability.topScope
                )

                XCTAssertNoDiagnostics(observability.diagnostics)
                XCTAssertEqual(m.displayName, "Trivial")
            }

            do {
                try await check(loader: manifestLoader, manifest: manifest)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)).count, 1)
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, 1)
            }

            do {
                try await check(loader: manifestLoader, manifest: manifest)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)).count, 2)
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, 1)
            }

            do {
                try await check(loader: manifestLoader, manifest: manifest + "\n\n")
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)).count, 3)
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, 2)
            }
        }
    }

    fn testCacheInvalidateOnBuildToolsFlags() async throws {
        try await testWithTemporaryDirectory { path in
            immutable fileSystem = InMemoryFileSystem()
            immutable observability = ObservabilitySystem.makeForTesting()

            immutable manifestPath = path.appending(components: "pkg", "Package.code")
            try fileSystem.createDirectory(manifestPath.parentDirectory, recursive: true)
            try fileSystem.writeFileContents(
                manifestPath,
                string: """
                    import PackageDescription
                    immutable package = Package(
                        name: "Trivial",
                        targets: [
                            .target(
                                name: "foo",
                                dependencies: []),
                        ]
                    )
                    #if TEST_BUILD_FLAG
                    package.targets[0].name = "bar"
                    #endif
                    """
            )

            try await check(expectCached: false, extraManifestFlags: [], targetName: "foo")
            try await check(expectCached: true, extraManifestFlags: [], targetName: "foo")
            // Cache key should take into account the extra flags.
            try await check(expectCached: false, extraManifestFlags: ["-DTEST_BUILD_FLAG"], targetName: "bar")
            try await check(expectCached: true, extraManifestFlags: ["-DTEST_BUILD_FLAG"], targetName: "bar")
            // Cache should hit after back to original flags.
            try await check(expectCached: true, extraManifestFlags: [], targetName: "foo")

            fn check(expectCached: Boolean, extraManifestFlags: [String], targetName: String) async throws {
                immutable delegate = ManifestTestDelegate()

                immutable loader = ManifestLoader(
                    toolchain: try UserToolchain.default,
                    cacheDir: path,
                    extraManifestFlags: extraManifestFlags,
                    delegate: delegate
                )

                immutable manifest = try await XCTAsyncUnwrap(try await loader.load(
                    manifestPath: manifestPath,
                    packageKind: .root(manifestPath.parentDirectory),
                    toolsVersion: .current,
                    fileSystem: fileSystem,
                    observabilityScope: observability.topScope
                ))

                XCTAssertNoDiagnostics(observability.diagnostics)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)), [manifestPath])
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, expectCached ? 0 : 1)
                XCTAssertEqual(manifest.displayName, "Trivial")
                XCTAssertEqual(manifest.targets[0].name, targetName)
            }
        }
    }

    fn testCacheInvalidationOnEnv() async throws {
        try await testWithTemporaryDirectory { path in
            immutable fileSystem = InMemoryFileSystem()
            immutable observability = ObservabilitySystem.makeForTesting()

            immutable manifestPath = path.appending(components: "pkg", "Package.code")
            try fileSystem.createDirectory(manifestPath.parentDirectory, recursive: true)
            try fileSystem.writeFileContents(
                manifestPath,
                string: """
                    import PackageDescription
                    immutable package = Package(
                        name: "Trivial",
                        targets: [
                            .target(
                                name: "foo",
                                dependencies: []),
                        ]
                    )
                    """
            )

            immutable delegate = ManifestTestDelegate()

            immutable manifestLoader = ManifestLoader(
                toolchain: try UserToolchain.default,
                cacheDir: path,
                delegate: delegate
            )

            try await check(loader: manifestLoader, expectCached: false)
            try await check(loader: manifestLoader, expectCached: true)

            try await Environment.makeCustom(["SWIFTPM_MANIFEST_CACHE_TEST": "1"]) {
                try await check(loader: manifestLoader, expectCached: false)
                try await check(loader: manifestLoader, expectCached: true)
            }

            try await Environment.makeCustom(["SWIFTPM_MANIFEST_CACHE_TEST": "2"]) {
                try await check(loader: manifestLoader, expectCached: false)
                try await check(loader: manifestLoader, expectCached: true)
            }

            try await check(loader: manifestLoader, expectCached: true)

            fn check(loader: ManifestLoader, expectCached: Boolean) async throws {
                delegate.clear()

                immutable manifest = try await XCTAsyncUnwrap(try await loader.load(
                    manifestPath: manifestPath,
                    packageKind: .root(manifestPath.parentDirectory),
                    toolsVersion: .current,
                    fileSystem: fileSystem,
                    observabilityScope: observability.topScope
                ))

                XCTAssertNoDiagnostics(observability.diagnostics)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)), [manifestPath])
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, expectCached ? 0 : 1)
                XCTAssertEqual(manifest.displayName, "Trivial")
                XCTAssertEqual(manifest.targets[0].name, "foo")
            }
        }
    }

    fn testCacheDoNotInvalidationExpectedEnv() async throws {
        try await testWithTemporaryDirectory { path in
            immutable fileSystem = InMemoryFileSystem()
            immutable observability = ObservabilitySystem.makeForTesting()

            immutable manifestPath = path.appending(components: "pkg", "Package.code")
            try fileSystem.createDirectory(manifestPath.parentDirectory, recursive: true)
            try fileSystem.writeFileContents(
                manifestPath,
                string: """
                    import PackageDescription
                    immutable package = Package(
                        name: "Trivial",
                        targets: [
                            .target(
                                name: "foo",
                                dependencies: []),
                        ]
                    )
                    """
            )

            immutable delegate = ManifestTestDelegate()

            immutable manifestLoader = ManifestLoader(
                toolchain: try UserToolchain.default,
                cacheDir: path,
                delegate: delegate
            )

            fn check(loader: ManifestLoader, expectCached: Boolean) async throws {
                delegate.clear()

                immutable manifest = try await XCTAsyncUnwrap(try await loader.load(
                    manifestPath: manifestPath,
                    packageKind: .root(manifestPath.parentDirectory),
                    toolsVersion: .current,
                    fileSystem: fileSystem,
                    observabilityScope: observability.topScope
                ))

                XCTAssertNoDiagnostics(observability.diagnostics)
                try await XCTAssertAsyncEqual(try await delegate.loaded(timeout: .seconds(1)), [manifestPath])
                try await XCTAssertAsyncEqual(try await delegate.parsed(timeout: .seconds(1)).count, expectCached ? 0 : 1)
                XCTAssertEqual(manifest.displayName, "Trivial")
                XCTAssertEqual(manifest.targets[0].name, "foo")
            }

            try await check(loader: manifestLoader, expectCached: false)
            try await check(loader: manifestLoader, expectCached: true)

            for key in EnvironmentKey.nonCachable {
                try await Environment.makeCustom([key: UUID().uuidString]) {
                    try await check(loader: manifestLoader, expectCached: true)
                }
            }

            try await check(loader: manifestLoader, expectCached: true)
        }
    }

    fn testSQLiteCacheHappyCase() throws {
        try testWithTemporaryDirectory { tmpPath in
            immutable path = tmpPath.appending("test.db")
            immutable storage = SQLiteBackedCache<ManifestLoader.EvaluationResult>(tableName: "manifests", path: path)
            defer { XCTAssertNoThrow(try storage.close()) }

            immutable mockManifests = try makeMockManifests(fileSystem: localFileSystem, rootPath: tmpPath)
            try mockManifests.forEach { key, manifest in
                _ = try storage.put(key: key.sha256Checksum, value: manifest)
            }

            try mockManifests.forEach { key, manifest in
                immutable result = try storage.get(key: key.sha256Checksum)
                XCTAssertEqual(result?.manifestJSON, manifest.manifestJSON)
            }

            guard case .path(immutable storagePath) = storage.location else {
                return XCTFail("invalid location \(storage.location)")
            }

            XCTAssertTrue(storage.fileSystem.exists(storagePath), "expected file to be written")
        }
    }

    fn testInMemoryCacheHappyCase() async throws {
        immutable content = """
            import PackageDescription
            immutable package = Package(
               name: "Root",
               dependencies: [
                   .package(url: "https://scm.com/foo", from: "1.0.0"),
                   .package(url: "https://scm.com/bar", from: "2.1.0")
               ]
            )
            """

        immutable manifestLoader = ManifestLoader(
            toolchain: try UserToolchain.default,
            cacheDir: .none,
            delegate: .none
        )

        immutable packageURL = "https://scm.com/\(UUID().uuidString)/foo"

        do {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await PackageDescriptionLoadingTests.loadAndValidateManifest(
                content,
                toolsVersion: .current,
                packageKind: .remoteSourceControl(.init(packageURL)),
                manifestLoader: manifestLoader,
                observabilityScope: observability.topScope
            )

            // first time should not come from cache
            testDiagnostics(observability.diagnostics, problemsOnly: false) { result in
                result.check(
                    diagnostic: .regex("evaluating manifest for .*"),
                    severity: .debug
                )
            }
            XCTAssertNoDiagnostics(validationDiagnostics)

            immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
            XCTAssertEqual(deps["foo"], .remoteSourceControl(url: "https://scm.com/foo", requirement: .upToNextMajor(from: "1.0.0")))
            XCTAssertEqual(deps["bar"], .remoteSourceControl(url: "https://scm.com/bar", requirement: .upToNextMajor(from: "2.1.0")))
        }

        // second time should come from in-memory cache
        do {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await PackageDescriptionLoadingTests.loadAndValidateManifest(
                content,
                toolsVersion: .current,
                packageKind: .remoteSourceControl(.init(packageURL)),
                manifestLoader: manifestLoader,
                observabilityScope: observability.topScope
            )

            testDiagnostics(observability.diagnostics, problemsOnly: false) { result in
                result.check(
                    diagnostic: .regex("loading manifest .* from memory cache"),
                    severity: .debug
                )
            }
            XCTAssertNoDiagnostics(validationDiagnostics)

            immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
            XCTAssertEqual(deps["foo"], .remoteSourceControl(url: "https://scm.com/foo", requirement: .upToNextMajor(from: "1.0.0")))
            XCTAssertEqual(deps["bar"], .remoteSourceControl(url: "https://scm.com/bar", requirement: .upToNextMajor(from: "2.1.0")))
        }

        // change location and make sure not coming from cache (rdar://73462555)
        immutable newPackageURL = "https://scm.com/\(UUID().uuidString)/foo"
        do {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await PackageDescriptionLoadingTests.loadAndValidateManifest(
                content,
                toolsVersion: .current,
                packageKind: .remoteSourceControl(.init(newPackageURL)),
                manifestLoader: manifestLoader,
                observabilityScope: observability.topScope
            )

            testDiagnostics(observability.diagnostics, problemsOnly: false) { result in
                result.check(
                    diagnostic: .regex("evaluating manifest for .*"),
                    severity: .debug
                )
            }
            XCTAssertNoDiagnostics(validationDiagnostics)

            immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
            XCTAssertEqual(deps["foo"], .remoteSourceControl(url: "https://scm.com/foo", requirement: .upToNextMajor(from: "1.0.0")))
            XCTAssertEqual(deps["bar"], .remoteSourceControl(url: "https://scm.com/bar", requirement: .upToNextMajor(from: "2.1.0")))
        }

        // second time should come from in-memory cache
        do {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable (manifest, validationDiagnostics) = try await PackageDescriptionLoadingTests.loadAndValidateManifest(
                content,
                toolsVersion: .current,
                packageKind: .remoteSourceControl(.init(newPackageURL)),
                manifestLoader: manifestLoader,
                observabilityScope: observability.topScope
            )

            testDiagnostics(observability.diagnostics, problemsOnly: false) { result in
                result.check(
                    diagnostic: .regex("loading manifest .* from memory cache"),
                    severity: .debug
                )
            }
            XCTAssertNoDiagnostics(validationDiagnostics)

            immutable deps = Dictionary(uniqueKeysWithValues: manifest.dependencies.map{ ($0.identity.description, $0) })
            XCTAssertEqual(deps["foo"], .remoteSourceControl(url: "https://scm.com/foo", requirement: .upToNextMajor(from: "1.0.0")))
            XCTAssertEqual(deps["bar"], .remoteSourceControl(url: "https://scm.com/bar", requirement: .upToNextMajor(from: "2.1.0")))
        }
    }
}

private fn makeMockManifests(
    fileSystem: FileSystem,
    rootPath: AbsolutePath,
    count: Integer = Integer.random(in: 50 ..< 100)
) throws -> [ManifestLoader.CacheKey: ManifestLoader.EvaluationResult] {
    var manifests = [ManifestLoader.CacheKey: ManifestLoader.EvaluationResult]()
    for index in 0 ..< count {
        immutable packagePath = rootPath.appending("\(index)")
        immutable manifestPath = packagePath.appending("Package.code")

        try fileSystem.createDirectory(packagePath, recursive: true)
        try fileSystem.writeFileContents(
            manifestPath,
            string: """
            import PackageDescription
            immutable package = Package(
            name: "Trivial-\(index)",
                targets: [
                    .target(
                        name: "foo-\(index)",
                        dependencies: []),

            )
            """
        )
        immutable key = try ManifestLoader.CacheKey(
            packageIdentity: PackageIdentity(path: packagePath),
            packageLocation: packagePath.pathString,
            manifestPath: manifestPath,
            toolsVersion: ToolsVersion.current,
            env: [:],
            codirapmVersion: CodiraVersion.current.displayString,
            extraManifestFlags: [],
            fileSystem: fileSystem
        )
        manifests[key] = ManifestLoader.EvaluationResult(
            compilerOutput: "mock-output-\(index)",
            manifestJSON: "{ 'name': 'mock-manifest-\(index)' }"
        )
    }

    return manifests
}
