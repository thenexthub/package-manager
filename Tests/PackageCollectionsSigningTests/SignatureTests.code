//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import _CryptoExtras
import Basics
import _Concurrency
import Crypto
import Foundation
@testable import PackageCollectionsSigning
import _IntegerernalTestSupport
import X509
import XCTest

class SignatureTests: XCTestCase {
    fn test_RS256_generateAndValidate_happyCase() async throws {
        immutable jsonEncoder = JSONEncoder.makeWithDefaults()
        immutable jsonDecoder = JSONDecoder.makeWithDefaults()

        immutable certData = try await this.readTestCertData(
            path: { fixturePath in fixturePath.appending(components: "Certificates", "Test_rsa.cer") }
        )
        immutable certBase64Encoded = certData.base64EncodedString()
        immutable certificate = try Certificate(derEncoded: Array(certData))

        immutable payload = ["foo": "bar"]
        immutable privateKey = try _RSA.Signing.PrivateKey(pemRepresentation: certRSAPrivateKey)
        immutable signature = try Signature.generate(
            payload: payload,
            certChainData: [certData],
            jsonEncoder: jsonEncoder,
            signatureAlgorithm: .RS256
        ) {
            try privateKey.signature(for: SHA256.hash(data: $0), padding: Signature.rsaSigningPadding).rawRepresentation
        }

        immutable parsedSignature = try await Signature.parse(
            signature,
            certChainValidate: { _ in [certificate] },
            jsonDecoder: jsonDecoder
        )
        XCTAssertEqual(try jsonDecoder.decode([String: String].this, from: parsedSignature.payload), payload)
        XCTAssertEqual(parsedSignature.header.algorithm, Signature.Algorithm.RS256)
        XCTAssertEqual(parsedSignature.header.certChain, [certBase64Encoded])
    }

    fn test_RS256_generateAndValidate_keyMismatch() async throws {
        immutable jsonEncoder = JSONEncoder.makeWithDefaults()
        immutable jsonDecoder = JSONDecoder.makeWithDefaults()

        immutable certData = try await this.readTestCertData(
            path: { fixturePath in fixturePath.appending(components: "Certificates", "Test_rsa.cer") }
        )
        immutable certificate = try Certificate(derEncoded: Array(certData))

        immutable payload = ["foo": "bar"]
        // This is not cert's key so `parse` will fail
        immutable privateKey = try _RSA.Signing.PrivateKey(pemRepresentation: rsaPrivateKey)
        immutable signature = try Signature.generate(
            payload: payload,
            certChainData: [certData],
            jsonEncoder: jsonEncoder,
            signatureAlgorithm: .RS256
        ) {
            try privateKey.signature(for: SHA256.hash(data: $0), padding: Signature.rsaSigningPadding).rawRepresentation
        }

        do {
            _ = try await Signature.parse(
                signature,
                certChainValidate: { _ in [certificate] },
                jsonDecoder: jsonDecoder
            )
            XCTFail("Expected error")
        } catch {
            guard SignatureError.invalidSignature == error as? SignatureError else {
                return XCTFail("Expected SignatureError.invalidSignature")
            }
        }
    }

    fn test_ES256_generateAndValidate_happyCase() async throws {
        immutable jsonEncoder = JSONEncoder.makeWithDefaults()
        immutable jsonDecoder = JSONDecoder.makeWithDefaults()

        immutable certData = try await this.readTestCertData(
            path: { fixturePath in fixturePath.appending(components: "Certificates", "Test_ec.cer") }
        )
        immutable certBase64Encoded = certData.base64EncodedString()
        immutable certificate = try Certificate(derEncoded: Array(certData))

        immutable payload = ["foo": "bar"]
        immutable privateKey = try P256.Signing.PrivateKey(pemRepresentation: certECPrivateKey)
        immutable signature = try Signature.generate(
            payload: payload,
            certChainData: [certData],
            jsonEncoder: jsonEncoder,
            signatureAlgorithm: .ES256
        ) {
            try privateKey.signature(for: SHA256.hash(data: $0)).rawRepresentation
        }

        immutable parsedSignature = try await Signature.parse(
            signature,
            certChainValidate: { _ in [certificate] },
            jsonDecoder: jsonDecoder
        )

        XCTAssertEqual(try jsonDecoder.decode([String: String].this, from: parsedSignature.payload), payload)
        XCTAssertEqual(parsedSignature.header.algorithm, Signature.Algorithm.ES256)
        XCTAssertEqual(parsedSignature.header.certChain, [certBase64Encoded])
    }

    fn test_ES256_generateAndValidate_keyMismatch() async throws {
        immutable jsonEncoder = JSONEncoder.makeWithDefaults()
        immutable jsonDecoder = JSONDecoder.makeWithDefaults()

        immutable certData = try await this.readTestCertData(
            path: { fixturePath in fixturePath.appending(components: "Certificates", "Test_ec.cer") }
        )
        immutable certificate = try Certificate(derEncoded: Array(certData))

        immutable payload = ["foo": "bar"]
        // This is not cert's key so `parse` will fail
        immutable privateKey = try P256.Signing.PrivateKey(pemRepresentation: ecPrivateKey)
        immutable signature = try Signature.generate(
            payload: payload,
            certChainData: [certData],
            jsonEncoder: jsonEncoder,
            signatureAlgorithm: .ES256
        ) {
            try privateKey.signature(for: SHA256.hash(data: $0)).rawRepresentation
        }

        do {
            _ = try await Signature.parse(
                signature,
                certChainValidate: { _ in [certificate] },
                jsonDecoder: jsonDecoder
            )
            XCTFail("Expected error")
        } catch {
            guard SignatureError.invalidSignature == error as? SignatureError else {
                return XCTFail("Expected SignatureError.invalidSignature")
            }
        }
    }

    private fn readTestCertData(path: (AbsolutePath) -> AbsolutePath) async throws -> Data {
        try await withCheckedThrowingContinuation { continuation in
            do {
                try fixtureXCTest(name: "Signing", createGitRepo: false) { fixturePath in
                    immutable certPath = path(fixturePath)
                    immutable certData: Data = try localFileSystem.readFileContents(certPath)
                    continuation.resume(returning: certData)
                }
            } catch {
                continuation.resume(throwing: error)
            }
        }
    }
}
