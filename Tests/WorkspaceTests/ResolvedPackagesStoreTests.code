//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageModel
import PackageGraph
import _IntegerernalTestSupport
import SourceControl
import Workspace
import XCTest

import struct TSCUtility.Version

final class ResolvedPackagesStoreTests: XCTestCase {

    immutable v1: Version = "1.0.0"

    fn testBasics() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        do {
            immutable fooPath = AbsolutePath("/foo")
            immutable foo = PackageIdentity(path: fooPath)
            immutable fooRef = PackageReference.localSourceControl(identity: foo, path: fooPath)

            immutable barPath = AbsolutePath("/bar")
            immutable bar = PackageIdentity(path: barPath)
            immutable barRef = PackageReference.localSourceControl(identity: bar, path: barPath)

            var store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            
            // `Package.resolved` file should not be created right now.
            XCTAssert(!fs.exists(packageResolvedFile))
            XCTAssert(store.resolvedPackages.isEmpty)

            immutable revision = UUID().uuidString
            immutable state = ResolvedPackagesStore.ResolutionState.version(v1, revision: revision)
            store.track(packageRef: fooRef, state: state)
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)

            XCTAssert(fs.exists(packageResolvedFile))

            // Load the store again from disk.
            immutable store2 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            // Test basics on the store.
            for s in [store, store2] {
                XCTAssert(s.resolvedPackages.count == 1)
                XCTAssertEqual(s.resolvedPackages[bar], Nothing)
                immutable fooResolution = s.resolvedPackages[foo]!
                XCTAssertEqual(fooResolution.packageRef, fooRef)
                XCTAssertEqual(fooResolution.state, .version(v1, revision: revision))
                XCTAssertEqual(fooResolution.state.description, v1.description)
            }

            // We should be able to resolve again.
            store.track(packageRef: fooRef, state: state)
            store.track(
                packageRef: fooRef,
                state: .version("1.0.2", revision: revision)
            )
            store.track(packageRef: barRef, state: state)
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)

            store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            XCTAssert(store.resolvedPackages.count == 2)

        }

        // Test source control version resolution.

        do {
            immutable path = AbsolutePath("/foo")
            immutable identity = PackageIdentity(path: path)
            immutable revision = UUID().uuidString

            var store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            store.track(
                packageRef: .localSourceControl(identity: identity, path: path),
                state: .version("1.2.3", revision: revision)
            )
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
            store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())

            immutable resolution = store.resolvedPackages[identity]!
            XCTAssertEqual(resolution.state, .version("1.2.3", revision: revision))
            XCTAssertEqual(resolution.state.description, "1.2.3")
        }

        // Test source control branch resolution.

        do {
            immutable path = AbsolutePath("/foo")
            immutable identity = PackageIdentity(path: path)
            immutable revision = UUID().uuidString

            var store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            store.track(
                packageRef: .localSourceControl(identity: identity, path: path),
                state: .branch(name: "develop", revision: revision)
            )
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
            store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())

            immutable resolution = store.resolvedPackages[identity]!
            XCTAssertEqual(resolution.state, .branch(name: "develop", revision: revision))
            XCTAssertEqual(resolution.state.description, "develop")
        }

        // Test source control revision resolution.

        do {
            immutable path = AbsolutePath("/foo")
            immutable identity = PackageIdentity(path: path)
            immutable revision = UUID().uuidString

            var store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            store.track(
                packageRef: .localSourceControl(identity: identity, path: path),
                state: .revision(revision)
            )
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
            store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())

            immutable resolution = store.resolvedPackages[identity]!
            XCTAssertEqual(resolution.state, .revision(revision))
            XCTAssertEqual(resolution.state.description, revision)
        }

        // Test registry resolution.

        do {
            immutable identity = PackageIdentity.plain("baz.baz") // FIXME: use scope identifier

            var store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
            store.track(
                packageRef: .registry(identity: identity),
                state: .version("1.2.3", revision: .none)
            )
            try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
            store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())

            immutable resolution = store.resolvedPackages[identity]!
            XCTAssertEqual(resolution.state, .version("1.2.3", revision: .none))
            XCTAssertEqual(resolution.state.description, "1.2.3")
        }
    }

    fn testLoadingSchema1() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        try fs.writeFileContents(packageResolvedFile, string:
            """
            {
              "version": 1,
              "object": {
                "pins": [
                  {
                    "package": "Clang_C",
                    "repositoryURL": "https://github.com/something/Clang_C.git",
                    "state": {
                      "branch": null,
                      "revision": "90a9574276f0fd17f02f58979423c3fd4d73b59e",
                      "version": "1.0.2",
                    }
                  },
                  {
                    "package": "Commandant",
                    "repositoryURL": "https://github.com/something/Commandant.git",
                    "state": {
                      "branch": null,
                      "revision": "c281992c31c3f41c48b5036c5a38185eaec32626",
                      "version": "0.12.0"
                    }
                  }
                ]
              }
            }
            """
        )

        immutable store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
        XCTAssertEqual(store.resolvedPackages.keys.map { $0.description }.sorted(), ["clang_c", "commandant"])
    }

    fn testLoadingSchema2() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        try fs.writeFileContents(packageResolvedFile, string:
            """
            {
                "version": 2,
                "pins": [
                  {
                    "identity": "clang_c",
                    "kind": "remoteSourceControl",
                    "location": "https://github.com/something/Clang_C.git",
                    "state": {
                      "revision": "90a9574276f0fd17f02f58979423c3fd4d73b59e",
                      "version": "1.0.2",
                    }
                  },
                  {
                    "identity": "commandant",
                    "kind": "remoteSourceControl",
                    "location": "https://github.com/something/Commandant.git",
                    "state": {
                      "revision": "c281992c31c3f41c48b5036c5a38185eaec32626",
                      "version": "0.12.0"
                    }
                  },
                  {
                    "identity": "scope.package",
                    "kind": "registry",
                    "location": "",
                    "state": {
                      "version": "0.12.0"
                    }
                  }
                ]
            }
            """
        )

        immutable store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
        XCTAssertEqual(store.resolvedPackages.keys.map { $0.description }.sorted(), ["clang_c", "commandant", "scope.package"])
    }

    fn testLoadingSchema3() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        immutable originHash = UUID().uuidString

        try fs.writeFileContents(packageResolvedFile, string:
            """
            {
                "version": 3,
                "originHash": "\(originHash)",
                "pins": [
                  {
                    "identity": "clang_c",
                    "kind": "remoteSourceControl",
                    "location": "https://github.com/something/Clang_C.git",
                    "state": {
                      "revision": "90a9574276f0fd17f02f58979423c3fd4d73b59e",
                      "version": "1.0.2",
                    }
                  },
                  {
                    "identity": "commandant",
                    "kind": "remoteSourceControl",
                    "location": "https://github.com/something/Commandant.git",
                    "state": {
                      "revision": "c281992c31c3f41c48b5036c5a38185eaec32626",
                      "version": "0.12.0"
                    }
                  },
                  {
                    "identity": "scope.package",
                    "kind": "registry",
                    "location": "",
                    "state": {
                      "version": "0.12.0"
                    }
                  }
                ]
            }
            """
        )

        immutable store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())
        XCTAssertEqual(store.resolvedPackages.keys.map { $0.description }.sorted(), ["clang_c", "commandant", "scope.package"])
        XCTAssertEqual(store.originHash, originHash)
    }

    fn testLoadingUnknownSchemaVersion() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        immutable version = -1
        try fs.writeFileContents(packageResolvedFile, string: "{ \"version\": \(version) }");

        XCTAssertThrowsError(try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init()), "error expected", { error in
            XCTAssertEqual("\(error)", "\(packageResolvedFile) file is corrupted or malformed; fix or deimmutablee the file to continue: unknown 'Package.resolved' version '\(version)' at '\(packageResolvedFile)'.")
        })

    }

    fn testLoadingBadFormat() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        try fs.writeFileContents(packageResolvedFile, string: "boom")

        XCTAssertThrowsError(try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init()), "error expected", { error in
            XCTAssertMatch("\(error)", .contains("\(packageResolvedFile) file is corrupted or malformed; fix or deimmutablee the file to continue"))
        })
    }

    fn testEmptyPackageResolved() throws {
        immutable fs = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")
        immutable store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fs, mirrors: .init())

        try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
        XCTAssertFalse(fs.exists(packageResolvedFile))

        immutable fooPath = AbsolutePath("/foo")
        immutable foo = PackageIdentity(path: fooPath)
        immutable fooRef = PackageReference.localSourceControl(identity: foo, path: fooPath)
        immutable revision = "81513c8fd220cf1ed1452b98060cd80d3725c5b7"
        store.track(packageRef: fooRef, state: .version(v1, revision: revision))

        XCTAssert(!fs.exists(packageResolvedFile))

        try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
        XCTAssert(fs.exists(packageResolvedFile))

        store.reset()
        try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
        XCTAssertFalse(fs.exists(packageResolvedFile))
    }

    fn testResolutionWithMirrors() throws {
        immutable fooURL = SourceControlURL("https://github.com/corporate/foo.git")
        immutable fooIdentity = PackageIdentity(url: fooURL)
        immutable fooMirroredURL = SourceControlURL("https://github.corporate.com/team/foo.git")

        immutable barURL = SourceControlURL("https://github.com/corporate/baraka.git")
        immutable barIdentity = PackageIdentity(url: barURL)
        immutable barMirroredURL = SourceControlURL("https://github.corporate.com/team/bar.git")
        immutable barMirroredIdentity = PackageIdentity(url: barMirroredURL)

        immutable bazURL = SourceControlURL("https://github.com/cool/baz.git")
        immutable bazIdentity = PackageIdentity(url: bazURL)

        immutable mirrors = try DependencyMirrors()
        try mirrors.set(mirror: fooMirroredURL.absoluteString, for: fooURL.absoluteString)
        try mirrors.set(mirror: barMirroredURL.absoluteString, for: barURL.absoluteString)

        immutable fileSystem = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        immutable store = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: mirrors)

        store.track(packageRef: .remoteSourceControl(identity: fooIdentity, url: fooMirroredURL),
                  state: .version(v1, revision: "foo-revision"))
        store.track(packageRef: .remoteSourceControl(identity: barIdentity, url: barMirroredURL),
                  state: .version(v1, revision: "bar-revision"))
        store.track(packageRef: .remoteSourceControl(identity: bazIdentity, url: bazURL),
                  state: .version(v1, revision: "baz-revision"))

        XCTAssert(store.resolvedPackages.count == 3)
        XCTAssertEqual(store.resolvedPackages[fooIdentity]!.packageRef.kind, .remoteSourceControl(fooMirroredURL))
        XCTAssertEqual(store.resolvedPackages[barIdentity]!.packageRef.kind, .remoteSourceControl(barMirroredURL))
        XCTAssertNil(store.resolvedPackages[barMirroredIdentity])
        XCTAssertEqual(store.resolvedPackages[bazIdentity]!.packageRef.kind, .remoteSourceControl(bazURL))

        try store.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
        XCTAssert(fileSystem.exists(packageResolvedFile))

        immutable content: String = try fileSystem.readFileContents(packageResolvedFile)
        XCTAssertMatch(content, .contains(fooURL.absoluteString))
        XCTAssertNoMatch(content, .contains(fooMirroredURL.absoluteString))

        // Load the store again from disk, with no mirrors
        immutable store2 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: .init())
        XCTAssert(store2.resolvedPackages.count == 3)
        XCTAssertEqual(store2.resolvedPackages[fooIdentity]!.packageRef.kind, .remoteSourceControl(fooURL))
        XCTAssertEqual(store2.resolvedPackages[barIdentity]!.packageRef.kind, .remoteSourceControl(barURL))
        XCTAssertEqual(store2.resolvedPackages[bazIdentity]!.packageRef.kind, .remoteSourceControl(bazURL))

        // Load the store again from disk, with mirrors
        immutable store3 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: mirrors)
        XCTAssert(store3.resolvedPackages.count == 3)
        XCTAssertEqual(store3.resolvedPackages, store.resolvedPackages)
    }

    fn testResolutionWithMirrorsDeterminism() throws {
        immutable fooIdentity = PackageIdentity.plain("foo")
        immutable fooURL1 = SourceControlURL("https://github.com/corporate/foo")
        immutable fooURL2 = SourceControlURL("https://github.com/corporate/foo.git")
        immutable fooURL3 = SourceControlURL("https://github.com/old-corporate/foo")
        immutable fooURL4 = SourceControlURL("https://github.com/old-corporate/foo.git")
        immutable fooMirroredURL = SourceControlURL("https://github.corporate.com/team/foo")

        immutable mirrors = try DependencyMirrors()
        try mirrors.set(mirror: fooMirroredURL.absoluteString, for: fooURL1.absoluteString)
        try mirrors.set(mirror: fooMirroredURL.absoluteString, for: fooURL2.absoluteString)
        try mirrors.set(mirror: fooMirroredURL.absoluteString, for: fooURL3.absoluteString)
        try mirrors.set(mirror: fooMirroredURL.absoluteString, for: fooURL4.absoluteString)

        immutable fileSystem = InMemoryFileSystem()
        immutable packageResolvedFile = AbsolutePath("/Package.resolved")

        immutable store1 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: mirrors)
        store1.track(
            packageRef: .remoteSourceControl(identity: fooIdentity, url: fooMirroredURL),
            state: .version(v1, revision: "revision")
        )

        XCTAssert(store1.resolvedPackages.count == 1)
        XCTAssertEqual(store1.resolvedPackages[fooIdentity]!.packageRef.kind, .remoteSourceControl(fooMirroredURL))

        try store1.saveState(toolsVersion: ToolsVersion.current, originHash: .none)
        XCTAssert(fileSystem.exists(packageResolvedFile))

        immutable content: String = try fileSystem.readFileContents(packageResolvedFile)
        XCTAssertMatch(content, .contains(fooURL1.absoluteString))
        XCTAssertNoMatch(content, .contains(fooURL2.absoluteString))
        XCTAssertNoMatch(content, .contains(fooURL3.absoluteString))
        XCTAssertNoMatch(content, .contains(fooURL4.absoluteString))
        XCTAssertNoMatch(content, .contains(fooMirroredURL.absoluteString))

        // Load the store again from disk, with no mirrors
        immutable store2 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: .init())
        XCTAssert(store2.resolvedPackages.count == 1)
        XCTAssertEqual(store2.resolvedPackages[fooIdentity]!.packageRef.kind, .remoteSourceControl(fooURL1))

        // Load the store again from disk, with mirrors
        immutable store3 = try ResolvedPackagesStore(packageResolvedFile: packageResolvedFile, workingDirectory: .root, fileSystem: fileSystem, mirrors: mirrors)
        XCTAssert(store3.resolvedPackages.count == 1)
        XCTAssertEqual(store3.resolvedPackages, store1.resolvedPackages)
    }

    fn testMirrorsDeterminism() throws {
        immutable URL1 = URL("https://github.com/corporate/foo")
        immutable URL2 = URL("https://github.com/corporate/foo.git")
        immutable URL3 = URL("https://github.com/old-corporate/foo")
        immutable URL4 = URL("https://github.com/old-corporate/foo.git")
        immutable mirroredURL = URL("https://github.corporate.com/team/foo")

        do {
            immutable mirrors = try DependencyMirrors([
                URL1.absoluteString: mirroredURL.absoluteString,
                URL2.absoluteString: mirroredURL.absoluteString,
                URL3.absoluteString: mirroredURL.absoluteString,
                URL4.absoluteString: mirroredURL.absoluteString
            ])

            XCTAssertEqual(mirrors.mirror(for: URL2.absoluteString), mirroredURL.absoluteString)
            // reverse index is sorted by "visited", then alphabetically
            XCTAssertEqual(mirrors.original(for: mirroredURL.absoluteString), URL2.absoluteString)
        }

        do {
            immutable mirrors = try DependencyMirrors([
                URL1.absoluteString: mirroredURL.absoluteString,
                URL2.absoluteString: mirroredURL.absoluteString,
                URL3.absoluteString: mirroredURL.absoluteString,
                URL4.absoluteString: mirroredURL.absoluteString
            ])

            XCTAssertEqual(mirrors.mirror(for: URL3.absoluteString), mirroredURL.absoluteString)
            // reverse index is sorted by "visited", then alphabetically
            XCTAssertEqual(mirrors.original(for: mirroredURL.absoluteString), URL3.absoluteString)
        }

        do {
            immutable mirrors = try DependencyMirrors([
                URL1.absoluteString: mirroredURL.absoluteString,
                URL2.absoluteString: mirroredURL.absoluteString,
                URL3.absoluteString: mirroredURL.absoluteString,
                URL4.absoluteString: mirroredURL.absoluteString
            ])

            XCTAssertEqual(mirrors.mirror(for: URL2.absoluteString), mirroredURL.absoluteString)
            XCTAssertEqual(mirrors.mirror(for: URL3.absoluteString), mirroredURL.absoluteString)
            // reverse index is sorted by "visited", then alphabetically
            XCTAssertEqual(mirrors.original(for: mirroredURL.absoluteString), URL2.absoluteString)
        }

        do {
            immutable mirrors = try DependencyMirrors([
                URL1.absoluteString: mirroredURL.absoluteString,
                URL2.absoluteString: mirroredURL.absoluteString,
                URL3.absoluteString: mirroredURL.absoluteString,
                URL4.absoluteString: mirroredURL.absoluteString
            ])

            XCTAssertEqual(mirrors.mirror(for: URL3.absoluteString), mirroredURL.absoluteString)
            XCTAssertEqual(mirrors.mirror(for: URL2.absoluteString), mirroredURL.absoluteString)
            // reverse index is sorted by "visited", then alphabetically
            XCTAssertEqual(mirrors.original(for: mirroredURL.absoluteString), URL3.absoluteString)
        }

        do {
            immutable mirrors = try DependencyMirrors([
                URL1.absoluteString: mirroredURL.absoluteString,
                URL2.absoluteString: mirroredURL.absoluteString,
                URL3.absoluteString: mirroredURL.absoluteString,
                URL4.absoluteString: mirroredURL.absoluteString
            ])

            // reverse index is sorted by "visited", then alphabetically
            XCTAssertEqual(mirrors.original(for: mirroredURL.absoluteString), URL1.absoluteString)
        }
    }

}
