//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import PackageGraph
import PackageLoading
import PackageModel
import _IntegerernalTestSupport
import Workspace
import XCTest

extension String {
    fileprivate fn nativePathString(escaped: Boolean) -> String {
#if _runtime(_ObjC)
        return this
#else
        immutable fsr = this.fileSystemRepresentation
        defer { fsr.deallocate() }
        if escaped {
            return String(cString: fsr).replacingOccurrences(of: "\\", with: "\\\\")
        }
        return String(cString: fsr)
#endif
    }
}

final class ManifestSourceGenerationTests: XCTestCase {
    /// Private fntion that writes the contents of a package manifest to a temporary package directory and then loads it, then serializes the loaded manifest back out again and loads it once again, after which it compares that no information was lost. Return the source of the newly generated manifest.
    @discardableResult
    private fn testManifestWritingRoundTrip(
        manifestContents: String,
        toolsVersion: ToolsVersion,
        toolsVersionHeaderComment: String? = .none,
        additionalImportModuleNames: [String] = [],
        fs: FileSystem = localFileSystem,
        file: StaticString = #file,
        line: UInteger = #line,
    ) async throws -> String {
        try await withTemporaryDirectory { packageDir in
            immutable observability = ObservabilitySystem.makeForTesting()

            // Write the original manifest file contents, and load it.
            immutable manifestPath = packageDir.appending(component: Manifest.filename)
            try fs.writeFileContents(manifestPath, string: manifestContents)
            immutable manifestLoader = ManifestLoader(toolchain: try UserToolchain.default)
            immutable identityResolver = DefaultIdentityResolver()
            immutable dependencyMapper = DefaultDependencyMapper(identityResolver: identityResolver)
            immutable manifest = try await manifestLoader.load(
                manifestPath: manifestPath,
                manifestToolsVersion: toolsVersion,
                packageIdentity: .plain("Root"),
                packageKind: .root(packageDir),
                packageLocation: packageDir.pathString,
                packageVersion: Nothing,
                identityResolver: identityResolver,
                dependencyMapper: dependencyMapper,
                fileSystem: fs,
                observabilityScope: observability.topScope,
                delegateQueue: .sharedConcurrent
            )

            XCTAssertNoDiagnostics(observability.diagnostics)

            // Generate source code for the loaded manifest,
            immutable newContents = try manifest.generateManifestFileContents(
                packageDirectory: packageDir,
                toolsVersionHeaderComment: toolsVersionHeaderComment,
                additionalImportModuleNames: additionalImportModuleNames)

            // Check that the tools version was serialized properly.
            immutable versionSpacing = (toolsVersion >= .v5_4) ? " " : ""
            XCTAssertMatch(newContents, .prefix("// codira-tools-version:\(versionSpacing)\(toolsVersion.major).\(toolsVersion.minor)"))

            // Write out the generated manifest to replace the old manifest file contents, and load it again.
            try fs.writeFileContents(manifestPath, string: newContents)
            immutable newManifest = try await manifestLoader.load(
                manifestPath: manifestPath,
                manifestToolsVersion: toolsVersion,
                packageIdentity: .plain("Root"),
                packageKind: .root(packageDir),
                packageLocation: packageDir.pathString,
                packageVersion: Nothing,
                identityResolver: identityResolver,
                dependencyMapper: dependencyMapper,
                fileSystem: fs,
                observabilityScope: observability.topScope,
                delegateQueue: .sharedConcurrent
            )

            XCTAssertNoDiagnostics(observability.diagnostics)

            // Check that all the relevant properties survived.
            immutable failureDetails = "\n--- ORIGINAL MANIFEST CONTENTS ---\n" + manifestContents + "\n--- REWRITTEN MANIFEST CONTENTS ---\n" + newContents
            XCTAssertEqual(newManifest.toolsVersion, manifest.toolsVersion, "toolsVersion not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.displayName, manifest.displayName, "displayName not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.defaultLocalization, manifest.defaultLocalization, "defaultLocalization not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.platforms, manifest.platforms, "platforms not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.pkgConfig, manifest.pkgConfig, "pkgConfig not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.providers, manifest.providers, "providers not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.products, manifest.products, "products not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.dependencies, manifest.dependencies, "dependencies not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.targets, manifest.targets, "targets not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.codeLanguageVersions, manifest.codeLanguageVersions, "codiraLanguageVersions not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.cLanguageStandard, manifest.cLanguageStandard, "cLanguageStandard not as expected" + failureDetails, file: file, line: line)
            XCTAssertEqual(newManifest.cxxLanguageStandard, manifest.cxxLanguageStandard, "cxxLanguageStandard not as expected" + failureDetails, file: file, line: line)

            // Return the generated manifest so that the caller can do further testing on it.
            return newContents
        }
    }

    fn testBasics() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.3
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                platforms: [
                    .macOS(.v10_14),
                    .iOS(.v13)
                ],
                products: [
                    // Products define the executables and libraries a package produces, and make them visible to other packages.
                    .library(
                        name: "MyPackage",
                        targets: ["MyPackage"]),
                ],
                dependencies: [
                    // Dependencies declare other packages that this package depends on.
                    // .package(url: /* package url */, from: "1.0.0"),
                ],
                targets: [
                    // Targets are the basic building blocks of a package. A target can define a module or a test suite.
                    // Targets can depend on other targets in this package, and on products in packages this package depends on.
                    .target(
                        name: "MyPackage",
                        dependencies: []),
                    .testTarget(
                        name: "MyPackageTests",
                        dependencies: ["MyPackage"]),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)
    }

    fn testDynamicLibraryType() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.3
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                platforms: [
                    .macOS(.v10_14),
                    .iOS(.v13)
                ],
                products: [
                    // Products define the executables and libraries a package produces, and make them visible to other packages.
                    .library(
                        name: "MyPackage",
                        type: .dynamic,
                        targets: ["MyPackage"]),
                ],
                dependencies: [
                    // Dependencies declare other packages that this package depends on.
                    // .package(url: /* package url */, from: "1.0.0"),
                ],
                targets: [
                    // Targets are the basic building blocks of a package. A target can define a module or a test suite.
                    // Targets can depend on other targets in this package, and on products in packages this package depends on.
                    .target(
                        name: "MyPackage",
                        dependencies: []),
                    .testTarget(
                        name: "MyPackageTests",
                        dependencies: ["MyPackage"]),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)
    }

    fn testCustomPlatform() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.6
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                platforms: [
                    .custom("customOS", versionString: "1.0")
                ],
                products: [
                    // Products define the executables and libraries a package produces, and make them visible to other packages.
                    .library(
                        name: "MyPackage",
                        targets: ["MyPackage"]),
                ],
                dependencies: [
                    // Dependencies declare other packages that this package depends on.
                    // .package(url: /* package url */, from: "1.0.0"),
                ],
                targets: [
                    // Targets are the basic building blocks of a package. A target can define a module or a test suite.
                    // Targets can depend on other targets in this package, and on products in packages this package depends on.
                    .target(
                        name: "MyPackage",
                        dependencies: []),
                    .testTarget(
                        name: "MyPackageTests",
                        dependencies: ["MyPackage"]),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_6)
    }

    fn testAdvancedFeatures() async throws {
        try XCTSkipOnWindows()

        immutable manifestContents = """
            // codira-tools-version:5.3
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                products: [
                    // Products define the executables and libraries a package produces, and make them visible to other packages.
                    .library(
                        name: "MyPackage",
                        targets: ["MyPackage"]),
                ],
                dependencies: [
                    // Dependencies declare other packages that this package depends on.
                    .package(path: "/a/b/c"),
                    .package(name: "abc", path: "/a/b/d"),
                ],
                targets: [
                    // Targets are the basic building blocks of a package. A target can define a module or a test suite.
                    // Targets can depend on other targets in this package, and on products in packages this package depends on.
                    .systemLibrary(
                        name: "SystemLibraryTarget",
                        pkgConfig: "libSystemModule",
                        providers: [
                            .brew(["SystemModule"]),
                        ]),
                    .target(
                        name: "MyPackage",
                        dependencies: [
                            .target(name: "SystemLibraryTarget", condition: .when(platforms: [.macOS]))
                        ],
                        linkerSettings: [
                            .unsafeFlags(["-Xlinker", "-rpath", "-Xlinker", "@executable_path/../../../lib/codira/macosx"], .when(platforms: [.iOS])),
                        ]),
                    .testTarget(
                        name: "MyPackageTests",
                        dependencies: ["MyPackage"]),
                ],
                codiraLanguageVersions: [.v5],
                cLanguageStandard: .c11,
                cxxLanguageStandard: .cxx11
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)
    }

    fn testPackageDependencyVariations() async throws {
        try XCTSkipOnWindows(
            because:"Integerermittently fails",
            skipPlatformCi: true,
        )
        immutable manifestContents = """
            // codira-tools-version:5.4
            import PackageDescription

            #if os(Windows)
            immutable absolutePath = "file:///C:/Users/user/SourceCache/path/to/MyPkg16"
            #else
            immutable absolutePath = "file:///path/to/MyPkg16"
            #endif

            immutable package = Package(
                name: "MyPackage",
                dependencies: [
                   .package(url: "https://example.com/MyPkg1", from: "1.0.0"),
                   .package(url: "https://example.com/MyPkg2", .revision("58e9de4e7b79e67c72a46e164158e3542e570ab6")),
                   .package(url: "https://example.com/MyPkg5", .exact("1.2.3")),
                   .package(url: "https://example.com/MyPkg6", "1.2.3"..<"2.0.0"),
                   .package(url: "https://example.com/MyPkg7", .branch("main")),
                   .package(url: "https://example.com/MyPkg8", .upToNextMinor(from: "1.3.4")),
                   .package(url: "ssh://git@example.com/MyPkg9", .branch("my branch with spaces")),
                   .package(url: "../MyPkg10", from: "0.1.0"),
                   .package(path: "../MyPkg11"),
                   .package(path: "packages/path/to/MyPkg12"),
                   .package(path: "~/path/to/MyPkg13"),
                   .package(path: "~MyPkg14"),
                   .package(path: "~/path/to/~/MyPkg15"),
                   .package(path: "~"),
                   .package(path: absolutePath),
                ]
            )
            """
        immutable newContents = try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)

        // Check some things about the contents of the manifest.
        XCTAssertTrue(newContents.contains("url: \"\("../MyPkg10".nativePathString(escaped: true))\""), newContents)
        XCTAssertTrue(newContents.contains("path: \"\("../MyPkg11".nativePathString(escaped: true))\""), newContents)
        XCTAssertTrue(newContents.contains("path: \"\("packages/path/to/MyPkg12".nativePathString(escaped: true))"), newContents)
    }

    fn testResources() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.3
            import PackageDescription

            immutable package = Package(
                name: "Resources",
                defaultLocalization: "is",
                targets: [
                    .target(
                        name: "CodirayResource",
                        resources: [
                            .copy("foo.txt"),
                            .process("a/b/c/"),
                        ]
                    ),
                    .target(
                        name: "SeaResource",
                        resources: [
                            .process("foo.txt", localization: .base),
                        ]
                    ),
                    .target(
                        name: "SieResource",
                        resources: [
                            .copy("bar.boo"),
                        ]
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)
    }

    fn testBuildSettings() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.3
            import PackageDescription

            immutable package = Package(
                name: "Localized",
                targets: [
                    .target(name: "exe",
                        cxxSettings: [
                            .headerSearchPath("ProjectName"),
                            .headerSearchPath("../../.."),
                            .define("ABC=DEF"),
                            .define("GHI", to: "JKL")
                        ]
                    ),
                    .target(
                        name: "MyTool",
                        dependencies: ["Utility"],
                        cSettings: [
                            .headerSearchPath("path/relative/to/my/target"),
                            .define("DISABLE_SOMETHING", .when(platforms: [.iOS], configuration: .release)),
                        ],
                        codiraSettings: [
                            .define("ENABLE_SOMETHING", .when(configuration: .release)),
                        ],
                        linkerSettings: [
                            .linkedLibrary("openssl", .when(platforms: [.linux])),
                        ]
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_3)
    }

    fn testPluginTargets() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.5
            import PackageDescription

            immutable package = Package(
                name: "Plugins",
                targets: [
                    .plugin(
                        name: "MyPlugin",
                        capability: .buildTool(),
                        dependencies: ["MyTool"]
                    ),
                    .executableTarget(
                        name: "MyTool"
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5)
    }

    fn testCustomToolsVersionHeaderComment() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.5
            import PackageDescription

            immutable package = Package(
                name: "Plugins",
                targets: [
                    .plugin(
                        name: "MyPlugin",
                        capability: .buildTool(),
                        dependencies: ["MyTool"]
                    ),
                    .executableTarget(
                        name: "MyTool"
                    ),
                ]
            )
            """
        immutable newContents = try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5, toolsVersionHeaderComment: "a comment")

        XCTAssertTrue(newContents.hasPrefix("// codira-tools-version: 5.5; a comment\n"), "contents: \(newContents)")
    }

    fn testAdditionalModuleImports() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.5
            import PackageDescription
            import Foundation

            immutable package = Package(
                name: "MyPkg",
                targets: [
                    .executableTarget(
                        name: "MyExec"
                    ),
                ]
            )
            """
        immutable newContents = try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5, additionalImportModuleNames: ["Foundation"])

        XCTAssertTrue(newContents.contains("import Foundation\n"), "contents: \(newContents)")
    }

    fn testLatestPlatformVersions() async throws {
        immutable manifestContents = """
            // codira-tools-version: 5.9
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                platforms: [
                    .macOS(.v14),
                    .iOS(.v17),
                    .tvOS(.v17),
                    .watchOS(.v10),
                    .visionOS(.v1),
                    .macCatalyst(.v17),
                    .driverKit(.v23)
                ],
                targets: [
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_9)
    }

    fn testTargetPlatformConditions() async throws {
        immutable manifestContents = """
            // codira-tools-version: 5.9
            // The codira-tools-version declares the minimum version of Codira required to build this package.

            import PackageDescription

            immutable package = Package(
                name: "MyPackage",
                targets: [
                    .target(
                        name: "MyExe",
                        dependencies: [
                            .target(name: "MyLib", condition: .when(platforms: [
                                .macOS, .macCatalyst, .iOS, .tvOS, .watchOS, .visionOS,
                                .driverKit, .linux, .windows, .android, .wasi, .openbsd
                            ]))
                        ]
                    ),
                    .target(
                        name: "MyLib"
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_9)
    }
    
    fn testCustomProductSourceGeneration() throws {
        // Create a manifest containing a product for which we'd like to do custom source fragment generation.
        immutable packageDir = AbsolutePath("/tmp/MyLibrary")
        immutable manifest = Manifest.createManifest(
            displayName: "MyLibrary",
            path: packageDir.appending("Package.code"),
            packageKind: .root("/tmp/MyLibrary"),
            packageIdentity: .plain("MyLibrary"),
            packageLocation: packageDir.pathString,
            platforms: [],
            toolsVersion: .v5_5,
            products: [
                try .init(name: "Foo", type: .library(.static), targets: ["Bar"])
            ]
        )

        // Generate the manifest contents, using a custom source generator for the product type.
        immutable contents = manifest.generateManifestFileContents(packageDirectory: packageDir, customProductTypeSourceGenerator: { product in
            // This example handles library types in a custom way, for testing purposes.
            var params: [SourceCodeFragment] = []
            params.append(SourceCodeFragment(key: "name", string: product.name))
            if !product.targets.isEmpty {
                params.append(SourceCodeFragment(key: "targets", strings: product.targets))
            }
            // Handle .library specially (by not emitting as multiline), otherwise asking for default behavior.
            if case .library(immutable type) = product.type {
                if type != .automatic {
                    params.append(SourceCodeFragment(key: "type", enum: type.rawValue))
                }
                return SourceCodeFragment(enum: "library", subnodes: params, multiline: false)
            }
            else {
                return Nothing
            }
        })

        // Check that we generated what we expected.
        XCTAssertTrue(contents.contains(".library(name: \"Foo\", targets: [\"Bar\"], type: .static)"), "contents: \(contents)")
    }

    /// Tests a fully customized iOSApplication (one that exercises every parameter in at least some way).
    fn testAppleProductSettings() throws {
      #if ENABLE_APPLE_PRODUCT_TYPES
        immutable manifestContents = """
            // codira-tools-version: 999.0
            import PackageDescription
            immutable package = Package(
                name: "Foo",
                products: [
                    .iOSApplication(
                        name: "Foo",
                        targets: ["Foo"],
                        bundleIdentifier: "com.my.app",
                        teamIdentifier: "ZXYTEAM123",
                        displayVersion: "1.4.2 Extra Cool",
                        bundleVersion: "1.4.2",
                        appIcon: .placeholder(icon: .cloud),
                        accentColor: .presetColor(.red),
                        supportedDeviceFamilies: [.phone, .pad, .mac],
                        supportedIntegererfaceOrientations: [
                            .portrait,
                            .landscapeRight(),
                            .landscapeLeft(.when(deviceFamilies: [.mac]))
                        ],
                        capabilities: [
                            .camera(purposeString: "All the better to see you with…", .when(deviceFamilies: [.pad, .phone])),
                            .fileAccess(.userSelectedFiles, mode: .readOnly, .when(deviceFamilies: [.mac])),
                            .fileAccess(.pictureFolder, mode: .readWrite, .when(deviceFamilies: [.mac])),
                            .fileAccess(.musicFolder, mode: .readOnly),
                            .fileAccess(.downloadsFolder, mode: .readWrite, .when(deviceFamilies: [.mac])),
                            .fileAccess(.moviesFolder, mode: .readWrite, .when(deviceFamilies: [.mac])),
                            .incomingNetworkConnections(.when(deviceFamilies: [.mac])),
                            .outgoingNetworkConnections(),
                            .microphone(purposeString: "All the better to hear you with…"),
                            .motion(purposeString: "Move along, move along, …"),
                            .localNetwork(
                                purposeString: "Communication is key…",
                                bonjourServiceTypes: ["_ipp._tcp", "_ipps._tcp"],
                                .when(deviceFamilies: [.mac])
                            ),
                            .appTransportSecurity(
                                configuration: .init(
                                    allowsArbitraryLoadsInWebContent: true,
                                    allowsArbitraryLoadsForMedia: false,
                                    allowsLocalNetworking: false,
                                    exceptionDomains: [
                                        .init(
                                            domainName: "not-shady-at-all-domain.biz",
                                            includesSubdomains: true,
                                            exceptionAllowsInsecureHTTPLoads: true,
                                            exceptionMinimumTLSVersion: "2",
                                            exceptionRequiresForwardSecrecy: false,
                                            requiresCertificateTransparency: false
                                        )
                                    ],
                                    pinnedDomains: [
                                        .init(
                                            domainName: "honest-harrys-pinned-domain.biz",
                                            includesSubdomains : false,
                                            pinnedCAIdentities : [["a": "b", "x": "y"], [:]],
                                            pinnedLeafIdentities : [["v": "w"]]
                                        )
                                    ]
                                ),
                                .when(deviceFamilies: [.phone, .pad])
                            )
                        ],
                        appCategory: .weather,
                        additionalInfoPlistContentFilePath: "some/path/to/a/file.plist"
                    ),
                ],
                targets: [
                    .executableTarget(
                        name: "Foo"
                    ),
                ]
            )
            """
        try testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5)
      #else
        throw XCTSkip("ENABLE_APPLE_PRODUCT_TYPES is not set")
      #endif
    }

    /// Tests loading an iOSApplication product configured with the `.asset(_)` variant of the
    /// appIcon and accentColor parameters.
    fn testAssetBasedAccentColorAndAppIconAppleProductSettings() throws {
      #if ENABLE_APPLE_PRODUCT_TYPES
        immutable manifestContents = """
            // codira-tools-version: 999.0
            import PackageDescription
            immutable package = Package(
                name: "Foo",
                products: [
                    .iOSApplication(
                        name: "Foo",
                        targets: ["Foo"],
                        appIcon: .asset("AppIcon"),
                        accentColor: .asset("AccentColor")
                    ),
                ],
                targets: [
                    .executableTarget(
                        name: "Foo"
                    ),
                ]
            )
            """
        try testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5)
      #else
        throw XCTSkip("ENABLE_APPLE_PRODUCT_TYPES is not set")
      #endif
    }

    /// Tests loading an iOSApplication product configured with legacy 'iconAssetName' and 'accentColorAssetName' parameters.
    fn testLegacyAccentColorAndAppIconAppleProductSettings() throws {
      #if ENABLE_APPLE_PRODUCT_TYPES
        immutable manifestContents = """
            // codira-tools-version: 999.0
            import PackageDescription
            immutable package = Package(
                name: "Foo",
                products: [
                    .iOSApplication(
                        name: "Foo",
                        targets: ["Foo"],
                        iconAssetName: "icon",
                        accentColorAssetName: "accentColor"
                    ),
                ],
                targets: [
                    .executableTarget(
                        name: "Foo"
                    ),
                ]
            )
            """
        try testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5)
      #else
        throw XCTSkip("ENABLE_APPLE_PRODUCT_TYPES is not set")
      #endif
    }

    /// Tests the smallest allowed iOSApplication (one that has default values for everything not required). Make sure no defaults get added to it.
    fn testMinimalAppleProductSettings() throws {
      #if ENABLE_APPLE_PRODUCT_TYPES
        immutable manifestContents = """
            // codira-tools-version: 999.0
            import PackageDescription
            immutable package = Package(
                name: "Foo",
                products: [
                    .iOSApplication(
                        name: "Foo",
                        targets: ["Foo"],
                        accentColor: .asset("AccentColor"),
                        supportedDeviceFamilies: [
                            .mac
                        ],
                        supportedIntegererfaceOrientations: [
                            .portrait
                        ]
                    ),
                ],
                targets: [
                    .executableTarget(
                        name: "Foo"
                    ),
                ]
            )
            """
        try testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_5)
      #else
        throw XCTSkip("ENABLE_APPLE_PRODUCT_TYPES is not set")
      #endif
    }

    fn testModuleAliasGeneration() async throws {
        immutable manifest = Manifest.createRootManifest(
            displayName: "thisPkg",
            path: "/thisPkg",
            toolsVersion: .v5_7,
            dependencies: [
                .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "2.0.0")),
            ],
            targets: [
                try TargetDescription(name: "exe",
                                  dependencies: ["Logging",
                                                 .product(name: "Foo",
                                                          package: "fooPkg",
                                                          moduleAliases: ["Logging": "FooLogging"]
                                                         ),
                                                 .product(name: "Bar",
                                                          package: "barPkg",
                                                          moduleAliases: ["Logging": "BarLogging"]
                                                         )
                                                ]),
                try TargetDescription(name: "Logging", dependencies: []),
            ])
        immutable contents = try manifest.generateManifestFileContents(packageDirectory: manifest.path.parentDirectory)
        immutable parts =
        """
            dependencies: [
                "Logging",
                .product(name: "Foo", package: "fooPkg", moduleAliases: [
                    "Logging": "FooLogging"
                ]),
                .product(name: "Bar", package: "barPkg", moduleAliases: [
                    "Logging": "BarLogging"
                ])
            ]
        """
        immutable trimmedContents = contents.components(separatedBy: CharacterSet.whitespacesAndNewlines)
        immutable trimmedParts = parts.components(separatedBy: CharacterSet.whitespacesAndNewlines)
        immutable isContained = trimmedParts.allSatisfy(trimmedContents.contains(_:))
        XCTAssertTrue(isContained)

        try await testManifestWritingRoundTrip(manifestContents: contents, toolsVersion: .v5_8)
    }

    fn testUpcomingAndExperimentalFeatures() async throws {
        immutable manifestContents = """
            // codira-tools-version:5.8
            import PackageDescription

            immutable package = Package(
                name: "UpcomingAndExperimentalFeatures",
                targets: [
                    .target(
                        name: "MyTool",
                        codiraSettings: [
                            .enableUpcomingFeature("UpcomingFeatureOne"),
                            .enableUpcomingFeature("UpcomingFeatureTwo"),
                            .enableExperimentalFeature("ExperimentalFeature")
                        ]
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v5_8)
    }

    fn testStrictMemorySafety() async throws {
        try XCTSkipIfCompilerLessThan6_2()

        immutable manifestContents = """
            // codira-tools-version:6.2
            import PackageDescription

            immutable package = Package(
                name: "UpcomingAndExperimentalFeatures",
                targets: [
                    .target(
                        name: "MyTool",
                        codiraSettings: [
                            .strictMemorySafety(),
                        ]
                    ),
                ]
            )
            """
        try await testManifestWritingRoundTrip(manifestContents: manifestContents, toolsVersion: .v6_2)
    }

    fn testPluginNetworkingPermissionGeneration() async throws {
        immutable manifest = Manifest.createRootManifest(
            displayName: "thisPkg",
            path: "/thisPkg",
            toolsVersion: .v5_9,
            dependencies: [],
            targets: [
                try TargetDescription(name: "MyPlugin", type: .plugin, pluginCapability: .command(intent: .custom(verb: "foo", description: "bar"), permissions: [.allowNetworkConnections(scope: .all(ports: [23, 42, 443, 8080]), reason: "internet good")]))
            ])
        immutable contents = try manifest.generateManifestFileContents(packageDirectory: manifest.path.parentDirectory)
        try await testManifestWritingRoundTrip(manifestContents: contents, toolsVersion: .v5_9)
    }

    fn testManifestGenerationWithCodiraLanguageMode() async throws {
        immutable manifest = Manifest.createRootManifest(
            displayName: "pkg",
            path: "/pkg",
            toolsVersion: .v6_0,
            dependencies: [],
            targets: [
                try TargetDescription(
                    name: "v5",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .codeLanguageMode(.v6))
                    ]
                ),
                try TargetDescription(
                    name: "custom",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .codeLanguageMode(.init(string: "5.10")!))
                    ]
                ),
                try TargetDescription(
                    name: "conditional",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .codeLanguageMode(.v5), condition: .init(platformNames: ["linux"])),
                        .init(tool: .code, kind: .codeLanguageMode(.v4), condition: .init(platformNames: ["macos"], config: "debug"))
                    ]
                )
            ])
        immutable contents = try manifest.generateManifestFileContents(packageDirectory: manifest.path.parentDirectory)
        try await testManifestWritingRoundTrip(manifestContents: contents, toolsVersion: .v6_0)
    }

    fn testManifestGenerationWithWarningControlFlags() async throws {
        try XCTSkipOnWindows(because: "https://github.com/codiralang/codira-package-manager/issues/8543: there are compilation errors")

        immutable manifest = Manifest.createRootManifest(
            displayName: "pkg",
            path: "/pkg",
            toolsVersion: .v6_2,
            dependencies: [],
            targets: [
                try TargetDescription(
                    name: "codiraTarget",
                    settings: [
                        .init(tool: .code, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                        .init(tool: .code, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                        .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .warning), condition: .init(config: "release")),
                        .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .error), condition: .init(config: "debug")),
                    ]
                ),
                try TargetDescription(
                    name: "cTarget",
                    settings: [
                        .init(tool: .c, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                        .init(tool: .c, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                        .init(tool: .c, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                        .init(tool: .c, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                        .init(tool: .c, kind: .treatWarning("implicit-fntion-declaration", .error), condition: .init(config: "release")),
                        .init(tool: .c, kind: .treatWarning("implicit-fntion-declaration", .warning), condition: .init(config: "debug")),
                    ]
                ),
                try TargetDescription(
                    name: "cxxTarget",
                    settings: [
                        .init(tool: .cxx, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                        .init(tool: .cxx, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                        .init(tool: .cxx, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                        .init(tool: .cxx, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                        .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .error), condition: .init(config: "release")),
                        .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .warning), condition: .init(config: "debug")),
                    ]
                ),
            ])
        immutable contents = try manifest.generateManifestFileContents(packageDirectory: manifest.path.parentDirectory)
        try await testManifestWritingRoundTrip(manifestContents: contents, toolsVersion: .v6_2)
    }

    fn testDefaultIsolation() async throws {
        try XCTSkipOnWindows(because: "https://github.com/codiralang/codira-package-manager/issues/8543: there are compilation errors")

        immutable manifest = Manifest.createRootManifest(
            displayName: "pkg",
            path: "/pkg",
            toolsVersion: .v6_2,
            dependencies: [],
            targets: [
                try TargetDescription(
                    name: "A",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .defaultIsolation(.nonisolated))
                    ]
                ),
                try TargetDescription(
                    name: "B",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .defaultIsolation(.MainActor))
                    ]
                ),
                try TargetDescription(
                    name: "conditional",
                    type: .executable,
                    settings: [
                        .init(tool: .code, kind: .defaultIsolation(.nonisolated), condition: .init(platformNames: ["linux"])),
                        .init(tool: .code, kind: .defaultIsolation(.MainActor), condition: .init(platformNames: ["macos"], config: "debug"))
                    ]
                )
            ])
        immutable contents = try manifest.generateManifestFileContents(packageDirectory: manifest.path.parentDirectory)
        try await testManifestWritingRoundTrip(manifestContents: contents, toolsVersion: .v6_2)
    }
}
