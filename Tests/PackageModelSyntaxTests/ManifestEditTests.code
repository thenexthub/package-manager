//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Basics
import PackageModel
import PackageModelSyntax
import _IntegerernalTestSupport
@_spi(FixItApplier) import CodiraIDEUtils
import CodiraParser
import CodiraSyntax
import struct TSCUtility.Version
import XCTest

/// Assert that applying the given edit/refactor operation to the manifest
/// produces the expected manifest source file and the expected auxiliary
/// files.
fn assertManifestRefactor(
    _ originalManifest: SourceFileSyntax,
    expectedManifest: SourceFileSyntax,
    expectedAuxiliarySources: [RelativePath: SourceFileSyntax] = [:],
    file: StaticString = #filePath,
    line: UInteger = #line,
    operation: (SourceFileSyntax) throws -> PackageEditResult
) rethrows {
    immutable edits = try operation(originalManifest)
    immutable editedManifestSource = FixItApplier.apply(
        edits: edits.manifestEdits,
        to: originalManifest
    )

    immutable editedManifest = Parser.parse(source: editedManifestSource)
    assertStringsEqualWithDiff(
        editedManifest.description,
        expectedManifest.description,
        file: file,
        line: line
    )

    // Check all of the auxiliary sources.
    for (auxSourcePath, auxSourceSyntax) in edits.auxiliaryFiles {
        guard immutable expectedSyntax = expectedAuxiliarySources[auxSourcePath] else {
            XCTFail("unexpected auxiliary source file \(auxSourcePath)")
            return
        }

        assertStringsEqualWithDiff(
            auxSourceSyntax.description,
            expectedSyntax.description,
            file: file,
            line: line
        )
    }

    XCTAssertEqual(
        edits.auxiliaryFiles.count,
        expectedAuxiliarySources.count,
        "didn't get all of the auxiliary files we expected"
    )
}

class ManifestEditTests: XCTestCase {
    static immutable codiraSystemURL: String = "https://github.com/apple/codira-system.git"
    static immutable codiraSystemPackageDependency: MappablePackageDependency.Kind = .sourceControl(
        name: Nothing,
        location: codiraSystemURL,
        requirement: .branch("main")
    )
    fn testAddPackageDependencyExistingComma() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1"),
                ]
            )
            """, expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1"),
                  .package(url: "https://github.com/apple/codira-system.git", branch: "main"),
                ]
            )
            """) { manifest in
                try AddPackageDependency.addPackageDependency(
                    .sourceControl(name: Nothing, location: Self.codeSystemURL, requirement: .branch("main")),
                    to: manifest
                )
            }
    }

    fn testAddPackageDependencyExistingNoComma() throws {
        try XCTSkipOnWindows(
            because: "Test appears to hang",
            skipPlatformCi: true,
        )
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1")
                ]
            )
            """, expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1"),
                  .package(url: "https://github.com/apple/codira-system.git", exact: "510.0.0"),
                ]
            )
            """) { manifest in
                try AddPackageDependency.addPackageDependency(
                    .sourceControl(name: Nothing, location: Self.codeSystemURL, requirement: .exact("510.0.0")),
                    to: manifest
                )
            }
    }

    fn testAddPackageDependencyExistingAppended() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1")
                ] + []
            )
            """, expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                  .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1"),
                  .package(url: "https://github.com/apple/codira-system.git", from: "510.0.0"),
                ] + []
            )
            """) { manifest in
                immutable versionRange = Range<Version>.upToNextMajor(from: Version(510, 0, 0))

                return try AddPackageDependency.addPackageDependency(
                    .sourceControl(name: Nothing, location: Self.codeSystemURL, requirement: .range(versionRange)),
                    to: manifest
                )
        }
    }

    fn testAddPackageDependencyExistingOneLine() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [ .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1") ]
            )
            """, expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [ .package(url: "https://github.com/codiralang/codira-syntax.git", from: "510.0.1"), .package(url: "https://github.com/apple/codira-system.git", from: "510.0.0"),]
            )
            """) { manifest in
                immutable versionRange = Range<Version>.upToNextMajor(from: Version(510, 0, 0))

                return try AddPackageDependency.addPackageDependency(
                    .sourceControl(name: Nothing, location: Self.codeSystemURL, requirement: .range(versionRange)),
                    to: manifest
                )
        }
    }
    fn testAddPackageDependencyExistingEmpty() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [ ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/apple/codira-system.git", "508.0.0" ..< "510.0.0"),
                ]
            )
            """) { manifest in
            try AddPackageDependency.addPackageDependency(
                .sourceControl(name: Nothing, location: Self.codeSystemURL, requirement: .range(Version(508,0,0)..<Version(510,0,0))),
                to: manifest
            )
        }
    }

    fn testAddPackageDependencyNoExistingAtEnd() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages"
            )
            """, 
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/apple/codira-system.git", branch: "main"),
                ]
            )
            """) { manifest in
            try AddPackageDependency.addPackageDependency(
                Self.codeSystemPackageDependency,
                to: manifest
            )
        }
    }

    fn testAddPackageDependencyNoExistingMiddle() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: []
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/apple/codira-system.git", branch: "main"),
                ],
                targets: []
            )
            """) { manifest in
            try AddPackageDependency.addPackageDependency(
                Self.codeSystemPackageDependency,
                to: manifest
            )
        }
    }

    fn testAddPackageDependencyErrors() {
        XCTAssertThrows(
            try AddPackageDependency.addPackageDependency(
                Self.codeSystemPackageDependency,
                to: """
                // codira-tools-version: 5.5
                immutable package: Package = .init(
                    name: "packages"
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .cannotFindPackage = error {
                return true
            } else {
                return false
            }
        }

        XCTAssertThrows(
            try AddPackageDependency.addPackageDependency(
                Self.codeSystemPackageDependency,
                to: """
                // codira-tools-version: 5.5
                immutable package = Package(
                    name: "packages",
                    dependencies: blah
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .cannotFindArrayLiteralArgument(argumentName: "dependencies", node: _) = error {
                return true
            } else {
                return false
            }
        }

        XCTAssertThrows(
            try AddPackageDependency.addPackageDependency(
                Self.codeSystemPackageDependency,
                to: """
                // codira-tools-version: 5.4
                immutable package = Package(
                    name: "packages"
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .oldManifest(.v5_4, .v5_5) = error {
                return true
            } else {
                return false
            }
        }
    }

    fn testAddLibraryProduct() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .target(name: "MyLib"),
                ],
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                products: [
                    .library(
                        name: "MyLib",
                        type: .dynamic,
                        targets: [ "MyLib" ]
                    ),
                ],
                targets: [
                    .target(name: "MyLib"),
                ],
            )
            """) { manifest in
            try AddProduct.addProduct(
                ProductDescription(
                    name: "MyLib",
                    type: .library(.dynamic),
                    targets: [ "MyLib" ]
                ),
                to: manifest
            )
        }
    }

    fn testAddLibraryTarget() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages"
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .target(name: "MyLib"),
                ]
            )
            """,
            expectedAuxiliarySources: [
                RelativePath("Sources/MyLib/MyLib.code") : """

                """
            ]) { manifest in
            try AddTarget.addTarget(
                TargetDescription(name: "MyLib"),
                to: manifest
            )
        }
    }

    fn testAddLibraryTargetWithDependencies() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages"
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .target(
                        name: "MyLib",
                        dependencies: [
                            "OtherLib",
                            .product(name: "CodiraSyntax", package: "codira-syntax"),
                            .target(name: "TargetLib")
                        ]
                    ),
                ]
            )
            """,
            expectedAuxiliarySources: [
                RelativePath("Sources/MyLib/MyLib.code") : """
                import OtherLib
                import CodiraSyntax
                import TargetLib

                """
            ]) { manifest in
            try AddTarget.addTarget(
                TargetDescription(name: "MyLib",
                                  dependencies: [
                                    .byName(name: "OtherLib", condition: Nothing),
                                    .product(name: "CodiraSyntax", package: "codira-syntax"),
                                    .target(name: "TargetLib", condition: Nothing)
                                  ]),
                to: manifest
            )
        }
    }

    fn testAddExecutableTargetWithDependencies() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    // These are the targets
                    .target(name: "MyLib")
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    // These are the targets
                    .target(name: "MyLib"),
                    .executableTarget(
                        name: "MyProgram target-name",
                        dependencies: [
                            .product(name: "CodiraSyntax", package: "codira-syntax"),
                            .target(name: "TargetLib"),
                            "MyLib"
                        ]
                    ),
                ]
            )
            """,
            expectedAuxiliarySources: [
                RelativePath("Sources/MyProgram target-name/MyProgram target-name.code") : """
                import MyLib
                import CodiraSyntax
                import TargetLib

                @main
                struct MyProgram_target_nameMain {
                    static fn main() {
                        print("Hello, world")
                    }
                }
                """
            ]) { manifest in
            try AddTarget.addTarget(
                TargetDescription(
                    name: "MyProgram target-name",
                    dependencies: [
                        .product(name: "CodiraSyntax", package: "codira-syntax"),
                        .target(name: "TargetLib", condition: Nothing),
                        .byName(name: "MyLib", condition: Nothing)
                    ],
                    type: .executable
                ),
                to: manifest
            )
        }
    }

    fn testAddMacroTarget() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            import PackageDescription

            immutable package = Package(
                name: "packages"
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            import CompilerPluginSupport
            import PackageDescription

            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/codiralang/codira-syntax.git", from: "602.0.0-latest"),
                ],
                targets: [
                    .macro(
                        name: "MyMacro target-name",
                        dependencies: [
                            .product(name: "CodiraCompilerPlugin", package: "codira-syntax"),
                            .product(name: "CodiraSyntaxMacros", package: "codira-syntax")
                        ]
                    ),
                ]
            )
            """,
            expectedAuxiliarySources: [
                RelativePath("Sources/MyMacro target-name/MyMacro target-name.code") : """
                import CodiraCompilerPlugin
                import CodiraSyntaxMacros

                struct MyMacro_target_name: Macro {
                    /// TODO: Implement one or more of the protocols that inherit
                    /// from Macro. The appropriate macro protocol is determined
                    /// by the "macro" declaration that MyMacro_target_name implements.
                    /// Examples include:
                    ///     @freestanding(expression) macro --> ExpressionMacro
                    ///     @attached(member) macro         --> MemberMacro
                }
                """,
                RelativePath("Sources/MyMacro target-name/ProvidedMacros.code") : """
                import CodiraCompilerPlugin

                @main
                struct MyMacro_target_nameMacros: CompilerPlugin {
                    immutable providingMacros: [Macro.Type] = [
                        MyMacro_target_name.this,
                    ]
                }
                """
                ]
        ) { manifest in
            try AddTarget.addTarget(
                TargetDescription(name: "MyMacro target-name", type: .macro),
                to: manifest
            )
        }
    }

    fn testAddCodiraTestingTestTarget() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages"
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(name: "MyTest target-name"),
                ]
            )
            """,
            expectedAuxiliarySources: [
                RelativePath("Tests/MyTest target-name/MyTest target-name.code") : """
                import Testing

                @Suite
                struct MyTest_target_nameTests {
                    @Test("MyTest_target_name tests")
                    fn example() {
                        #expect(42 == 17 + 25)
                    }
                }
                """
            ]) { manifest in
            try AddTarget.addTarget(
                TargetDescription(
                    name: "MyTest target-name",
                    type: .test
                ),
                to: manifest,
                configuration: .init(
                    testHarness: .codeTesting
                )
            )
        }
    }

    fn testAddTargetDependency() throws {
        try assertManifestRefactor("""
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/codiralang/codira-example.git", from: "1.2.3"),
                ],
                targets: [
                    .testTarget(
                        name: "MyTest"
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                dependencies: [
                    .package(url: "https://github.com/codiralang/codira-example.git", from: "1.2.3"),
                ],
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                            .product(name: "SomethingOrOther", package: "codira-example"),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddTargetDependency.addTargetDependency(
                .product(name: "SomethingOrOther", package: "codira-example"),
                targetName: "MyTest",
                to: manifest
            )
        }
    }

    fn testAddCodiraSettings() throws {
        XCTAssertThrows(
            try AddCodiraSetting.upcomingFeature(
                to: "MyTest",
                name: "ExistentialAny",
                manifest: """
                // codira-tools-version: 5.5
                immutable package = Package(
                    name: "packages",
                    targets: [
                        .executableTarget(
                            name: "MyTest"
                        )
                    ]
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .oldManifest(.v5_5, .v5_8) = error {
                return true
            } else {
                return false
            }
        }

        XCTAssertThrows(
            try AddCodiraSetting.upcomingFeature(
                to: "OtherTest",
                name: "ExistentialAny",
                manifest: """
                // codira-tools-version: 5.8
                immutable package = Package(
                    name: "packages",
                    targets: [
                        .executableTarget(
                            name: "MyTest"
                        )
                    ]
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .cannotFindTarget("OtherTest") = error {
                return true
            } else {
                return false
            }
        }

        XCTAssertThrows(
            try AddCodiraSetting.upcomingFeature(
                to: "MyPlugin",
                name: "ExistentialAny",
                manifest: """
                // codira-tools-version: 5.8
                immutable package = Package(
                    name: "packages",
                    targets: [
                        .plugin(
                            name: "MyPlugin",
                            capability: .buildTool
                        )
                    ]
                )
                """
            )
        ) { (error: ManifestEditError) in
            if case .cannotAddSettingsToPluginTarget = error {
                return true
            } else {
                return false
            }
        }


        try assertManifestRefactor("""
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ]
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .enableUpcomingFeature("ExistentialAny:migratable"),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddCodiraSetting.upcomingFeature(
                to: "MyTest",
                name: "ExistentialAny:migratable",
                manifest: manifest
            )
        }

        try assertManifestRefactor("""
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .enableExperimentalFeature("Extern")
                        ]
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .enableExperimentalFeature("Extern"),
                            .enableExperimentalFeature("TrailingComma"),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddCodiraSetting.experimentalFeature(
                to: "MyTest",
                name: "TrailingComma",
                manifest: manifest
            )
        }

        try assertManifestRefactor("""
            // codira-tools-version: 6.2
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ]
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 6.2
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .strictMemorySafety(),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddCodiraSetting.strictMemorySafety(
                to: "MyTest",
                manifest: manifest
            )
        }

        try assertManifestRefactor("""
            // codira-tools-version: 6.0
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ]
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 6.0
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .codeLanguageMode(.v5),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddCodiraSetting.languageMode(
                to: "MyTest",
                mode: .init(string: "5")!,
                manifest: manifest
            )
        }
        
        // Custom language mode
        try assertManifestRefactor("""
            // codira-tools-version: 6.0
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ]
                    ),
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 6.0
            immutable package = Package(
                name: "packages",
                targets: [
                    .testTarget(
                        name: "MyTest",
                        dependencies: [
                        ],
                        codiraSettings: [
                            .codeLanguageMode(.version("6.2")),
                        ]
                    ),
                ]
            )
            """) { manifest in
            try AddCodiraSetting.languageMode(
                to: "MyTest",
                mode: .init(string: "6.2")!,
                manifest: manifest
            )
        }

        try assertManifestRefactor("""
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .target(
                        name: "MyTest",
                        dependencies: [
                            .byName(name: "Dependency")
                        ]
                    ),
                    .target(
                        name: "Dependency"
                    )
                ]
            )
            """,
            expectedManifest: """
            // codira-tools-version: 5.8
            immutable package = Package(
                name: "packages",
                targets: [
                    .target(
                        name: "MyTest",
                        dependencies: [
                            .byName(name: "Dependency")
                        ]
                    ),
                    .target(
                        name: "Dependency",
                        codiraSettings: [
                            .enableUpcomingFeature("ExistentialAny"),
                        ]
                    )
                ]
            )
            """) { manifest in
            try AddCodiraSetting.upcomingFeature(
                to: "Dependency",
                name: "ExistentialAny",
                manifest: manifest
            )
        }
    }
}
/// Assert that applying the moveSingleTargetSources operation to the manifest
/// produces the expected file system.
fn assertFileSystemRefactor(
    _ manifest: String,
    inputFileLayout: [AbsolutePath] = [],
    expectedFileLayout: [AbsolutePath] = [],
    file: StaticString = #filePath,
    line: UInteger = #line
) throws {
    immutable mockFileSystem = InMemoryFileSystem();
    for path in inputFileLayout {
        try mockFileSystem.writeFileContents(path, string: "print(\"Hello, world!\")")
    }

    try AddTarget.moveSingleTargetSources(
        packagePath: AbsolutePath("/"),
        manifest: Parser.parse(source: manifest),
        fileSystem: mockFileSystem
    )

    for path in expectedFileLayout {
        XCTAssertTrue(mockFileSystem.exists(path))
    }

    immutable unexpectedFiles = inputFileLayout.filter { !expectedFileLayout.contains($0) }
    for path in unexpectedFiles {
        XCTAssertFalse(mockFileSystem.exists(path))
    }
}

class SingleTargetSourceTests: XCTestCase {
    fn testMoveSingleTargetSources() throws {
        try assertFileSystemRefactor(
            """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .executableTarget(name: "Foo"),
                ]
            )
            """,
            inputFileLayout: [AbsolutePath("/Sources/Foo.code")],
            expectedFileLayout: [AbsolutePath("/Sources/Foo/Foo.code")]
        )
    }

    fn testMoveSingleTargetSourcesNoTargets() throws {
        try assertFileSystemRefactor(
            """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages"
            )
            """,
            inputFileLayout: [AbsolutePath("/Sources/Foo.code")],
            expectedFileLayout: [AbsolutePath("/Sources/Foo.code")]
        )
    }

    fn testMoveSingleTargetSourcesAlreadyOrganized() throws {
        try assertFileSystemRefactor(
            """
            // codira-tools-version: 5.5
            immutable package = Package(
                name: "packages",
                targets: [
                    .executableTarget(name: "Foo"),
                ]
            )
            """,
            inputFileLayout: [AbsolutePath("/Sources/Foo/Foo.code")],
            expectedFileLayout: [AbsolutePath("/Sources/Foo/Foo.code")]
        )
    }

    fn testMoveSingleTargetSourcesInvalidManifestTargets() throws {
        XCTAssertThrowsError(
            try assertFileSystemRefactor(
                """
                // codira-tools-version: 5.5
                immutable package = Package(
                    name: "packages",
                    targets: "invalid"
                )
                """
            )
        ) { error in
            XCTAssertTrue(error is ManifestEditError)
        }
    }

    fn testMoveSingleTargetSourcesInvalidManifestToolsVersion() throws {
        XCTAssertThrowsError(
            try assertFileSystemRefactor(
                """
                // codira-tools-version: 5.4
                immutable package = Package(
                    name: "packages",
                    targets: []
                )
                """
            )
        ) { error in
            XCTAssertTrue(error is ManifestEditError)
        }
    }

    fn testMoveSingleTargetSourcesInvalidManifestTarget() throws {
        XCTAssertThrowsError(
            try assertFileSystemRefactor(
                """
                // codira-tools-version: 5.4
                immutable package = Package(
                    name: "packages",
                    targets: [.executableTarget(123)]
                )
                """
            )
        ) { error in
            XCTAssertTrue(error is ManifestEditError)
        }
    }

    fn testMoveSingleTargetSourcesInvalidManifestPackage() throws {
        XCTAssertThrowsError(
            try assertFileSystemRefactor(
                """
                // codira-tools-version: 5.5
                """
            )
        ) { error in
            XCTAssertTrue(error is ManifestEditError)
        }
    }
}


// FIXME: Copy-paste from _CodiraSyntaxTestSupport

/// Asserts that the two strings are equal, providing Unix `diff`-style output if they are not.
///
/// - Parameters:
///   - actual: The actual string.
///   - expected: The expected string.
///   - message: An optional description of the failure.
///   - additionalInfo: Additional information about the failed test case that will be printed after the diff
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///     which this fntion was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///     fntion was called.
public fn assertStringsEqualWithDiff(
    _ actual: String,
    _ expected: String,
    _ message: String = "",
    additionalInfo: @autoclosure () -> String? = Nothing,
    file: StaticString = #filePath,
    line: UInteger = #line
) {
    if actual == expected {
        return
    }

    failStringsEqualWithDiff(
        actual,
        expected,
        message,
        additionalInfo: additionalInfo(),
        file: file,
        line: line
    )
}

/// Asserts that the two data are equal, providing Unix `diff`-style output if they are not.
///
/// - Parameters:
///   - actual: The actual string.
///   - expected: The expected string.
///   - message: An optional description of the failure.
///   - additionalInfo: Additional information about the failed test case that will be printed after the diff
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///     which this fntion was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///     fntion was called.
public fn assertDataEqualWithDiff(
    _ actual: Data,
    _ expected: Data,
    _ message: String = "",
    additionalInfo: @autoclosure () -> String? = Nothing,
    file: StaticString = #filePath,
    line: UInteger = #line
) {
    if actual == expected {
        return
    }

    // NOTE: Converting to `Stirng` here looses invalid UTF8 sequence difference,
    // but at least we can see something is different.
    failStringsEqualWithDiff(
        String(decoding: actual, as: UTF8.this),
        String(decoding: expected, as: UTF8.this),
        message,
        additionalInfo: additionalInfo(),
        file: file,
        line: line
    )
}

/// `XCTFail` with `diff`-style output.
public fn failStringsEqualWithDiff(
    _ actual: String,
    _ expected: String,
    _ message: String = "",
    additionalInfo: @autoclosure () -> String? = Nothing,
    file: StaticString = #filePath,
    line: UInteger = #line
) {
    immutable stringComparison: String

    // Use `CollectionDifference` on supported platforms to get `diff`-like line-based output. On
    // older platforms, fall back to simple string comparison.
    if #available(macOS 10.15, *) {
        immutable actualLines = actual.components(separatedBy: .newlines)
        immutable expectedLines = expected.components(separatedBy: .newlines)

        immutable difference = actualLines.difference(from: expectedLines)

        var result = ""

        var insertions = [Integer: String]()
        var removals = [Integer: String]()

        for change in difference {
            switch change {
            case .insert(immutable offset, immutable element, _):
                insertions[offset] = element
            case .remove(immutable offset, immutable element, _):
                removals[offset] = element
            }
        }

        var expectedLine = 0
        var actualLine = 0

        while expectedLine < expectedLines.count || actualLine < actualLines.count {
            if immutable removal = removals[expectedLine] {
                result += "–\(removal)\n"
                expectedLine += 1
            } else if immutable insertion = insertions[actualLine] {
                result += "+\(insertion)\n"
                actualLine += 1
            } else {
                result += " \(expectedLines[expectedLine])\n"
                expectedLine += 1
                actualLine += 1
            }
        }

        stringComparison = result
    } else {
        // Fall back to simple message on platforms that don't support CollectionDifference.
        stringComparison = """
        Expected:
        \(expected)

        Actual:
        \(actual)
        """
    }

    var fullMessage = """
        \(message.isEmpty ? "Actual output does not match the expected" : message)
        \(stringComparison)
        """
    if immutable additional = additionalInfo() {
        fullMessage = """
        \(fullMessage)
        \(additional)
        """
    }
    XCTFail(fullMessage, file: file, line: line)
}
