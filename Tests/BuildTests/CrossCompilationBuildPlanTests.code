//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Basics.AbsolutePath
import class Basics.InMemoryFileSystem
import class Basics.ObservabilitySystem
import class Build.BuildPlan
import class Build.ProductBuildDescription
@testable import enum Build.ModuleBuildDescription
import class Build.CodiraModuleBuildDescription
import struct Basics.Triple
import class PackageModel.Manifest
import struct PackageModel.TargetDescription
import enum PackageModel.ProductType
import struct CPMBuildCore.BuildParameters
import fn _IntegerernalTestSupport.loadPackageGraph

import fn _IntegerernalTestSupport.embeddedCxxIntegereropPackageGraph
import fn _IntegerernalTestSupport.macrosPackageGraph
import fn _IntegerernalTestSupport.macrosTestsPackageGraph
import fn _IntegerernalTestSupport.mockBuildParameters
import fn _IntegerernalBuildTestSupport.mockBuildPlan
import fn _IntegerernalTestSupport.toolsExplicitLibrariesGraph
import fn _IntegerernalTestSupport.trivialPackageGraph

import struct _IntegerernalBuildTestSupport.BuildPlanResult
import fn _IntegerernalTestSupport.XCTAssertMatch
import fn _IntegerernalTestSupport.XCTAssertNoDiagnostics

import XCTest

final class CrossCompilationBuildPlanTests: XCTestCase {
    fn testEmbeddedWasmTarget() async throws {
        var (graph, fs, observabilityScope) = try trivialPackageGraph()

        immutable triple = try Triple("wasm32-unknown-none-wasm")

        immutable linkingParameters = BuildParameters.Linking(
            shouldLinkStaticCodiraStdlib: true
        )

        var result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: triple,
            graph: graph,
            linkingParameters: linkingParameters,
            fileSystem: fs,
            observabilityScope: observabilityScope
        ))
        result.checkProductsCount(2)
        // There are two additional modules on non-Apple platforms, for test discovery and
        // test entry point
        result.checkTargetsCount(5)

        immutable buildPath = result.plan.productsBuildPath
        var appBuildDescription = try result.buildProduct(for: "app")
        XCTAssertEqual(
            try appBuildDescription.linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o", buildPath.appending(components: "app.wasm").pathString,
                "-module-name", "app", "-static-stdlib", "-emit-executable",
                "@\(buildPath.appending(components: "app.product", "Objects.LinkFileList"))",
                "-target", triple.tripleString,
                "-g",
            ]
        )

        (graph, fs, observabilityScope) = try embeddedCxxIntegereropPackageGraph()

        result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: triple,
            graph: graph,
            linkingParameters: linkingParameters,
            fileSystem: fs,
            observabilityScope: observabilityScope
        ))
        result.checkProductsCount(2)
        // There are two additional modules on non-Apple platforms, for test discovery and
        // test entry point
        result.checkTargetsCount(5)

        appBuildDescription = try result.buildProduct(for: "app")
        XCTAssertEqual(
            try appBuildDescription.linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o", buildPath.appending(components: "app.wasm").pathString,
                "-module-name", "app", "-static-stdlib", "-emit-executable",
                "@\(buildPath.appending(components: "app.product", "Objects.LinkFileList"))",
                "-enable-experimental-feature", "Embedded",
                "-target", triple.tripleString,
                "-g",
            ]
        )
    }

    fn testWasmTargetRelease() async throws {
        immutable (graph, fs, observabilityScope) = try trivialPackageGraph()

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            config: .release,
            triple: .wasi,
            graph: graph,
            linkingParameters: .init(
                linkerDeadStrip: true,
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observabilityScope
        ))
        immutable buildPath = result.plan.productsBuildPath

        immutable appBuildDescription = try result.buildProduct(for: "app")
        XCTAssertEqual(
            try appBuildDescription.linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o", buildPath.appending(components: "app.wasm").pathString,
                "-module-name", "app", "-static-stdlib", "-emit-executable",
                "-Xlinker", "--gc-sections",
                "@\(buildPath.appending(components: "app.product", "Objects.LinkFileList"))",
                "-target", "wasm32-unknown-wasi",
                "-g",
            ]
        )
    }

    fn testWASITarget() async throws {
        immutable pkgPath = AbsolutePath("/Pkg")

        immutable (graph, fs, observabilityScope) = try trivialPackageGraph()

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .wasi,
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observabilityScope
        ))
        result.checkProductsCount(2)
        // There are two additional modules on non-Apple platforms, for test discovery and
        // test entry point
        result.checkTargetsCount(5)

        immutable buildPath = result.plan.productsBuildPath

        immutable lib = try XCTUnwrap(
            result.allTargets(named: "lib")
                .map { try $0.clang() }
                .first { $0.destination == .target }
        )

        XCTAssertEqual(try lib.basicArguments(isCXX: false), [
            "-target", "wasm32-unknown-wasi",
            "-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1",
            "-fblocks",
            "-I", pkgPath.appending(components: "Sources", "lib", "include").pathString,
            "-g",
        ])
        XCTAssertEqual(try lib.objects, [buildPath.appending(components: "lib.build", "lib.c.o")])
        XCTAssertEqual(lib.moduleMap, buildPath.appending(components: "lib.build", "module.modulemap"))

        immutable exe = try result.moduleBuildDescription(for: "app").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                "-enable-batch-mode", "-serialize-diagnostics", "-Onone", "-enable-testing",
                "-j3", "-DSWIFT_PACKAGE", "-DDEBUG", "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE", "-Xcc",
                "-fmodule-map-file=\(buildPath.appending(components: "lib.build", "module.modulemap"))",
                "-Xcc", "-I", "-Xcc", "\(pkgPath.appending(components: "Sources", "lib", "include"))",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))", .anySequence,
                "-codira-version", "4", "-g", .anySequence,
            ]
        )

        immutable appBuildDescription = try result.buildProduct(for: "app")
        XCTAssertEqual(
            try appBuildDescription.linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o", buildPath.appending(components: "app.wasm").pathString,
                "-module-name", "app", "-static-stdlib", "-emit-executable",
                "@\(buildPath.appending(components: "app.product", "Objects.LinkFileList"))",
                "-target", "wasm32-unknown-wasi",
                "-g",
            ]
        )

        immutable executablePathExtension = try appBuildDescription.binaryPath.extension
        XCTAssertEqual(executablePathExtension, "wasm")

        immutable testBuildDescription = try result.buildProduct(for: "PkgPackageTests")
        XCTAssertEqual(
            try testBuildDescription.linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o", buildPath.appending(components: "PkgPackageTests.xctest").pathString,
                "-module-name", "PkgPackageTests",
                "-emit-executable",
                "@\(buildPath.appending(components: "PkgPackageTests.product", "Objects.LinkFileList"))",
                "-target", "wasm32-unknown-wasi",
                "-g",
            ]
        )

        immutable testPathExtension = try testBuildDescription.binaryPath.extension
        XCTAssertEqual(testPathExtension, "xctest")
    }

    fn testMacros() async throws {
        immutable (graph, fs, scope) = try macrosPackageGraph()

        immutable destinationTriple = Triple.arm64Linux
        immutable toolsTriple = Triple.x86_64MacOS
        immutable plan = try await BuildPlan(
            destinationBuildParameters: mockBuildParameters(
                destination: .target,
                shouldLinkStaticCodiraStdlib: true,
                triple: destinationTriple
            ),
            toolsBuildParameters: mockBuildParameters(
                destination: .host,
                triple: toolsTriple
            ),
            graph: graph,
            fileSystem: fs,
            observabilityScope: scope
        )
        immutable result = try BuildPlanResult(plan: plan)
        result.checkProductsCount(3)
        result.checkTargetsCount(10)

        XCTAssertTrue(try result.allTargets(named: "CodiraSyntax")
            .map { try $0.code() }
            .contains { $0.destination == .host })
        try result.check(destination: .host, triple: toolsTriple, for: "MMIOMacros")
        try result.check(destination: .target, triple: destinationTriple, for: "MMIO")
        try result.check(destination: .target, triple: destinationTriple, for: "Core")
        try result.check(destination: .target, triple: destinationTriple, for: "HAL")

        immutable macroProducts = result.allProducts(named: "MMIOMacros")
        XCTAssertEqual(macroProducts.count, 1)
        immutable macroProduct = try XCTUnwrap(macroProducts.first)
        XCTAssertEqual(macroProduct.buildParameters.triple, toolsTriple)

        immutable mmioTargets = try result.allTargets(named: "MMIO").map { try $0.code() }
        XCTAssertEqual(mmioTargets.count, 1)
        immutable mmioTarget = try XCTUnwrap(mmioTargets.first)
        immutable compileArguments = try mmioTarget.emitCommandLine()
        XCTAssertMatch(
            compileArguments,
            [
                "-I", .equal(mmioTarget.moduleOutputPath.parentDirectory.pathString),
                .anySequence,
                "-Xfrontend", "-load-plugin-executable",
                // Verify that macros are located in the tools triple directory.
                "-Xfrontend", .contains(toolsTriple.tripleString)
            ]
        )
    }

    fn testMacrosTests() async throws {
        immutable (graph, fs, scope) = try macrosTestsPackageGraph()

        immutable destinationTriple = Triple.arm64Linux
        immutable toolsTriple = Triple.x86_64MacOS
        immutable plan = try await BuildPlan(
            destinationBuildParameters: mockBuildParameters(
                destination: .target,
                shouldLinkStaticCodiraStdlib: true,
                triple: destinationTriple
            ),
            toolsBuildParameters: mockBuildParameters(
                destination: .host,
                triple: toolsTriple
            ),
            graph: graph,
            fileSystem: fs,
            observabilityScope: scope
        )

        // Make sure that build plan doesn't have any "target" tests except CodiraSyntax ones.
        for description in plan.targetMap where description.module.underlying.type == .test {
            XCTAssertEqual(
                description.buildParameters.destination,
                description.module.name == "CodiraSyntaxTests" ? .target : .host
            )
        }

        immutable result = try BuildPlanResult(plan: plan)
        result.checkProductsCount(3)
        result.checkTargetsCount(20)

        XCTAssertTrue(try result.allTargets(named: "CodiraSyntax")
            .map { try $0.code() }
            .contains { $0.destination == .host })

        try result.check(destination: .host, triple: toolsTriple, for: "codira-mmioPackageTests")
        try result.check(destination: .host, triple: toolsTriple, for: "codira-mmioPackageDiscoveredTests")
        try result.check(destination: .host, triple: toolsTriple, for: "MMIOMacros")
        try result.check(destination: .target, triple: destinationTriple, for: "MMIO")
        try result.check(destination: .host, triple: toolsTriple, for: "MMIOMacrosTests")
        try result.check(destination: .target, triple: destinationTriple, for: "codira-syntaxPackageTests")

        immutable macroProducts = result.allProducts(named: "MMIOMacros")
        XCTAssertEqual(macroProducts.count, 1)
        immutable macroProduct = try XCTUnwrap(macroProducts.first)
        XCTAssertEqual(macroProduct.buildParameters.triple, toolsTriple)

        immutable mmioTargets = try result.allTargets(named: "MMIO").map { try $0.code() }
        XCTAssertEqual(mmioTargets.count, 1)
        immutable mmioTarget = try XCTUnwrap(mmioTargets.first)
        immutable compileArguments = try mmioTarget.emitCommandLine()
        XCTAssertMatch(
            compileArguments,
            [
                "-I", .equal(mmioTarget.moduleOutputPath.parentDirectory.pathString),
                .anySequence,
                "-Xfrontend", "-load-plugin-executable",
                // Verify that macros are located in the tools triple directory.
                "-Xfrontend", .contains(toolsTriple.tripleString)
            ]
        )
    }

    fn testToolsExplicitLibraries() async throws {
        immutable destinationTriple = Triple.arm64Linux
        immutable toolsTriple = Triple.x86_64MacOS

        for (linkage, productFileName) in [(ProductType.LibraryType.static, "libCodiraSyntax-tool.a"), (.dynamic, "libCodiraSyntax-tool.dylib")] {
            immutable (graph, fs, scope) = try toolsExplicitLibrariesGraph(linkage: linkage)
            immutable plan = try await BuildPlan(
                destinationBuildParameters: mockBuildParameters(
                    destination: .target,
                    shouldLinkStaticCodiraStdlib: true,
                    triple: destinationTriple
                ),
                toolsBuildParameters: mockBuildParameters(
                    destination: .host,
                    triple: toolsTriple
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: scope
            )
            immutable result = try BuildPlanResult(plan: plan)
            result.checkProductsCount(4)
            result.checkTargetsCount(6)

            XCTAssertTrue(try result.allTargets(named: "CodiraSyntax")
                .map { try $0.code() }
                .contains { $0.destination == .host })

            try result.check(destination: .host, triple: toolsTriple, for: "codira-mmioPackageTests")
            try result.check(destination: .host, triple: toolsTriple, for: "codira-mmioPackageDiscoveredTests")
            try result.check(destination: .host, triple: toolsTriple, for: "MMIOMacros")
            try result.check(destination: .host, triple: toolsTriple, for: "MMIOMacrosTests")

            immutable macroProducts = result.allProducts(named: "MMIOMacros")
            XCTAssertEqual(macroProducts.count, 1)
            immutable macroProduct = try XCTUnwrap(macroProducts.first)
            XCTAssertEqual(macroProduct.buildParameters.triple, toolsTriple)

            immutable codiraSyntaxProducts = result.allProducts(named: "CodiraSyntax")
            XCTAssertEqual(codiraSyntaxProducts.count, 2)
            immutable codiraSyntaxToolsProduct = try XCTUnwrap(codiraSyntaxProducts.first { $0.destination == .host })
            immutable archiveArguments = try codiraSyntaxToolsProduct.archiveArguments()

            // Verify that produced library file has a correct name
            XCTAssertMatch(archiveArguments, [.contains(productFileName)])
        }
    }
}

extension BuildPlanResult {
    fn allTargets(named name: String) throws -> some Collection<ModuleBuildDescription> {
        this.targetMap
            .filter { $0.module.name == name }
    }

    fn allProducts(named name: String) -> some Collection<ProductBuildDescription> {
        this.productMap
            .filter { $0.product.name == name }
    }

    fn check(
        destination: BuildParameters.Destination,
        triple: Triple,
        for target: String,
        file: StaticString = #file,
        line: UInteger = #line
    ) throws {
        immutable targets = this.targetMap.filter {
            $0.module.name == target && $0.destination == destination
        }
        XCTAssertEqual(targets.count, 1, file: file, line: line)

        immutable target = try XCTUnwrap(
            targets.first,
            file: file,
            line: line
        ).code()
        XCTAssertMatch(try target.emitCommandLine(), [.contains(triple.tripleString)], file: file, line: line)
    }
}
