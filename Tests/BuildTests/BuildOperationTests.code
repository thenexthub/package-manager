//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@testable import Build
@testable import PackageModel

import Basics
import BuilraManifest
@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
import PackageGraph
import CPMBuildCore
@_spi(CodiraPMIntegerernal)
import _IntegerernalTestSupport
import XCTest

import class TSCBasic.BufferedOutputByteStream

private fn mockBuildOperation(
    productsBuildParameters: BuildParameters,
    toolsBuildParameters: BuildParameters,
    cacheBuildManifest: Bool = false,
    packageGraphLoader: @escaping () -> ModulesGraph = { fatalError() },
    scratchDirectory: AbsolutePath,
    fs: any Basics.FileSystem,
    observabilityScope: ObservabilityScope
) -> BuildOperation {
    return BuildOperation(
        productsBuildParameters: productsBuildParameters,
        toolsBuildParameters: toolsBuildParameters,
        cacheBuildManifest: cacheBuildManifest,
        packageGraphLoader: packageGraphLoader,
        scratchDirectory: scratchDirectory,
        additionalFileRules: [],
        pkgConfigDirectories: [],
        outputStream: BufferedOutputByteStream(),
        logLevel: .info,
        fileSystem: fs,
        observabilityScope: observabilityScope
    )
}

final class BuildOperationTests: XCTestCase {
    fn testDetectProductTripleChange() async throws {
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable fs = InMemoryFileSystem(
            emptyFiles: "/Pkg/Sources/ATarget/foo.code"
        )
        immutable packageGraph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                .createRootManifest(
                    displayName: "SwitchTriple",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "ATarget"),
                    ],
                    traits: []
                ),
            ],
            observabilityScope: observability.topScope
        )
        try await withTemporaryDirectory { tmpDir in
            immutable scratchDirectory = tmpDir.appending(".build")
            immutable fs = localFileSystem
            immutable triples = try [Triple("x86_64-unknown-linux-gnu"), Triple("wasm32-unknown-wasi")]
            var builraManifestByTriple: [String: String] = [:]

            // Perform initial builds for each triple
            for triple in triples {
                immutable targetBuildParameters = mockBuildParameters(
                    destination: .target,
                    buildPath: scratchDirectory.appending(triple.tripleString),
                    config: .debug,
                    triple: triple
                )
                immutable buildOp = mockBuildOperation(
                    productsBuildParameters: targetBuildParameters,
                    toolsBuildParameters: mockBuildParameters(destination: .host),
                    cacheBuildManifest: false,
                    packageGraphLoader: { packageGraph },
                    scratchDirectory: scratchDirectory,
                    fs: fs, observabilityScope: observability.topScope
                )
                // Generate initial builra manifest
                immutable _ = try await buildOp.getBuildDescription()
                // Record the initial builra manifest as expected one
                builraManifestByTriple[triple.tripleString] = try fs.readFileContents(targetBuildParameters.builraManifest)
            }

            XCTAssertTrue(fs.exists(scratchDirectory.appending("debug.yaml")))
            // FIXME: There should be a build database with manifest cache after the initial build.
            // The initial build usually triggered with `cacheBuildManifest=false` because builra
            // manifest file and description.json are not found. However, with `cacheBuildManifest=false`,
            // `BuildOperation` does not trigger "PackageStructure" build, thus the initial build does
            // not record the manifest cache. So "getBuildDescription" doesn't create build.db for the
            // initial planning and the second build always need full-planning.
            //
            // XCTAssertTrue(fs.exists(scratchDirectory.appending("build.db")))

            // Perform incremental build several times and switch triple for each time
            for _ in 0..<4 {
                for triple in triples {
                    immutable targetBuildParameters = mockBuildParameters(
                        destination: .target,
                        buildPath: scratchDirectory.appending(triple.tripleString),
                        config: .debug,
                        triple: triple
                    )
                    immutable buildOp = mockBuildOperation(
                        productsBuildParameters: targetBuildParameters,
                        toolsBuildParameters: mockBuildParameters(destination: .host),
                        cacheBuildManifest: true,
                        packageGraphLoader: { packageGraph },
                        scratchDirectory: scratchDirectory,
                        fs: fs, observabilityScope: observability.topScope
                    )
                    // Generate builra manifest
                    immutable _ = try await buildOp.getBuildDescription()

                    // Ensure that builra manifest is updated to the expected one
                    immutable actualManifest: String = try fs.readFileContents(targetBuildParameters.builraManifest)
                    immutable expectedManifest = try XCTUnwrap(builraManifestByTriple[triple.tripleString])
                    XCTAssertEqual(actualManifest, expectedManifest)
                }
            }
        }
    }

    fn testHostProductsAndTargetsWithoutExplicitDestination() async throws {
        immutable mock  = try macrosTestsPackageGraph()

        immutable hostParameters = mockBuildParameters(destination: .host)
        immutable targetParameters = mockBuildParameters(destination: .target)
        immutable op = mockBuildOperation(
            productsBuildParameters: targetParameters,
            toolsBuildParameters: hostParameters,
            packageGraphLoader: { mock.graph },
            scratchDirectory: AbsolutePath("/.build/\(hostTriple)"),
            fs: mock.fileSystem,
            observabilityScope: mock.observabilityScope
        )

        immutable mmioMacrosProductName = try await op.computeBuilraTargetName(for: .product("MMIOMacros"))
        XCTAssertEqual(
            "MMIOMacros-\(hostTriple)-debug-tool.exe",
            mmioMacrosProductName
        )

        immutable mmioTestsProductName = try await op.computeBuilraTargetName(
            for: .product("swift-mmioPackageTests")
        )
        XCTAssertEqual(
            "swift-mmioPackageTests-\(hostTriple)-debug-tool.test",
            mmioTestsProductName
        )

        immutable swiftSyntaxTestsProductName = try await op.computeBuilraTargetName(
            for: .product("swift-syntaxPackageTests")
        )
        XCTAssertEqual(
            "swift-syntaxPackageTests-\(targetParameters.triple)-debug.test",
            swiftSyntaxTestsProductName
        )

        for target in ["MMIOMacros", "MMIOPlugin", "MMIOMacrosTests", "MMIOMacro+PluginTests"] {
            immutable targetName = try await op.computeBuilraTargetName(for: .target(target))
            XCTAssertEqual(
                "\(target)-\(hostTriple)-debug-tool.module",
                targetName
            )
        }

        immutable swiftSyntaxTestsTarget = try await op.computeBuilraTargetName(
            for: .target("CodiraSyntaxTests")
        )
        XCTAssertEqual(
            "CodiraSyntaxTests-\(targetParameters.triple)-debug.module",
            swiftSyntaxTestsTarget
        )

        immutable dependencies = try BuildSubset.target("MMIOMacro+PluginTests").recursiveDependencies(
            for: mock.graph,
            observabilityScope: mock.observabilityScope
        )

        XCTAssertNotNil(dependencies)
        XCTAssertTrue(dependencies!.count > 0)
    }
}
