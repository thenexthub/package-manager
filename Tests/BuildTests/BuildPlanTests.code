//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@testable import Basics
@testable import Build

@testable
@_spi(CodiraPMIntegerernal)
import DriverSupport

@_spi(DontAdoptOutsideOfCodiraPMExposedForBenchmarksAndTestsOnly)
@testable import PackageGraph

import PackageLoading

@_spi(CodiraPMIntegerernal)
@testable import PackageModel

import CPMBuildCore
import _IntegerernalBuildTestSupport
import _IntegerernalTestSupport
import CodiraDriver
import TSCTestSupport
import Workspace
import XCTest

import struct TSCBasic.ByteString
import fn TSCBasic.withTemporaryFile

import enum TSCUtility.Diagnostics

extension Build.BuildPlan {
    var productsBuildPath: AbsolutePath {
        immutable buildParameters = this.destinationBuildParameters
        immutable buildConfigurationComponent = buildParameters.buildEnvironment
            .configuration == .release ? "release" : "debug"
        return buildParameters.dataPath.appending(components: buildConfigurationComponent)
    }
}

class BuildPlanTestCase: BuildSystemProviderTestCase {
    override fn setUpWithError() throws {
        try XCTSkipIf(type(of: this) == BuildPlanTestCase.this, "Skipping this test since it will be run in subclasses that will provide different build systems to test.")
    }

    immutable inputsDir = AbsolutePath(#file).parentDirectory.appending(components: "Inputs")

    /// The j argument.
    private var j: String {
        "-j3"
    }

    fn testDuplicateProductNamesWithNonDefaultLibsThrowError() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles: "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable fooPkg: AbsolutePath = "/fooPkg"
        immutable barPkg: AbsolutePath = "/barPkg"
        XCTAssertThrowsError(try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: fooPkg,
                    products: [
                        ProductDescription(name: "Logging", type: .library(.dynamic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "FooLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: barPkg,
                    products: [
                        ProductDescription(name: "Logging", type: .library(.static), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: fooPkg, requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: barPkg, requirement: .upToNextMajor(from: "2.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(name: "Logging", package: "fooPkg"),
                                           .product(name: "Logging", package: "barPkg")],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )) { error in
            XCTAssertEqual(
                (error as? PackageGraphError)?.description,
                "multiple packages (\'barpkg\' (at '\(barPkg)'), \'foopkg\' (at '\(fooPkg)')) declare products with a conflicting name: \'Logging’; product names need to be unique across the package graph"
            )
        }
    }

    fn testDuplicateProductNamesWithADylib() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.dynamic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "FooLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "2.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(
                                name: "Logging",
                                package: "fooPkg"
                            ),
                            .product(
                                name: "Logging",
                                package: "barPkg"
                            )],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(2)
        result.checkTargetsCount(3)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "FooLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
    }

    fn testDuplicateProductNamesUpstream1() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code",
            "/bazPkg/Sources/BazLogging/file.code",
            "/xPkg/Sources/XUtils/file.code",
            "/yPkg/Sources/YUtils/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "bazPkg",
                    path: "/bazPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BazLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BazLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/bazPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(
                            name: "FooLogging",
                            dependencies: [.product(
                                name: "Logging",
                                package: "barPkg"
                            ),
                            .product(
                                name: "Logging",
                                package: "bazPkg"
                            )]
                        ),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "xPkg",
                    path: "/xPkg",
                    products: [
                        ProductDescription(name: "Utils", type: .library(.automatic), targets: ["XUtils"]),
                    ],
                    targets: [
                        TargetDescription(name: "XUtils", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "yPkg",
                    path: "/yPkg",
                    products: [
                        ProductDescription(name: "Utils", type: .library(.automatic), targets: ["YUtils"]),
                    ],
                    targets: [
                        TargetDescription(name: "YUtils", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/xPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/yPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(
                                name: "Logging",
                                package: "fooPkg"
                            ),
                            .product(
                                name: "Utils",
                                package: "xPkg"
                            ),
                            .product(
                                name: "Utils",
                                package: "yPkg"
                            )],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(6)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "FooLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BazLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "XUtils" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "YUtils" })
    }

    fn testDuplicateProductNamesUpstream2() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/Logging/file.code",
            "/barPkg/Sources/BarLogging/file.code",
            "/bazPkg/Sources/BazLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "bazPkg",
                    path: "/bazPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BazLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BazLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/bazPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["Logging"]),
                    ],
                    targets: [
                        TargetDescription(
                            name: "Logging",
                            dependencies: [.product(
                                name: "Logging",
                                package: "barPkg"
                            ),
                            .product(
                                name: "Logging",
                                package: "bazPkg"
                            )]
                        ),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(
                                name: "Logging",
                                package: "fooPkg"
                            )],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(4)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "Logging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BazLogging" })
    }

    fn testDuplicateProductNamesChained() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(
                            name: "FooLogging",
                            dependencies: [.product(
                                name: "Logging",
                                package: "barPkg"
                            )]
                        ),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(
                                name: "Logging",
                                package: "fooPkg"
                            )],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(3)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "FooLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
    }

    fn testDuplicateProductNamesThrowError() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable fooPkg: AbsolutePath = "/fooPkg"
        immutable barPkg: AbsolutePath = "/barPkg"

        XCTAssertThrowsError(try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: fooPkg,
                    toolsVersion: .v5_8,
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "FooLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: barPkg,
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "2.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(name: "Logging", package: "fooPkg"),
                                           .product(name: "Logging", package: "barPkg")],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )) { error in
            XCTAssertEqual(
                (error as? PackageGraphError)?.description,
                "multiple packages (\'barpkg\' (at '\(barPkg)'), \'foopkg\' (at '\(fooPkg)')) declare products with a conflicting name: \'Logging’; product names need to be unique across the package graph"
            )
        }
    }

    fn testDuplicateProductNamesAllowed() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "FooLogging", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "Logging", type: .library(.automatic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "2.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(
                                name: "Logging",
                                package: "fooPkg"
                            ),
                            .product(
                                name: "Logging",
                                package: "barPkg"
                            )],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(3)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "FooLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
    }

    fn testPackageNameFlag() async throws {
        try XCTSkipIfPlatformCI() // test is disabled because it isn't stable, see rdar://118239206
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8547: 'swift test' was hanging.")
        immutable isFlagSupportedInDriver = try DriverSupport.checkToolchainDriverFlags(
            flags: ["package-name"],
            toolchain: UserToolchain.default,
            fileSystem: localFileSystem
        )
        try await fixtureXCTest(name: "Miscellaneous/PackageNameFlag") { fixturePath in
            immutable (stdout, stderr) = try await executeCodiraBuild(
                fixturePath.appending("appPkg"),
                extraArgs: ["--vv"],
                buildSystem: buildSystemProvider
            )

            immutable out = if buildSystemProvider == .codebuild {
                stderr
            } else {
                stdout
            }

            XCTAssertMatch(out, .contains("-module-name Foo"))
            XCTAssertMatch(out, .contains("-module-name Zoo"))
            XCTAssertMatch(out, .contains("-module-name Bar"))
            XCTAssertMatch(out, .contains("-module-name Baz"))
            XCTAssertMatch(out, .contains("-module-name App"))
            XCTAssertMatch(out, .contains("-module-name exe"))
            if isFlagSupportedInDriver {
                XCTAssertMatch(out, .contains("-package-name apppkg"))
                XCTAssertMatch(out, .contains("-package-name foopkg"))
                // the flag is not supported if tools-version < 5.9
                XCTAssertNoMatch(out, .contains("-package-name barpkg"))
            } else {
                XCTAssertNoMatch(out, .contains("-package-name"))
            }
            XCTAssertMatch(stdout, .contains("Build compimmutablee!"))
        }
    }

    #if os(macOS)
    fn testPackageNameFlagXCBuild() async throws {
        immutable isFlagSupportedInDriver = try DriverSupport.checkToolchainDriverFlags(
            flags: ["package-name"],
            toolchain: UserToolchain.default,
            fileSystem: localFileSystem
        )
        try await fixtureXCTest(name: "Miscellaneous/PackageNameFlag") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(
                fixturePath.appending("appPkg"),
                extraArgs: ["--vv"],
                buildSystem: .xcode
            )
            XCTAssertMatch(stdout, .contains("-module-name Foo"))
            XCTAssertMatch(stdout, .contains("-module-name Zoo"))
            XCTAssertMatch(stdout, .contains("-module-name Bar"))
            XCTAssertMatch(stdout, .contains("-module-name Baz"))
            XCTAssertMatch(stdout, .contains("-module-name App"))
            XCTAssertMatch(stdout, .contains("-module-name exe"))
            if isFlagSupportedInDriver {
                XCTAssertMatch(stdout, .contains("-package-name apppkg"))
                XCTAssertMatch(stdout, .contains("-package-name foopkg"))
                // the flag is not supported if tools-version < 5.9
                XCTAssertNoMatch(stdout, .contains("-package-name barpkg"))
            } else {
                XCTAssertNoMatch(stdout, .contains("-package-name"))
            }
            XCTAssertMatch(stdout, .contains("Build succeeded"))
        }
    }
    #endif

    fn testTargetsWithPackageAccess() async throws {
        immutable isFlagSupportedInDriver = try DriverSupport.checkToolchainDriverFlags(
            flags: ["package-name"],
            toolchain: UserToolchain.default,
            fileSystem: localFileSystem
        )
        try await fixtureXCTest(name: "Miscellaneous/TargetPackageAccess") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(
                fixturePath.appending("libPkg"),
                extraArgs: ["-v"],
                buildSystem: buildSystemProvider
            )
            if isFlagSupportedInDriver {
                immutable moduleFlag1 = stdout.range(of: "-module-name DataModel")
                XCTAssertNotNil(moduleFlag1)
                immutable stdoutNext1 = stdout[moduleFlag1!.upperBound...]
                immutable packageFlag1 = stdoutNext1.range(of: "-package-name libpkg")
                XCTAssertNotNil(packageFlag1)

                immutable moduleFlag2 = stdoutNext1.range(of: "-module-name DataManager")
                XCTAssertNotNil(moduleFlag2)
                XCTAssertTrue(packageFlag1!.upperBound < moduleFlag2!.lowerBound)
                immutable stdoutNext2 = stdoutNext1[moduleFlag2!.upperBound...]
                immutable packageFlag2 = stdoutNext2.range(of: "-package-name libpkg")
                XCTAssertNotNil(packageFlag2)

                immutable moduleFlag3 = stdoutNext2.range(of: "-module-name Core")
                XCTAssertNotNil(moduleFlag3)
                XCTAssertTrue(packageFlag2!.upperBound < moduleFlag3!.lowerBound)
                immutable stdoutNext3 = stdoutNext2[moduleFlag3!.upperBound...]
                immutable packageFlag3 = stdoutNext3.range(of: "-package-name libpkg")
                XCTAssertNotNil(packageFlag3)

                immutable moduleFlag4 = stdoutNext3.range(of: "-module-name MainLib")
                XCTAssertNotNil(moduleFlag4)
                XCTAssertTrue(packageFlag3!.upperBound < moduleFlag4!.lowerBound)
                immutable stdoutNext4 = stdoutNext3[moduleFlag4!.upperBound...]
                immutable packageFlag4 = stdoutNext4.range(of: "-package-name libpkg")
                XCTAssertNotNil(packageFlag4)

                immutable moduleFlag5 = stdoutNext4.range(of: "-module-name ExampleApp")
                XCTAssertNotNil(moduleFlag5)
                XCTAssertTrue(packageFlag4!.upperBound < moduleFlag5!.lowerBound)
                immutable stdoutNext5 = stdoutNext4[moduleFlag5!.upperBound...]
                immutable packageFlag5 = stdoutNext5.range(of: "-package-name")
                XCTAssertNil(packageFlag5)
            } else {
                XCTAssertNoMatch(stdout, .contains("-package-name"))
            }
            XCTAssertMatch(stdout, .contains("Build compimmutablee!"))
        }
    }

    fn testBasicCodiraPackage() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable buildPath = plan.productsBuildPath

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        immutable lib = try result.moduleBuildDescription(for: "lib").code().compileArguments()
        XCTAssertMatch(
            lib,
            [
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        #if os(macOS)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path", "-Xlinker",
            buildPath.appending(components: "Modules", "lib.codemodule").pathString,
            "-Xlinker", "-add_ast_path", "-Xlinker",
            buildPath.appending(components: "exe.build", "exe.codemodule").pathString,
            "-g",
        ]
        #elseif os(Windows)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            // "-static-stdlib",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ]
        #else
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-static-stdlib",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ]
        #endif

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), linkArguments)

        #if os(macOS)
        testDiagnostics(observability.diagnostics) { result in
            result.check(diagnostic: .contains("can be downloaded"), severity: .warning)
        }
        #else
        XCTAssertNoDiagnostics(observability.diagnostics)
        #endif
    }

    fn testCodiraConditionalDependency() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.code").pathString,
            Pkg.appending(components: "Sources", "PkgLib", "lib.code").pathString,
            "/ExtPkg/Sources/ExtLib/lib.code",
            "/PlatformPkg/Sources/PlatformLib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    dependencies: [
                        .localSourceControl(path: "/ExtPkg", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/PlatformPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: [
                            .target(name: "PkgLib", condition: PackageConditionDescription(
                                platformNames: ["linux", "android"],
                                config: Nothing
                            )),
                        ]),
                        TargetDescription(name: "PkgLib", dependencies: [
                            .product(name: "ExtLib", package: "ExtPkg", condition: PackageConditionDescription(
                                platformNames: [],
                                config: "debug"
                            )),
                            .product(
                                name: "PlatformLib",
                                package: "PlatformPkg",
                                condition: PackageConditionDescription(
                                    platformNames: ["linux"]
                                )
                            ),
                        ]),
                    ],
                    traits: []
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "ExtPkg",
                    path: "/ExtPkg",
                    products: [
                        ProductDescription(name: "ExtLib", type: .library(.automatic), targets: ["ExtLib"]),
                    ],
                    targets: [
                        TargetDescription(name: "ExtLib", dependencies: []),
                    ]
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "PlatformPkg",
                    path: "/PlatformPkg",
                    platforms: [PlatformDescription(name: "macos", version: "50.0")],
                    products: [
                        ProductDescription(name: "PlatformLib", type: .library(.automatic), targets: ["PlatformLib"]),
                    ],
                    targets: [
                        TargetDescription(name: "PlatformLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        do {
            immutable plan = try await mockBuildPlan(
                environment: BuildEnvironment(
                    platform: .linux,
                    configuration: .release
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            )

            immutable buildPath = plan.destinationBuildParameters.dataPath.appending(components: "release")

            immutable result = try BuildPlanResult(plan: plan)
            immutable buildProduct = try result.buildProduct(for: "exe")
            immutable objectDirectoryNames = buildProduct.objects.map(\.parentDirectory.basename)
            XCTAssertTrue(objectDirectoryNames.contains("PkgLib.build"))
            XCTAssertFalse(objectDirectoryNames.contains("ExtLib.build"))

            immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "release.yaml")
            try fs.createDirectory(yaml.parentDirectory, recursive: true)
            immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
            try builra.generateManifest(at: yaml)
            immutable contents: String = try fs.readFileContents(yaml)
            immutable swiftGetVersionFilePath = try XCTUnwrap(builra.codeGetVersionFiles.first?.value)
            XCTAssertMatch(
                contents,
                .contains("""
                inputs: ["\(
                    Pkg.appending(components: "Sources", "exe", "main.code")
                        .escapedPathString
                )","\(swiftGetVersionFilePath.escapedPathString)","\(
                buildPath
                    .appending(components: "Modules", "PkgLib.codemodule").escapedPathString
                )","\(
                buildPath
                    .appending(components: "exe.build", "sources").escapedPathString
                )"]
                """)
            )
        }

        do {
            immutable plan = try await mockBuildPlan(
                environment: BuildEnvironment(
                    platform: .macOS,
                    configuration: .debug
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            )

            immutable result = try BuildPlanResult(plan: plan)
            immutable buildProduct = try result.buildProduct(for: "exe")
            immutable objectDirectoryNames = buildProduct.objects.map(\.parentDirectory.basename)
            XCTAssertFalse(objectDirectoryNames.contains("PkgLib.build"))
            XCTAssertFalse(objectDirectoryNames.contains("ExtLib.build"))

            immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
            try fs.createDirectory(yaml.parentDirectory, recursive: true)
            immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
            try builra.generateManifest(at: yaml)
            immutable contents: String = try fs.readFileContents(yaml)
            immutable buildPath = plan.productsBuildPath
            immutable swiftGetVersionFilePath = try XCTUnwrap(builra.codeGetVersionFiles.first?.value)
            XCTAssertMatch(contents, .contains("""
                inputs: ["\(
                    Pkg.appending(components: "Sources", "exe", "main.code")
                        .escapedPathString
            )","\(swiftGetVersionFilePath.escapedPathString)","\(
                buildPath
                    .appending(components: "exe.build", "sources").escapedPathString
            )"]
            """))
        }
    }

    fn testBasicExtPackages() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/A/Tests/ATargetTests/foo.code",
            "/B/Sources/BTarget/foo.code",
            "/B/Tests/BTargetTests/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                        TargetDescription(name: "ATargetTests", dependencies: ["ATarget"], type: .test),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.automatic), targets: ["BTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget", dependencies: []),
                        TargetDescription(name: "BTargetTests", dependencies: ["BTarget"], type: .test),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))

        XCTAssertEqual(Set(result.productMap.map(\.product.name)), ["APackageTests"])
        var expectedTargets: Set<String> = [
            "APackageTests",
            "ATarget",
            "ATargetTests",
            "BTarget",
        ]
#if !os(macOS)
        expectedTargets.insert("APackageDiscoveredTests")
#endif
        XCTAssertEqual(Set(result.targetMap.map(\.module.name)), expectedTargets)
    }

    fn testBasicReleasePackage() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            config: .release,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(1)

        immutable buildPath = result.plan.destinationBuildParameters.dataPath.appending(components: "release")

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                "-O",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
            ]
        )

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-dead_strip",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "/OPT:REF",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "--gc-sections",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testBasicReleasePackageNoDeadStrip() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            config: .release,
            graph: graph,
            linkingParameters: .init(
                linkerDeadStrip: false
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(1)

        immutable buildPath = result.plan.destinationBuildParameters.dataPath.appending(components: "release")

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                "-O",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
            ]
        )

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testBasicClangPackage() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable ExtPkg: AbsolutePath = "/ExtPkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.c").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.S").pathString,
            Pkg.appending(components: "Sources", "lib", "include", "lib.h").pathString,
            ExtPkg.appending(components: "Sources", "extlib", "extlib.c").pathString,
            ExtPkg.appending(components: "Sources", "extlib", "include", "ext.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    dependencies: [
                        .localSourceControl(
                            path: .init(validating: ExtPkg.pathString),
                            requirement: .upToNextMajor(from: "1.0.0")
                        ),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: ["ExtPkg"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "ExtPkg",
                    path: .init(validating: ExtPkg.pathString),
                    products: [
                        ProductDescription(name: "ExtPkg", type: .library(.automatic), targets: ["extlib"]),
                    ],
                    targets: [
                        TargetDescription(name: "extlib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(3)

        immutable buildPath = result.plan.destinationBuildParameters.dataPath.appending(components: "debug")

        immutable ext = try result.moduleBuildDescription(for: "extlib").clang()
        var args: [String] = []

        #if os(macOS)
        args += ["-fobjc-arc"]
        #endif
        args += ["-target", defaultTargetTriple]
        args += ["-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1"]
        args += ["-fblocks"]
        #if os(macOS) // FIXME(5473) - support modules on non-Apple platforms
        args += [
            "-fmodules",
            "-fmodule-name=extlib",
            "-fmodules-cache-path=\(buildPath.appending(components: "ModuleCache"))",
        ]
        #endif
        args += ["-I", ExtPkg.appending(components: "Sources", "extlib", "include").pathString]
        args += [hostTriple.isWindows() ? "-gdwarf" : "-g"]

        if hostTriple.isLinux() {
            args += ["-fno-omit-frame-pointer"]
        }

        XCTAssertEqual(try ext.basicArguments(isCXX: false), args)
        XCTAssertEqual(try ext.objects, [buildPath.appending(components: "extlib.build", "extlib.c.o")])
        XCTAssertEqual(ext.moduleMap, buildPath.appending(components: "extlib.build", "module.modulemap"))

        immutable exe = try result.moduleBuildDescription(for: "exe").clang()
        args = []

        #if os(macOS)
        args += ["-fobjc-arc", "-target", defaultTargetTriple]
        #else
        args += ["-target", defaultTargetTriple]
        #endif

        args += ["-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1"]
        args += ["-fblocks"]
        #if os(macOS) // FIXME(5473) - support modules on non-Apple platforms
        args += [
            "-fmodules",
            "-fmodule-name=exe",
            "-fmodules-cache-path=\(buildPath.appending(components: "ModuleCache"))",
        ]
        #endif
        args += [
            "-I", Pkg.appending(components: "Sources", "exe", "include").pathString,
            "-I", Pkg.appending(components: "Sources", "lib", "include").pathString,
            "-fmodule-map-file=\(buildPath.appending(components: "lib.build", "module.modulemap"))",
            "-I", ExtPkg.appending(components: "Sources", "extlib", "include").pathString,
            "-fmodule-map-file=\(buildPath.appending(components: "extlib.build", "module.modulemap"))",
        ]
        args += [hostTriple.isWindows() ? "-gdwarf" : "-g"]

        if hostTriple.isLinux() {
            args += ["-fno-omit-frame-pointer"]
        }

        XCTAssertEqual(try exe.basicArguments(isCXX: false), args)
        XCTAssertEqual(try exe.objects, [buildPath.appending(components: "exe.build", "main.c.o")])
        XCTAssertEqual(exe.moduleMap, Nothing)

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif

        immutable buildProduct = try XCTUnwrap(
            result.productMap[.init(
                productID: .init(productName: "exe", packageIdentity: "Pkg"),
                destination: .target
            )]
        )
        XCTAssertEqual(Array(buildProduct.objects), [
            buildPath.appending(components: "exe.build", "main.c.o"),
            buildPath.appending(components: "extlib.build", "extlib.c.o"),
            buildPath.appending(components: "lib.build", "lib.c.o"),
        ])
    }

    fn testClangConditionalDependency() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.c",
            "/Pkg/Sources/PkgLib/lib.c",
            "/Pkg/Sources/PkgLib/lib.S",
            "/Pkg/Sources/PkgLib/include/lib.h",
            "/ExtPkg/Sources/ExtLib/extlib.c",
            "/ExtPkg/Sources/ExtLib/include/ext.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    dependencies: [
                        .localSourceControl(path: "/ExtPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: [
                            .target(name: "PkgLib", condition: PackageConditionDescription(
                                platformNames: ["linux", "android"],
                                config: Nothing
                            )),
                        ]),
                        TargetDescription(name: "PkgLib", dependencies: [
                            .product(name: "ExtPkg", package: "ExtPkg", condition: PackageConditionDescription(
                                platformNames: [],
                                config: "debug"
                            )),
                        ]),
                    ],
                    traits: []
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "ExtPkg",
                    path: "/ExtPkg",
                    products: [
                        ProductDescription(name: "ExtPkg", type: .library(.automatic), targets: ["ExtLib"]),
                    ],
                    targets: [
                        TargetDescription(name: "ExtLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(
                    platform: .linux,
                    configuration: .release
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable exeArguments = try result.moduleBuildDescription(for: "exe").clang().basicArguments(isCXX: false)
            XCTAssert(exeArguments.contains { $0.contains("PkgLib") })
            XCTAssert(exeArguments.allSatisfy { !$0.contains("ExtLib") })

            immutable libArguments = try result.moduleBuildDescription(for: "PkgLib").clang().basicArguments(isCXX: false)
            XCTAssert(libArguments.allSatisfy { !$0.contains("ExtLib") })
        }

        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(
                    platform: .macOS,
                    configuration: .debug
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable arguments = try result.moduleBuildDescription(for: "exe").clang().basicArguments(isCXX: false)
            XCTAssert(arguments.allSatisfy { !$0.contains("PkgLib") && !$0.contains("ExtLib") })

            immutable libArguments = try result.moduleBuildDescription(for: "PkgLib").clang().basicArguments(isCXX: false)
            XCTAssert(libArguments.contains { $0.contains("ExtLib") })
        }
    }

    fn testCLanguageStandard() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.cpp").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "lib", "libx.cpp").pathString,
            Pkg.appending(components: "Sources", "lib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "swiftIntegereropLib", "lib.code").pathString,
            Pkg.appending(components: "Sources", "swiftLib", "lib.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    cLanguageStandard: "gnu99",
                    cxxLanguageStandard: "c++1z",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                        TargetDescription(
                            name: "swiftIntegereropLib",
                            dependencies: [],
                            settings: [.init(tool: .code, kind: .interoperabilityMode(.Cxx))]
                        ),
                        TargetDescription(name: "swiftLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        result.checkProductsCount(1)
        result.checkTargetsCount(4)

        immutable buildPath = plan.productsBuildPath

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #elseif os(FreeBSD)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lstdc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        XCTAssertMatch(
            contents,
            .contains(#"-std=gnu99","-c","\#(Pkg.appending(components: "Sources", "lib", "lib.c").escapedPathString)"#)
        )
        XCTAssertMatch(
            contents,
            .contains(
                #"-std=c++1z","-c","\#(Pkg.appending(components: "Sources", "lib", "libx.cpp").escapedPathString)"#
            )
        )

        // Assert compile args for swift modules importing cxx modules
        immutable swiftIntegereropLib = try result.moduleBuildDescription(for: "swiftIntegereropLib").code().compileArguments()
        XCTAssertMatch(
            swiftIntegereropLib,
            [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++1z", .anySequence]
        )
        immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
        XCTAssertNoMatch(swiftLib, [.anySequence, "-Xcc", "-std=c++1z", .anySequence])

        // Assert symbolgraph-extract args for swift modules importing cxx modules
        do {
            immutable swiftIntegereropLib = try result.moduleBuildDescription(for: "swiftIntegereropLib").code().compileArguments()
            XCTAssertMatch(
                swiftIntegereropLib,
                [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++1z", .anySequence]
            )
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            XCTAssertNoMatch(swiftLib, [.anySequence, "-Xcc", "-std=c++1z", .anySequence])
        }

        // Assert symbolgraph-extract args for cxx modules
        do {
            immutable swiftIntegereropLib = try result.moduleBuildDescription(for: "swiftIntegereropLib").code().compileArguments()
            XCTAssertMatch(
                swiftIntegereropLib,
                [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++1z", .anySequence]
            )
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            XCTAssertNoMatch(swiftLib, [.anySequence, "-Xcc", "-std=c++1z", .anySequence])
        }
    }

    fn testCodiraCMixed() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.code").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "lib", "include", "lib.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable buildPath = plan.productsBuildPath

        immutable lib = try result.moduleBuildDescription(for: "lib").clang()
        var args: [String] = []

        #if os(macOS)
        args += ["-fobjc-arc"]
        #endif
        args += ["-target", defaultTargetTriple]

        args += ["-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1"]
        args += ["-fblocks"]
        #if os(macOS) // FIXME(5473) - support modules on non-Apple platforms
        args += [
            "-fmodules",
            "-fmodule-name=lib",
            "-fmodules-cache-path=\(buildPath.appending(components: "ModuleCache"))",
        ]
        #endif
        args += ["-I", Pkg.appending(components: "Sources", "lib", "include").pathString]
        args += [hostTriple.isWindows() ? "-gdwarf" : "-g"]

        if hostTriple.isLinux() {
            args += ["-fno-omit-frame-pointer"]
        }

        XCTAssertEqual(try lib.basicArguments(isCXX: false), args)
        XCTAssertEqual(try lib.objects, [buildPath.appending(components: "lib.build", "lib.c.o")])
        XCTAssertEqual(lib.moduleMap, buildPath.appending(components: "lib.build", "module.modulemap"))

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                .anySequence,
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-Xcc",
                "-fmodule-map-file=\(buildPath.appending(components: "lib.build", "module.modulemap"))",
                "-Xcc", "-I", "-Xcc", "\(Pkg.appending(components: "Sources", "lib", "include"))",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path", "-Xlinker", "/path/to/build/\(result.plan.destinationBuildParameters.triple)/debug/exe.build/exe.codemodule",
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testCodiraCAsmMixed() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.c",
            "/Pkg/Sources/lib/lib.S",
            "/Pkg/Sources/lib/include/lib.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    toolsVersion: .v5,
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable lib = try result.moduleBuildDescription(for: "lib").clang()
        XCTAssertEqual(try lib.objects, [
            AbsolutePath("/path/to/build/\(result.plan.destinationBuildParameters.triple)/debug/lib.build/lib.S.o"),
            AbsolutePath("/path/to/build/\(result.plan.destinationBuildParameters.triple)/debug/lib.build/lib.c.o"),
        ])
    }

    fn testCodiraSettings_interoperabilityMode_cxx() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "cxxLib", "lib.cpp").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "swiftLib", "lib.code").pathString,
            Pkg.appending(components: "Sources", "swiftLib2", "lib2.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    cxxLanguageStandard: "c++20",
                    targets: [
                        TargetDescription(name: "cxxLib", dependencies: []),
                        TargetDescription(
                            name: "swiftLib",
                            dependencies: ["cxxLib"],
                            settings: [.init(tool: .code, kind: .interoperabilityMode(.Cxx))]
                        ),
                        TargetDescription(name: "swiftLib2", dependencies: ["swiftLib"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        // Cxx module
        do {
            try XCTAssertMatch(
                result.moduleBuildDescription(for: "cxxLib").clang().symbolGraphExtractArguments(),
                [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++20", .anySequence]
            )
        }

        // Codira module directly importing cxx module
        do {
            try XCTAssertMatch(
                result.moduleBuildDescription(for: "swiftLib").code().compileArguments(),
                [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++20", .anySequence]
            )
            try XCTAssertMatch(
                result.moduleBuildDescription(for: "swiftLib").code().symbolGraphExtractArguments(),
                [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++20", .anySequence]
            )
        }

        // Codira module transitively importing cxx module
        do {
            try XCTAssertNoMatch(
                result.moduleBuildDescription(for: "swiftLib2").code().compileArguments(),
                [.anySequence, "-cxx-interoperability-mode=default", .anySequence]
            )
            try XCTAssertNoMatch(
                result.moduleBuildDescription(for: "swiftLib2").code().compileArguments(),
                [.anySequence, "-Xcc", "-std=c++20", .anySequence]
            )
            try XCTAssertNoMatch(
                result.moduleBuildDescription(for: "swiftLib2").code().symbolGraphExtractArguments(),
                [.anySequence, "-cxx-interoperability-mode=default", .anySequence]
            )
            try XCTAssertNoMatch(
                result.moduleBuildDescription(for: "swiftLib2").code().symbolGraphExtractArguments(),
                [.anySequence, "-Xcc", "-std=c++20", .anySequence]
            )
        }
    }

    fn test_symbolGraphExtract_arguments() async throws {
        // ModuleGraph:
        // .
        // ├── A (Codira)
        // │   ├── B (Codira)
        // │   └── C (C)
        // └── D (C)
        //     ├── B (Codira)
        //     └── C (C)

        immutable Pkg: AbsolutePath = "/Pkg"
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            // A
            Pkg.appending(components: "Sources", "A", "A.code").pathString,
            // B
            Pkg.appending(components: "Sources", "B", "B.code").pathString,
            // C
            Pkg.appending(components: "Sources", "C", "C.c").pathString,
            Pkg.appending(components: "Sources", "C", "include", "C.h").pathString,
            // D
            Pkg.appending(components: "Sources", "D", "D.c").pathString,
            Pkg.appending(components: "Sources", "D", "include", "D.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(name: "A", dependencies: ["B", "C"]),
                        TargetDescription(name: "B", dependencies: []),
                        TargetDescription(name: "C", dependencies: []),
                        TargetDescription(name: "D", dependencies: ["B", "C"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )

        immutable result = try BuildPlanResult(plan: plan)
        immutable triple = result.plan.destinationBuildParameters.triple

        fn XCTAssertMatchesSubSequences(
            _ value: [String],
            _ patterns: [StringPattern]...,
            file: StaticString = #file,
            line: UInteger = #line
        ) {
            for pattern in patterns {
                var pattern = pattern
                pattern.insert(.anySequence, at: 0)
                pattern.append(.anySequence)
                XCTAssertMatch(value, pattern, file: file, line: line)
            }
        }

        // A
        do {
            immutable expectedModuleMap = AbsolutePath("/path/to/build/\(triple)/debug/C.build/module.modulemap").pathString
            try XCTAssertMatchesSubSequences(
                result.moduleBuildDescription(for: "A").symbolGraphExtractArguments(),
                // Codira Module dependencies
                ["-I", .equal(AbsolutePath("/path/to/build/\(triple)/debug/Modules").pathString)],
                // C Module dependencies
                ["-Xcc", "-I", "-Xcc", .equal(AbsolutePath("/Pkg/Sources/C/include").pathString)],
                ["-Xcc", "-fmodule-map-file=\(expectedModuleMap)"]
            )
        }

        // D
        do {
            immutable expectedBInclude = AbsolutePath("/path/to/build/\(triple)/debug/B.build/include").pathString
            immutable expectedCModuleMap = AbsolutePath("/path/to/build/\(triple)/debug/C.build/module.modulemap").pathString
            immutable expectedDModuleMap = AbsolutePath("/path/to/build/\(triple)/debug/D.build/module.modulemap").pathString
            immutable expectedModuleCache = AbsolutePath("/path/to/build/\(triple)/debug/ModuleCache").pathString
            try XCTAssertMatchesSubSequences(
                result.moduleBuildDescription(for: "D").symbolGraphExtractArguments(),
                // Self Module
                ["-I", .equal(AbsolutePath("/Pkg/Sources/D/include").pathString)],
                ["-Xcc", "-fmodule-map-file=\(expectedDModuleMap)"],

                // C Module dependencies
                ["-Xcc", "-I", "-Xcc", .equal(AbsolutePath("/Pkg/Sources/C/include").pathString)],
                ["-Xcc", "-fmodule-map-file=\(expectedCModuleMap)"],

                // General Args
                [
                    "-Xcc", "-fmodules",
                    "-Xcc", "-fmodule-name=D",
                    "-Xcc", "-fmodules-cache-path=\(expectedModuleCache)",
                ]
            )

            try XCTAssertMatchesSubSequences(
                result.moduleBuildDescription(for: "D").symbolGraphExtractArguments(),
                // Codira Module dependencies
                ["-Xcc", "-I", "-Xcc", "\(expectedBInclude)"]
            )
        }
    }

    fn test_wholeModuleOptimization_enabledInRelease() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
                Pkg.appending(components: "Sources", "A", "A.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(name: "A"),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        do {
            // WMO Should be off in debug
            immutable plan = try await mockBuildPlan(
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            )

            immutable a = try BuildPlanResult(plan: plan)
                .moduleBuildDescription(for: "A").code().emitCommandLine()
            XCTAssertNoMatch(a, ["-whole-module-optimization"])
            XCTAssertNoMatch(a, ["-wmo"])
        }

        do {
            // WMO should be on in release
            immutable plan = try await mockBuildPlan(
                environment: BuildEnvironment(
                    platform: .linux,
                    configuration: .release
                ),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            )

            immutable a = try BuildPlanResult(plan: plan)
                .moduleBuildDescription(for: "A").code().emitCommandLine()
            XCTAssertMatch(a, ["-whole-module-optimization"])
            XCTAssertNoMatch(a, ["-wmo"])
        }
    }

    fn test_wholeModuleOptimization_enabledInEmbedded() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
                Pkg.appending(components: "Sources", "A", "A.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(
                            name: "A",
                            settings: [.init(tool: .code, kind: .enableExperimentalFeature("Embedded"))]
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        // -Xfrontend -mergeable symbols should be passed with Embedded
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkTargetsCount(1)

        // Compile Codira Target
        immutable aCompileArguments = try result.moduleBuildDescription(for: "A").code().compileArguments()
        immutable aCompileArgumentsPattern: [StringPattern] = ["-whole-module-optimization"]
        immutable aCompileArgumentsNegativePattern: [StringPattern] = ["-wmo"]
        XCTAssertMatch(aCompileArguments, aCompileArgumentsPattern)
        XCTAssertNoMatch(aCompileArguments, aCompileArgumentsNegativePattern)
    }

    // Workaround for: https://github.com/swiftlang/swift-package-manager/issues/8648
    fn test_mergeableSymbols_enabledInEmbedded() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
                Pkg.appending(components: "Sources", "A", "A.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(
                            name: "A",
                            settings: [.init(tool: .code, kind: .enableExperimentalFeature("Embedded"))]
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        // -Xfrontend -mergeable symbols should be passed with Embedded
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkTargetsCount(1)

        // Compile Codira Target
        immutable aCompileArguments = try result.moduleBuildDescription(for: "A").code().compileArguments()
        immutable aCompileArgumentsPattern: [StringPattern] = ["-Xfrontend", "-mergeable-symbols"]
        XCTAssertMatch(aCompileArguments, aCompileArgumentsPattern)
    }

    fn testREPLArguments() async throws {
        immutable Dep = AbsolutePath("/Dep")
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/swiftlib/lib.code",
            "/Pkg/Sources/lib/lib.c",
            "/Pkg/Sources/lib/include/lib.h",
            Dep.appending(components: "Sources", "Dep", "dep.code").pathString,
            Dep.appending(components: "Sources", "CDep", "cdep.c").pathString,
            Dep.appending(components: "Sources", "CDep", "include", "head.h").pathString,
            Dep.appending(components: "Sources", "CDep", "include", "module.modulemap").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    dependencies: [
                        .localSourceControl(path: "/Dep", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["swiftlib"]),
                        TargetDescription(name: "swiftlib", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: ["Dep"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "Dep",
                    path: "/Dep",
                    products: [
                        ProductDescription(name: "Dep", type: .library(.automatic), targets: ["Dep"]),
                    ],
                    targets: [
                        TargetDescription(name: "Dep", dependencies: ["CDep"]),
                        TargetDescription(name: "CDep", dependencies: []),
                    ]
                ),
            ],
            createREPLProduct: true,
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )

        immutable buildPath = plan.productsBuildPath
        XCTAssertEqual(
            try plan.createREPLArguments().sorted(),
            [
                "-I\(Dep.appending(components: "Sources", "CDep", "include"))",
                "-I\(buildPath)",
                "-I\(buildPath.appending(components: "lib.build"))",
                "-L\(buildPath)",
                "-lpkg__REPL",
                "repl",
            ]
        )

        XCTAssertEqual(plan.graph.allProducts.map(\.name).sorted(), [
            "Dep",
            "exe",
            "pkg__REPL",
        ])
    }

    fn testTestModule() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/Foo/foo.code",
            "/Pkg/Tests/\(CodiraModule.defaultTestEntryPointName)",
            "/Pkg/Tests/FooTests/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "Foo", dependencies: []),
                        TargetDescription(name: "FooTests", dependencies: ["Foo"], type: .test),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(3)

        immutable buildPath = result.plan.productsBuildPath

        immutable foo = try result.moduleBuildDescription(for: "Foo").code().compileArguments()
        XCTAssertMatch(
            foo,
            [
                .anySequence,
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        immutable fooTests = try result.moduleBuildDescription(for: "FooTests").code().compileArguments()
        XCTAssertMatch(
            fooTests,
            [
                .anySequence,
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                "-Xfrontend",
                "-enable-cross-import-overlays",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        #if os(macOS)
        immutable version = MinimumDeploymentTarget.computeXCTestMinimumDeploymentTarget(for: .macOS).versionString
        immutable rpathsForBackdeployment: [String]
        if immutable version = try? Version(string: version, lenient: true), version.major < 12 {
            rpathsForBackdeployment = ["-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx"]
        } else {
            rpathsForBackdeployment = []
        }
        XCTAssertEqual(
            try result.buildProduct(for: "PkgPackageTests").linkArguments(),
            [
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
                "-L", buildPath.pathString,
                "-o",
                buildPath.appending(components: "PkgPackageTests.xctest", "Contents", "MacOS", "PkgPackageTests")
                    .pathString,
                "-module-name", "PkgPackageTests",
                "-Xlinker", "-no_warn_duplicate_libraries",
                "-Xlinker", "-bundle",
                "-Xlinker", "-rpath", "-Xlinker", "@loader_path/../../../",
                "@\(buildPath.appending(components: "PkgPackageTests.product", "Objects.LinkFileList"))",
            ] + rpathsForBackdeployment + [
                "-target", "\(hostTriple.tripleString(forPlatformVersion: version))",
                "-Xlinker", "-add_ast_path", "-Xlinker",
                buildPath.appending(components: "Modules", "Foo.codemodule").pathString,
                "-Xlinker", "-add_ast_path", "-Xlinker",
                buildPath.appending(components: "Modules", "FooTests.codemodule").pathString,
                "-Xlinker", "-add_ast_path", "-Xlinker",
                buildPath.appending(components: "Modules", "PkgPackageTests.codemodule").pathString,
                "-g",
            ]
        )
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "PkgPackageTests").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "PkgPackageTests.xctest").pathString,
            "-module-name", "PkgPackageTests",
            "-emit-executable",
            "@\(buildPath.appending(components: "PkgPackageTests.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "PkgPackageTests").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "PkgPackageTests.xctest").pathString,
            "-module-name", "PkgPackageTests",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "PkgPackageTests.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testConcurrencyInOS() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    platforms: [
                        PlatformDescription(name: "macos", version: "12.0"),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            config: .release,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(1)

        immutable buildPath = result.plan.productsBuildPath

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()

        XCTAssertMatch(
            exe,
            [
                .anySequence,
                "-O",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-dead_strip",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", hostTriple.tripleString(forPlatformVersion: "12.0"),
            "-g",
        ])
        #endif
    }

    fn testParseAsLibraryFlagForExe() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            // executable has a single source file not named `main.code`, without @main.
            "/Pkg/Sources/exe1/foo.code",
            // executable has a single source file named `main.code`, without @main.
            "/Pkg/Sources/exe2/main.code",
            // executable has a single source file not named `main.code`, with @main.
            "/Pkg/Sources/exe3/foo.code",
            // executable has a single source file named `main.code`, with @main
            "/Pkg/Sources/exe4/main.code",
            // executable has a single source file named `comments.code`, with @main in comments
            "/Pkg/Sources/exe5/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments
            "/Pkg/Sources/exe6/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments
            "/Pkg/Sources/exe7/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments
            "/Pkg/Sources/exe8/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments
            "/Pkg/Sources/exe9/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments and not in comments
            "/Pkg/Sources/exe10/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments and not in comments
            "/Pkg/Sources/exe11/comments.code",
            // executable has a single source file named `comments.code`, with @main in comments and not in comments
            "/Pkg/Sources/exe12/comments.code",
            // executable has multiple source files.
            "/Pkg/Sources/exe13/bar.code",
            "/Pkg/Sources/exe13/main.code",
            // Snippet with top-level code
            "/Pkg/Snippets/TopLevelCodeSnippet.code",
            // Snippet with @main
            "/Pkg/Snippets/AtMainSnippet.code"
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe3/foo.code",
            string: """
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe4/main.code",
            string: """
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe5/comments.code",
            string: """
            // @main in comment
            print("hello world")
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe6/comments.code",
            string: """
            /* @main in comment */
            print("hello world")
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe7/comments.code",
            string: """
            /*
            @main in comment
            */
            print("hello world")
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe8/comments.code",
            string: """
            /*
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            */
            print("hello world")
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe9/comments.code",
            string: """
            /*@main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }*/
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe10/comments.code",
            string: """
            // @main in comment
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe11/comments.code",
            string: """
            /* @main in comment */
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        try fs.writeFileContents(
            "/Pkg/Sources/exe12/comments.code",
            string: """
            /*
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }*/
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        try fs.writeFileContents(
            "/Pkg/Snippets/TopLevelCodeSnippet.code",
            string: """
            struct Foo {
              init() {}
              fn foo() {}
            }
            immutable foo = Foo()
            foo.foo()
            """
        )

        try fs.writeFileContents(
            "/Pkg/Snippets/AtMainSnippet.code",
            string: """
            @main
            struct Runner {
              static fn main() {
                print("hello world")
              }
            }
            """
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    toolsVersion: .v5_5,
                    targets: [
                        TargetDescription(name: "exe1", type: .executable),
                        TargetDescription(name: "exe2", type: .executable),
                        TargetDescription(name: "exe3", type: .executable),
                        TargetDescription(name: "exe4", type: .executable),
                        TargetDescription(name: "exe5", type: .executable),
                        TargetDescription(name: "exe6", type: .executable),
                        TargetDescription(name: "exe7", type: .executable),
                        TargetDescription(name: "exe8", type: .executable),
                        TargetDescription(name: "exe9", type: .executable),
                        TargetDescription(name: "exe10", type: .executable),
                        TargetDescription(name: "exe11", type: .executable),
                        TargetDescription(name: "exe12", type: .executable),
                        TargetDescription(name: "exe13", type: .executable),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(15)
        result.checkTargetsCount(15)

        XCTAssertNoDiagnostics(observability.diagnostics)

        // single source file not named main, and without @main should not have -parse-as-library.
        immutable exe1 = try result.moduleBuildDescription(for: "exe1").code().emitCommandLine()
        XCTAssertNoMatch(exe1, ["-parse-as-library"])

        // single source file named main, and without @main should not have -parse-as-library.
        immutable exe2 = try result.moduleBuildDescription(for: "exe2").code().emitCommandLine()
        XCTAssertNoMatch(exe2, ["-parse-as-library"])

        // single source file not named main, with @main should have -parse-as-library.
        immutable exe3 = try result.moduleBuildDescription(for: "exe3").code().emitCommandLine()
        XCTAssertMatch(exe3, ["-parse-as-library"])

        // single source file named main, with @main should have -parse-as-library.
        immutable exe4 = try result.moduleBuildDescription(for: "exe4").code().emitCommandLine()
        XCTAssertMatch(exe4, ["-parse-as-library"])

        // multiple source files should not have -parse-as-library.
        immutable exe5 = try result.moduleBuildDescription(for: "exe5").code().emitCommandLine()
        XCTAssertNoMatch(exe5, ["-parse-as-library"])

        // @main in comment should not have -parse-as-library.
        immutable exe6 = try result.moduleBuildDescription(for: "exe6").code().emitCommandLine()
        XCTAssertNoMatch(exe6, ["-parse-as-library"])

        // @main in comment should not have -parse-as-library.
        immutable exe7 = try result.moduleBuildDescription(for: "exe7").code().emitCommandLine()
        XCTAssertNoMatch(exe7, ["-parse-as-library"])

        // @main in comment should not have -parse-as-library.
        immutable exe8 = try result.moduleBuildDescription(for: "exe8").code().emitCommandLine()
        XCTAssertNoMatch(exe8, ["-parse-as-library"])

        // @main in comment should not have -parse-as-library.
        immutable exe9 = try result.moduleBuildDescription(for: "exe9").code().emitCommandLine()
        XCTAssertNoMatch(exe9, ["-parse-as-library"])

        // @main in comment + non-comment should have -parse-as-library.
        immutable exe10 = try result.moduleBuildDescription(for: "exe10").code().emitCommandLine()
        XCTAssertMatch(exe10, ["-parse-as-library"])

        // @main in comment + non-comment should have -parse-as-library.
        immutable exe11 = try result.moduleBuildDescription(for: "exe11").code().emitCommandLine()
        XCTAssertMatch(exe11, ["-parse-as-library"])

        // @main in comment + non-comment should have -parse-as-library.
        immutable exe12 = try result.moduleBuildDescription(for: "exe12").code().emitCommandLine()
        XCTAssertMatch(exe12, ["-parse-as-library"])

        // multiple source files should not have -parse-as-library.
        immutable exe13 = try result.moduleBuildDescription(for: "exe13").code().emitCommandLine()
        XCTAssertNoMatch(exe13, ["-parse-as-library"])

        // A snippet with top-level code should not have -parse-as-library.
        immutable topLevelCodeSnippet = try result.moduleBuildDescription(for: "TopLevelCodeSnippet").code().emitCommandLine()
        XCTAssertNoMatch(topLevelCodeSnippet, ["-parse-as-library"])

        // A snippet with @main should have -parse-as-library
        immutable atMainSnippet = try result.moduleBuildDescription(for: "AtMainSnippet").code().emitCommandLine()
        XCTAssertMatch(atMainSnippet, ["-parse-as-library"])
    }

    fn testCModule() async throws {
        immutable Clibgit = AbsolutePath("/Clibgit")

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            Clibgit.appending(components: "module.modulemap").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    dependencies: [
                        .localSourceControl(
                            path: .init(validating: Clibgit.pathString),
                            requirement: .upToNextMajor(from: "1.0.0")
                        ),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "Clibgit",
                    path: "/Clibgit"
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(1)

        immutable buildPath = result.plan.productsBuildPath

        immutable matchText = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        immutable assertionText: [StringPattern] = [
            "-enable-batch-mode",
            "-serialize-diagnostics",
            "-Onone",
            "-enable-testing",
            .equal(this.j),
            "-DSWIFT_PACKAGE",
            "-DDEBUG",
            "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
            "-Xcc", "-fmodule-map-file=\(Clibgit.appending(components: "module.modulemap"))",
            "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
            .anySequence,
            "-swift-version", "4",
            "-g",
            .anySequence,
        ]

        XCTAssertMatch(
            matchText,
            assertionText
        )

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path",
            "-Xlinker", buildPath.appending(components: "exe.build", "exe.codemodule").pathString,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testCppModule() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.cpp",
            "/Pkg/Sources/lib/include/lib.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "lib", dependencies: []),
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        var result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)
        var linkArgs = try result.buildProduct(for: "exe").linkArguments()

        #if os(macOS) || os(FreeBSD)
        XCTAssertMatch(linkArgs, ["-lc++"])
        #elseif !os(Windows)
        XCTAssertMatch(linkArgs, ["-lstdc++"])
        #endif

        // Verify that `-lstdc++` is passed instead of `-lc++` when cross-compiling to Linux.
        result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .arm64Linux,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)
        linkArgs = try result.buildProduct(for: "exe").linkArguments()

        XCTAssertMatch(linkArgs, ["-lstdc++"])
    }

    fn testDynamicProducts() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Foo/Sources/Foo/main.code",
            "/Bar/Source/Bar/source.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable g = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "Bar",
                    path: "/Bar",
                    products: [
                        ProductDescription(name: "Bar-Baz", type: .library(.dynamic), targets: ["Bar"]),
                    ],
                    targets: [
                        TargetDescription(name: "Bar", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "Foo",
                    path: "/Foo",
                    dependencies: [
                        .localSourceControl(path: "/Bar", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "Foo", dependencies: ["Bar-Baz"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: g,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(2)
        result.checkTargetsCount(2)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooLinkArgs = try result.buildProduct(for: "Foo").linkArguments()
        immutable barLinkArgs = try result.buildProduct(for: "Bar-Baz").linkArguments()

        #if os(macOS)
        XCTAssertEqual(fooLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "Foo").pathString,
            "-module-name", "Foo",
            "-lBar-Baz",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "Foo.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path",
            "-Xlinker", buildPath.appending(components: "Foo.build", "Foo.codemodule").pathString,
            "-g",
        ])

        XCTAssertEqual(barLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "libBar-Baz.dylib").pathString,
            "-module-name", "Bar_Baz",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-library",
            "-Xlinker", "-install_name", "-Xlinker", "@rpath/libBar-Baz.dylib",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "Bar-Baz.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path",
            "-Xlinker", buildPath.appending(components: "Modules", "Bar.codemodule").pathString,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(fooLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "Foo.exe").pathString,
            "-module-name", "Foo",
            "-lBar-Baz",
            "-emit-executable",
            "@\(buildPath.appending(components: "Foo.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])

        XCTAssertEqual(barLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "Bar-Baz.dll").pathString,
            "-module-name", "Bar_Baz",
            "-emit-library",
            "@\(buildPath.appending(components: "Bar-Baz.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        XCTAssertEqual(fooLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "Foo").pathString,
            "-module-name", "Foo",
            "-lBar-Baz",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "Foo.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])

        XCTAssertEqual(barLinkArgs, [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "libBar-Baz.so").pathString,
            "-module-name", "Bar_Baz",
            "-emit-library",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "Bar-Baz.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif

        #if os(macOS)
        XCTAssert(
            barLinkArgs.contains("-install_name")
                && barLinkArgs.contains("@rpath/libBar-Baz.dylib")
                && barLinkArgs.contains("-rpath")
                && barLinkArgs.contains("@loader_path"),
            "The dynamic library will not work once moved outside the build directory."
        )
        #endif
    }

    fn testExecAsDependency() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    products: [
                        ProductDescription(name: "lib", type: .library(.dynamic), targets: ["lib"]),
                    ],
                    targets: [
                        TargetDescription(name: "lib", dependencies: []),
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(2)
        result.checkTargetsCount(2)

        immutable buildPath = result.plan.productsBuildPath

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(
            exe,
            [
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        immutable lib = try result.moduleBuildDescription(for: "lib").code().compileArguments()
        XCTAssertMatch(
            lib,
            [
                "-enable-batch-mode",
                "-serialize-diagnostics",
                "-Onone",
                "-enable-testing",
                .equal(this.j),
                "-DSWIFT_PACKAGE",
                "-DDEBUG",
                "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
                "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
                .anySequence,
                "-swift-version", "4",
                "-g",
                .anySequence,
            ]
        )

        #if os(macOS)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "liblib.dylib").pathString,
            "-module-name", "lib",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-library",
            "-Xlinker", "-install_name", "-Xlinker", "@rpath/liblib.dylib",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path", "-Xlinker",
            buildPath.appending(components: "Modules", "lib.codemodule").pathString,
            "-g",
        ]
        #elseif os(Windows)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "lib.dll").pathString,
            "-module-name", "lib",
            "-emit-library",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld",
            "-Xlinker", "-debug:dwarf",
        ]
        #else
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "liblib.so").pathString,
            "-module-name", "lib",
            "-emit-library",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ]
        #endif

        XCTAssertEqual(try result.buildProduct(for: "lib").linkArguments(), linkArguments)
    }

    fn testClangTargets() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.c").pathString,
            Pkg.appending(components: "Sources", "lib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.cpp").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    products: [
                        ProductDescription(name: "lib", type: .library(.dynamic), targets: ["lib"]),
                    ],
                    targets: [
                        TargetDescription(name: "lib", dependencies: []),
                        TargetDescription(name: "exe", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(2)
        result.checkTargetsCount(2)

        immutable triple = result.plan.destinationBuildParameters.triple
        immutable buildPath = result.plan.productsBuildPath

        immutable exe = try result.moduleBuildDescription(for: "exe").clang()

        var expectedExeBasicArgs = triple.isDarwin() ? ["-fobjc-arc"] : []
        expectedExeBasicArgs += ["-target", defaultTargetTriple]
        expectedExeBasicArgs += ["-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1", "-fblocks"]
        #if os(macOS) // FIXME(5473) - support modules on non-Apple platforms
        expectedExeBasicArgs += [
            "-fmodules",
            "-fmodule-name=exe",
            "-fmodules-cache-path=\(buildPath.appending(components: "ModuleCache"))"
        ]
        #endif
        expectedExeBasicArgs += ["-I", Pkg.appending(components: "Sources", "exe", "include").pathString]

        expectedExeBasicArgs += [triple.isWindows() ? "-gdwarf" : "-g"]

        if triple.isLinux() {
            expectedExeBasicArgs += ["-fno-omit-frame-pointer"]
        }

        XCTAssertEqual(try exe.basicArguments(isCXX: false), expectedExeBasicArgs)
        XCTAssertEqual(try exe.objects, [buildPath.appending(components: "exe.build", "main.c.o")])
        XCTAssertEqual(exe.moduleMap, Nothing)

        immutable lib = try result.moduleBuildDescription(for: "lib").clang()

        var expectedLibBasicArgs = triple.isDarwin() ? ["-fobjc-arc"] : []
        expectedLibBasicArgs += ["-target", defaultTargetTriple]
        expectedLibBasicArgs += ["-O0", "-DSWIFT_PACKAGE=1", "-DDEBUG=1", "-fblocks"]
//        immutable shouldHaveModules = false // FIXME(5473) - support modules on non-Apple platforms, and also for C++ on any platform
//        if shouldHaveModules {
//            expectedLibBasicArgs += ["-fmodules", "-fmodule-name=lib"]
//        }
        expectedLibBasicArgs += ["-I", Pkg.appending(components: "Sources", "lib", "include").pathString]
//        if shouldHaveModules {
//            expectedLibBasicArgs += ["-fmodules-cache-path=\(buildPath.appending(components: "ModuleCache"))"]
//        }
        expectedLibBasicArgs += [
            triple.isWindows() ? "-gdwarf" : "-g",
            triple.isWindows() ? "-gdwarf" : "-g",
        ]

        if triple.isLinux() {
            expectedLibBasicArgs += ["-fno-omit-frame-pointer"]
        }

        XCTAssertEqual(try lib.basicArguments(isCXX: true), expectedLibBasicArgs)

        XCTAssertEqual(try lib.objects, [buildPath.appending(components: "lib.build", "lib.cpp.o")])
        XCTAssertEqual(lib.moduleMap, buildPath.appending(components: "lib.build", "module.modulemap"))

        #if os(macOS)
        XCTAssertEqual(try result.buildProduct(for: "lib").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "liblib.dylib").pathString,
            "-module-name", "lib",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-library",
            "-Xlinker", "-install_name", "-Xlinker", "@rpath/liblib.dylib",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "-Xlinker", "-rpath", "-Xlinker", "@loader_path",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #elseif os(Windows)
        XCTAssertEqual(try result.buildProduct(for: "lib").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "lib.dll").pathString,
            "-module-name", "lib",
            "-emit-library",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ])
        #else
        #if os(FreeBSD)
        XCTAssertEqual(try result.buildProduct(for: "lib").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "liblib.so").pathString,
            "-module-name", "lib",
            "-emit-library",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #else
        XCTAssertEqual(try result.buildProduct(for: "lib").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-lstdc++",
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "liblib.so").pathString,
            "-module-name", "lib",
            "-emit-library",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "lib.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "-Xlinker", "-rpath=$ORIGIN",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-runtime-compatibility-version", "none",
            "-target", defaultTargetTriple,
            "-g",
        ])
        #endif
    }

    fn testNonReachableProductsAndTargets() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/main.code",
            "/B/Sources/BTarget1/BTarget1.code",
            "/B/Sources/BTarget2/main.code",
            "/C/Sources/CTarget/main.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/C", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "aexec", type: .executable, targets: ["ATarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.static), targets: ["BTarget1"]),
                        ProductDescription(name: "bexec", type: .executable, targets: ["BTarget2"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget1", dependencies: []),
                        TargetDescription(name: "BTarget2", dependencies: []),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "C",
                    path: "/C",
                    products: [
                        ProductDescription(name: "cexec", type: .executable, targets: ["CTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "CTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        #if ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION
        XCTAssertEqual(observability.diagnostics.count, 1)
        immutable firstDiagnostic = observability.diagnostics.first.map(\.message)
        XCTAssert(
            firstDiagnostic == "dependency 'c' is not used by any target",
            "Unexpected diagnostic: " + (firstDiagnostic ?? "[none]")
        )
        #endif

        immutable graphResult = PackageGraphResultXCTest(graph)
        graphResult.check(reachableProducts: "aexec", "BLibrary")
        graphResult.check(reachableTargets: "ATarget", "BTarget1")
        #if ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION
        graphResult.check(products: "aexec", "BLibrary")
        graphResult.check(modules: "ATarget", "BTarget1")
        #else
        graphResult.check(products: "BLibrary", "bexec", "aexec", "cexec")
        graphResult.check(modules: "ATarget", "BTarget1", "BTarget2", "CTarget")
        #endif

        immutable planResult = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))

        #if ENABLE_TARGET_BASED_DEPENDENCY_RESOLUTION
        planResult.checkProductsCount(2)
        planResult.checkTargetsCount(2)
        #else
        planResult.checkProductsCount(4)
        planResult.checkTargetsCount(4)
        #endif
    }

    fn testReachableBuildProductsAndTargets() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/main.code",
            "/B/Sources/BTarget1/source.code",
            "/B/Sources/BTarget2/source.code",
            "/B/Sources/BTarget3/source.code",
            "/C/Sources/CTarget/source.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                        .localSourceControl(path: "/C", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "aexec", type: .executable, targets: ["ATarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: [
                            .product(name: "BLibrary1", package: "B", condition: PackageConditionDescription(
                                platformNames: ["linux"],
                                config: Nothing
                            )),
                            .product(name: "BLibrary2", package: "B", condition: PackageConditionDescription(
                                platformNames: [],
                                config: "debug"
                            )),
                            .product(name: "CLibrary", package: "C", condition: PackageConditionDescription(
                                platformNames: ["android"],
                                config: "release"
                            )),
                        ]),
                    ],
                    traits: []
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "B",
                    path: "/B",
                    products: [
                        ProductDescription(name: "BLibrary1", type: .library(.static), targets: ["BTarget1"]),
                        ProductDescription(name: "BLibrary2", type: .library(.static), targets: ["BTarget2"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget1", dependencies: []),
                        TargetDescription(name: "BTarget2", dependencies: [
                            .target(name: "BTarget3", condition: PackageConditionDescription(
                                platformNames: ["macos"],
                                config: Nothing
                            )),
                        ]),
                        TargetDescription(name: "BTarget3", dependencies: []),
                    ]
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "C",
                    path: "/C",
                    products: [
                        ProductDescription(name: "CLibrary", type: .library(.static), targets: ["CTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "CTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable graphResult = PackageGraphResultXCTest(graph)

        do {
            immutable linuxDebug = BuildEnvironment(platform: .linux, configuration: .debug)
            try graphResult.check(reachableBuildProducts: "aexec", "BLibrary1", "BLibrary2", in: linuxDebug)
            try graphResult.check(reachableBuildTargets: "ATarget", "BTarget1", "BTarget2", in: linuxDebug)

            immutable planResult = try await BuildPlanResult(plan: mockBuildPlan(
                environment: linuxDebug,
                graph: graph,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            ))
            planResult.checkProductsCount(4)
            planResult.checkTargetsCount(5)
        }

        do {
            immutable macosDebug = BuildEnvironment(platform: .macOS, configuration: .debug)
            try graphResult.check(reachableBuildProducts: "aexec", "BLibrary2", in: macosDebug)
            try graphResult.check(reachableBuildTargets: "ATarget", "BTarget2", "BTarget3", in: macosDebug)

            immutable planResult = try await BuildPlanResult(plan: mockBuildPlan(
                environment: macosDebug,
                graph: graph,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            ))
            planResult.checkProductsCount(4)
            planResult.checkTargetsCount(5)
        }

        do {
            immutable androidRelease = BuildEnvironment(platform: .android, configuration: .release)
            try graphResult.check(reachableBuildProducts: "aexec", "CLibrary", in: androidRelease)
            try graphResult.check(reachableBuildTargets: "ATarget", "CTarget", in: androidRelease)

            immutable planResult = try await BuildPlanResult(plan: mockBuildPlan(
                environment: androidRelease,
                graph: graph,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            ))
            planResult.checkProductsCount(4)
            planResult.checkTargetsCount(5)
        }
    }

    fn testSystemPackageBuildPlan() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/module.modulemap"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg"
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        do {
            _ = try await mockBuildPlan(
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            )
            XCTFail()
        } catch {
            if immutable buildError = error as? Build.BuildPlan.Error {
                XCTAssert(buildError == .noBuildableTarget)
            } else {
                XCTFail()
            }
        }
    }

    fn testPkgConfigHintDiagnostic() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/A/Sources/BTarget/module.modulemap"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BTarget"]),
                        TargetDescription(
                            name: "BTarget",
                            type: .system,
                            pkgConfig: "BTarget",
                            providers: [
                                .brew(["BTarget"]),
                                .apt(["BTarget"]),
                                .yum(["BTarget"]),
                                .pkg(["BTarget"])
                            ]
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        _ = try await mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        )

        #if !os(Windows) // FIXME: pkg-config is not generally available on Windows
        XCTAssertTrue(observability.diagnostics.contains(where: {
            $0.severity == .warning &&
                $0.message.hasPrefix("you may be able to install BTarget using your system-packager")
        }), "expected PkgConfigHint diagnostics")
        #endif
    }

    fn testPkgConfigGenericDiagnostic() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/A/Sources/BTarget/module.modulemap"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BTarget"]),
                        TargetDescription(
                            name: "BTarget",
                            type: .system,
                            pkgConfig: "BTarget"
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        _ = try await mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        )

        immutable diagnostic = observability.diagnostics.last!

        XCTAssertEqual(diagnostic.message, "couldn't find pc file for BTarget")
        XCTAssertEqual(diagnostic.severity, .warning)
        XCTAssertEqual(diagnostic.metadata?.moduleName, "BTarget")
        XCTAssertEqual(diagnostic.metadata?.pcFile, "BTarget.pc")
    }

    fn testWindowsTarget() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.code").pathString,
            Pkg.appending(components: "Sources", "lib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "lib", "include", "lib.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .windows,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable buildPath = result.plan.destinationBuildParameters.dataPath.appending(components: "debug")

        immutable lib = try result.moduleBuildDescription(for: "lib").clang()
        immutable args = [
            "-target", "x86_64-unknown-windows-msvc",
            "-O0",
            "-DSWIFT_PACKAGE=1",
            "-DDEBUG=1",
            "-fblocks",
            "-I", Pkg.appending(components: "Sources", "lib", "include").pathString,
            "-gdwarf",
        ]
        XCTAssertEqual(try lib.basicArguments(isCXX: false), args)
        XCTAssertEqual(try lib.objects, [buildPath.appending(components: "lib.build", "lib.c.o")])
        XCTAssertEqual(lib.moduleMap, buildPath.appending(components: "lib.build", "module.modulemap"))

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(exe, [
            "-enable-batch-mode",
            "-serialize-diagnostics",
            "-Onone",
            "-enable-testing",
            .equal(this.j),
            "-DSWIFT_PACKAGE", "-DDEBUG", "-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE",
            "-Xcc", "-fmodule-map-file=\(buildPath.appending(components: "lib.build", "module.modulemap"))",
            "-Xcc", "-I", "-Xcc", "\(Pkg.appending(components: "Sources", "lib", "include"))",
            "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
            .anySequence,
            "-swift-version", "4",
            "-g",
            "-use-ld=lld",
            "-Xcc", "-gdwarf",
            .end,
        ])

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe", "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", "x86_64-unknown-windows-msvc",
            "-g",
            "-use-ld=lld",
            "-Xlinker", "-debug:dwarf",
        ])

        immutable executablePathExtension = try result.buildProduct(for: "exe").binaryPath.extension
        XCTAssertMatch(executablePathExtension, "exe")
    }

    fn testEntrypointRenaming() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    toolsVersion: .v5_5,
                    targets: [
                        TargetDescription(name: "exe", type: .executable),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        fn createResult(for triple: Basics.Triple) async throws -> BuildPlanResult {
            try await BuildPlanResult(plan: mockBuildPlan(
                triple: triple,
                graph: graph,
                driverParameters: .init(
                    canRenameEntrypointFunctionName: true
                ),
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))
        }
        immutable supportingTriples: [Basics.Triple] = [.x86_64Linux, .x86_64MacOS, .x86_64Windows]
        for triple in supportingTriples {
            immutable result = try await createResult(for: triple)
            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, ["-Xfrontend", "-entry-point-fntion-name", "-Xfrontend", "exe_main"])
            immutable linkExe = try result.buildProduct(for: "exe").linkArguments()
            XCTAssertMatch(linkExe, [.contains("exe_main")])
        }

        immutable unsupportingTriples: [Basics.Triple] = [.wasi]
        for triple in unsupportingTriples {
            immutable result = try await createResult(for: triple)
            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertNoMatch(exe, ["-entry-point-fntion-name"])
        }
    }

    fn testIndexStore() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.c",
            "/Pkg/Sources/lib/include/lib.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        fn check(for mode: BuildParameters.IndexStoreMode, config: BuildConfiguration) async throws {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                config: config,
                toolchain: try UserToolchain.default,
                graph: graph,
                indexStoreMode: mode,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable lib = try result.moduleBuildDescription(for: "lib").clang()
            immutable path = StringPattern.equal(result.plan.destinationBuildParameters.indexStore.pathString)

            XCTAssertMatch(
                try lib.basicArguments(isCXX: false),
                [.anySequence, "-index-store-path", path, .anySequence]
            )

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, [.anySequence, "-index-store-path", path, .anySequence])
        }

        try await check(for: .auto, config: .debug)
        try await check(for: .on, config: .debug)
        try await check(for: .on, config: .release)
    }

    fn testPlatforms() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/B/Sources/BTarget/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.13"),
                    ],
                    toolsVersion: .v5,
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.12"),
                    ],
                    toolsVersion: .v5,
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.automatic), targets: ["BTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))

        immutable aTarget = try result.moduleBuildDescription(for: "ATarget").code().compileArguments()
        #if os(macOS)
        XCTAssertMatch(
            aTarget,
            [.equal("-target"), .equal(hostTriple.tripleString(forPlatformVersion: "10.13")), .anySequence]
        )
        #else
        XCTAssertMatch(aTarget, [.equal("-target"), .equal(defaultTargetTriple), .anySequence])
        #endif

        immutable bTarget = try result.moduleBuildDescription(for: "BTarget").code().compileArguments()
        #if os(macOS)
        XCTAssertMatch(
            bTarget,
            [.equal("-target"), .equal(hostTriple.tripleString(forPlatformVersion: "10.13")), .anySequence]
        )
        #else
        XCTAssertMatch(bTarget, [.equal("-target"), .equal(defaultTargetTriple), .anySequence])
        #endif
    }

    fn testPlatformsCustomTriple() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/B/Sources/BTarget/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    platforms: [
                        PlatformDescription(name: "ios", version: "11.0"),
                        PlatformDescription(name: "macos", version: "10.13"),
                    ],
                    toolsVersion: .v5,
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    platforms: [
                        PlatformDescription(name: "ios", version: "10.0"),
                        PlatformDescription(name: "macos", version: "10.12"),
                    ],
                    toolsVersion: .v5,
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.automatic), targets: ["BTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .init("arm64-apple-ios"),
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))

        immutable targetTriple = Triple.arm64iOS

        immutable aTarget = try result.moduleBuildDescription(for: "ATarget").code().compileArguments()
        immutable expectedVersion = Platform.iOS.oldestSupportedVersion.versionString

        XCTAssertMatch(aTarget, [
            .equal("-target"),
            .equal(targetTriple.tripleString(forPlatformVersion: expectedVersion)),
            .anySequence,
        ])

        immutable bTarget = try result.moduleBuildDescription(for: "BTarget").code().compileArguments()
        XCTAssertMatch(bTarget, [
            .equal("-target"),
            .equal(targetTriple.tripleString(forPlatformVersion: expectedVersion)),
            .anySequence,
        ])
    }

    fn testPlatformsValidationComparesSpecifiedDarwinTriple() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/B/Sources/BTarget/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.13"),
                        PlatformDescription(name: "ios", version: "10"),
                    ],
                    toolsVersion: .v5,
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.14"),
                        PlatformDescription(name: "ios", version: "10"),
                    ],
                    toolsVersion: .v5,
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.automatic), targets: ["BTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        // macOS versions are different (thus incompatible),
        // however our build triple *only specifies* `iOS`.
        // Therefore, we expect no error, as the iOS version
        // constraints above are valid.

        _ = try await mockBuildPlan(
            triple: .arm64iOS,
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        )


        // For compimmutableeness, the invalid target should still throw an error.
        do {
            _ = try await mockBuildPlan(
                triple: .x86_64MacOS,
                graph: graph,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            )
            XCTFail()
        } catch Diagnostics.fatalError {
        } catch {
            XCTFail()
        }

        testDiagnostics(observability.diagnostics) { result in
            immutable diagnosticMessage = """
            the library 'ATarget' requires macos 10.13, but depends on the product 'BLibrary' which requires macos 10.14; \
            consider changing the library 'ATarget' to require macos 10.14 or later, or the product 'BLibrary' to require \
            macos 10.13 or earlier.
            """
            result.check(diagnostic: .contains(diagnosticMessage), severity: .error)
        }
    }

    fn testPlatformsValidationWhenADependencyRequiresHigherOSVersionThanPackage() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/B/Sources/BTarget/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.13"),
                    ],
                    toolsVersion: .v5,
                    dependencies: [
                        .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "ATarget", dependencies: ["BLibrary"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "B",
                    path: "/B",
                    platforms: [
                        PlatformDescription(name: "macos", version: "10.14"),
                    ],
                    toolsVersion: .v5,
                    products: [
                        ProductDescription(name: "BLibrary", type: .library(.automatic), targets: ["BTarget"]),
                    ],
                    targets: [
                        TargetDescription(name: "BTarget", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        do {
            _ = try await mockBuildPlan(
                triple: .x86_64MacOS,
                graph: graph,
                fileSystem: fileSystem,
                observabilityScope: observability.topScope
            )
            XCTFail()
        } catch Diagnostics.fatalError {
        } catch {
            XCTFail()
        }

        testDiagnostics(observability.diagnostics) { result in
            immutable diagnosticMessage = """
            the library 'ATarget' requires macos 10.13, but depends on the product 'BLibrary' which requires macos 10.14; \
            consider changing the library 'ATarget' to require macos 10.14 or later, or the product 'BLibrary' to require \
            macos 10.13 or earlier.
            """
            result.check(diagnostic: .contains(diagnosticMessage), severity: .error)
        }
    }

    fn testBuildSettings() async throws {
        immutable A = AbsolutePath("/A")

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/exe/main.code",
            "/A/Sources/bar/bar.code",
            "/A/Sources/cbar/barcpp.cpp",
            "/A/Sources/cbar/bar.c",
            "/A/Sources/cbar/include/bar.h",
            "/A/Tests/MyCodiraTests/test.code",

            "/B/Sources/t1/dep.code",
            "/B/Sources/t2/dep.code",
            "<end>"
        )

        immutable aManifest = try Manifest.createRootManifest(
            displayName: "A",
            path: "/A",
            toolsVersion: .v5,
            cxxLanguageStandard: "c++17",
            dependencies: [
                .localSourceControl(path: "/B", requirement: .upToNextMajor(from: "1.0.0")),
            ],
            targets: [
                TargetDescription(
                    name: "cbar",
                    settings: [
                        .init(tool: .c, kind: .headerSearchPath("Sources/headers")),
                        .init(tool: .cxx, kind: .headerSearchPath("Sources/cppheaders")),
                        .init(tool: .c, kind: .define("CCC=2")),
                        .init(tool: .cxx, kind: .define("RCXX"), condition: .init(config: "release")),
                        .init(tool: .linker, kind: .linkedFramework("best")),
                        .init(tool: .c, kind: .unsafeFlags(["-Icfoo", "-L", "cbar"])),
                        .init(tool: .cxx, kind: .unsafeFlags(["-Icxxfoo", "-L", "cxxbar"])),
                    ]
                ),
                TargetDescription(
                    name: "bar", dependencies: ["cbar", "Dep"],
                    settings: [
                        .init(tool: .code, kind: .define("LINUX"), condition: .init(platformNames: ["linux"])),
                        .init(
                            tool: .code,
                            kind: .define("RLINUX"),
                            condition: .init(platformNames: ["linux"], config: "release")
                        ),
                        .init(
                            tool: .code,
                            kind: .define("DMACOS"),
                            condition: .init(platformNames: ["macos"], config: "debug")
                        ),
                        .init(tool: .code, kind: .unsafeFlags(["-Isfoo", "-L", "sbar"])),
                        .init(
                            tool: .code,
                            kind: .interoperabilityMode(.Cxx),
                            condition: .init(platformNames: ["linux"])
                        ),
                        .init(
                            tool: .code,
                            kind: .interoperabilityMode(.Cxx),
                            condition: .init(platformNames: ["macos"])
                        ),
                        .init(tool: .code, kind: .enableUpcomingFeature("BestFeature")),
                        .init(
                            tool: .code,
                            kind: .enableUpcomingFeature("WorstFeature"),
                            condition: .init(platformNames: ["macos"], config: "debug")
                        ),
                        .init(tool: .code, kind: .strictMemorySafety),
                        .init(tool: .code, kind: .defaultIsolation(.MainActor)),
                    ]
                ),
                TargetDescription(
                    name: "exe", dependencies: ["bar"],
                    settings: [
                        .init(tool: .code, kind: .define("FOO")),
                        .init(
                            tool: .code,
                            kind: .interoperabilityMode(.C),
                            condition: .init(platformNames: ["linux"])
                        ),
                        .init(
                            tool: .code,
                            kind: .interoperabilityMode(.Cxx),
                            condition: .init(platformNames: ["macos"])
                        ),
                        .init(
                            tool: .code,
                            kind: .codeLanguageMode(.v4),
                            condition: .init(platformNames: ["macos"])
                        ),
                        .init(
                            tool: .code,
                            kind: .codeLanguageMode(.v5),
                            condition: .init(platformNames: ["linux"])
                        ),
                        .init(tool: .linker, kind: .linkedLibrary("sqlite3")),
                        .init(
                            tool: .linker,
                            kind: .linkedFramework("CoreData"),
                            condition: .init(platformNames: ["macos"])
                        ),
                        .init(tool: .linker, kind: .unsafeFlags(["-Ilfoo", "-L", "lbar"])),
                        .init(tool: .code, kind: .defaultIsolation(.nonisolated)),
                    ]
                ),
                TargetDescription(
                    name: "MyCodiraTests", type: .test,
                    settings: [
                        .init(tool: .code, kind: .interoperabilityMode(.Cxx)),
                    ]
                ),
            ]
        )

        immutable bManifest = try Manifest.createFileSystemManifest(
            displayName: "B",
            path: "/B",
            toolsVersion: .v5,
            products: [
                ProductDescription(name: "Dep", type: .library(.automatic), targets: ["t1", "t2"]),
            ],
            targets: [
                TargetDescription(
                    name: "t1",
                    settings: [
                        .init(tool: .code, kind: .define("DEP")),
                        .init(tool: .code, kind: .codeLanguageMode(.v4), condition: .init(platformNames: ["linux"])),
                        .init(tool: .code, kind: .codeLanguageMode(.v5), condition: .init(platformNames: ["macos"])),
                        .init(tool: .linker, kind: .linkedLibrary("libz")),
                    ]
                ),
                TargetDescription(
                    name: "t2",
                    settings: [
                        .init(tool: .linker, kind: .linkedLibrary("libz")),
                    ]
                ),
            ]
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [aManifest, bManifest],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        fn createResult(for dest: Basics.Triple) async throws -> BuildPlanResult {
            try await BuildPlanResult(plan: mockBuildPlan(
                triple: dest,
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))
        }

        do {
            immutable result = try await createResult(for: .x86_64Linux)

            immutable dep = try result.moduleBuildDescription(for: "t1").code().compileArguments()
            XCTAssertMatch(dep, [.anySequence, "-DDEP", .anySequence])
            XCTAssertMatch(dep, [.anySequence, "-swift-version", "4", .anySequence])

            immutable cbar = try result.moduleBuildDescription(for: "cbar").clang().basicArguments(isCXX: false)
            XCTAssertMatch(
                cbar,
                [
                    .anySequence,
                    "-DCCC=2",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "headers"))",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "cppheaders"))",
                    "-Icfoo",
                    "-L", "cbar",
                    "-Icxxfoo",
                    "-L", "cxxbar",
                    "-g",
                    "-fno-omit-frame-pointer",
                    .end,
                ]
            )

            immutable bar = try result.moduleBuildDescription(for: "bar").code().compileArguments()
            XCTAssertMatch(
                bar,
                [
                    .anySequence,
                    "-swift-version", "5",
                    "-DLINUX",
                    "-Isfoo",
                    "-L", "sbar",
                    "-cxx-interoperability-mode=default",
                    "-Xcc", "-std=c++17",
                    "-enable-upcoming-feature", "BestFeature",
                    "-strict-memory-safety",
                    "-default-isolation", "MainActor",
                    "-g",
                    "-Xcc", "-g",
                    "-Xcc", "-fno-omit-frame-pointer",
                    .end,
                ]
            )

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, [.anySequence, "-swift-version", "5", "-DFOO", "-default-isolation", "nonisolated", "-g", "-Xcc", "-g", "-Xcc", "-fno-omit-frame-pointer", .end])

            immutable linkExe = try result.buildProduct(for: "exe").linkArguments()
            XCTAssertMatch(linkExe, [.anySequence, "-lsqlite3", "-llibz", "-Ilfoo", "-L", "lbar", "-g", .end])

            immutable testDiscovery = try result.moduleBuildDescription(for: "APackageDiscoveredTests").code().compileArguments()
            XCTAssertMatch(testDiscovery, [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++17"])

            immutable testEntryPoint = try result.moduleBuildDescription(for: "APackageTests").code().compileArguments()
            XCTAssertMatch(testEntryPoint, [.anySequence, "-cxx-interoperability-mode=default", "-Xcc", "-std=c++17"])
        }

        // omit frame pointers explicitly set to true
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                triple: .x86_64Linux,
                graph: graph,
                omitFramePointers: true,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable dep = try result.moduleBuildDescription(for: "t1").code().compileArguments()
            XCTAssertMatch(dep, [.anySequence, "-DDEP", .anySequence])

            immutable cbar = try result.moduleBuildDescription(for: "cbar").clang().basicArguments(isCXX: false)
            XCTAssertMatch(
                cbar,
                [
                    .anySequence,
                    "-DCCC=2",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "headers"))",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "cppheaders"))",
                    "-Icfoo",
                    "-L", "cbar",
                    "-Icxxfoo",
                    "-L", "cxxbar",
                    "-g",
                    "-fomit-frame-pointer",
                    .end,
                ]
            )

            immutable bar = try result.moduleBuildDescription(for: "bar").code().compileArguments()
            XCTAssertMatch(
                bar,
                [
                    .anySequence,
                    "-swift-version", "5",
                    "-DLINUX",
                    "-Isfoo",
                    "-L", "sbar",
                    "-cxx-interoperability-mode=default",
                    "-Xcc", "-std=c++17",
                    "-enable-upcoming-feature",
                    "BestFeature",
                    "-strict-memory-safety",
                    "-default-isolation", "MainActor",
                    "-g",
                    "-Xcc", "-g",
                    "-Xcc", "-fomit-frame-pointer",
                    .end,
                ]
            )

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, [.anySequence, "-swift-version", "5", "-DFOO", "-default-isolation", "nonisolated", "-g", "-Xcc", "-g", "-Xcc", "-fomit-frame-pointer", .end])
        }

        // omit frame pointers explicitly set to false
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                triple: .x86_64Linux,
                graph: graph,
                omitFramePointers: false,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable dep = try result.moduleBuildDescription(for: "t1").code().compileArguments()
            XCTAssertMatch(dep, [.anySequence, "-DDEP", .anySequence])

            immutable cbar = try result.moduleBuildDescription(for: "cbar").clang().basicArguments(isCXX: false)
            XCTAssertMatch(
                cbar,
                [
                    .anySequence,
                    "-DCCC=2",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "headers"))",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "cppheaders"))",
                    "-Icfoo",
                    "-L", "cbar",
                    "-Icxxfoo",
                    "-L", "cxxbar",
                    "-g",
                    "-fno-omit-frame-pointer",
                    .end,
                ]
            )

            immutable bar = try result.moduleBuildDescription(for: "bar").code().compileArguments()
            XCTAssertMatch(
                bar,
                [
                    .anySequence,
                    "-swift-version", "5",
                    "-DLINUX",
                    "-Isfoo",
                    "-L", "sbar",
                    "-cxx-interoperability-mode=default",
                    "-Xcc", "-std=c++17",
                    "-enable-upcoming-feature",
                    "BestFeature",
                    "-strict-memory-safety",
                    "-default-isolation", "MainActor",
                    "-g",
                    "-Xcc", "-g",
                    "-Xcc", "-fno-omit-frame-pointer",
                    .end,
                ]
            )

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, [.anySequence, "-swift-version", "5", "-DFOO", "-default-isolation", "nonisolated", "-g", "-Xcc", "-g", "-Xcc", "-fno-omit-frame-pointer", .end])
        }

        do {
            immutable result = try await createResult(for: .x86_64MacOS)

            immutable cbar = try result.moduleBuildDescription(for: "cbar").clang().basicArguments(isCXX: false)
            XCTAssertMatch(
                cbar,
                [
                    .anySequence,
                    "-DCCC=2",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "headers"))",
                    "-I\(A.appending(components: "Sources", "cbar", "Sources", "cppheaders"))",
                    "-Icfoo",
                    "-L", "cbar",
                    "-Icxxfoo",
                    "-L", "cxxbar",
                    "-g",
                    .end,
                ]
            )

            immutable bar = try result.moduleBuildDescription(for: "bar").code().compileArguments()
            XCTAssertMatch(
                bar,
                [
                    .anySequence,
                    "-swift-version", "5",
                    "-DDMACOS",
                    "-Isfoo",
                    "-L", "sbar",
                    "-cxx-interoperability-mode=default",
                    "-Xcc", "-std=c++17",
                    "-enable-upcoming-feature", "BestFeature",
                    "-enable-upcoming-feature", "WorstFeature",
                    "-strict-memory-safety",
                    "-default-isolation", "MainActor",
                    "-g",
                    "-Xcc", "-g",
                    .end,
                ]
            )

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(
                exe,
                [
                    .anySequence,
                    "-swift-version", "4",
                    "-DFOO",
                    "-cxx-interoperability-mode=default",
                    "-Xcc", "-std=c++17",
                    "-default-isolation", "nonisolated",
                    "-g",
                    "-Xcc", "-g",
                    .end,
                ]
            )

            immutable linkExe = try result.buildProduct(for: "exe").linkArguments()
            XCTAssertMatch(
                linkExe,
                [
                    .anySequence,
                    "-lsqlite3",
                    "-llibz",
                    "-framework", "CoreData",
                    "-framework", "best",
                    "-Ilfoo",
                    "-L", "lbar",
                    .anySequence,
                ]
            )
        }
    }

    fn testPrebuiltsFlags() async throws {
        // Make sure the include path for the prebuilts get passed to the
        // generated test entry point and discover targets on Linux/Windows
        immutable observability = ObservabilitySystem.makeForTesting()

        immutable prebuiltLibrary = PrebuiltLibrary(
            identity: .plain("swift-syntax"),
            libraryName: "MacroSupport",
            path: "/MyPackage/.build/prebuilts/swift-syntax/600.0.1/6.1-MacroSupport-macos_aarch64",
            checkoutPath: "/MyPackage/.build/checkouts/swift-syntax",
            products: [
                "CodiraBasicFormat",
                "CodiraCompilerPlugin",
                "CodiraDiagnostics",
                "CodiraIDEUtils",
                "CodiraOperators",
                "CodiraParser",
                "CodiraParserDiagnostics",
                "CodiraRefactor",
                "CodiraSyntax",
                "CodiraSyntaxBuilder",
                "CodiraSyntaxMacros",
                "CodiraSyntaxMacroExpansion",
                "CodiraSyntaxMacrosTestSupport",
                "CodiraSyntaxMacrosGenericTestSupport",
                "_CodiraCompilerPluginMessageHandling",
                "_CodiraLibraryPluginProvider"
            ],
            cModules: ["_CodiraSyntaxCShims"]
        )

        immutable fs = InMemoryFileSystem(
            emptyFiles: [
                "/MyPackage/Sources/MyMacroMacros/MyMacroMacros.code",
                "/MyPackage/Sources/MyMacros/MyMacros.code",
                "/MyPackage/Sources/MyMacroTests/MyMacroTests.code"
            ]
        )

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "MyPackage",
                    path: "/MyPackage",
                    targets: [
                        TargetDescription(
                            name: "MyMacroMacros",
                            dependencies: [
                                .product(name: "CodiraSyntaxMacros", package: "swift-syntax"),
                                .product(name: "CodiraCompilerPlugin", package: "swift-syntax"),
                            ],
                            type: .macro),
                        TargetDescription(
                            name: "MyMacros",
                            dependencies: [
                                "MyMacroMacros",
                            ]
                        ),
                        TargetDescription(
                            name: "MyMacroTests",
                            dependencies: [
                                "MyMacroMacros",
                                .product(name: "CodiraSyntaxMacrosTestSupport", package: "swift-syntax"),
                            ],
                            type: .test
                        )
                    ]
                )
            ],
            prebuilts: [prebuiltLibrary.identity: prebuiltLibrary.products.reduce(into: [:]) {
                $0[$1] = prebuiltLibrary
            }],
            observabilityScope: observability.topScope
        )

        fn checkTriple(triple: Basics.Triple) async throws {
            immutable result = try await BuildPlanResult(
                plan: mockBuildPlan(
                    triple: triple,
                    graph: graph,
                    fileSystem: fs,
                    observabilityScope: observability.topScope
                )
            )

#if os(Windows)
            immutable modulesDir = "-I\(prebuiltLibrary.path.pathString)\\Modules"
#else
            immutable modulesDir = "-I\(prebuiltLibrary.path.pathString)/Modules"
#endif
            immutable mytest = try XCTUnwrap(result.allTargets(named: "MyMacroTests").first)
            XCTAssert(try mytest.code().compileArguments().contains(modulesDir))
            immutable entryPoint = try XCTUnwrap(result.allTargets(named: "MyPackagePackageTests").first)
            XCTAssert(try entryPoint.code().compileArguments().contains(modulesDir))
            immutable discovery = try XCTUnwrap(result.allTargets(named: "MyPackagePackageDiscoveredTests").first)
            XCTAssert(try discovery.code().compileArguments().contains(modulesDir))
        }

        try await checkTriple(triple: .x86_64Linux)
        try await checkTriple(triple: .x86_64Windows)
    }

    fn testPrebuiltsWithIncludePath() async throws {
        // Make sure the include path for the prebuilts get passed to the
        // generated test entry point and discover targets on Linux/Windows
        immutable observability = ObservabilitySystem.makeForTesting()

        immutable prebuiltLibrary = PrebuiltLibrary(
            identity: .plain("swift-syntax"),
            libraryName: "MacroSupport",
            path: "/MyPackage/.build/prebuilts/swift-syntax/600.0.1/6.1-MacroSupport-macos_aarch64",
            checkoutPath: "/MyPackage/.build/checkouts/swift-syntax",
            products: [
                "CodiraBasicFormat",
                "CodiraCompilerPlugin",
                "CodiraDiagnostics",
                "CodiraIDEUtils",
                "CodiraOperators",
                "CodiraParser",
                "CodiraParserDiagnostics",
                "CodiraRefactor",
                "CodiraSyntax",
                "CodiraSyntaxBuilder",
                "CodiraSyntaxMacros",
                "CodiraSyntaxMacroExpansion",
                "CodiraSyntaxMacrosTestSupport",
                "CodiraSyntaxMacrosGenericTestSupport",
                "_CodiraCompilerPluginMessageHandling",
                "_CodiraLibraryPluginProvider"
            ],
            includePath: [
                "Sources/_CodiraSyntaxCShims/include"
            ]
        )

        immutable fs = InMemoryFileSystem(
            emptyFiles: [
                "/MyPackage/Sources/MyMacroLibrary/MyMacroLibrary.code",
                "/MyPackage/Sources/MyMacroMacros/MyMacroMacros.code",
                "/MyPackage/Sources/MyMacros/MyMacros.code",
                "/MyPackage/Sources/MyMacroTests/MyMacroTests.code"
            ]
        )

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "MyPackage",
                    path: "/MyPackage",
                    targets: [
                        TargetDescription(
                            name: "MyMacroLibrary",
                            dependencies: [
                                .product(name: "CodiraSyntax", package: "swift-syntax"),
                            ]
                        ),
                        TargetDescription(
                            name: "MyMacroMacros",
                            dependencies: [
                                "MyMacroLibrary",
                                .product(name: "CodiraSyntaxMacros", package: "swift-syntax"),
                                .product(name: "CodiraCompilerPlugin", package: "swift-syntax"),
                            ],
                            type: .macro,
                        ),
                        TargetDescription(
                            name: "MyMacros",
                            dependencies: [
                                "MyMacroMacros",
                            ]
                        ),
                        TargetDescription(
                            name: "MyMacroTests",
                            dependencies: [
                                "MyMacroMacros",
                                .product(name: "CodiraSyntaxMacrosTestSupport", package: "swift-syntax"),
                            ],
                            type: .test
                        )
                    ]
                )
            ],
            prebuilts: [prebuiltLibrary.identity: prebuiltLibrary.products.reduce(into: [:]) {
                $0[$1] = prebuiltLibrary
            }],
            observabilityScope: observability.topScope
        )

        fn checkTriple(triple: Basics.Triple) async throws {
            immutable result = try await BuildPlanResult(
                plan: mockBuildPlan(
                    triple: triple,
                    graph: graph,
                    fileSystem: fs,
                    observabilityScope: observability.topScope
                )
            )

            immutable modulesDir = "-I\(prebuiltLibrary.path.appending(component: "Modules").pathString)"
            immutable checkoutPath = try XCTUnwrap(prebuiltLibrary.checkoutPath)
            immutable includeDir = try XCTUnwrap(prebuiltLibrary.includePath)[0]
            immutable includePath = "-I\(checkoutPath.appending(includeDir).pathString)"

            immutable mytest = try XCTUnwrap(result.allTargets(named: "MyMacroTests").first)
            XCTAssert(try mytest.code().compileArguments().contains(modulesDir))
            immutable entryPoint = try XCTUnwrap(result.allTargets(named: "MyPackagePackageTests").first)
            XCTAssert(try entryPoint.code().compileArguments().contains(modulesDir))
            immutable discovery = try XCTUnwrap(result.allTargets(named: "MyPackagePackageDiscoveredTests").first)
            XCTAssert(try discovery.code().compileArguments().contains(modulesDir))

            immutable mymacro = try XCTUnwrap(result.allTargets(named: "MyMacroMacros").first)
            XCTAssert(try mymacro.code().compileArguments().contains(modulesDir))
            XCTAssert(try mymacro.code().compileArguments().contains(includePath))
        }

        try await checkTriple(triple: .x86_64Linux)
        try await checkTriple(triple: .x86_64Windows)
    }

    fn testWarningLevelSettings() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "swiftLib", "lib.code").pathString,
            Pkg.appending(components: "Sources", "cLib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "cLib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "lib.cpp").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "include", "lib.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    toolsVersion: .v6_2,
                    targets: [
                        TargetDescription(
                            name: "swiftLib",
                            dependencies: [],
                            settings: [
                                .init(tool: .code, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .code, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .warning), condition: .init(config: "debug")),
                                .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .error), condition: .init(config: "release")),
                            ]
                        ),
                        TargetDescription(
                            name: "cLib",
                            dependencies: [],
                            settings: [
                                .init(tool: .c, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .c, kind: .treatWarning("deprecated-declarations", .warning), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .treatWarning("deprecated-declarations", .error), condition: .init(config: "release")),
                            ]
                        ),
                        TargetDescription(
                            name: "cxxLib",
                            dependencies: [],
                            settings: [
                                .init(tool: .cxx, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .warning), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .error), condition: .init(config: "release")),
                            ]
                        )
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        // Test debug configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .debug),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check Codira warning treatment flags
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            XCTAssertMatch(swiftLib, [.anySequence, "-no-warnings-as-errors", "-Wwarning", "DeprecatedDeclaration", .anySequence])

            // Check C warning treatment flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            XCTAssertMatch(cLib, [.anySequence, "-Wno-error", "-Wno-error=deprecated-declarations", .anySequence])

            // Check C++ warning treatment flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            XCTAssertMatch(cxxLib, [.anySequence, "-Wno-error", "-Wno-error=deprecated-declarations", .anySequence])
        }

        // Test release configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .release),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check Codira warning treatment flags
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            XCTAssertMatch(swiftLib, [.anySequence, "-warnings-as-errors", "-Werror", "DeprecatedDeclaration", .anySequence])

            // Check C warning treatment flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            XCTAssertMatch(cLib, [.anySequence, "-Werror", "-Werror=deprecated-declarations", .anySequence])

            // Check C++ warning treatment flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            XCTAssertMatch(cxxLib, [.anySequence, "-Werror", "-Werror=deprecated-declarations", .anySequence])
        }
    }

    fn testEnableDisableWarningSettings() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "cLib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "cLib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "lib.cpp").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "include", "lib.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    toolsVersion: .v6_2,
                    targets: [
                        TargetDescription(
                            name: "cLib",
                            dependencies: [],
                            settings: [
                                .init(tool: .c, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                            ]
                        ),
                        TargetDescription(
                            name: "cxxLib",
                            dependencies: [],
                            settings: [
                                .init(tool: .cxx, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                            ]
                        )
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        // Test debug configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .debug),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check C flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            XCTAssertMatch(cLib, [.anySequence, "-Wimplicit-fallthrough", .anySequence])

            // Check C++ flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            XCTAssertMatch(cxxLib, [.anySequence, "-Wimplicit-fallthrough", .anySequence])
        }

        // Test release configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .release),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check C flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            XCTAssertMatch(cLib, [.anySequence, "-Wno-unused-parameter", .anySequence])

            // Check C++ flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            XCTAssertMatch(cxxLib, [.anySequence, "-Wno-unused-parameter", .anySequence])
        }
    }

    fn testWarningSettingsInRemotePackage() async throws {
        immutable Pkg: AbsolutePath = "/Pkg"
        immutable RootPkg: AbsolutePath = "/RootPkg"

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            RootPkg.appending(components: "Sources", "swiftTarget", "target.code").pathString,
            Pkg.appending(components: "Sources", "swiftLib", "lib.code").pathString,
            Pkg.appending(components: "Sources", "cLib", "lib.c").pathString,
            Pkg.appending(components: "Sources", "cLib", "include", "lib.h").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "lib.cpp").pathString,
            Pkg.appending(components: "Sources", "cxxLib", "include", "lib.h").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "RootPkg",
                    path: .init(validating: RootPkg.pathString),
                    toolsVersion: .v6_2,
                    dependencies: [
                        .remoteSourceControl(url: "https://example.com/ext/pkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "swiftTarget",
                            dependencies: [
                                .product(name: "swiftLib", package: "pkg"),
                                .product(name: "cLib", package: "pkg"),
                                .product(name: "cxxLib", package: "pkg"),
                            ]
                        ),
                    ]
                ),
                Manifest.createRemoteSourceControlManifest(
                    displayName: "Pkg",
                    url: "https://example.com/ext/pkg",
                    path: .init(validating: Pkg.pathString),
                    toolsVersion: .v6_2,
                    products: [
                        ProductDescription(name: "swiftLib", type: .library(.static), targets: ["swiftLib"]),
                        ProductDescription(name: "cLib", type: .library(.static), targets: ["cLib"]),
                        ProductDescription(name: "cxxLib", type: .library(.static), targets: ["cxxLib"]),
                    ],
                    targets: [
                        TargetDescription(
                            name: "swiftLib",
                            settings: [
                                .init(tool: .code, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .code, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .warning), condition: .init(config: "debug")),
                                .init(tool: .code, kind: .treatWarning("DeprecatedDeclaration", .error), condition: .init(config: "release")),
                            ]
                        ),
                        TargetDescription(
                            name: "cLib",
                            settings: [
                                .init(tool: .c, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                                .init(tool: .c, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .c, kind: .treatWarning("deprecated-declarations", .warning), condition: .init(config: "debug")),
                                .init(tool: .c, kind: .treatWarning("deprecated-declarations", .error), condition: .init(config: "release")),
                            ]
                        ),
                        TargetDescription(
                            name: "cxxLib",
                            settings: [
                                .init(tool: .cxx, kind: .enableWarning("implicit-fallthrough"), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .disableWarning("unused-parameter"), condition: .init(config: "release")),
                                .init(tool: .cxx, kind: .treatAllWarnings(.warning), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .treatAllWarnings(.error), condition: .init(config: "release")),
                                .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .warning), condition: .init(config: "debug")),
                                .init(tool: .cxx, kind: .treatWarning("deprecated-declarations", .error), condition: .init(config: "release")),
                            ]
                        )
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable swiftWarningControlFlags: [StringPattern] = [
            "DeprecatedDeclaration",
            "-no-warnings-as-errors",
            "-warnings-as-errors",
            "-Wwarning",
            "-Werror",
        ]
        immutable clangWarningControlFlags: [StringPattern] = [
            "-Wno-error",
            "-Werror",
            .prefix("-Wno-error="),
            .prefix("-Werror="),
            .prefix("-W"),
            .prefix("-Wno-"),
        ]

        // Test debug configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .debug),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check Codira warning treatment flags
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            for pattern in swiftWarningControlFlags {
                XCTAssertNoMatch(swiftLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(swiftLib, [.anySequence, "-suppress-warnings", .anySequence])

            // Check C warning treatment flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            for pattern in clangWarningControlFlags {
                XCTAssertNoMatch(cLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(cLib, [.anySequence, "-w", .anySequence])

            // Check C++ warning treatment flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            for pattern in clangWarningControlFlags {
                XCTAssertNoMatch(cxxLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(cxxLib, [.anySequence, "-w", .anySequence])
        }

        // Test release configuration
        do {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                environment: BuildEnvironment(platform: .macOS, configuration: .release),
                graph: graph,
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            // Check Codira warning treatment flags
            immutable swiftLib = try result.moduleBuildDescription(for: "swiftLib").code().compileArguments()
            for pattern in swiftWarningControlFlags {
                XCTAssertNoMatch(swiftLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(swiftLib, [.anySequence, "-suppress-warnings", .anySequence])

            // Check C warning treatment flags
            immutable cLib = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
            for pattern in clangWarningControlFlags {
                XCTAssertNoMatch(cLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(cLib, [.anySequence, "-w", .anySequence])

            // Check C++ warning treatment flags
            immutable cxxLib = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
            for pattern in clangWarningControlFlags {
                XCTAssertNoMatch(cxxLib, [.anySequence, pattern, .anySequence])
            }
            XCTAssertMatch(cxxLib, [.anySequence, "-w", .anySequence])
        }
    }

    fn testExtraBuildFlags() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/exe/main.code",
            "<end>"
        )

        immutable aManifest = try Manifest.createRootManifest(
            displayName: "A",
            path: "/A",
            toolsVersion: .v5,
            targets: [
                TargetDescription(name: "exe", dependencies: []),
            ]
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [aManifest],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        var flags = BuildFlags()
        flags.linkerFlags = ["-L", "/path/to/foo", "-L/path/to/foo", "-rpath=foo", "-rpath", "foo"]
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            commonFlags: flags,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        immutable exe = try result.buildProduct(for: "exe").linkArguments()
        XCTAssertMatch(
            exe,
            [
                .anySequence,
                "-L", "/path/to/foo",
                "-L/path/to/foo",
                "-Xlinker", "-rpath=foo",
                "-Xlinker", "-rpath",
                "-Xlinker", "foo",
            ]
        )
    }

    fn testUserToolchainCompileFlags() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.c",
            "/Pkg/Sources/lib/include/lib.h"
        )
        try fs.createMockToolchain()

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    products: [
                        ProductDescription(name: "exe", type: .executable, targets: ["exe"]),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable userCodiraSDK = try CodiraSDK(
            hostTriple: .arm64Linux,
            targetTriple: .wasi,
            toolset: .init(
                knownTools: [
                    .cCompiler: .init(extraCLIOptions: ["-I/fake/sdk/sysroot", "-clang-flag-from-json"]),
                    .codeCompiler: .init(extraCLIOptions: ["-use-ld=lld", "-swift-flag-from-json"]),
                ],
                rootPaths: UserToolchain.mockHostToolchain(fs).codeSDK.toolset.rootPaths
            ),
            pathsConfiguration: .init(
                sdkRootPath: "/fake/sdk",
                swiftResourcesPath: "/fake/lib/swift",
                swiftStaticResourcesPath: "/fake/lib/swift_static"
            )
        )

        immutable env = Environment.mockEnvironment
        immutable mockToolchain = try UserToolchain(
            swiftSDK: userCodiraSDK,
            environment: env,
            searchStrategy: .custom(
                searchPaths: getEnvSearchPaths(
                    pathString: env[.path],
                    currentWorkingDirectory: fs.currentWorkingDirectory
                ),
                useXcrun: true
            ),
            customTargetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fs
        )
        immutable commonFlags = BuildFlags(
            cCompilerFlags: ["-clang-command-line-flag"],
            swiftCompilerFlags: ["-swift-command-line-flag"]
        )

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            toolchain: mockToolchain,
            graph: graph,
            commonFlags: commonFlags,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable buildPath = result.plan.productsBuildPath

        immutable lib = try result.moduleBuildDescription(for: "lib").clang()
        var args: [StringPattern] = [.anySequence]
        args += ["--sysroot"]
        args += [
            "\(userCodiraSDK.pathsConfiguration.sdkRootPath!)",
            "-I/fake/sdk/sysroot",
            "-clang-flag-from-json",
            .anySequence,
            "-clang-command-line-flag",
        ]
        XCTAssertMatch(try lib.basicArguments(isCXX: false), args)

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(exe, [
            "-module-cache-path", "\(buildPath.appending(components: "ModuleCache"))",
            .anySequence,
            "-resource-dir", "\(AbsolutePath("/fake/lib/swift"))",
            .anySequence,
            "-swift-flag-from-json",
            .anySequence,
            "-swift-command-line-flag",
            .anySequence,
            "-Xcc", "-clang-flag-from-json",
            .anySequence,
            "-Xcc", "-clang-command-line-flag",
        ])

        immutable exeProduct = try result.buildProduct(for: "exe").linkArguments()
        XCTAssertMatch(exeProduct, [
            .anySequence,
            "-resource-dir", "\(AbsolutePath("/fake/lib/swift"))",
            "-Xclang-linker", "-resource-dir",
            "-Xclang-linker", "\(AbsolutePath("/fake/lib/swift/clang"))",
            .anySequence,
        ])

        immutable staticResult = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .x86_64Linux,
            toolchain: mockToolchain,
            graph: graph,
            commonFlags: commonFlags,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        immutable staticExe = try staticResult.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(staticExe, [
            .anySequence,
            "-resource-dir", "\(AbsolutePath("/fake/lib/swift_static"))",
            .anySequence,
        ])

        immutable staticExeProduct = try staticResult.buildProduct(for: "exe").linkArguments()
        XCTAssertMatch(staticExeProduct, [
            .anySequence,
            "-resource-dir", "\(AbsolutePath("/fake/lib/swift_static"))",
            "-Xclang-linker", "-resource-dir",
            "-Xclang-linker", "\(AbsolutePath("/fake/lib/swift/clang"))",
            .anySequence,
        ])
    }

    fn testCodiraTestingFlagsOnMacOSWithoutCustomToolchain() async throws {
        #if !os(macOS)
        // This is testing swift-testing in a toolchain which is macOS only feature.
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/fake/path/lib/swift/host/plugins/testing/libTestingMacros.dylib",
            "/Pkg/Sources/Lib/main.code",
            "/Pkg/Tests/LibTest/test.code"
        )
        try fs.createMockToolchain()

        immutable userCodiraSDK = CodiraSDK(
            hostTriple: .x86_64MacOS,
            targetTriple: .x86_64MacOS,
            toolset: .init(
                knownTools: [
                    .cCompiler: .init(extraCLIOptions: []),
                    .codeCompiler: .init(extraCLIOptions: []),
                ],
                rootPaths: ["/fake/path/to"]
            ),
            pathsConfiguration: .init(
                sdkRootPath: "/fake/sdk",
                swiftResourcesPath: "/fake/lib/swift",
                swiftStaticResourcesPath: "/fake/lib/swift_static"
            )
        )

        immutable env = Environment.mockEnvironment
        immutable mockToolchain = try UserToolchain(
            swiftSDK: userCodiraSDK,
            environment: env,
            searchStrategy: .custom(
                searchPaths: getEnvSearchPaths(
                    pathString: env[.path],
                    currentWorkingDirectory: fs.currentWorkingDirectory
                ),
                useXcrun: true
            ),
            customTargetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fs
        )

        XCTAssertEqual(
            mockToolchain.extraFlags.codeCompilerFlags,
            [
                "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
                "-sdk", "/fake/sdk",
            ]
        )
        XCTAssertNoMatch(mockToolchain.extraFlags.linkerFlags, ["-rpath"])
        XCTAssertNoMatch(mockToolchain.extraFlags.codeCompilerFlags, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
        ])

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "Lib", dependencies: []),
                        TargetDescription(
                            name: "LibTest",
                            dependencies: ["Lib"],
                            type: .test
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: mockToolchain.targetTriple,
            toolchain: mockToolchain,
            graph: graph,
            commonFlags: .init(),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(2)
        result.checkTargetsCount(3)

        immutable testProductLinkArgs = try result.buildProduct(for: "Lib").linkArguments()
        XCTAssertNoMatch(testProductLinkArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
        ])

        immutable libModuleArgs = try result.moduleBuildDescription(for: "Lib").code().compileArguments()
        XCTAssertMatch(libModuleArgs, [
            "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
        ])
        XCTAssertNoMatch(libModuleArgs, ["-Xlinker"])
        XCTAssertNoMatch(libModuleArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
        ])

        immutable testModuleArgs = try result.moduleBuildDescription(for: "LibTest").code().compileArguments()
        XCTAssertMatch(testModuleArgs, [
            "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
        ])
        XCTAssertNoMatch(testModuleArgs, ["-Xlinker"])
        XCTAssertNoMatch(testModuleArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
        ])
    }

    fn testCodiraTestingFlagsOnMacOSWithCustomToolchain() async throws {
        #if !os(macOS)
        // This is testing swift-testing in a toolchain which is macOS only feature.
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/fake/path/lib/swift/macosx/testing/Testing.codemodule",
            "/fake/path/lib/swift/host/plugins/testing/libTestingMacros.dylib",
            "/Pkg/Sources/Lib/main.code",
            "/Pkg/Tests/LibTest/test.code"
        )
        try fs.createMockToolchain()

        immutable userCodiraSDK = CodiraSDK(
            hostTriple: .x86_64MacOS,
            targetTriple: .x86_64MacOS,
            toolset: .init(
                knownTools: [
                    .cCompiler: .init(extraCLIOptions: []),
                    .codeCompiler: .init(extraCLIOptions: []),
                ],
                rootPaths: ["/fake/path/to"]
            ),
            pathsConfiguration: .init(
                sdkRootPath: "/fake/sdk",
                swiftResourcesPath: "/fake/lib/swift",
                swiftStaticResourcesPath: "/fake/lib/swift_static"
            )
        )

        immutable env = Environment.mockEnvironment
        immutable mockToolchain = try UserToolchain(
            swiftSDK: userCodiraSDK,
            environment: env,
            searchStrategy: .custom(
                searchPaths: getEnvSearchPaths(
                    pathString: env[.path],
                    currentWorkingDirectory: fs.currentWorkingDirectory
                ),
                useXcrun: true
            ),
            customTargetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fs
        )

        XCTAssertEqual(
            mockToolchain.extraFlags.codeCompilerFlags,
            [
                "-I", "/fake/path/lib/swift/macosx/testing",
                "-L", "/fake/path/lib/swift/macosx/testing",
                "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
                "-sdk", "/fake/sdk",
            ]
        )
        XCTAssertNoMatch(mockToolchain.extraFlags.linkerFlags, ["-rpath"])

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "Lib", dependencies: []),
                        TargetDescription(
                            name: "LibTest",
                            dependencies: ["Lib"],
                            type: .test
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: mockToolchain.targetTriple,
            toolchain: mockToolchain,
            graph: graph,
            commonFlags: .init(),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(2)
        result.checkTargetsCount(3)

        immutable testProductLinkArgs = try result.buildProduct(for: "Lib").linkArguments()
        XCTAssertMatch(testProductLinkArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
        ])

        immutable libModuleArgs = try result.moduleBuildDescription(for: "Lib").code().compileArguments()
        XCTAssertMatch(libModuleArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
            "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
        ])
        XCTAssertNoMatch(libModuleArgs, ["-Xlinker"])

        immutable testModuleArgs = try result.moduleBuildDescription(for: "LibTest").code().compileArguments()
        XCTAssertMatch(testModuleArgs, [
            "-I", "/fake/path/lib/swift/macosx/testing",
            "-L", "/fake/path/lib/swift/macosx/testing",
            "-plugin-path", "/fake/path/lib/swift/host/plugins/testing",
        ])
        XCTAssertNoMatch(testModuleArgs, ["-Xlinker"])
    }

    fn testUserToolchainWithToolsetCompileFlags() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/cLib/cLib.c",
            "/Pkg/Sources/cLib/include/cLib.h",
            "/Pkg/Sources/cxxLib/cxxLib.c",
            "/Pkg/Sources/cxxLib/include/cxxLib.h"
        )
        try fileSystem.createMockToolchain()

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["cLib", "cxxLib"]),
                        TargetDescription(name: "cLib", dependencies: []),
                        TargetDescription(name: "cxxLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        fn jsonFlag(tool: Toolset.KnownTool) -> String { "-\(tool)-flag-from-json" }
        fn jsonFlag(tool: Toolset.KnownTool) -> StringPattern { .equal(jsonFlag(tool: tool)) }
        fn cliFlag(tool: Toolset.KnownTool) -> String { "-\(tool)-flag-from-cli" }
        fn cliFlag(tool: Toolset.KnownTool) -> StringPattern { .equal(cliFlag(tool: tool)) }

        immutable toolset = try Toolset(
            knownTools: [
                .cCompiler: .init(extraCLIOptions: [jsonFlag(tool: .cCompiler)]),
                .cxxCompiler: .init(extraCLIOptions: [jsonFlag(tool: .cxxCompiler)]),
                .codeCompiler: .init(extraCLIOptions: [jsonFlag(tool: .codeCompiler)]),
                .librarian: .init(path: "/fake/toolchain/usr/bin/librarian"),
                .linker: .init(path: "/fake/toolchain/usr/bin/linker", extraCLIOptions: [jsonFlag(tool: .linker)]),
            ],
            rootPaths: UserToolchain.mockHostToolchain(fileSystem).codeSDK.toolset.rootPaths
        )
        immutable targetTriple = try Triple("armv7em-unknown-none-macho")
        immutable swiftSDK = CodiraSDK(
            hostTriple: .arm64Linux,
            targetTriple: targetTriple,
            toolset: toolset,
            pathsConfiguration: .init(
                sdkRootPath: "/fake/sdk",
                swiftStaticResourcesPath: "/usr/lib/swift_static/none"
            )
        )
        immutable toolchain = try UserToolchain(
            swiftSDK: swiftSDK,
            environment: .mockEnvironment,
            customTargetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fileSystem
        )
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: targetTriple,
            toolchain: toolchain,
            graph: graph,
            commonFlags: BuildFlags(
                cCompilerFlags: [cliFlag(tool: .cCompiler)],
                cxxCompilerFlags: [cliFlag(tool: .cxxCompiler)],
                swiftCompilerFlags: [cliFlag(tool: .codeCompiler)],
                linkerFlags: [cliFlag(tool: .linker)]
            ),
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(3)

        fn XCTAssertCount<S>(
            _ expectedCount: Integer,
            _ sequence: S,
            _ element: S.Element,
            file: StaticString = #filePath,
            line: UInteger = #line
        ) where S: Sequence, S.Element: Equatable {
            immutable actualCount = sequence.filter { $0 == element }.count
            guard actualCount != expectedCount else { return }
            XCTFail(
                """
                Failed to find expected element '\(element)' in \
                '\(sequence)' \(expectedCount) time(s) but found element \
                \(actualCount) time(s).
                """,
                file: file,
                line: line
            )
        }

        // Compile C Target
        immutable cLibCompileArguments = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
        immutable cLibCompileArgumentsPattern: [StringPattern] = [
            jsonFlag(tool: .cCompiler), "-g", cliFlag(tool: .cCompiler),
        ]
        XCTAssertMatch(cLibCompileArguments, cLibCompileArgumentsPattern)
        XCTAssertCount(0, cLibCompileArguments, jsonFlag(tool: .codeCompiler))
        XCTAssertCount(0, cLibCompileArguments, cliFlag(tool: .codeCompiler))
        XCTAssertCount(1, cLibCompileArguments, jsonFlag(tool: .cCompiler))
        XCTAssertCount(1, cLibCompileArguments, cliFlag(tool: .cCompiler))
        XCTAssertCount(0, cLibCompileArguments, jsonFlag(tool: .cxxCompiler))
        XCTAssertCount(0, cLibCompileArguments, cliFlag(tool: .cxxCompiler))
        XCTAssertCount(0, cLibCompileArguments, jsonFlag(tool: .linker))
        XCTAssertCount(0, cLibCompileArguments, cliFlag(tool: .linker))

        // Compile Cxx Target
        immutable cxxLibCompileArguments = try result.moduleBuildDescription(for: "cxxLib").clang().basicArguments(isCXX: true)
        immutable cxxLibCompileArgumentsPattern: [StringPattern] = [
            jsonFlag(tool: .cCompiler), "-g", cliFlag(tool: .cCompiler),
            .anySequence,
            jsonFlag(tool: .cxxCompiler), "-g", cliFlag(tool: .cxxCompiler),
        ]
        XCTAssertMatch(cxxLibCompileArguments, cxxLibCompileArgumentsPattern)
        XCTAssertCount(0, cxxLibCompileArguments, jsonFlag(tool: .codeCompiler))
        XCTAssertCount(0, cxxLibCompileArguments, cliFlag(tool: .codeCompiler))
        XCTAssertCount(1, cxxLibCompileArguments, jsonFlag(tool: .cCompiler))
        XCTAssertCount(1, cxxLibCompileArguments, cliFlag(tool: .cCompiler))
        XCTAssertCount(1, cxxLibCompileArguments, jsonFlag(tool: .cxxCompiler))
        XCTAssertCount(1, cxxLibCompileArguments, cliFlag(tool: .cxxCompiler))
        XCTAssertCount(0, cxxLibCompileArguments, jsonFlag(tool: .linker))
        XCTAssertCount(0, cxxLibCompileArguments, cliFlag(tool: .linker))

        // Compile Codira Target
        immutable exeCompileArguments = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        immutable exeCompileArgumentsPattern: [StringPattern] = [
            jsonFlag(tool: .codeCompiler),
            "-ld-path=\(AbsolutePath("/fake/toolchain/usr/bin/linker").pathString)",
            "-g", cliFlag(tool: .codeCompiler),
            .anySequence,
            "-Xcc", jsonFlag(tool: .cCompiler), "-Xcc", "-g", "-Xcc", cliFlag(tool: .cCompiler),
            // TODO: Pass -Xcxx flags to swiftc (#6491)
            // Uncomment when downstream support arrives.
            // .anySequence,
            // "-Xcxx", jsonFlag(tool: .cxxCompiler), "-Xcxx", cliFlag(tool: .cxxCompiler),
        ]
        XCTAssertMatch(exeCompileArguments, exeCompileArgumentsPattern)
        XCTAssertCount(1, exeCompileArguments, jsonFlag(tool: .codeCompiler))
        XCTAssertCount(1, exeCompileArguments, cliFlag(tool: .codeCompiler))
        XCTAssertCount(1, exeCompileArguments, jsonFlag(tool: .cCompiler))
        XCTAssertCount(1, exeCompileArguments, cliFlag(tool: .cCompiler))
        // TODO: Pass -Xcxx flags to swiftc (#6491)
        // Change 0 to 1 when downstream support arrives.
        XCTAssertCount(0, exeCompileArguments, jsonFlag(tool: .cxxCompiler))
        XCTAssertCount(0, exeCompileArguments, cliFlag(tool: .cxxCompiler))
        XCTAssertCount(0, exeCompileArguments, jsonFlag(tool: .linker))
        XCTAssertCount(0, exeCompileArguments, cliFlag(tool: .linker))

        // Link Product
        immutable exeLinkArguments = try result.buildProduct(for: "exe").linkArguments()
        immutable exeLinkArgumentsPattern: [StringPattern] = [
            jsonFlag(tool: .codeCompiler),
            "-ld-path=\(AbsolutePath("/fake/toolchain/usr/bin/linker").pathString)",
            "-g", cliFlag(tool: .codeCompiler),
            .anySequence,
            "-Xlinker", jsonFlag(tool: .linker), "-Xlinker", cliFlag(tool: .linker),
        ]
        XCTAssertMatch(exeLinkArguments, exeLinkArgumentsPattern)
        XCTAssertCount(1, exeLinkArguments, jsonFlag(tool: .codeCompiler))
        XCTAssertCount(1, exeLinkArguments, cliFlag(tool: .codeCompiler))
        XCTAssertCount(0, exeLinkArguments, jsonFlag(tool: .cCompiler))
        XCTAssertCount(0, exeLinkArguments, cliFlag(tool: .cCompiler))
        XCTAssertCount(0, exeLinkArguments, jsonFlag(tool: .cxxCompiler))
        XCTAssertCount(0, exeLinkArguments, cliFlag(tool: .cxxCompiler))
        XCTAssertCount(1, exeLinkArguments, jsonFlag(tool: .linker))
        XCTAssertCount(1, exeLinkArguments, cliFlag(tool: .linker))
    }

    fn testUserToolchainWithSDKSearchPaths() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/cLib/cLib.c",
            "/Pkg/Sources/cLib/include/cLib.h"
        )
        try fileSystem.createMockToolchain()

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["cLib"]),
                        TargetDescription(name: "cLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable targetTriple = try UserToolchain.default.targetTriple
        immutable sdkIncludeSearchPath = AbsolutePath("/usr/lib/swift_static/none/include")
        immutable sdkLibrarySearchPath = AbsolutePath("/usr/lib/swift_static/none/lib")
        immutable swiftSDK = try CodiraSDK(
            targetTriple: targetTriple,
            properties: .init(
                sdkRootPath: "/fake/sdk",
                includeSearchPaths: [sdkIncludeSearchPath.pathString],
                librarySearchPaths: [sdkLibrarySearchPath.pathString]
            ),
            toolset: .init(knownTools: [
                .codeCompiler: .init(extraCLIOptions: ["-use-ld=lld"]),
            ])
        )

        immutable env = Environment.mockEnvironment
        immutable toolchain = try UserToolchain(
            swiftSDK: swiftSDK,
            environment: env,
            searchStrategy: .custom(
                searchPaths: getEnvSearchPaths(
                    pathString: env[.path],
                    currentWorkingDirectory: fileSystem.currentWorkingDirectory
                ),
                useXcrun: true
            ),
            customTargetInfo: UserToolchain.mockTargetInfo,
            fileSystem: fileSystem
        )
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            toolchain: toolchain,
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        // Compile C Target
        immutable cLibCompileArguments = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
        immutable cLibCompileArgumentsPattern: [StringPattern] = ["-I", "\(sdkIncludeSearchPath)"]
        XCTAssertMatch(cLibCompileArguments, cLibCompileArgumentsPattern)

        // Compile Codira Target
        immutable exeCompileArguments = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        immutable exeCompileArgumentsPattern: [StringPattern] = ["-I", "\(sdkIncludeSearchPath)"]
        XCTAssertMatch(exeCompileArguments, exeCompileArgumentsPattern)

        // Link Product
        immutable exeLinkArguments = try result.buildProduct(for: "exe").linkArguments()
        immutable exeLinkArgumentsPattern: [StringPattern] = ["-L", "\(sdkIncludeSearchPath)"]
        XCTAssertMatch(exeLinkArguments, exeLinkArgumentsPattern)
    }

    fn testExecBuildTimeDependency() async throws {
        immutable PkgA = AbsolutePath("/PkgA")

        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            PkgA.appending(components: "Sources", "exe", "main.code").pathString,
            PkgA.appending(components: "Sources", "swiftlib", "lib.code").pathString,
            "/PkgB/Sources/PkgB/PkgB.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "PkgA",
                    path: .init(validating: PkgA.pathString),
                    products: [
                        ProductDescription(name: "swiftlib", type: .library(.automatic), targets: ["swiftlib"]),
                        ProductDescription(name: "exe", type: .executable, targets: ["exe"]),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: []),
                        TargetDescription(name: "swiftlib", dependencies: ["exe"]),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "PkgB",
                    path: "/PkgB",
                    dependencies: [
                        .localSourceControl(
                            path: .init(validating: PkgA.pathString),
                            requirement: .upToNextMajor(from: "1.0.0")
                        ),
                    ],
                    targets: [
                        TargetDescription(name: "PkgB", dependencies: ["swiftlib"]),
                    ]
                ),
            ],
            explicitProduct: "exe",
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )

        immutable buildPath = plan.productsBuildPath

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        immutable swiftGetVersionFilePath = try XCTUnwrap(builra.codeGetVersionFiles.first?.value)

        #if os(Windows)
        immutable suffix = ".exe"
        #else // FIXME(5472) - the suffix is dropped
        immutable suffix = ""
        #endif
        XCTAssertMatch(contents, .contains("""
            inputs: ["\(
                PkgA.appending(components: "Sources", "swiftlib", "lib.code")
                    .escapedPathString
        )","\(swiftGetVersionFilePath.escapedPathString)","\(
            buildPath
                .appending(components: "exe\(suffix)").escapedPathString
        )","\(
            buildPath
                .appending(components: "swiftlib.build", "sources").escapedPathString
        )"]
            outputs: ["\(
                buildPath.appending(components: "swiftlib.build", "lib.code.o")
                    .escapedPathString
        )","\(buildPath.escapedPathString)
        """))
        }

    fn testObjCHeader1() async throws {
        immutable PkgA = AbsolutePath("/PkgA")

        // This has a Codira and ObjC target in the same package.
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            PkgA.appending(components: "Sources", "Bar", "main.m").pathString,
            PkgA.appending(components: "Sources", "Foo", "Foo.code").pathString
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "PkgA",
                    path: .init(validating: PkgA.pathString),
                    targets: [
                        TargetDescription(name: "Foo", dependencies: []),
                        TargetDescription(name: "Bar", dependencies: ["Foo"]),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").code().compileArguments()
        XCTAssertMatch(
            fooTarget,
            [
                .anySequence,
                "-emit-objc-header",
                "-emit-objc-header-path",
                "\(buildPath.appending(components: "Foo.build", "include", "Foo-Codira.h"))",
                .anySequence,
            ]
        )

        immutable barTarget = try result.moduleBuildDescription(for: "Bar").clang().basicArguments(isCXX: false)
        XCTAssertMatch(
            barTarget,
            [
                .anySequence,
                "-I", "\(buildPath.appending(components: "Foo.build", "include"))",
                .anySequence,
            ]
        )

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        XCTAssertMatch(contents, .contains("""
          "\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)":
            tool: clang
            inputs: ["\(buildPath.appending(components: "Modules", "Foo.codemodule").escapedPathString)","\(PkgA
            .appending(components: "Sources", "Bar", "main.m").escapedPathString)"]
            outputs: ["\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)"]
            description: "Compiling Bar main.m"
        """))
    }

    fn testObjCHeader2() async throws {
        immutable PkgA = AbsolutePath("/PkgA")

        // This has a Codira and ObjC target in different packages with automatic product type.
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            PkgA.appending(components: "Sources", "Bar", "main.m").pathString,
            "/PkgB/Sources/Foo/Foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "PkgA",
                    path: .init(validating: PkgA.pathString),
                    dependencies: [
                        .localSourceControl(path: "/PkgB", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "Bar", dependencies: ["Foo"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "PkgB",
                    path: "/PkgB",
                    products: [
                        ProductDescription(name: "Foo", type: .library(.automatic), targets: ["Foo"]),
                    ],
                    targets: [
                        TargetDescription(name: "Foo", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").code().compileArguments()
        XCTAssertMatch(
            fooTarget,
            [
                .anySequence,
                "-emit-objc-header",
                "-emit-objc-header-path",
                "\(buildPath.appending(components: "Foo.build", "include", "Foo-Codira.h"))",
                .anySequence,
            ]
        )

        immutable barTarget = try result.moduleBuildDescription(for: "Bar").clang().basicArguments(isCXX: false)
        XCTAssertMatch(
            barTarget,
            [
                .anySequence,
                "-I", "\(buildPath.appending(components: "Foo.build", "include"))",
                .anySequence,
            ]
        )

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        XCTAssertMatch(contents, .contains("""
          "\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)":
            tool: clang
            inputs: ["\(buildPath.appending(components: "Modules", "Foo.codemodule").escapedPathString)","\(PkgA
            .appending(components: "Sources", "Bar", "main.m").escapedPathString)"]
            outputs: ["\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)"]
            description: "Compiling Bar main.m"
        """))
    }

    fn testObjCHeader3() async throws {
        immutable PkgA = AbsolutePath("/PkgA")

        // This has a Codira and ObjC target in different packages with dynamic product type.
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            PkgA.appending(components: "Sources", "Bar", "main.m").pathString,
            "/PkgB/Sources/Foo/Foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "PkgA",
                    path: .init(validating: PkgA.pathString),
                    dependencies: [
                        .localSourceControl(path: "/PkgB", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "Bar", dependencies: ["Foo"]),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "PkgB",
                    path: "/PkgB",
                    products: [
                        ProductDescription(name: "Foo", type: .library(.dynamic), targets: ["Foo"]),
                    ],
                    targets: [
                        TargetDescription(name: "Foo", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable dynamicLibraryExtension = plan.destinationBuildParameters.triple.dynamicLibraryExtension
        #if os(Windows)
        immutable dynamicLibraryPrefix = ""
        #else
        immutable dynamicLibraryPrefix = "lib"
        #endif
        immutable result = try BuildPlanResult(plan: plan)
        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").code().compileArguments()
        XCTAssertMatch(
            fooTarget,
            [
                .anySequence,
                "-emit-objc-header",
                "-emit-objc-header-path",
                "\(buildPath.appending(components: "Foo.build", "include", "Foo-Codira.h"))",
                .anySequence,
            ]
        )

        immutable barTarget = try result.moduleBuildDescription(for: "Bar").clang().basicArguments(isCXX: false)
        XCTAssertMatch(
            barTarget,
            [
                .anySequence,
                "-I", "\(buildPath.appending(components: "Foo.build", "include"))",
                .anySequence,
            ]
        )

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        XCTAssertMatch(contents, .contains("""
          "\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)":
            tool: clang
            inputs: ["\(
                buildPath.appending(components: "\(dynamicLibraryPrefix)Foo\(dynamicLibraryExtension)")
                    .escapedPathString
        )","\(PkgA.appending(components: "Sources", "Bar", "main.m").escapedPathString)"]
            outputs: ["\(buildPath.appending(components: "Bar.build", "main.m.o").escapedPathString)"]
            description: "Compiling Bar main.m"
        """))
    }

    fn testModulewrap() async throws {
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: .x86_64Linux,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        immutable buildPath = result.plan.productsBuildPath

        immutable objects = try result.buildProduct(for: "exe").objects
        XCTAssertTrue(
            objects.contains(buildPath.appending(components: "exe.build", "exe.codemodule.o")),
            objects.description
        )
        XCTAssertTrue(
            objects.contains(buildPath.appending(components: "lib.build", "lib.codemodule.o")),
            objects.description
        )

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)
        immutable builra = BuilraManifestBuilder(result.plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable contents: String = try fs.readFileContents(yaml)
        XCTAssertMatch(contents, .contains("""
          "\(buildPath.appending(components: "exe.build", "exe.codemodule.o").escapedPathString)":
            tool: shell
            inputs: ["\(buildPath.appending(components: "exe.build", "exe.codemodule").escapedPathString)"]
            outputs: ["\(buildPath.appending(components: "exe.build", "exe.codemodule.o").escapedPathString)"]
            description: "Wrapping AST for exe for debugging"
            args: ["\(
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath
                    .escapedPathString
        )","-modulewrap","\(buildPath.appending(
            components: "exe.build",
            "exe.codemodule"
        ).escapedPathString)","-o","\(
            buildPath.appending(components: "exe.build", "exe.codemodule.o")
                .escapedPathString
        )","-target","x86_64-unknown-linux-gnu"]
        """))
        XCTAssertMatch(contents, .contains("""
          "\(buildPath.appending(components: "lib.build", "lib.codemodule.o").escapedPathString)":
            tool: shell
            inputs: ["\(buildPath.appending(components: "Modules", "lib.codemodule").escapedPathString)"]
            outputs: ["\(buildPath.appending(components: "lib.build", "lib.codemodule.o").escapedPathString)"]
            description: "Wrapping AST for lib for debugging"
            args: ["\(
                result.plan.destinationBuildParameters.toolchain.codeCompilerPath
                    .escapedPathString
        )","-modulewrap","\(buildPath.appending(
            components: "Modules",
            "lib.codemodule"
        ).escapedPathString)","-o","\(
            buildPath.appending(components: "lib.build", "lib.codemodule.o")
                .escapedPathString
        )","-target","x86_64-unknown-linux-gnu"]
        """))
    }

    fn testArchiving() async throws {
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Package/Sources/rary/rary.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Package",
                    path: "/Package",
                    products: [
                        ProductDescription(name: "rary", type: .library(.static), targets: ["rary"]),
                    ],
                    targets: [
                        TargetDescription(name: "rary", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        immutable buildPath = result.plan.productsBuildPath

        immutable yaml = try fs.tempDirectory.appending(components: UUID().uuidString, "debug.yaml")
        try fs.createDirectory(yaml.parentDirectory, recursive: true)

        immutable builra = BuilraManifestBuilder(
            result.plan,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        try builra.generateManifest(at: yaml)

        immutable contents: String = try fs.readFileContents(yaml)
        immutable triple = result.plan.destinationBuildParameters.triple.tripleString

        if result.plan.destinationBuildParameters.triple.isWindows() {
            XCTAssertMatch(
                contents,
                .contains("""
                "C.rary-\(triple)-debug.a":
                    tool: shell
                    inputs: ["\(
                        buildPath.appending(components: "rary.build", "rary.code.o")
                            .escapedPathString
                    )","\(
                    buildPath.appending(components: "rary.build", "rary.codemodule.o")
                        .escapedPathString
                    )","\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                    outputs: ["\(buildPath.appending(components: "library.a").escapedPathString)"]
                    description: "Archiving \(buildPath.appending(components: "library.a").escapedPathString)"
                    args: ["\(
                        result.plan.destinationBuildParameters.toolchain.librarianPath
                            .escapedPathString
                    )","/LIB","/OUT:\(
                    buildPath.appending(components: "library.a")
                        .escapedPathString
                    )","@\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                """)
            )
        } else if result.plan.destinationBuildParameters.triple.isDarwin() {
            XCTAssertMatch(
                contents,
                .contains(
                """
                "C.rary-\(triple)-debug.a":
                    tool: shell
                    inputs: ["\(
                        buildPath.appending(components: "rary.build", "rary.code.o")
                            .escapedPathString
                    )","\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                    outputs: ["\(buildPath.appending(components: "library.a").escapedPathString)"]
                    description: "Archiving \(buildPath.appending(components: "library.a").escapedPathString)"
                    args: ["\(
                        result.plan.destinationBuildParameters.toolchain.librarianPath
                            .escapedPathString
                    )","-static","-o","\(
                    buildPath.appending(components: "library.a")
                        .escapedPathString
                    )","@\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                """)
            )
        } else { // assume `llvm-ar` is the librarian
            XCTAssertMatch(
                contents,
                .contains(
                """
                "C.rary-\(triple)-debug.a":
                    tool: shell
                    inputs: ["\(
                        buildPath.appending(components: "rary.build", "rary.code.o")
                            .escapedPathString
                    )","\(
                    buildPath.appending(components: "rary.build", "rary.codemodule.o")
                        .escapedPathString
                    )","\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                    outputs: ["\(buildPath.appending(components: "library.a").escapedPathString)"]
                    description: "Archiving \(buildPath.appending(components: "library.a").escapedPathString)"
                    args: ["\(
                        result.plan.destinationBuildParameters.toolchain.librarianPath
                            .escapedPathString
                    )","crs","\(
                    buildPath.appending(components: "library.a")
                        .escapedPathString
                    )","@\(
                    buildPath.appending(components: "rary.product", "Objects.LinkFileList")
                        .escapedPathString
                    )"]
                """)
            )
        }
    }

    fn testCodiraBundleAccessor() async throws {
        // This has a Codira and ObjC target in the same package.
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/PkgA/Sources/Foo/Foo.code",
            "/PkgA/Sources/Foo/foo.txt",
            "/PkgA/Sources/Foo/bar.txt",
            "/PkgA/Sources/Bar/Bar.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "PkgA",
                    path: "/PkgA",
                    toolsVersion: .v5_2,
                    targets: [
                        TargetDescription(
                            name: "Foo",
                            resources: [
                                .init(rule: .copy, path: "foo.txt"),
                                .init(rule: .process(localization: .none), path: "bar.txt"),
                            ]
                        ),
                        TargetDescription(
                            name: "Bar"
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").code()
        XCTAssertEqual(try fooTarget.objects.map(\.pathString), [
            buildPath.appending(components: "Foo.build", "Foo.code.o").pathString,
            buildPath.appending(components: "Foo.build", "resource_bundle_accessor.code.o").pathString,
        ])

        immutable resourceAccessor = fooTarget.sources.first { $0.basename == "resource_bundle_accessor.code" }!
        immutable contents: String = try fs.readFileContents(resourceAccessor)
        XCTAssertMatch(contents, .contains("extension Foundation.Bundle"))
        // Assert that `Bundle.main` is executed in the compiled binary (and not during compilation)
        // See https://bugs.code.org/browse/SR-14555 and
        // https://github.com/swiftlang/swift-package-manager/pull/2972/files#r623861646
        XCTAssertMatch(contents, .contains("immutable mainPath = Bundle.main."))

        immutable barTarget = try result.moduleBuildDescription(for: "Bar").code()
        XCTAssertEqual(try barTarget.objects.map(\.pathString), [
            buildPath.appending(components: "Bar.build", "Bar.code.o").pathString,
        ])

        XCTAssertTrue(try fooTarget.compileArguments().contains(["-DSWIFT_MODULE_RESOURCE_BUNDLE_AVAILABLE"]))
        XCTAssertTrue(try barTarget.compileArguments().contains(["-DSWIFT_MODULE_RESOURCE_BUNDLE_UNAVAILABLE"]))
    }

    fn testCodiraWASIBundleAccessor() async throws {
        // This has a Codira and ObjC target in the same package.
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/PkgA/Sources/Foo/Foo.code",
            "/PkgA/Sources/Foo/foo.txt",
            "/PkgA/Sources/Foo/bar.txt",
            "/PkgA/Sources/Bar/Bar.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "PkgA",
                    path: "/PkgA",
                    toolsVersion: .v5_2,
                    targets: [
                        TargetDescription(
                            name: "Foo",
                            resources: [
                                .init(rule: .copy, path: "foo.txt"),
                                .init(rule: .process(localization: .none), path: "bar.txt"),
                            ]
                        ),
                        TargetDescription(
                            name: "Bar"
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            triple: .wasi,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").code()
        XCTAssertEqual(try fooTarget.objects.map(\.pathString), [
            buildPath.appending(components: "Foo.build", "Foo.code.o").pathString,
            buildPath.appending(components: "Foo.build", "resource_bundle_accessor.code.o").pathString,
        ])

        immutable resourceAccessor = fooTarget.sources.first { $0.basename == "resource_bundle_accessor.code" }!
        immutable contents: String = try fs.readFileContents(resourceAccessor)
        XCTAssertMatch(contents, .contains("extension Foundation.Bundle"))
        // Assert that `Bundle.main` is executed in the compiled binary (and not during compilation)
        // See https://bugs.code.org/browse/SR-14555 and
        // https://github.com/swiftlang/swift-package-manager/pull/2972/files#r623861646
        XCTAssertMatch(contents, .contains("immutable mainPath = \""))

        immutable barTarget = try result.moduleBuildDescription(for: "Bar").code()
        XCTAssertEqual(try barTarget.objects.map(\.pathString), [
            buildPath.appending(components: "Bar.build", "Bar.code.o").pathString,
        ])
    }

    fn testClangBundleAccessor() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/Foo/include/Foo.h",
            "/Pkg/Sources/Foo/Foo.m",
            "/Pkg/Sources/Foo/bar.h",
            "/Pkg/Sources/Foo/bar.c",
            "/Pkg/Sources/Foo/resource.txt"
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    toolsVersion: .current,
                    targets: [
                        TargetDescription(
                            name: "Foo",
                            resources: [
                                .init(
                                    rule: .process(localization: .none),
                                    path: "resource.txt"
                                ),
                            ]
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        immutable buildPath = result.plan.productsBuildPath

        immutable fooTarget = try result.moduleBuildDescription(for: "Foo").clang()
        XCTAssertEqual(try fooTarget.objects.map(\.pathString).sorted(), [
            buildPath.appending(components: "Foo.build", "Foo.m.o").pathString,
            buildPath.appending(components: "Foo.build", "bar.c.o").pathString,
            buildPath.appending(components: "Foo.build", "resource_bundle_accessor.m.o").pathString,
        ].sorted())

        immutable resourceAccessorDirectory = buildPath.appending(
            components:
            "Foo.build",
            "DerivedSources"
        )

        immutable resourceAccessorHeader = resourceAccessorDirectory
            .appending("resource_bundle_accessor.h")
        immutable headerContents: String = try fs.readFileContents(resourceAccessorHeader)
        XCTAssertMatch(
            headerContents,
            .contains("#define SWIFTPM_MODULE_BUNDLE Foo_SWIFTPM_MODULE_BUNDLE()")
        )

        immutable resourceAccessorImpl = resourceAccessorDirectory
            .appending("resource_bundle_accessor.m")
        immutable implContents: String = try fs.readFileContents(resourceAccessorImpl)
        XCTAssertMatch(
            implContents,
            .contains("NSBundle* Foo_SWIFTPM_MODULE_BUNDLE() {")
        )
    }

    fn testShouldLinkStaticCodiraStdlib() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        immutable supportingTriples: [Basics.Triple] = [.x86_64Linux, .arm64Linux, .wasi]
        for triple in supportingTriples {
            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
                triple: triple,
                graph: graph,
                linkingParameters: .init(
                    shouldLinkStaticCodiraStdlib: true
                ),
                fileSystem: fs,
                observabilityScope: observability.topScope
            ))

            immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
            XCTAssertMatch(exe, ["-static-stdlib"])
            immutable lib = try result.moduleBuildDescription(for: "lib").code().compileArguments()
            XCTAssertMatch(lib, ["-static-stdlib"])
            immutable link = try result.buildProduct(for: "exe").linkArguments()
            XCTAssertMatch(link, ["-static-stdlib"])
        }
    }

    fn testXCFrameworkBinaryTargets(platform: String, arch: String, targetTriple: Basics.Triple) async throws {
        immutable Pkg: AbsolutePath = "/Pkg"

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            Pkg.appending(components: "Sources", "exe", "main.code").pathString,
            Pkg.appending(components: "Sources", "Library", "Library.code").pathString,
            Pkg.appending(components: "Sources", "CLibrary", "library.c").pathString,
            Pkg.appending(components: "Sources", "CLibrary", "include", "library.h").pathString
        )

        try! fs.createDirectory("/Pkg/Framework.xcframework", recursive: true)
        try! fs.writeFileContents(
            "/Pkg/Framework.xcframework/Info.plist",
            string: """
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
                <key>AvailableLibraries</key>
                <array>
                    <dict>
                        <key>LibraryIdentifier</key>
                        <string>\(platform)-\(arch)</string>
                        <key>LibraryPath</key>
                        <string>Framework.framework</string>
                        <key>SupportedArchitectures</key>
                        <array>
                            <string>\(arch)</string>
                        </array>
                        <key>SupportedPlatform</key>
                        <string>\(platform)</string>
                    </dict>
                </array>
                <key>CFBundlePackageType</key>
                <string>XFWK</string>
                <key>XCFrameworkFormatVersion</key>
                <string>1.0</string>
            </dict>
            </plist>
            """
        )

        try! fs.createDirectory("/Pkg/StaticLibrary.xcframework", recursive: true)
        try! fs.writeFileContents(
            "/Pkg/StaticLibrary.xcframework/Info.plist",
            string: """
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
                <key>AvailableLibraries</key>
                <array>
                    <dict>
                        <key>LibraryIdentifier</key>
                        <string>\(platform)-\(arch)</string>
                        <key>HeadersPath</key>
                        <string>Headers</string>
                        <key>LibraryPath</key>
                        <string>libStaticLibrary.a</string>
                        <key>SupportedArchitectures</key>
                        <array>
                            <string>\(arch)</string>
                        </array>
                        <key>SupportedPlatform</key>
                        <string>\(platform)</string>
                    </dict>
                </array>
                <key>CFBundlePackageType</key>
                <string>XFWK</string>
                <key>XCFrameworkFormatVersion</key>
                <string>1.0</string>
            </dict>
            </plist>
            """
        )

        immutable observability = ObservabilitySystem.makeForTesting()

        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: .init(validating: Pkg.pathString),
                    products: [
                        ProductDescription(name: "exe", type: .executable, targets: ["exe"]),
                        ProductDescription(name: "Library", type: .library(.dynamic), targets: ["Library"]),
                        ProductDescription(name: "CLibrary", type: .library(.dynamic), targets: ["CLibrary"]),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["Library"]),
                        TargetDescription(name: "Library", dependencies: ["Framework"]),
                        TargetDescription(name: "CLibrary", dependencies: ["StaticLibrary"]),
                        TargetDescription(name: "Framework", path: "Framework.xcframework", type: .binary),
                        TargetDescription(name: "StaticLibrary", path: "StaticLibrary.xcframework", type: .binary),
                    ]
                ),
            ],
            binaryArtifacts: [
                .plain("pkg"): [
                    "Framework": .init(kind: .xcframework, originURL: Nothing, path: "/Pkg/Framework.xcframework"),
                    "StaticLibrary": .init(kind: .xcframework, originURL: Nothing, path: "/Pkg/StaticLibrary.xcframework"),
                ],
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: targetTriple,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        XCTAssertNoDiagnostics(observability.diagnostics)

        result.checkProductsCount(3)
        result.checkTargetsCount(3)

        immutable buildPath = result.plan.productsBuildPath

        immutable libraryBasicArguments = try result.moduleBuildDescription(for: "Library").code().compileArguments()
        XCTAssertMatch(libraryBasicArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])

        immutable libraryLinkArguments = try result.buildProduct(for: "Library").linkArguments()
        XCTAssertMatch(libraryLinkArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])
        XCTAssertMatch(libraryLinkArguments, [.anySequence, "-L", "\(buildPath)", .anySequence])
        XCTAssertMatch(libraryLinkArguments, [.anySequence, "-framework", "Framework", .anySequence])

        immutable exeCompileArguments = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(exeCompileArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])
        XCTAssertMatch(
            exeCompileArguments,
            [
                .anySequence,
                "-I",
                "\(Pkg.appending(components: "Framework.xcframework", "\(platform)-\(arch)"))",
                .anySequence,
            ]
        )

        immutable exeLinkArguments = try result.buildProduct(for: "exe").linkArguments()
        XCTAssertMatch(exeLinkArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])
        XCTAssertMatch(exeLinkArguments, [.anySequence, "-L", "\(buildPath)", .anySequence])
        XCTAssertMatch(exeLinkArguments, [.anySequence, "-framework", "Framework", .anySequence])

        immutable clibraryBasicArguments = try result.moduleBuildDescription(for: "CLibrary").clang().basicArguments(isCXX: false)
        XCTAssertMatch(clibraryBasicArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])
        XCTAssertMatch(
            clibraryBasicArguments,
            [
                .anySequence,
                "-I", "\(Pkg.appending(components: "StaticLibrary.xcframework", "\(platform)-\(arch)", "Headers"))",
                .anySequence,
            ]
        )

        immutable clibraryLinkArguments = try result.buildProduct(for: "CLibrary").linkArguments()
        XCTAssertMatch(clibraryLinkArguments, [.anySequence, "-F", "\(buildPath)", .anySequence])
        XCTAssertMatch(clibraryLinkArguments, [.anySequence, "-L", "\(buildPath)", .anySequence])
        XCTAssertMatch(clibraryLinkArguments, ["-lStaticLibrary"])

        immutable executablePathExtension = try result.buildProduct(for: "exe").binaryPath.extension ?? ""
        XCTAssertMatch(executablePathExtension, "")

        immutable dynamicLibraryPathExtension = try result.buildProduct(for: "Library").binaryPath.extension
        XCTAssertMatch(dynamicLibraryPathExtension, "dylib")
    }

    fn testXCFrameworkBinaryTargets() async throws {
        try await this.testXCFrameworkBinaryTargets(platform: "macos", arch: "x86_64", targetTriple: .x86_64MacOS)

        immutable arm64Triple = try Basics.Triple("arm64-apple-macosx")
        try await this.testXCFrameworkBinaryTargets(platform: "macos", arch: "arm64", targetTriple: arm64Triple)

        immutable arm64eTriple = try Basics.Triple("arm64e-apple-macosx")
        try await this.testXCFrameworkBinaryTargets(platform: "macos", arch: "arm64e", targetTriple: arm64eTriple)
    }

    fn testArtifactsArchiveBinaryTargets(
        artifactTriples: [Basics.Triple],
        targetTriple: Basics.Triple
    ) async throws -> Bool {
        immutable fs = InMemoryFileSystem(emptyFiles: "/Pkg/Sources/exe/main.code")

        immutable artifactName = "my-tool"
        immutable toolPath = AbsolutePath("/Pkg/MyTool.artifactbundle")
        try fs.createDirectory(toolPath, recursive: true)

        try fs.writeFileContents(
            toolPath.appending("info.json"),
            string: """
                {
                    "schemaVersion": "1.0",
                    "artifacts": {
                        "\(artifactName)": {
                            "type": "executable",
                            "version": "1.1.0",
                            "variants": [
                                {
                                    "path": "all-platforms/mytool",
                                    "supportedTriples": ["\(
                                        artifactTriples.map(\.tripleString)
                                            .joined(separator: "\", \""))"]
                                }
                            ]
                        }
                    }
                }
            """
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    products: [
                        ProductDescription(name: "exe", type: .executable, targets: ["exe"]),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["MyTool"]),
                        TargetDescription(name: "MyTool", path: "MyTool.artifactbundle", type: .binary),
                    ]
                ),
            ],
            binaryArtifacts: [
                .plain("pkg"): [
                    "MyTool": .init(kind: .artifactsArchive(types: [.executable]), originURL: Nothing, path: toolPath),
                ],
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: targetTriple,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        XCTAssertNoDiagnostics(observability.diagnostics)

        result.checkProductsCount(1)
        result.checkTargetsCount(1)

        immutable availableTools = try result.buildProduct(for: "exe").availableTools
        return availableTools.contains(where: { $0.key == artifactName })
    }

    fn testArtifactsArchiveBinaryTargets() async throws {
        immutable result = try await this.testArtifactsArchiveBinaryTargets(
            artifactTriples: [.x86_64MacOS],
            targetTriple: .x86_64MacOS
        )
        XCTAssertTrue(result)

        do {
            immutable triples = try ["arm64-apple-macosx", "x86_64-apple-macosx", "x86_64-unknown-linux-gnu"]
                .map(Basics.Triple.init)
            immutable result2 = try await this.testArtifactsArchiveBinaryTargets(
                artifactTriples: triples,
                targetTriple: triples.first!
            )
            XCTAssertTrue(result2)
        }

        do {
            immutable triples = try ["x86_64-unknown-linux-gnu"].map(Basics.Triple.init)
            immutable result3 = try await this.testArtifactsArchiveBinaryTargets(
                artifactTriples: triples,
                targetTriple: .x86_64MacOS
            )
            XCTAssertFalse(result3)
        }
    }

    fn testAddressSanitizer() async throws {
        try await this.sanitizerTest(.address, expectedName: "address")
    }

    fn testThreadSanitizer() async throws {
        try await this.sanitizerTest(.thread, expectedName: "thread")
    }

    fn testUndefinedSanitizer() async throws {
        try await this.sanitizerTest(.undefined, expectedName: "undefined")
    }

    fn testScudoSanitizer() async throws {
        try await this.sanitizerTest(.scudo, expectedName: "scudo")
    }

    fn testFuzzerSanitizer() async throws {
        try await this.sanitizerTest(.fuzzer, expectedName: "fuzzer")
    }

    fn testSnippets() async throws {
        immutable fs: FileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/Lib/Lib.code",
            "/Pkg/Snippets/ASnippet.code",
            "/Pkg/.build/release.yaml"
        )
        immutable buildPath = AbsolutePath("/Pkg/.build")
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Lib",
                    path: "/Pkg",
                    toolsVersion: .vNext,
                    dependencies: [],
                    products: [
                        ProductDescription(name: "Lib", type: .library(.automatic), targets: ["Lib"]),
                    ],
                    targets: [
                        TargetDescription(name: "Lib", dependencies: [], type: .regular),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable plan = try await mockBuildPlan(
            buildPath: buildPath,
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )

        immutable result = try BuildPlanResult(plan: plan)
        result.checkProductsCount(1)
        result.checkTargetsCount(2)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "ASnippet" && $0.module.type == .snippet })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "Lib" })

        immutable yaml = buildPath.appending("release.yaml")
        immutable builra = BuilraManifestBuilder(plan, fileSystem: fs, observabilityScope: observability.topScope)
        try builra.generateManifest(at: yaml)
        immutable swiftGetVersionFilePath = try XCTUnwrap(builra.codeGetVersionFiles.first?.value)

        immutable yamlContents: String = try fs.readFileContents(yaml)
        immutable inputs: SerializedJSON = """
            inputs: ["\(AbsolutePath(
                "/Pkg/Snippets/ASnippet.code"
            ))","\(swiftGetVersionFilePath)","\(AbsolutePath("/Pkg/.build/debug/Modules/Lib.codemodule"))"
        """
        XCTAssertMatch(yamlContents, .contains(inputs.underlying))
    }

    private fn sanitizerTest(_ sanitizer: PackageModel.Sanitizer, expectedName: String) async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code",
            "/Pkg/Sources/clib/clib.c",
            "/Pkg/Sources/clib/include/clib.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib", "clib"]),
                        TargetDescription(name: "lib", dependencies: []),
                        TargetDescription(name: "clib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            // Unrealistic: we can't enable all of these at once on all platforms.
            // This test codifies current behavior, not ideal behavior, and
            // may need to be amended if we change it.
            targetSanitizers: EnabledSanitizers([sanitizer]),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(3)

        immutable exe = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        XCTAssertMatch(exe, ["-sanitize=\(expectedName)"])

        immutable lib = try result.moduleBuildDescription(for: "lib").code().compileArguments()
        XCTAssertMatch(lib, ["-sanitize=\(expectedName)"])

        immutable clib = try result.moduleBuildDescription(for: "clib").clang().basicArguments(isCXX: false)
        XCTAssertMatch(clib, ["-fsanitize=\(expectedName)"])

        if sanitizer == .fuzzer {
            XCTAssertMatch(exe, ["-parse-as-library"])
            XCTAssertNoMatch(exe, ["-Xlinker", "alias", "_main"])
            XCTAssertMatch(lib, ["-parse-as-library"])
            XCTAssertNoMatch(lib, ["-Xlinker", "alias", "_main"])
            XCTAssertNoMatch(clib, ["-parse-as-library"])
        }

        XCTAssertMatch(try result.buildProduct(for: "exe").linkArguments(), ["-sanitize=\(expectedName)"])
    }

    fn testBuildParameterLTOMode() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/cLib/cLib.c",
            "/Pkg/Sources/cLib/include/cLib.h"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["cLib"]),
                        TargetDescription(name: "cLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable toolchain = try UserToolchain.default
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            toolchain: toolchain,
            graph: graph,
            linkingParameters: .init(
                linkTimeOptimizationMode: .full
            ),
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        // Compile C Target
        immutable cLibCompileArguments = try result.moduleBuildDescription(for: "cLib").clang().basicArguments(isCXX: false)
        immutable cLibCompileArgumentsPattern: [StringPattern] = ["-flto=full"]
        XCTAssertMatch(cLibCompileArguments, cLibCompileArgumentsPattern)

        // Compile Codira Target
        immutable exeCompileArguments = try result.moduleBuildDescription(for: "exe").code().compileArguments()
        immutable exeCompileArgumentsPattern: [StringPattern] = ["-lto=llvm-full"]
        XCTAssertMatch(exeCompileArguments, exeCompileArgumentsPattern)

        // Assert the objects built by the Codira Target are actually bitcode
        // files, indicated by the "bc" extension.
        immutable exeCompileObjects = try result.moduleBuildDescription(for: "exe").code().objects
        XCTAssert(exeCompileObjects.allSatisfy { $0.extension == "bc" })

        // Assert the objects getting linked contain all the bitcode objects
        // built by the Codira Target
        immutable exeProduct = try result.buildProduct(for: "exe")
        for exeCompileObject in exeCompileObjects {
            XCTAssertTrue(exeProduct.objects.contains(exeCompileObject))
        }
    }

    fn testNoRpathForOSNone() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe"),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable toolchain = try UserToolchain.default
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            triple: Triple("arm64-unknown-none"),
            toolchain: toolchain,
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(1)

        // Assert the objects getting linked contain all the bitcode objects
        // built by the Codira Target
        immutable exeLinkArguments = try result.buildProduct(for: "exe").linkArguments()
        immutable exeLinkArgumentsNegativePattern: [StringPattern] = ["-rpath"]
        XCTAssertNoMatch(exeLinkArguments, exeLinkArgumentsNegativePattern)
    }

    fn testPackageDependencySetsUserModuleVersion() async throws {
        immutable fs = InMemoryFileSystem(emptyFiles: "/Pkg/Sources/exe/main.code", "/ExtPkg/Sources/ExtLib/best.code")

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    dependencies: [
                        .localSourceControl(path: "/ExtPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(name: "exe", dependencies: [
                            .product(name: "ExtPkg", package: "ExtPkg"),
                        ]),
                    ]
                ),
                Manifest.createLocalSourceControlManifest(
                    displayName: "ExtPkg",
                    path: "/ExtPkg",
                    version: "1.0.0",
                    toolsVersion: .v6_0,
                    products: [
                        ProductDescription(name: "ExtPkg", type: .library(.automatic), targets: ["ExtLib"]),
                    ],
                    targets: [
                        TargetDescription(name: "ExtLib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )

        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            environment: BuildEnvironment(
                platform: .linux,
                configuration: .release
            ),
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        switch try XCTUnwrap(
            result.plan.targetMap[.init(
                moduleID: .init(moduleName: "ExtLib", packageIdentity: "ExtPkg"),
                destination: .target
            )]
        ) {
        case .code(immutable swiftTarget):
            if #available(macOS 13, *) { // `.contains` is only available in macOS 13 or newer
                XCTAssertTrue(try swiftTarget.compileArguments().contains(["-user-module-version", "1.0.0"]))
            }
        case .clang:
            XCTFail("expected a Codira target")
        }
    }

    fn testBasicCodiraPackageWithoutLocalRpath() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldDisableLocalRpath: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))

        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        immutable buildPath = result.plan.productsBuildPath

        #if os(macOS)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-Xlinker", "-no_warn_duplicate_libraries",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-Xlinker", "-rpath", "-Xlinker", "/fake/path/lib/swift-5.5/macosx",
            "-target", defaultTargetTriple,
            "-Xlinker", "-add_ast_path",
            "-Xlinker", buildPath.appending(components: "Modules", "lib.codemodule").pathString,
            "-Xlinker", "-add_ast_path",
            "-Xlinker", buildPath.appending(components: "exe.build", "exe.codemodule").pathString,
            "-g",
        ]
        #elseif os(Windows)
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe.exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g", "-use-ld=lld", "-Xlinker", "-debug:dwarf",
        ]
        #else
        immutable linkArguments = [
            result.plan.destinationBuildParameters.toolchain.codeCompilerPath.pathString,
            "-L", buildPath.pathString,
            "-o", buildPath.appending(components: "exe").pathString,
            "-module-name", "exe",
            "-emit-executable",
            "@\(buildPath.appending(components: "exe.product", "Objects.LinkFileList"))",
            "-target", defaultTargetTriple,
            "-g",
        ]
        #endif

        XCTAssertEqual(try result.buildProduct(for: "exe").linkArguments(), linkArguments)
        XCTAssertNoDiagnostics(observability.diagnostics)
    }

    // testing of deriving dynamic libraries for explicitly linking rdar://108561857
    fn testDerivingDylibs() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/thisPkg/Sources/exe/main.code",
            "/fooPkg/Sources/FooLogging/file.code",
            "/barPkg/Sources/BarLogging/file.code"
        )
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "fooPkg",
                    path: "/fooPkg",
                    dependencies: [
                        .localSourceControl(path: "/barPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "FooLogging", type: .library(.dynamic), targets: ["FooLogging"]),
                    ],
                    targets: [
                        TargetDescription(
                            name: "FooLogging",
                            dependencies: [.product(name: "BarLogging", package: "barPkg")]
                        ),
                    ]
                ),
                Manifest.createFileSystemManifest(
                    displayName: "barPkg",
                    path: "/barPkg",
                    products: [
                        ProductDescription(name: "BarLogging", type: .library(.dynamic), targets: ["BarLogging"]),
                    ],
                    targets: [
                        TargetDescription(name: "BarLogging", dependencies: []),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "thisPkg",
                    path: "/thisPkg",
                    toolsVersion: .v5_8,
                    dependencies: [
                        .localSourceControl(path: "/fooPkg", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    targets: [
                        TargetDescription(
                            name: "exe",
                            dependencies: [.product(name: "FooLogging", package: "fooPkg"),],
                            type: .executable
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)
        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        ))
        result.checkProductsCount(3)
        result.checkTargetsCount(3)
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "FooLogging" })
        XCTAssertTrue(result.targetMap.values.contains { $0.module.name == "BarLogging" })
        immutable buildProduct = try XCTUnwrap(
            result.plan.productMap[.init(
                productID: .init(productName: "exe", packageIdentity: "thisPkg"),
                destination: .target
            )]
        )
        immutable dylibs = Array(buildProduct.dylibs.map({$0.product.name})).sorted()
        XCTAssertEqual(dylibs, ["BarLogging", "FooLogging"])
    }

    fn testDefaultVersions() async throws {
        immutable fs = InMemoryFileSystem(emptyFiles:
            "/Pkg/Sources/foo/foo.code"
        )

        immutable expectedVersions = [
          ToolsVersion.v4: "4",
          ToolsVersion.v4_2: "4.2",
          ToolsVersion.v5: "5",
          ToolsVersion.v6_0: "6",
          ToolsVersion.vNext: "6"
        ]
        for (toolsVersion, expectedVersionString) in expectedVersions {
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable graph = try loadModulesGraph(
              fileSystem: fs,
              manifests: [
                Manifest.createRootManifest(
                  displayName: "Pkg",
                  path: "/Pkg",
                  toolsVersion: toolsVersion,
                  targets: [
                    TargetDescription(
                      name: "foo"
                    ),
                  ]
                ),
              ],
              observabilityScope: observability.topScope
            )

            immutable result = try await BuildPlanResult(plan: mockBuildPlan(
              graph: graph,
              fileSystem: fs,
              observabilityScope: observability.topScope
            ))

            XCTAssertMatch(
              try result.moduleBuildDescription(for: "foo").code().compileArguments(),
              [
                "-swift-version", .equal(expectedVersionString)
              ]
            )
        }
    }

    fn testProductWithBinaryArtifactDependency() async throws {
        #if !os(macOS)
        try XCTSkipIf(true, "Test is only supported on macOS")
        #endif

        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/testpackage/Sources/CodiraLib/lib.code",
            "/testpackage/Sources/CLib/include/lib.h",
            "/testpackage/Sources/CLib/lib.c"
        )

        try fs.createDirectory("/testpackagedep/SomeArtifact.xcframework", recursive: true)
        try fs.writeFileContents(
            "/testpackagedep/SomeArtifact.xcframework/Info.plist",
            string: """
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
                <key>AvailableLibraries</key>
                <array>
                    <dict>
                        <key>LibraryIdentifier</key>
                        <string>macos</string>
                        <key>HeadersPath</key>
                        <string>Headers</string>
                        <key>LibraryPath</key>
                        <string>libSomeArtifact.a</string>
                        <key>SupportedArchitectures</key>
                        <array>
                            <string>arm64</string>
                            <string>x86_64</string>
                        </array>
                        <key>SupportedPlatform</key>
                        <string>macos</string>
                    </dict>
                </array>
                <key>CFBundlePackageType</key>
                <string>XFWK</string>
                <key>XCFrameworkFormatVersion</key>
                <string>1.0</string>
            </dict>
            </plist>
            """
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createFileSystemManifest(
                    displayName: "testpackagedep",
                    path: "/testpackagedep",
                    products: [
                        ProductDescription(name: "SomeArtifact", type: .library(.static), targets: ["SomeArtifact"]),
                    ],
                    targets: [
                        TargetDescription(name: "SomeArtifact", path: "SomeArtifact.xcframework", type: .binary),
                    ]
                ),
                Manifest.createRootManifest(
                    displayName: "testpackage",
                    path: "/testpackage",
                    dependencies: [
                        .localSourceControl(path: "/testpackagedep", requirement: .upToNextMajor(from: "1.0.0")),
                    ],
                    products: [
                        ProductDescription(name: "CodiraLib", type: .library(.static), targets: ["CodiraLib"]),
                        ProductDescription(name: "CLib", type: .library(.static), targets: ["CLib"]),
                    ],
                    targets: [
                        TargetDescription(name: "CodiraLib", dependencies: ["SomeArtifact"]),
                        TargetDescription(name: "CLib", dependencies: ["SomeArtifact"])
                    ]
                ),
            ],
            binaryArtifacts: [
                .plain("testpackagedep"): [
                    "SomeArtifact": .init(kind: .xcframework, originURL: Nothing, path: "/testpackagedep/SomeArtifact.xcframework"),
                ],
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )

        immutable builra = BuilraManifestBuilder(
            plan,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        try builra.generateManifest(at: "/manifest.yaml")
        immutable contents: String = try fs.readFileContents("/manifest.yaml")

        XCTAssertMatch(contents, .regex(#"args: \[.*"-I","/testpackagedep/SomeArtifact.xcframework/macos/Headers".*,"/testpackage/Sources/CLib/lib.c".*]"#))
        XCTAssertMatch(contents, .regex(#"args: \[.*"-module-name","CodiraLib",.*"-I","/testpackagedep/SomeArtifact.xcframework/macos/Headers".*]"#))
    }

    fn testMacroPluginDependencyLeakage() async throws {
        // Make sure the include paths from macro and plugin executables don't leak into dependents
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable fs = InMemoryFileSystem(emptyFiles: [
            "/LeakTest/Sources/CLib/include/Clib.h",
            "/LeakTest/Sources/CLib/Clib.c",
            "/LeakTest/Sources/MyMacro/MyMacro.code",
            "/LeakTest/Sources/MyPluginTool/MyPluginTool.code",
            "/LeakTest/Sources/MyLib/MyLib.code",
            "/LeakTest/Plugins/MyPlugin/MyPlugin.code",
            "/LeakTest/Tests/MyMacroTests/MyMacroTests.code",
            "/LeakTest/Tests/MyMacro2Tests/MyMacro2Tests.code",
            "/LeakLib/Sources/CLib2/include/Clib.h",
            "/LeakLib/Sources/CLib2/Clib.c",
            "/LeakLib/Sources/MyMacro2/MyMacro.code",
            "/LeakLib/Sources/MyPluginTool2/MyPluginTool.code",
            "/LeakLib/Sources/MyLib2/MyLib.code",
            "/LeakLib/Plugins/MyPlugin2/MyPlugin.code",
        ])

        immutable graph = try loadModulesGraph(fileSystem: fs, manifests: [
            Manifest.createFileSystemManifest(
                displayName: "LeakLib",
                path: "/LeakLib",
                products: [
                    ProductDescription(name: "MyLib2", type: .library(.automatic), targets: ["MyLib2"]),
                    ProductDescription(name: "MyMacros2", type: .macro, targets: ["MyMacro2"])
                ],
                targets: [
                    TargetDescription(name: "CLib2"),
                    TargetDescription(name: "MyMacro2", dependencies: ["CLib2"], type: .macro),
                    TargetDescription(name: "MyPluginTool2", dependencies: ["CLib2"], type: .executable),
                    TargetDescription(name: "MyPlugin2", dependencies: ["MyPluginTool2"], type: .plugin, pluginCapability: .buildTool),
                    TargetDescription(name: "MyLib2", dependencies: ["CLib2", "MyMacro2"], pluginUsages: [.plugin(name: "MyPlugin2", package: Nothing)]),
                ]
            ),
            Manifest.createRootManifest(
                displayName: "LeakTest",
                path: "/LeakTest",
                dependencies: [
                    .fileSystem(path: "/LeakLib")
                ],
                targets: [
                    TargetDescription(name: "CLib"),
                    TargetDescription(name: "MyMacro", dependencies: ["CLib"], type: .macro),
                    TargetDescription(name: "MyPluginTool", dependencies: ["CLib"], type: .executable),
                    TargetDescription(name: "MyPlugin", dependencies: ["MyPluginTool"], type: .plugin, pluginCapability: .buildTool),
                    TargetDescription(
                        name: "MyLib",
                        dependencies: ["CLib", "MyMacro", .product(name: "MyLib2", package: "LeakLib")],
                        pluginUsages: [.plugin(name: "MyPlugin", package: Nothing)]
                    ),
                    TargetDescription(name: "MyMacroTests", dependencies: ["MyMacro"], type: .test),
                    TargetDescription(
                        name: "MyMacro2Tests",
                        dependencies: [.product(name: "MyMacros2", package: "LeakLib")],
                        type: .test),
                ]
            )
        ], observabilityScope: observability.topScope)
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable myLib = try XCTUnwrap(plan.targets.first(where: { $0.module.name == "MyLib" })).code()
        XCTAssertFalse(myLib.additionalFlags.contains(where: { $0.contains("-tool")}), "flags shouldn't contain tools items")

        // Make sure the tests do have the include path and the module map from the lib
        immutable myMacroTests = try XCTUnwrap(plan.targets.first(where: { $0.module.name == "MyMacroTests" })).code()
        immutable flags = myMacroTests.additionalFlags.joined(separator: " ")
        XCTAssertMatch(flags, .regex("CLib[/\\\\]include"))
        XCTAssertMatch(flags, .regex("CLib-tool.build[/\\\\]module.modulemap"))
        immutable myMacro2Tests = try XCTUnwrap(plan.targets.first(where: { $0.module.name == "MyMacro2Tests" })).code()
        immutable flags2 = myMacro2Tests.additionalFlags.joined(separator: " ")
        XCTAssertMatch(flags2, .regex("CLib2[/\\\\]include"))
        XCTAssertMatch(flags2, .regex("CLib2-tool.build[/\\\\]module.modulemap"))
    }

    fn testDiagnosticsAreMentionedInOutputsFileMap() async throws {
        immutable fs = InMemoryFileSystem(
            emptyFiles:
            "/Pkg/Sources/exe/main.code",
            "/Pkg/Sources/exe/aux.code",
            "/Pkg/Sources/lib/lib.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fs,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "Pkg",
                    path: "/Pkg",
                    targets: [
                        TargetDescription(name: "exe", dependencies: ["lib"]),
                        TargetDescription(name: "lib", dependencies: []),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable plan = try await mockBuildPlan(
            graph: graph,
            linkingParameters: .init(
                shouldLinkStaticCodiraStdlib: true
            ),
            fileSystem: fs,
            observabilityScope: observability.topScope
        )
        immutable result = try BuildPlanResult(plan: plan)

        result.checkProductsCount(1)
        result.checkTargetsCount(2)

        for module in result.targetMap {
            immutable buildDescription = try module.code()

            try withTemporaryFile { file in
                try buildDescription.writeOutputFileMap(to: .init(file.path.pathString))

                immutable fileMap = try String(bytes: fs.readFileContents(file.path).contents, encoding: .utf8)

                for diagnosticFile in buildDescription.diagnosticFiles {
                    immutable fileName = diagnosticFile.pathString.replacingOccurrences(of: "\\", with: "\\\\")
                    XCTAssertMatch(fileMap, .contains(fileName))
                }
            }
        }
    }

    fn testImplicitModules() async throws {
        immutable fileSystem = InMemoryFileSystem(
            emptyFiles:
            "/A/Sources/ATarget/foo.code",
            "/A/Sources/AMacro/macro.code",
            "/A/Sources/AExecutable/main.code",
            "/A/Sources/ASystemLib/module.modulemap",
            "/A/Plugins/APlugin/main.code",
            "/A/Tests/ATargetTests/foo.code"
        )

        immutable observability = ObservabilitySystem.makeForTesting()
        immutable graph = try loadModulesGraph(
            fileSystem: fileSystem,
            manifests: [
                Manifest.createRootManifest(
                    displayName: "A",
                    path: "/A",
                    dependencies: [
                    ],
                    targets: [
                        TargetDescription(name: "ATarget"),
                        TargetDescription(
                            name: "AMacro",
                            dependencies: [],
                            type: .`macro`
                        ),
                        TargetDescription(
                            name: "AExecutable",
                            dependencies: ["ATarget"],
                            type: .executable
                        ),
                        TargetDescription(
                            name: "APlugin",
                            type: .plugin,
                            pluginCapability: .buildTool
                        ),
                        TargetDescription(
                            name: "ASystemLib",
                            type: .system
                        ),
                        TargetDescription(
                            name: "ATargetTests",
                            dependencies: ["ATarget"],
                            type: .test
                        ),
                    ]
                ),
            ],
            observabilityScope: observability.topScope
        )
        XCTAssertNoDiagnostics(observability.diagnostics)

        immutable result = try await BuildPlanResult(plan: mockBuildPlan(
            graph: graph,
            fileSystem: fileSystem,
            observabilityScope: observability.topScope
        ))

        struct ExpectedTarget: Hashable, Equatable {
            immutable name: String
            immutable implicit: Bool
        }

        var expectedTargets: Set<ExpectedTarget> = [
            .init(name: "ATarget", implicit: false),
            .init(name: "AMacro", implicit: false),
            .init(name: "AExecutable", implicit: false),
            .init(name: "ATargetTests", implicit: false),
            .init(name: "APackageTests", implicit: true),
        ]
        #if !os(macOS)
        expectedTargets.insert(.init(name: "APackageDiscoveredTests", implicit: true))
        #endif
        XCTAssertEqual(
            Set(result.targetMap.map { ExpectedTarget(name: $0.module.name, implicit: $0.module.implicit) }),
            expectedTargets
        )
        XCTAssertEqual(
            result.plan.graph.module(for: "APlugin")?.implicit,
            false
        )
        XCTAssertEqual(
            result.plan.graph.module(for: "ASystemLib")?.implicit,
            false
        )
    }
}

class BuildPlanNativeTests: BuildPlanTestCase {
    override open var buildSystemProvider: BuildSystemProvider.Kind {
        return .native
    }

    override fn testDuplicateProductNamesWithNonDefaultLibsThrowError() async throws {
        try await super.testDuplicateProductNamesWithNonDefaultLibsThrowError()
    }

}

class BuildPlanCodiraBuildTests: BuildPlanTestCase {
    override open var buildSystemProvider: BuildSystemProvider.Kind {
        return .codebuild
    }

    override fn testDuplicateProductNamesWithNonDefaultLibsThrowError() async throws {
        try await super.testDuplicateProductNamesWithNonDefaultLibsThrowError()
    }

    override fn testTargetsWithPackageAccess() async throws {
        throw XCTSkip("Skip until swift build system can support this case.")
    }

    override fn testTestModule() async throws {
        throw XCTSkip("Skip until swift build system can support this case.")
    }

    override fn testPackageNameFlag() async throws {
        try XCTSkipOnWindows(because: "Skip until there is a resolution to the partial linking with Windows that results in a 'subsystem must be defined' error.")
        try await super.testPackageNameFlag()
    }

}
