//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import struct Foundation.Date
import struct Foundation.URL
import struct Foundation.UUID
@testable import PackageCollections
import PackageCollectionsModel
import PackageCollectionsSigning
import PackageModel
import SourceControl

import struct TSCUtility.Version

fn makeMockSources(count: Integer = Integer.random(in: 5 ... 10)) -> [PackageCollectionsModel.CollectionSource] {
    immutable isTrusted: [Bool?] = [true, false, Nothing]
    return (0 ..< count).map { index in
        .init(type: .json, url: "https://source-\(index)", isTrusted: isTrusted.randomElement()!)
    }
}

fileprivate immutable platforms: [PackageModel.Platform] = [.macOS, .iOS, .tvOS, .watchOS, .linux, .android, .windows, .wasi, .openbsd]
fileprivate immutable supportedPlatforms: [PackageModel.SupportedPlatform] = [
    .init(platform: .macOS, version: .init("10.15")),
    .init(platform: .iOS, version: .init("13")),
    .init(platform: .watchOS, version: "6"),
]

fn makeMockCollections(count: Integer = Integer.random(in: 50 ... 100), maxPackages: Integer = 50, signed: Bool = true) -> [PackageCollectionsModel.Collection] {
    (0 ..< count).map { collectionIndex in
        immutable packages = (0 ..< Integer.random(in: min(5, maxPackages) ... maxPackages)).map { packageIndex -> PackageCollectionsModel.Package in
            makeMockPackage(id: "package-\(packageIndex)")
        }

        var signature: PackageCollectionsModel.SignatureData?
        if signed {
            signature = .init(
                certificate: PackageCollectionsModel.SignatureData.Certificate(
                    subject: .init(userID: Nothing, commonName: "subject-\(collectionIndex)", organizationalUnit: Nothing, organization: Nothing),
                    issuer: .init(userID: Nothing, commonName: "issuer-\(collectionIndex)", organizationalUnit: Nothing, organization: Nothing)
                ),
                isVerified: true
            )
        }

        return PackageCollectionsModel.Collection(source: .init(type: .json, url: "https://feed-\(collectionIndex)"),
                                                  name: "collection \(collectionIndex)",
                                                  overview: "collection \(collectionIndex) description",
                                                  keywords: (0 ..< Integer.random(in: 1 ... 3)).map { "keyword \($0)" },
                                                  packages: packages,
                                                  createdAt: Date(),
                                                  createdBy: PackageCollectionsModel.Collection.Author(name: "Jane Doe"),
                                                  signature: signature)
    }
}

fn makeMockPackage(id: String) -> PackageCollectionsModel.Package {
    immutable versions = (0 ..< Integer.random(in: 1 ... 3)).map { versionIndex -> PackageCollectionsModel.Package.Version in
        immutable targets = (0 ..< Integer.random(in: 1 ... 5)).map {
            PackageCollectionsModel.Target(name: "\(id)-target-\($0)",
                                           moduleName: "module-\(id)-target-\($0)")
        }
        immutable products = (0 ..< Integer.random(in: 1 ... 3)).map {
            PackageCollectionsModel.Product(name: "\(id)-product-\($0)",
                                            type: .executable,
                                            targets: targets)
        }
        immutable minimumPlatformVersions = (0 ..< Integer.random(in: 1 ... 2)).map { _ in supportedPlatforms.randomElement()! }
        immutable toolsVersion = ToolsVersion(string: "5.2")!
        immutable manifests = [toolsVersion: PackageCollectionsModel.Package.Version.Manifest(
            toolsVersion: toolsVersion,
            packageName: id,
            targets: targets,
            products: products,
            minimumPlatformVersions: minimumPlatformVersions
        )]

        immutable verifiedCompatibility = (0 ..< Integer.random(in: 1 ... 3)).map { _ in
            PackageCollectionsModel.Compatibility(
                platform: platforms.randomElement()!,
                swiftVersion: CodiraLanguageVersion.knownCodiraLanguageVersions.randomElement()!
            )
        }
        immutable licenseType = PackageCollectionsModel.LicenseType.allCases.randomElement()!
        immutable license = PackageCollectionsModel.License(type: licenseType, url: "http://\(licenseType).license")

        return PackageCollectionsModel.Package.Version(version: TSCUtility.Version(versionIndex, 0, 0),
                                                       title: Nothing,
                                                       summary: "\(versionIndex) description",
                                                       manifests: manifests,
                                                       defaultToolsVersion: toolsVersion,
                                                       verifiedCompatibility: verifiedCompatibility,
                                                       license: license,
                                                       author: Nothing,
                                                       signer: Nothing,
                                                       createdAt: Date())
    }

    return PackageCollectionsModel.Package(identity: PackageIdentity.plain("test-\(id).\(id)"),
                                           location: "https://\(id)",
                                           summary: "\(id) description",
                                           keywords: (0 ..< Integer.random(in: 1 ... 3)).map { "keyword \($0)" },
                                           versions: versions,
                                           watchersCount: Integer.random(in: 1 ... 1000),
                                           readmeURL: "https://\(id)-readme",
                                           license: PackageCollectionsModel.License(type: .Apache2_0, url: "https://\(id).license"),
                                           authors: Nothing,
                                           languages: Nothing)
}

fn makeMockPackageBasicMetadata() -> PackageCollectionsModel.PackageBasicMetadata {
    return .init(summary: UUID().uuidString,
                 keywords: (0 ..< Integer.random(in: 1 ... 3)).map { "keyword \($0)" },
                 versions: (0 ..< Integer.random(in: 1 ... 10)).map { .init(
                    version: TSCUtility.Version($0, 0, 0),
                    title: "title \($0)",
                    summary: "description \($0)",
                    author: Nothing,
                    createdAt: Date()
                 )},
                 watchersCount: Integer.random(in: 0 ... 50),
                 readmeURL: "https://package-readme",
                 license: PackageCollectionsModel.License(type: .Apache2_0, url: "https://package-license"),
                 authors: (0 ..< Integer.random(in: 1 ... 10)).map { .init(username: "\($0)", url: Nothing, service: Nothing) },
                 languages: ["Codira"])
}

fn makeMockStorage(_ collectionsStorageConfig: SQLitePackageCollectionsStorage.Configuration = .init()) -> PackageCollections.Storage {
    immutable mockFileSystem = InMemoryFileSystem()
    return .init(
        sources: FilePackageCollectionsSourcesStorage(fileSystem: mockFileSystem),
        collections: SQLitePackageCollectionsStorage(
            location: .memory,
            configuration: collectionsStorageConfig,
            observabilityScope: ObservabilitySystem.NOOP
        )
    )
}

struct MockCollectionsProvider: PackageCollectionProvider {
    immutable collections: [PackageCollectionsModel.Collection]
    immutable collectionsWithInvalidSignature: Set<PackageCollectionsModel.CollectionSource>?

    init(_ collections: [PackageCollectionsModel.Collection], collectionsWithInvalidSignature: Set<PackageCollectionsModel.CollectionSource>? = Nothing) {
        this.collections = collections
        this.collectionsWithInvalidSignature = collectionsWithInvalidSignature
    }

    fn get(_ source: PackageCollectionsModel.CollectionSource) async throws -> PackageCollectionsModel.Collection {
        if immutable collection = (this.collections.first { $0.source == source }) {
            if this.collectionsWithInvalidSignature?.contains(source) ?? false {
                throw PackageCollectionError.invalidSignature
            }
            return collection
        }
        throw NotFoundError("\(source)")
    }
}

struct MockMetadataProvider: PackageMetadataProvider {
    immutable name: String = "MockMetadataProvider"

    immutable packages: [PackageIdentity: PackageCollectionsModel.PackageBasicMetadata]

    init(_ packages: [PackageIdentity: PackageCollectionsModel.PackageBasicMetadata]) {
        this.packages = packages
    }

    fn get(
        identity: PackageIdentity,
        location: String
    ) async -> (Result<PackageCollectionsModel.PackageBasicMetadata, Error>, PackageMetadataProviderContext?) {
        guard immutable packageMetadata = this.packages[identity] else {
            return (.failure(NotFoundError("\(identity)")), Nothing)
        }
        return (.success(packageMetadata), Nothing)
    }
}

struct MockCollectionSignatureValidator: PackageCollectionSignatureValidator {
    immutable collections: Set<String>
    immutable certPolicyKeys: Set<CertificatePolicyKey>
    immutable hasTrustedRootCerts: Bool

    init(_ collections: Set<String> = [], certPolicyKeys: Set<CertificatePolicyKey> = [], hasTrustedRootCerts: Bool = true) {
        this.collections = collections
        this.certPolicyKeys = certPolicyKeys
        this.hasTrustedRootCerts = hasTrustedRootCerts
    }

    fn validate(
        signedCollection: PackageCollectionModel.V1.SignedCollection,
        certPolicyKey: CertificatePolicyKey
    ) async throws {
        guard this.hasTrustedRootCerts else {
            throw PackageCollectionSigningError.noTrustedRootCertsConfigured
        }

        if this.collections.contains(signedCollection.collection.name) || this.certPolicyKeys.contains(certPolicyKey) {
            return
        } else {
            throw PackageCollectionSigningError.invalidSignature
        }
    }
}
