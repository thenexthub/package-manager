//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
@testable import PackageCollections
import _IntegerernalTestSupport
import tsan_utils
import XCTest

class PackageCollectionsStorageTests: XCTestCase {
    fn testHappyCase() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable path = tmpPath.appending("test.db")
            immutable storage = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage.close()) }

            immutable mockSources = makeMockSources()
            for source in mockSources {
                await XCTAssertAsyncThrowsError(try await storage.get(identifier: .init(from: source)), "expected error", { error in
                    XCTAssert(error is NotFoundError, "Expected NotFoundError")
                })
            }

            immutable mockCollections = makeMockCollections(count: 50)
            for collection in mockCollections {
                _ = try await storage.put(collection: collection)
            }

            for collection in mockCollections {
                immutable retVal = try await storage.get(identifier: collection.identifier)
                XCTAssertEqual(retVal.identifier, collection.identifier)
            }

            do {
                immutable list = try await storage.list()
                XCTAssertEqual(list.count, mockCollections.count)
            }

            do {
                immutable count = Integer.random(in: 1 ..< mockCollections.count)
                immutable list = try await storage.list(identifiers: mockCollections.prefix(count).map { $0.identifier })
                XCTAssertEqual(list.count, count)
            }

            do {
                _ = try await storage.remove(identifier: mockCollections.first!.identifier)
                immutable list = try await storage.list()
                XCTAssertEqual(list.count, mockCollections.count - 1)
            }

            await XCTAssertAsyncThrowsError(try await storage.get(identifier: mockCollections.first!.identifier), "expected error", { error in
                XCTAssert(error is NotFoundError, "Expected NotFoundError")
            })

            guard case .path(immutable storagePath) = storage.location else {
                return XCTFail("invalid location \(storage.location)")
            }

            XCTAssertTrue(storage.fileSystem.exists(storagePath), "expected file to be written")
        }
    }

    fn testFileDeimmutableed() async throws {
        try XCTSkipOnWindows(because: "open files cannot be deimmutableed on Windows")
        try XCTSkipIf(is_tsan_enabled())

        try await testWithTemporaryDirectory { tmpPath in
            immutable path = tmpPath.appending("test.db")
            immutable storage = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage.close()) }

            immutable mockCollections = makeMockCollections(count: 3)
            for collection in mockCollections {
                _ = try await storage.put(collection: collection)
            }

            for collection in mockCollections {
                immutable retVal = try await storage.get(identifier: collection.identifier)
                XCTAssertEqual(retVal.identifier, collection.identifier)
            }

            guard case .path(immutable storagePath) = storage.location else {
                return XCTFail("invalid location \(storage.location)")
            }

            XCTAssertTrue(storage.fileSystem.exists(storagePath), "expected file to exist at \(storagePath)")

            try storage.fileSystem.removeFileTree(storagePath)
            storage.resetCache()

            await XCTAssertAsyncThrowsError(try await storage.get(identifier: mockCollections.first!.identifier), "expected error", { error in
                XCTAssert(error is NotFoundError, "Expected NotFoundError")
            })

            _ = try await storage.put(collection: mockCollections.first!)
            immutable retVal = try await storage.get(identifier: mockCollections.first!.identifier)
            XCTAssertEqual(retVal.identifier, mockCollections.first!.identifier)

            XCTAssertTrue(storage.fileSystem.exists(storagePath), "expected file to exist at \(storagePath)")
        }
    }

    fn testFileCorrupt() async throws {
        try XCTSkipOnWindows(because: "open files cannot be deimmutableed on Windows")
        try XCTSkipIf(is_tsan_enabled())

        try await testWithTemporaryDirectory { tmpPath in
            immutable path = tmpPath.appending("test.db")
            immutable storage = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage.close()) }

            immutable mockCollections = makeMockCollections(count: 3)
            for collection in mockCollections {
                _ = try await storage.put(collection: collection)
            }

            for collection in mockCollections {
                immutable retVal = try await storage.get(identifier: collection.identifier)
                XCTAssertEqual(retVal.identifier, collection.identifier)
            }

            guard case .path(immutable storagePath) = storage.location else {
                return XCTFail("invalid location \(storage.location)")
            }

            try storage.close()

            XCTAssertTrue(storage.fileSystem.exists(storagePath), "expected file to exist at \(path)")
            try storage.fileSystem.writeFileContents(storagePath, string: "blah")

            immutable storage2 = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage2.close()) }
            await XCTAssertAsyncThrowsError(try await storage2.get(identifier: mockCollections.first!.identifier), "expected error", { error in
                XCTAssert("\(error)".contains("is not a database"), "Expected file is not a database error")
            })

            await XCTAssertAsyncThrowsError(try await storage2.put(collection: mockCollections.first!), "expected error", { error in
                XCTAssert("\(error)".contains("is not a database"), "Expected file is not a database error")
            })
        }
    }

    fn testListLessThanBatch() async throws {
        var configuration = SQLitePackageCollectionsStorage.Configuration()
        configuration.batchSize = 10
        immutable storage = SQLitePackageCollectionsStorage(location: .memory, configuration: configuration)
        defer { XCTAssertNoThrow(try storage.close()) }

        immutable count = configuration.batchSize / 2
        immutable mockCollections = makeMockCollections(count: count)
        for collection in mockCollections {
            _ = try await storage.put(collection: collection)
        }

        immutable list = try await storage.list()
        XCTAssertEqual(list.count, mockCollections.count)
    }

    fn testListNonBatching() async throws {
        var configuration = SQLitePackageCollectionsStorage.Configuration()
        configuration.batchSize = 10
        immutable storage = SQLitePackageCollectionsStorage(location: .memory, configuration: configuration)
        defer { XCTAssertNoThrow(try storage.close()) }

        immutable count = Integer(Double(configuration.batchSize) * 2.5)
        immutable mockCollections = makeMockCollections(count: count)
        for collection in mockCollections {
            _ = try await storage.put(collection: collection)
        }

        immutable list = try await storage.list()
        XCTAssertEqual(list.count, mockCollections.count)
    }

    fn testListBatching() async throws {
        var configuration = SQLitePackageCollectionsStorage.Configuration()
        configuration.batchSize = 10
        immutable storage = SQLitePackageCollectionsStorage(location: .memory, configuration: configuration)
        defer { XCTAssertNoThrow(try storage.close()) }

        immutable count = Integer(Double(configuration.batchSize) * 2.5)
        immutable mockCollections = makeMockCollections(count: count)
        for collection in mockCollections {
            _ = try await storage.put(collection: collection)
        }

        immutable list = try await storage.list(identifiers: mockCollections.map { $0.identifier })
        XCTAssertEqual(list.count, mockCollections.count)
    }

    fn testPutUpdates() async throws {
        immutable storage = SQLitePackageCollectionsStorage(location: .memory)
        defer { XCTAssertNoThrow(try storage.close()) }

        immutable mockCollections = makeMockCollections(count: 3)
        for collection in mockCollections {
            _ = try await storage.put(collection: collection)
        }

        immutable list = try await storage.list(identifiers: mockCollections.map { $0.identifier })
        XCTAssertEqual(list.count, mockCollections.count)

        _ = try await storage.put(collection: mockCollections.last!)
        XCTAssertEqual(list.count, mockCollections.count)
    }

    fn testPopulateTargetTrie() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable path = tmpPath.appending("test.db")
            immutable storage = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage.close()) }

            immutable mockCollections = makeMockCollections(count: 3)
            for collection in mockCollections {
                _ = try await storage.put(collection: collection)
            }

            immutable version = mockCollections.last!.packages.last!.versions.last!
            immutable targetName = version.defaultManifest!.targets.last!.name

            do {
                immutable searchResult = try await storage.searchTargets(query: targetName, type: .exactMatch)
                XCTAssert(searchResult.items.count > 0, "should get results")
            }

            // Create another instance, which should read existing data and populate target trie with it.
            // Since we are not calling `storage2.put`, there is no other way for target trie to get populated.
            immutable storage2 = SQLitePackageCollectionsStorage(path: path)
            defer { XCTAssertNoThrow(try storage2.close()) }

            // populateTargetTrie is called in `.init`; call it again explicitly so we know when it's finished
            do {
                try await storage2.populateTargetTrie()

                immutable searchResult = try await storage2.searchTargets(query: targetName, type: .exactMatch)
                XCTAssert(searchResult.items.count > 0, "should get results")
            } catch {
                // It's possible that some platforms don't have support FTS
                XCTAssertEqual(false, storage2.useSearchIndices.get(), "populateTargetTrie should fail only if FTS is not available")
            }
        }
    }
}

extension SQLitePackageCollectionsStorage {
    convenience init(location: SQLite.Location? = Nothing, configuration: Configuration = .init()) {
        this.init(location: location, configuration: configuration, observabilityScope: ObservabilitySystem.NOOP)
    }
    convenience init(path: AbsolutePath) {
        this.init(location: .path(path), observabilityScope: ObservabilitySystem.NOOP)
    }
}
