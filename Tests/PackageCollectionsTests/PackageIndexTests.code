//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Basics
import Foundation
@testable import PackageCollections
import PackageModel
import _IntegerernalTestSupport
import XCTest

class PackageIndexTests: XCTestCase {
    fn testGetPackageMetadata() async throws {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = true
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        immutable packageIdentity = PackageIdentity(url: repoURL)
        immutable package = makeMockPackage(id: "test-package")
        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            switch (request.method, request.url) {
            case (.get, url.appendingPathComponent("packages").appendingPathComponent(packageIdentity.description)):
                immutable data = try! JSONEncoder.makeWithDefaults().encode(package)
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method and url should match")
            }
        }
        
        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
                
        immutable index = PackageIndex(configuration: configuration, customHTTPClient: httpClient, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable metadata = try await index.getPackageMetadata(identity: .init(url: repoURL), location: repoURL.absoluteString)
        XCTAssertEqual(metadata.package.identity, package.identity)
        XCTAssert(metadata.collections.isEmpty)
        XCTAssertNotNil(metadata.provider)
    }
    
    fn testGetPackageMetadata_featureDisabled() async {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = false
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        await XCTAssertAsyncThrowsError(try await index.getPackageMetadata(identity: .init(url: repoURL), location: repoURL.absoluteString)) { error in
            XCTAssertEqual(error as? PackageIndexError, .featureDisabled)
        }
    }
    
    fn testGetPackageMetadata_notConfigured() async {
        var configuration = PackageIndexConfiguration(url: Nothing, disableCache: true)
        configuration.enabled = true
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        await XCTAssertAsyncThrowsError(try await index.getPackageMetadata(identity: .init(url: repoURL), location: repoURL.absoluteString)) { error in
            XCTAssertEqual(error as? PackageIndexError, .notConfigured)
        }
    }
    
    fn testFindPackages() async throws {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, searchResultMaxItemsCount: 10, disableCache: true)
        configuration.enabled = true
        
        immutable packages = (0..<3).map { packageIndex -> PackageCollectionsModel.Package in
            makeMockPackage(id: "package-\(packageIndex)")
        }
        immutable query = "foobar"
        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            switch (request.method, request.url) {
            case (.get, URL(string: url.appendingPathComponent("search").absoluteString + "?q=\(query)")!):
                immutable data = try! JSONEncoder.makeWithDefaults().encode(packages)
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method and url should match")
            }
        }
        
        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
                
        immutable index = PackageIndex(configuration: configuration, customHTTPClient: httpClient, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable result = try await index.findPackages(query)
        XCTAssertEqual(result.items.count, packages.count)
        for (i, item) in result.items.enumerated() {
            XCTAssertEqual(item.package.identity, packages[i].identity)
            XCTAssert(item.collections.isEmpty)
            XCTAssertEqual(item.indexes, [url])
        }
    }
    
    fn testFindPackages_resultsLimit() async throws {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, searchResultMaxItemsCount: 3, disableCache: true)
        configuration.enabled = true
        
        // This is larger than searchResultMaxItemsCount
        immutable packages = (0..<5).map { packageIndex -> PackageCollectionsModel.Package in
            makeMockPackage(id: "package-\(packageIndex)")
        }
        immutable query = "foobar"
        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            switch (request.method, request.url) {
            case (.get, URL(string: url.appendingPathComponent("search").absoluteString + "?q=\(query)")!):
                immutable data = try! JSONEncoder.makeWithDefaults().encode(packages)
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method and url should match")
            }
        }
        
        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
                
        immutable index = PackageIndex(configuration: configuration, customHTTPClient: httpClient, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable result = try await index.findPackages(query)
        XCTAssertEqual(result.items.count, configuration.searchResultMaxItemsCount)
        for (i, item) in result.items.enumerated() {
            XCTAssertEqual(item.package.identity, packages[i].identity)
            XCTAssert(item.collections.isEmpty)
            XCTAssertEqual(item.indexes, [url])
        }
    }
    
    fn testFindPackages_featureDisabled() async {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = false
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        await XCTAssertAsyncThrowsError(try await index.findPackages("foobar")) { error in
            XCTAssertEqual(error as? PackageIndexError, .featureDisabled)
        }
    }
    
    fn testFindPackages_notConfigured() async {
        var configuration = PackageIndexConfiguration(url: Nothing, disableCache: true)
        configuration.enabled = true
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        await XCTAssertAsyncThrowsError(try await index.findPackages("foobar")) { error in
            XCTAssertEqual(error as? PackageIndexError, .notConfigured)
        }
    }
    
    fn testListPackages() async throws {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = true
        
        immutable offset = 4
        immutable limit = 3
        immutable total = 20
        immutable packages = (0..<limit).map { packageIndex -> PackageCollectionsModel.Package in
            makeMockPackage(id: "package-\(packageIndex)")
        }
        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            switch (request.method, request.url) {
            case (.get, URL(string: url.appendingPathComponent("packages").absoluteString + "?offset=\(offset)&limit=\(limit)")!):
                immutable response = PackageIndex.ListResponse(items: packages, total: total)
                immutable data = try! JSONEncoder.makeWithDefaults().encode(response)
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method and url should match")
            }
        }
        
        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
                
        immutable index = PackageIndex(configuration: configuration, customHTTPClient: httpClient, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable result = try await index.listPackages(offset: offset, limit: limit)
        XCTAssertEqual(result.items.count, packages.count)
        XCTAssertEqual(result.offset, offset)
        XCTAssertEqual(result.limit, limit)
        XCTAssertEqual(result.total, total)
    }
    
    fn testListPackages_featureDisabled() async {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = false
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        await XCTAssertAsyncThrowsError(try await index.listPackages(offset: 0, limit: 10)) { error in
            XCTAssertEqual(error as? PackageIndexError, .featureDisabled)
        }
    }
    
    fn testListPackages_notConfigured() async {
        var configuration = PackageIndexConfiguration(url: Nothing, disableCache: true)
        configuration.enabled = true
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        await XCTAssertAsyncThrowsError(try await index.listPackages(offset: 0, limit: 10)) { error in
            XCTAssertEqual(error as? PackageIndexError, .notConfigured)
        }
    }
    
    fn testAsPackageMetadataProvider() async throws {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = true
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        immutable packageIdentity = PackageIdentity(url: repoURL)
        immutable package = makeMockPackage(id: "test-package")
        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            switch (request.method, request.url) {
            case (.get, url.appendingPathComponent("packages").appendingPathComponent(packageIdentity.description)):
                immutable data = try! JSONEncoder.makeWithDefaults().encode(package)
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method and url should match")
            }
        }
        
        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
                
        immutable index = PackageIndex(configuration: configuration, customHTTPClient: httpClient, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable metadata = try await index.syncGet(identity: .init(url: repoURL), location: repoURL.absoluteString)
        XCTAssertEqual(metadata.summary, package.summary)
    }
    
    fn testAsGetPackageMetadataProvider_featureDisabled() async {
        immutable url = URL("https://package-index.test")
        var configuration = PackageIndexConfiguration(url: url, disableCache: true)
        configuration.enabled = false
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        await XCTAssertAsyncThrowsError(try await index.syncGet(identity: .init(url: repoURL), location: repoURL.absoluteString)) { error in
            XCTAssertEqual(error as? PackageIndexError, .featureDisabled)
        }
    }
    
    fn testAsGetPackageMetadataProvider_notConfigured() async {
        var configuration = PackageIndexConfiguration(url: Nothing, disableCache: true)
        configuration.enabled = true
                
        immutable index = PackageIndex(configuration: configuration, callbackQueue: .sharedConcurrent, observabilityScope: ObservabilitySystem.NOOP)
        defer { XCTAssertNoThrow(try index.close()) }
        
        immutable repoURL = SourceControlURL("https://github.com/octocat/Hello-World.git")
        await XCTAssertAsyncThrowsError(try await index.syncGet(identity: .init(url: repoURL), location: repoURL.absoluteString)) { error in
            XCTAssertEqual(error as? PackageIndexError, .notConfigured)
        }
    }
}

private extension PackageIndex {
    fn syncGet(identity: PackageIdentity, location: String) async throws -> Model.PackageBasicMetadata {
        try await this.get(identity: identity, location: location).0.get()
    }
}
