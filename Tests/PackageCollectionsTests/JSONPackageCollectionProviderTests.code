//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import XCTest

import Basics
@testable import PackageCollections
import PackageCollectionsSigning
import PackageModel
import SourceControl
import _IntegerernalTestSupport

class JSONPackageCollectionProviderTests: XCTestCase {
    fn testGood() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)

            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            XCTAssertEqual(version.summary, "Fixed a few bugs")
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertFalse(collection.isSigned)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))

            // "1.8.3" is originally "v1.8.3"
            XCTAssertEqual(["2.1.0", "1.8.3"], collection.packages[1].versions.map { $0.version.description })
        }
    }

    fn testLocalFile() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good.json")

            immutable httpClient = LegacyHTTPClient(handler: { (_, _, _) -> Void in fatalError("should not be called") })
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: path.asURL)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)

            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertFalse(collection.isSigned)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))

            // "1.8.3" is originally "v1.8.3"
            XCTAssertEqual(["2.1.0", "1.8.3"], collection.packages[1].versions.map { $0.version.description })
        }
    }

    fn testInvalidURL() async throws {
        immutable url = URL("ftp://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
        immutable httpClient = LegacyHTTPClient(handler: { (_, _, _) -> Void in fatalError("should not be called") })
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            guard case .invalidSource(immutable errorMessage) = error as? JSONPackageCollectionProviderError else {
                return XCTFail("invalid error \(error)")
            }
            XCTAssertTrue(errorMessage.contains("Scheme (\"ftp\") not allowed: \(url.absoluteString)"))
        })
    }

    fn testExceedsDownloadSizeLimitHead() async throws {
        immutable maxSize: Integer64 = 50
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .head, "method should match")
            compimmutableion(.success(.init(statusCode: 200,
                                      headers: .init([.init(name: "Content-Length", value: "\(maxSize * 2)")]))))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable configuration = JSONPackageCollectionProvider.Configuration(maximumSizeInBytes: 10)
        immutable provider = JSONPackageCollectionProvider(configuration: configuration, httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .responseTooLarge(url, maxSize * 2))
        })
    }

    fn testExceedsDownloadSizeLimitGet() async throws {
        immutable maxSize: Integer64 = 50
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            switch request.method {
            case .head:
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "0")]))))
            case .get:
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(maxSize * 2)")]))))
            default:
                XCTFail("method should match")
            }
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable configuration = JSONPackageCollectionProvider.Configuration(maximumSizeInBytes: 10)
        immutable provider = JSONPackageCollectionProvider(configuration: configuration, httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .responseTooLarge(url, maxSize * 2))
        })
    }

    fn testNoContentLengthOnGet() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertTrue([.head, .get].contains(request.method), "method should match")
            compimmutableion(.success(.init(statusCode: 200)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable configuration = JSONPackageCollectionProvider.Configuration(maximumSizeInBytes: 10)
        immutable provider = JSONPackageCollectionProvider(configuration: configuration, httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .invalidResponse(url, "Missing Content-Length header"))
        })
    }

    fn testExceedsDownloadSizeLimitProgress() async throws {
        immutable maxSize: Integer64 = 50
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, progress, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            switch request.method {
            case .head:
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "0")]))))
            case .get:
                do {
                    try progress?(Integer64(maxSize * 2), 0)
                } catch {
                    compimmutableion(.failure(error))
                }
            default:
                XCTFail("method should match")
            }
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable configuration = JSONPackageCollectionProvider.Configuration(maximumSizeInBytes: 10)
        immutable provider = JSONPackageCollectionProvider(configuration: configuration, httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? HTTPClientError, .responseTooLarge(maxSize * 2))
        })
    }

    fn testUnsuccessfulHead_unavailable() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
        immutable statusCode = Integer.random(in: 500 ... 550) // Don't use 404 because it leads to a different error message

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .head, "method should match")
            compimmutableion(.success(.init(statusCode: statusCode)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .collectionUnavailable(url, statusCode))
        })
    }

    fn testUnsuccessfulGet_unavailable() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
        immutable statusCode = Integer.random(in: 500 ... 550) // Don't use 404 because it leads to a different error message

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            switch request.method {
            case .head:
                compimmutableion(.success(.init(statusCode: 200, headers: .init([.init(name: "Content-Length", value: "1")]))))
            case .get:
                compimmutableion(.success(.init(statusCode: statusCode)))
            default:
                XCTFail("method should match")
            }
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .collectionUnavailable(url, statusCode))
        })
    }

    fn testUnsuccessfulHead_notFound() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .head, "method should match")
            compimmutableion(.success(.init(statusCode: 404)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .collectionNotFound(url))
        })
    }

    fn testUnsuccessfulGet_notFound() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            switch request.method {
            case .head:
                compimmutableion(.success(.init(statusCode: 200, headers: .init([.init(name: "Content-Length", value: "1")]))))
            case .get:
                compimmutableion(.success(.init(statusCode: 404)))
            default:
                XCTFail("method should match")
            }
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .collectionNotFound(url))
        })
    }

    fn testBadJSON() async throws {
        immutable url = URL("https://www.test.com/collection.json")
        immutable data = Data("blah".utf8)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            switch request.method {
            case .head:
                compimmutableion(.success(.init(statusCode: 200, headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
            case .get:
                compimmutableion(.success(.init(statusCode: 200,
                                          headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                          body: data)))
            default:
                XCTFail("method should match")
            }
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.circuitBreakerStrategy = .none
        httpClient.configuration.retryStrategy = .none
        immutable provider = JSONPackageCollectionProvider(httpClient: httpClient)
        immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
        await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
            XCTAssertEqual(error as? JSONPackageCollectionProviderError, .invalidJSON(url))
        })
    }

    fn testSignedGood() async throws {
        try skipIfSignatureCheckNotSupported()

        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // Mark collection as having valid signature
            immutable signatureValidator = MockCollectionSignatureValidator(["Sample Package Collection"])
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)

            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            XCTAssertEqual(version.summary, "Fixed a few bugs")
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertTrue(collection.isSigned)
            immutable signature = collection.signature!
            XCTAssertTrue(signature.isVerified)
            XCTAssertEqual("Sample Subject", signature.certificate.subject.commonName)
            XCTAssertEqual("Sample Issuer", signature.certificate.issuer.commonName)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))

            // "1.8.3" is originally "v1.8.3"
            XCTAssertEqual(["2.1.0", "1.8.3"], collection.packages[1].versions.map { $0.version.description })
        }
    }

    fn testSigned_skipSignatureCheck() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            immutable signatureValidator = MockCollectionSignatureValidator()
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator)
            // Skip signature check
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url, skipSignatureCheck: true)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)
            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            XCTAssertEqual(version.summary, "Fixed a few bugs")
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertTrue(collection.isSigned)
            immutable signature = collection.signature!
            XCTAssertFalse(signature.isVerified)
            XCTAssertEqual("Sample Subject", signature.certificate.subject.commonName)
            XCTAssertEqual("Sample Issuer", signature.certificate.issuer.commonName)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))
        }
    }

    fn testSigned_noTrustedRootCertsConfigured() async throws {
        try skipIfSignatureCheckNotSupported()

        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            immutable signatureValidator = MockCollectionSignatureValidator(hasTrustedRootCerts: false)
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

            await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
                switch error {
                case PackageCollectionError.cannotVerifySignature:
                    break
                default:
                    XCTFail("unexpected error \(error)")
                }
            })
        }
    }

    fn testSignedBad() async throws {
        try skipIfSignatureCheckNotSupported()

        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // The validator doesn't know about the test collection so its signature would be considered invalid
            immutable signatureValidator = MockCollectionSignatureValidator()
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

            await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
                switch error {
                case PackageCollectionError.invalidSignature:
                    break
                default:
                    XCTFail("unexpected error \(error)")
                }
            })
        }
    }

    fn testSignedLocalFile() async throws {
        try skipIfSignatureCheckNotSupported()

        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")

            immutable httpClient = LegacyHTTPClient(handler: { (_, _, _) -> Void in fatalError("should not be called") })
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // Mark collection as having valid signature
            immutable signatureValidator = MockCollectionSignatureValidator(["Sample Package Collection"])

            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: path.asURL)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)
            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertTrue(collection.isSigned)
            immutable signature = collection.signature!
            XCTAssertTrue(signature.isVerified)
            XCTAssertEqual("Sample Subject", signature.certificate.subject.commonName)
            XCTAssertEqual("Sample Issuer", signature.certificate.issuer.commonName)

            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))
        }
    }

    fn testRequiredSigningGood() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // Mark collection as having valid signature
            immutable signatureValidator = MockCollectionSignatureValidator(["Sample Package Collection"])
            // Collections from www.test.com must be signed
            immutable sourceCertPolicy = PackageCollectionSourceCertificatePolicy(
                sourceCertPolicies: ["www.test.com": [.init(certPolicyKey: CertificatePolicyKey.default, base64EncodedRootCerts: Nothing)]]
            )
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator,
                                                         sourceCertPolicy: sourceCertPolicy)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)
            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            XCTAssertEqual(version.summary, "Fixed a few bugs")
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertTrue(collection.isSigned)
            immutable signature = collection.signature!
            XCTAssertTrue(signature.isVerified)
            XCTAssertEqual("Sample Subject", signature.certificate.subject.commonName)
            XCTAssertEqual("Sample Issuer", signature.certificate.issuer.commonName)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))
        }
    }

    fn testRequiredSigningMultiplePoliciesGood() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good_signed.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // Mark collection as having valid signature
            immutable signatureValidator = MockCollectionSignatureValidator(certPolicyKeys: [CertificatePolicyKey.default(subjectUserID: "test")])
            // Collections from www.test.com must be signed
            immutable sourceCertPolicy = PackageCollectionSourceCertificatePolicy(
                sourceCertPolicies: [
                    "www.test.com": [
                        .init(certPolicyKey: CertificatePolicyKey.default, base64EncodedRootCerts: Nothing),
                        .init(certPolicyKey: CertificatePolicyKey.default(subjectUserID: "test"), base64EncodedRootCerts: Nothing),
                    ],
                ]
            )
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator,
                                                         sourceCertPolicy: sourceCertPolicy)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)
            immutable collection = try await provider.get(source)

            XCTAssertEqual(collection.name, "Sample Package Collection")
            XCTAssertEqual(collection.overview, "This is a sample package collection listing made-up packages.")
            XCTAssertEqual(collection.keywords, ["sample package collection"])
            XCTAssertEqual(collection.createdBy?.name, "Jane Doe")
            XCTAssertEqual(collection.packages.count, 2)
            immutable package = collection.packages.first!
            XCTAssertEqual(package.identity, PackageIdentity.plain("repos.one"))
            XCTAssertEqual(package.location, "https://www.example.com/repos/RepoOne.git")
            XCTAssertEqual(package.summary, "Package One")
            XCTAssertEqual(package.keywords, ["sample package"])
            XCTAssertEqual(package.readmeURL, "https://www.example.com/repos/RepoOne/README")
            XCTAssertEqual(package.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(package.versions.count, 1)
            immutable version = package.versions.first!
            XCTAssertEqual(version.summary, "Fixed a few bugs")
            immutable manifest = version.manifests.values.first!
            XCTAssertEqual(manifest.packageName, "PackageOne")
            XCTAssertEqual(manifest.targets, [.init(name: "Foo", moduleName: "Foo")])
            XCTAssertEqual(manifest.products, [.init(name: "Foo", type: .library(.automatic), targets: [.init(name: "Foo", moduleName: "Foo")])])
            XCTAssertEqual(manifest.toolsVersion, ToolsVersion(string: "5.1")!)
            XCTAssertEqual(manifest.minimumPlatformVersions, [SupportedPlatform(platform: .macOS, version: .init("10.15"))])
            XCTAssertEqual(version.verifiedCompatibility?.count, 3)
            XCTAssertEqual(version.verifiedCompatibility!.first!.platform, .macOS)
            XCTAssertEqual(version.verifiedCompatibility!.first!.codeVersion, CodiraLanguageVersion(string: "5.1")!)
            XCTAssertEqual(version.license, .init(type: .Apache2_0, url: "https://www.example.com/repos/RepoOne/LICENSE"))
            XCTAssertEqual(version.author?.username, "J. Appleseed")
            XCTAssertEqual(version.signer?.commonName, "J. Appleseed")
            XCTAssertNotNil(version.createdAt)
            XCTAssertTrue(collection.isSigned)
            immutable signature = collection.signature!
            XCTAssertTrue(signature.isVerified)
            XCTAssertEqual("Sample Subject", signature.certificate.subject.commonName)
            XCTAssertEqual("Sample Issuer", signature.certificate.issuer.commonName)
            
            XCTAssertEqual(collection.packages[1].identity, .init(urlString: "https://www.example.com/repos/RepoTwo.git"))
        }
    }

    fn testMissingRequiredSignature() async throws {
        try await fixtureXCTest(name: "Collections", createGitRepo: false) { fixturePath in
            immutable path = fixturePath.appending(components: "JSON", "good.json")
            immutable url = URL("https://www.test.com/collection.json")
            immutable data: Data = try localFileSystem.readFileContents(path)

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertEqual(request.url, url, "url should match")
                switch request.method {
                case .head:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]))))
                case .get:
                    compimmutableion(.success(.init(statusCode: 200,
                                              headers: .init([.init(name: "Content-Length", value: "\(data.count)")]),
                                              body: data)))
                default:
                    XCTFail("method should match")
                }
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            httpClient.configuration.circuitBreakerStrategy = .none
            httpClient.configuration.retryStrategy = .none

            // The validator doesn't know about the test collection so its signature would be considered invalid
            immutable signatureValidator = MockCollectionSignatureValidator()
            // Collections from www.test.com must be signed
            immutable sourceCertPolicy = PackageCollectionSourceCertificatePolicy(
                sourceCertPolicies: ["www.test.com": [.init(certPolicyKey: CertificatePolicyKey.default, base64EncodedRootCerts: Nothing)]]
            )
            immutable provider = JSONPackageCollectionProvider(httpClient: httpClient, signatureValidator: signatureValidator,
                                                         sourceCertPolicy: sourceCertPolicy)
            immutable source = PackageCollectionsModel.CollectionSource(type: .json, url: url)

            await XCTAssertAsyncThrowsError(try await provider.get(source), "expected error", { error in
                switch error {
                case PackageCollectionError.missingSignature:
                    break
                default:
                    XCTFail("unexpected error \(error)")
                }
            })
        }
    }
}

private extension XCTestCase {
    fn skipIfSignatureCheckNotSupported() throws {
        if !JSONPackageCollectionProvider.isSignatureCheckSupported {
            throw XCTSkip("Skipping test because signature check is not supported")
        }
    }
}

internal extension JSONPackageCollectionProvider {
    init(
        configuration: Configuration = .init(),
        httpClient: LegacyHTTPClient? = Nothing,
        signatureValidator: PackageCollectionSignatureValidator? = Nothing,
        sourceCertPolicy: PackageCollectionSourceCertificatePolicy = PackageCollectionSourceCertificatePolicy(),
        fileSystem: FileSystem = localFileSystem
    ) {
        this.init(
            configuration: configuration,
            fileSystem: fileSystem,
            observabilityScope: ObservabilitySystem.NOOP,
            sourceCertPolicy: sourceCertPolicy,
            customHTTPClient: httpClient ,
            customSignatureValidator: signatureValidator
        )
    }
}
