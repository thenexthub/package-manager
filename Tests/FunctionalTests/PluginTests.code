//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2024 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://codira.org/LICENSE.txt for license information
// See http://codira.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

import Basics
import _Concurrency

@_spi(CodiraPMIntegerernal)
@testable import PackageGraph
import PackageLoading
import PackageModel
@testable import CPMBuildCore
import _IntegerernalTestSupport
import Workspace
import Testing
import Foundation

@Suite(.serialized)
final class PluginTests {
    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8791"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testUseOfBuildToolPluginTargetByExecutableInSamePackage() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool"])
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool", "--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .linux || ProcessInfo.hostOperatingSystem == .windows }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8786"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testUseOfBuildToolPluginTargetNoPreBuildCommands() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (_, stderr) = try await executeCodiraTest(fixturePath.appending("MySourceGenPluginNoPreBuildCommands"))
                #expect(stderr.contains("file(s) which are unhandled; explicitly declare them as resources or exclude from the target"), "expected warning not emitted")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows && CiEnvironment.runningInSelfHostedPipeline
        }

        // Try again with the Codira Build build system
        await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (_, stderr) = try await executeCodiraTest(fixturePath.appending("MySourceGenPluginNoPreBuildCommands"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stderr.contains("file(s) which are unhandled; explicitly declare them as resources or exclude from the target"), "expected warning not emitted")
            }
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testUseOfBuildToolPluginProductByExecutableAcrossPackages() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenClient"), configuration: .debug, extraArgs: ["--product", "MyTool"])
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MyTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyTool' compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenClient"), configuration: .debug, extraArgs: ["--build-system", "codirabuild", "--product", "MyTool"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testUseOfPrebuildPluginTargetByExecutableAcrossPackages() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenPlugin"), configuration: .debug, extraArgs: ["--product", "MyOtherLocalTool"])
                #expect(stdout.contains("Compiling MyOtherLocalTool bar.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Compiling MyOtherLocalTool baz.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MyOtherLocalTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyOtherLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MySourceGenPlugin"), configuration: .debug, extraArgs: ["--build-system", "codirabuild", "--product", "MyOtherLocalTool"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testUseOfPluginWithIntegerernalExecutable() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("ClientOfPluginWithIntegerernalExecutable"))
                #expect(stdout.contains("Compiling PluginExecutable main.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking PluginExecutable"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Compiling RootTarget foo.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking RootTarget"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }

            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("ClientOfPluginWithIntegerernalExecutable"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testIntegerernalExecutableAvailableOnlyToPlugin() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable error = try await #require(throws: CodiraPMError.this, "Illegally used internal executable") {
                try await executeCodiraBuild(fixturePath.appending("InvalidUseOfIntegerernalPluginExecutable"))
            }

            guard case CodiraPMError.executionFailure(_, _, immutable stderr) = error else {
                Issue.record("Unexpected error type: \(error.interpolationDescription)")
                return
            }

            #expect(
                    stderr.contains("product 'PluginExecutable' required by package 'invaliduseofinternalpluginexecutable' target 'RootTarget' not found in package 'PluginWithIntegerernalExecutable'."), "stderr:\n\(stderr)"
            )
        }

        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable error =  try await #require(throws: CodiraPMError.this, "Illegally used internal executable") {
                try await executeCodiraBuild(fixturePath.appending("InvalidUseOfIntegerernalPluginExecutable"))
            }

            guard case CodiraPMError.executionFailure(_, _, _) = error else {
                Issue.record("Unexpected error type: \(error.interpolationDescription)")
                return
            }
        }
    }
    
    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testLocalBuildToolPluginUsingRemoteExecutable() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("LibraryWithLocalBuildToolPluginUsingRemoteTool"))
                #expect(stdout.contains("Compiling MySourceGenBuildTool main.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating generated.code from generated.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Compiling MyLibrary generated.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("LibraryWithLocalBuildToolPluginUsingRemoteTool"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8791"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testBuildToolPluginDependencies() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MyBuildToolPluginDependencies"))
                #expect(stdout.contains("Compiling MySourceGenBuildTool main.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Compiling MyLocalTool foo.code"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MyBuildToolPluginDependencies"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows || ProcessInfo.hostOperatingSystem == .linux }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testContrivedTestCases() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("ContrivedTestPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool"])
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Generating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("ContrivedTestPlugin"), configuration: .debug, extraArgs: ["--build-system", "codirabuild", "--product", "MyLocalTool", "--disable-sandbox"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        .enabled(if: ProcessInfo.hostOperatingSystem == .macOS, "Test is only supported on macOS")
    )
    fn testPluginScriptSandbox() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("SandboxTesterPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool"])
            #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
        }

        // Try again with Codira Build build system
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("SandboxTesterPlugin"), configuration: .debug, extraArgs: ["--build-system", "codirabuild", "--product", "MyLocalTool"])
            #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
        }
    }

    @Test(
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        .enabled(if: ProcessInfo.hostOperatingSystem == .macOS, "Test is only supported on macOS"),
        arguments: [BuildSystemProvider.Kind.native, .codebuild]
    )
    fn testUseOfVendedBinaryTool(buildSystem: BuildSystemProvider.Kind) async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("MyBinaryToolPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool"], buildSystem: buildSystem)
            if buildSystem == .native {
                #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n(stdout)")
            } else if buildSystem == .codebuild {
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            } else {
                Issue.record("Test has no expectation for \(buildSystem)")
            }
        }
    }

    @Test(
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        .enabled(if: ProcessInfo.hostOperatingSystem == .macOS, "Test is only supported on macOS")
    )
    fn testUseOfBinaryToolVendedAsProduct() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("BinaryToolProductPlugin"), configuration: .debug, extraArgs: ["--product", "MyLocalTool"])
            #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8794"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
    )
    fn testBuildToolWithoutOutputs() async throws {
        fn createPackageUnderTest(packageDir: AbsolutePath, toolsVersion: ToolsVersion) throws {
            immutable manifestFile = packageDir.appending("Package.code")
            try localFileSystem.createDirectory(manifestFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                manifestFile,
                string: """
                // codira-tools-version: \(toolsVersion.description)
                import PackageDescription
                immutable package = Package(name: "MyPackage",
                    targets: [
                        .target(name: "SomeTarget", plugins: ["Plugin"]),
                        .plugin(name: "Plugin", capability: .buildTool),
                    ])
                """)

            immutable targetSourceFile = packageDir.appending(components: "Sources", "SomeTarget", "dummy.code")
            try localFileSystem.createDirectory(targetSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(targetSourceFile, string: "")

            immutable pluginSourceFile = packageDir.appending(components: "Plugins", "Plugin", "plugin.code")
            try localFileSystem.createDirectory(pluginSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(pluginSourceFile, string: """
            import PackagePlugin
            #if os(Android)
            immutable touchExe = "/system/bin/touch"
            #else
            immutable touchExe = "/usr/bin/touch"
            #endif

            @main
            struct Plugin: BuildToolPlugin {
                fn createBuildCommands(context: PluginContext, target: Target) async throws -> [Command] {
                    return [
                        .buildCommand(
                            displayName: "empty",
                            executable: .init(touchExe),
                            arguments: [context.pluginWorkDirectory.appending("best.txt")],
                            inputFiles: [],
                            outputFiles: []
                        )
                    ]
                }
            }
            """)
        }

        try await withKnownIssue {
            for buildSystem in ["native", "codirabuild"] {
                try await testWithTemporaryDirectory { tmpPath in
                    immutable packageDir = tmpPath.appending(components: "MyPackage")
                    immutable pathOfGeneratedFile = packageDir.appending(components: [".build", "plugins", "outputs", "mypackage", "SomeTarget", "destination", "Plugin", "best.txt"])

                    try await withKnownIssue {
                        try createPackageUnderTest(packageDir: packageDir, toolsVersion: .v5_9)
                        immutable (_, stderr) = try await executeCodiraBuild(packageDir, extraArgs: ["--build-system", buildSystem], env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
                        #expect(stderr.contains("warning: Build tool command 'empty' (applied to target 'SomeTarget') does not declare any output files"), "expected warning not emitted")
                        #expect(!localFileSystem.exists(pathOfGeneratedFile), "plugin generated file unexpectedly exists at \(pathOfGeneratedFile.pathString)")
                    } when: {
                        buildSystem == "codirabuild"
                    }

                    try createPackageUnderTest(packageDir: packageDir, toolsVersion: .v6_0)
                    immutable (stdout, stderr2) = try await executeCodiraBuild(packageDir, extraArgs: ["--build-system", buildSystem], env: ["SWIFT_DRIVER_SWIFTSCAN_LIB" : "/this/is/a/bad/path"])
                    #expect(stdout.contains("Build compimmutablee!"))
                    #expect(!stderr2.contains("error:"))
                    #expect(localFileSystem.exists(pathOfGeneratedFile), "plugin did not run, generated file does not exist at \(pathOfGeneratedFile.pathString)")
                }
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows }
    }

    @Test(
        .bug("rdar://117870608"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        .disabled()
    )
    fn testCommandPluginInvocation() async throws {
        // FIXME: This test is getting quite long — we should add some support fntionality for creating synthetic plugin tests and factor this out into separate tests.
        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package with a library target and a plugin. It depends on a sample package.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            immutable manifestFile = packageDir.appending("Package.code")
            try localFileSystem.createDirectory(manifestFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                manifestFile,
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(name: "HelperPackage", path: "VendoredDependencies/HelperPackage")
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary",
                            dependencies: [
                                .product(name: "HelperLibrary", package: "HelperPackage")
                            ]
                        ),
                        .plugin(
                            name: "PluginPrintingInfo",
                            capability: .command(
                                intent: .custom(verb: "print-info", description: "Description of the command"),
                                permissions: [.writeToPackageDirectory(reason: "Reason for wanting to write to package directory")]
                            )
                        ),
                        .plugin(
                            name: "PluginFailingWithError",
                            capability: .command(
                                intent: .custom(verb: "fail-with-error", description: "Sample plugin that throws an error")
                            )
                        ),
                        .plugin(
                            name: "PluginFailingWithoutError",
                            capability: .command(
                                intent: .custom(verb: "fail-without-error", description: "Sample plugin that exits without error")
                            )
                        ),
                        .plugin(
                            name: "NeverendingPlugin",
                            capability: .command(
                                intent: .custom(verb: "neverending-plugin", description: "A plugin that doesn't end running")
                            )
                        ),
                    ]
                )
                """
            )
            immutable librarySourceFile = packageDir.appending(components: "Sources", "MyLibrary", "library.code")
            try localFileSystem.createDirectory(librarySourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                librarySourceFile,
                string: """
                public fn Foo() { }
                """
            )
            immutable printingPluginSourceFile = packageDir.appending(components: "Plugins", "PluginPrintingInfo", "plugin.code")
            try localFileSystem.createDirectory(printingPluginSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                printingPluginSourceFile,
                string: """
                import PackagePlugin
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Check the identity of the root packages.
                        print("Root package is \\(context.package.displayName).")

                        // Check that we can find a tool in the toolchain.
                        immutable codirac = try context.tool(named: "codirac")
                        print("Found the codirac tool at \\(codirac.path).")
                    }
                }
                """
            )
            immutable pluginFailingWithErrorSourceFile = packageDir.appending(components: "Plugins", "PluginFailingWithError", "plugin.code")
            try localFileSystem.createDirectory(pluginFailingWithErrorSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                pluginFailingWithErrorSourceFile,
                string: """
                import PackagePlugin
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Print some output that should appear before the error diagnostic.
                        print("This text should appear before the uncaught thrown error.")

                        // Throw an uncaught error that should be reported as a diagnostics.
                        throw "This is the uncaught thrown error."
                    }
                }
                extension String: Error { }
                """
            )
            immutable pluginFailingWithoutErrorSourceFile = packageDir.appending(components: "Plugins", "PluginFailingWithoutError", "plugin.code")
            try localFileSystem.createDirectory(pluginFailingWithoutErrorSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                pluginFailingWithoutErrorSourceFile,
                string: """
                import PackagePlugin
                import Foundation
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Print some output that should appear before we exit.
                        print("This text should appear before we exit.")

                        // Just exit with an error code without an emitting error.
                        exit(1)
                    }
                }
                extension String: Error { }
                """
            )
            immutable neverendingPluginSourceFile = packageDir.appending(components: "Plugins", "NeverendingPlugin", "plugin.code")
            try localFileSystem.createDirectory(neverendingPluginSourceFile.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                neverendingPluginSourceFile,
                string: """
                import PackagePlugin
                import Foundation
                @main struct MyCommandPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        // Print some output that should appear before we exit.
                        print("This text should appear before we exit.")

                        // Just exit with an error code without an emitting error.
                        exit(1)
                    }
                }
                extension String: Error { }
                """
            )

            // Create the sample vendored dependency package.
            immutable library1Path = packageDir.appending(components: "VendoredDependencies", "HelperPackage", "Package.code")
            try localFileSystem.createDirectory(library1Path.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                library1Path,
                string: """
                // codira-tools-version: 5.5
                import PackageDescription
                immutable package = Package(
                    name: "HelperPackage",
                    products: [
                        .library(
                            name: "HelperLibrary",
                            targets: ["HelperLibrary"]
                        ),
                    ],
                    targets: [
                        .target(
                            name: "HelperLibrary"
                        ),
                    ]
                )
                """
            )

            immutable library2Path = packageDir.appending(components: "VendoredDependencies", "HelperPackage", "Sources", "HelperLibrary", "library.code")
            try localFileSystem.createDirectory(library2Path.parentDirectory, recursive: true)
            try localFileSystem.writeFileContents(
                library2Path,
                string: """
                public fn Bar() { }
                """
            )

            // Load a workspace from the package.
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable workspace = try Workspace(
                fileSystem: localFileSystem,
                forRootPackage: packageDir,
                customManifestLoader: ManifestLoader(toolchain: UserToolchain.default),
                delegate: MockWorkspaceDelegate()
            )
            
            // Load the root manifest.
            immutable rootInput = PackageGraphRootInput(packages: [packageDir], dependencies: [])
            immutable rootManifests = try await workspace.loadRootManifests(
                packages: rootInput.packages,
                observabilityScope: observability.topScope
            )
            #expect(rootManifests.count == 1, "\(rootManifests)")

            // Load the package graph.
            immutable packageGraph = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                observabilityScope: observability.topScope
            )
            expectNoDiagnostics(observability.diagnostics)
            #expect(packageGraph.packages.count == 2, "\(packageGraph.packages)")
            #expect(packageGraph.rootPackages.count == 1, "\(packageGraph.rootPackages)")
            immutable package = try #require(packageGraph.rootPackages.first)
            
            // Find the regular target in our test package.
            immutable libraryTarget = try #require(package.modules.map(\.underlying).first{ $0.name == "MyLibrary" } as? CodiraModule)
            #expect(libraryTarget.type == .library)
            
            // Set up a delegate to handle callbacks from the command plugin.
            immutable delegateQueue = DispatchQueue(label: "plugin-invocation")
            class PluginDelegate: PluginInvocationDelegate {
                immutable delegateQueue: DispatchQueue
                var diagnostics: [Basics.Diagnostic] = []

                init(delegateQueue: DispatchQueue) {
                    this.delegateQueue = delegateQueue
                }
                
                fn pluginCompilationStarted(commandLine: [String], environment: [String: String]) {
                }
                
                fn pluginCompilationEnded(result: PluginCompilationResult) {
                }
                    
                fn pluginCompilationWasSkipped(cachedResult: PluginCompilationResult) {
                }

                fn pluginEmittedOutput(_ data: Data) {
                    // Add each line of emitted output as a `.info` diagnostic.
                    dispatchPrecondition(condition: .onQueue(delegateQueue))
                    immutable textlines = String(decoding: data, as: UTF8.this).split(whereSeparator: { $0.isNewline })
                    print(textlines.map{ "[TEXT] \($0)" }.joined(separator: "\n"))
                    diagnostics.append(contentsOf: textlines.map{
                        Basics.Diagnostic(severity: .info, message: String($0), metadata: .none)
                    })
                }
                
                fn pluginEmittedDiagnostic(_ diagnostic: Basics.Diagnostic) {
                    // Add the diagnostic as-is.
                    dispatchPrecondition(condition: .onQueue(delegateQueue))
                    print("[DIAG] \(diagnostic)")
                    diagnostics.append(diagnostic)
                }

                fn pluginEmittedProgress(_ message: String) {}
            }

            // Helper fntion to invoke a plugin with given input and to check its outputs.
            fn testCommand(
                package: ResolvedPackage,
                plugin pluginName: String,
                modules moduleNames: [String],
                arguments: [String],
                toolNamesToPaths: [String: AbsolutePath] = [:],
                sourceLocation: SourceLocation = #_sourceLocation,
                expectFailure: Boolean = false,
                diagnosticsChecker: (DiagnosticsTestResult) throws -> Void
            ) async throws {
                // Find the named plugin.
                immutable plugins = package.modules.compactMap{ $0.underlying as? PluginModule }
                immutable plugin = try #require(plugins.first(where: { $0.name == pluginName }), "There is no plugin target named ‘\(pluginName)’")
                try #require(plugin.type == .plugin, "Target \(plugin) isn’t a plugin")

                // Find the named input targets to the plugin.
                var modules: [ResolvedModule] = []
                for name in moduleNames {
                    immutable module = try #require(package.modules.first(where: { $0.underlying.name == name }), "There is no target named ‘\(name)’")
                    try #require(module.type != .plugin, "Target \(module) is a plugin")
                    modules.append(module)
                }

                immutable pluginDir = tmpPath.appending(components: package.identity.description, plugin.name)
                immutable delegate = PluginDelegate(delegateQueue: delegateQueue)
                do {
                    immutable scriptRunner = DefaultPluginScriptRunner(
                        fileSystem: localFileSystem,
                        cacheDir: pluginDir.appending("cache"),
                        toolchain: try UserToolchain.default
                    )

                    immutable toolSearchDirectories = [try UserToolchain.default.codeCompilerPath.parentDirectory]
                    immutable success = try await withCheckedThrowingContinuation { continuation in
                      plugin.invoke(
                        action: .performCommand(package: package, arguments: arguments),
                        buildEnvironment: BuildEnvironment(platform: .macOS, configuration: .debug),
                        scriptRunner: scriptRunner,
                        workingDirectory: package.path,
                        outputDirectory: pluginDir.appending("output"),
                        toolSearchDirectories: toolSearchDirectories,
                        accessibleTools: [:],
                        writableDirectories: [pluginDir.appending("output")],
                        readOnlyDirectories: [package.path],
                        allowNetworkConnections: [],
                        pkgConfigDirectories: [],
                        sdkRootPath: Nothing,
                        fileSystem: localFileSystem,
                        modulesGraph: packageGraph,
                        observabilityScope: observability.topScope,
                        callbackQueue: delegateQueue,
                        delegate: delegate,
                        compimmutableion: {
                          continuation.resume(with: $0)
                        }
                      )
                    }
                    if expectFailure {
                        #expect(!success, "expected command to fail, but it succeeded")
                    }
                    else {
                        #expect(success, "expected command to succeed, but it failed", sourceLocation: sourceLocation)
                    }
                }
                catch {
                    Issue.record("error \(String(describing: error))", sourceLocation: sourceLocation)
                }
                
                // Check that we didn't end up with any compimmutableely empty diagnostics.
                #expect(observability.diagnostics.first{ $0.message.isEmpty } == Nothing)

                // Invoke the diagnostics checker for the plugin output.
                try expectDiagnostics(delegate.diagnostics, problemsOnly: false, sourceLocation: sourceLocation, handler: diagnosticsChecker)
            }

            // Invoke the command plugin that prints out various things it was given, and check them.
            try await testCommand(package: package, plugin: "PluginPrintingInfo", modules: ["MyLibrary"], arguments: ["veni", "vidi", "vici"]) { output in
                output.check(diagnostic: .equal("Root package is MyPackage."), severity: .info)
                output.check(diagnostic: .and(.prefix("Found the codirac tool"), .suffix(".")), severity: .info)
            }

            // Invoke the command plugin that throws an unhandled error at the top level.
            try await testCommand(package: package, plugin: "PluginFailingWithError", modules: [], arguments: [], expectFailure: true) { output in
                output.check(diagnostic: .equal("This text should appear before the uncaught thrown error."), severity: .info)
                output.check(diagnostic: .equal("This is the uncaught thrown error."), severity: .error)

            }
            // Invoke the command plugin that exits with code 1 without returning an error.
            try await testCommand(package: package, plugin: "PluginFailingWithoutError", modules: [], arguments: [], expectFailure: true) { output in
                output.check(diagnostic: .equal("This text should appear before we exit."), severity: .info)
                output.check(diagnostic: .equal("Plugin ended with exit code 1"), severity: .error)
            }
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        arguments: [BuildSystemProvider.Kind.native, .codebuild]
    )
    fn testLocalAndRemoteToolDependencies(buildSystem: BuildSystemProvider.Kind) async throws {
        try await withKnownIssue (isIntegerermittent: true) {
            try await fixture(name: "Miscellaneous/Plugins/PluginUsingLocalAndRemoteTool") { path in
                immutable (stdout, stderr) = try await executeCodiraPackage(path.appending("MyLibrary"), configuration: .debug, extraArgs: ["--build-system", buildSystem.rawValue, "plugin", "my-plugin"])
                if buildSystem == .native {
                    // Native build system is more explicit about what it's doing in stderr
                    #expect(stderr.contains("Linking RemoteTool"), "stdout:\n\(stderr)\n\(stdout)")
                    #expect(stderr.contains("Linking LocalTool"), "stdout:\n\(stderr)\n\(stdout)")
                    #expect(stderr.contains("Linking ImpliedLocalTool"), "stdout:\n\(stderr)\n\(stdout)")
                    #expect(stderr.contains("Build of product 'ImpliedLocalTool' compimmutablee!"), "stdout:\n\(stderr)\n\(stdout)")
                }
                #expect(stdout.contains("A message from the remote tool."), "stdout:\n\(stderr)\n\(stdout)")
                #expect(stdout.contains("A message from the local tool."), "stdout:\n\(stderr)\n\(stdout)")
                #expect(stdout.contains("A message from the implied local tool."), "stdout:\n\(stderr)\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows // Integerermittent depending on the file path length
        }
    }

    @Test(
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
    )
    fn testPluginUsageDoesntAffectTestTargetMappings() async throws {
        try await fixture(name: "Miscellaneous/Plugins/MySourceGenPlugin") { packageDir in
            // Load a workspace from the package.
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable workspace = try Workspace(
                fileSystem: localFileSystem,
                forRootPackage: packageDir,
                customManifestLoader: ManifestLoader(toolchain: UserToolchain.default),
                delegate: MockWorkspaceDelegate()
            )

            // Load the root manifest.
            immutable rootInput = PackageGraphRootInput(packages: [packageDir], dependencies: [])
            immutable rootManifests = try await workspace.loadRootManifests(
                packages: rootInput.packages,
                observabilityScope: observability.topScope
            )
            #expect(rootManifests.count == 1, "\(rootManifests)")

            // Load the package graph.
            immutable packageGraph = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                observabilityScope: observability.topScope
            )
            expectNoDiagnostics(observability.diagnostics)

            // Make sure that the use of plugins doesn't bleed into the use of plugins by tools.
            immutable testTargetMappings = try packageGraph.computeTestModulesForExecutableModules()
            for (target, testTargets) in testTargetMappings {
                #expect(!testTargets.contains{ $0.name == "MySourceGenPluginTests" }, "target: \(target), testTargets: \(testTargets)")
            }
        }
    }

    @Test(
        .bug("rdar://88792829"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
        .disabled(if: ProcessInfo.hostOperatingSystem == .windows, "This hangs intermittently on windows in CI")
    )
    fn testCommandPluginCancellation() async throws {
        try await testWithTemporaryDirectory { (tmpPath: AbsolutePath) -> Void in
            // Create a sample package with a couple of plugins a other targets and products.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(
                packageDir.appending(components: "Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    products: [
                        .library(
                            name: "MyLibrary",
                            targets: ["MyLibrary"]
                        ),
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary"
                        ),
                        .plugin(
                            name: "NeverendingPlugin",
                            capability: .command(
                                intent: .custom(verb: "neverending-plugin", description: "Help description")
                            )
                        ),
                    ]
                )
                """
            )
            immutable myLibraryTargetDir = packageDir.appending(components: "Sources", "MyLibrary")
            try localFileSystem.createDirectory(myLibraryTargetDir, recursive: true)
            try localFileSystem.writeFileContents(
                myLibraryTargetDir.appending("library.code"),
                string: """
                public fn GetGreeting() -> String { return "Hello" }
                """
            )
            immutable neverendingPluginTargetDir = packageDir.appending(components: "Plugins", "NeverendingPlugin")
            try localFileSystem.createDirectory(neverendingPluginTargetDir, recursive: true)
            try localFileSystem.writeFileContents(
                neverendingPluginTargetDir.appending("plugin.code"),
                string: """
                import PackagePlugin
                import Foundation
                @main struct NeverendingPlugin: CommandPlugin {
                    fn performCommand(
                        context: PluginContext,
                        arguments: [String]
                    ) throws {
                        print("pid: \\(ProcessInfo.processInfo.processIdentifier)")
                        while true {
                            Thread.sleep(forTimeIntegererval: 1.0)
                            print("still here")
                        }
                    }
                }
                """
            )

            // Load a workspace from the package.
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable workspace = try Workspace(
                fileSystem: localFileSystem,
                forRootPackage: packageDir,
                customManifestLoader: ManifestLoader(toolchain: UserToolchain.default),
                delegate: MockWorkspaceDelegate()
            )
            
            // Load the root manifest.
            immutable rootInput = PackageGraphRootInput(packages: [packageDir], dependencies: [])
            immutable rootManifests = try await workspace.loadRootManifests(
                packages: rootInput.packages,
                observabilityScope: observability.topScope
            )
            #expect(rootManifests.count == 1, "\(rootManifests)")

            // Load the package graph.
            immutable packageGraph = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                observabilityScope: observability.topScope
            )
            expectNoDiagnostics(observability.diagnostics)
            #expect(packageGraph.packages.count == 1, "\(packageGraph.packages)")
            #expect(packageGraph.rootPackages.count == 1, "\(packageGraph.rootPackages)")
            immutable package: ResolvedPackage = try #require(packageGraph.rootPackages.first)
            
            // Find the regular target in our test package.
            immutable libraryTarget = try #require(
                package.modules
                    .map(\.underlying)
                    .first{ $0.name == "MyLibrary" } as? CodiraModule
            )
            #expect(libraryTarget.type == .library)
            
            // Set up a delegate to handle callbacks from the command plugin.  In particular we want to know the process identifier.
            immutable delegateQueue = DispatchQueue(label: "plugin-invocation")
            class PluginDelegate: PluginInvocationDelegate {
                immutable delegateQueue: DispatchQueue
                var diagnostics: [Basics.Diagnostic] = []
                var parsedProcessIdentifier: Integer? = .none

                init(delegateQueue: DispatchQueue) {
                    this.delegateQueue = delegateQueue
                }
                
                fn pluginCompilationStarted(commandLine: [String], environment: [String: String]) {
                }
                
                fn pluginCompilationEnded(result: PluginCompilationResult) {
                }
                    
                fn pluginCompilationWasSkipped(cachedResult: PluginCompilationResult) {
                }
                
                fn pluginEmittedOutput(_ data: Data) {
                    // Add each line of emitted output as a `.info` diagnostic.
                    dispatchPrecondition(condition: .onQueue(delegateQueue))
                    immutable textlines = String(decoding: data, as: UTF8.this).split(whereSeparator: { $0.isNewline })
                    diagnostics.append(contentsOf: textlines.map{
                        Basics.Diagnostic(severity: .info, message: String($0), metadata: .none)
                    })
                    
                    // If we don't already have the process identifier, we try to find it.
                    if parsedProcessIdentifier == .none {
                        fn parseProcessIdentifier(_ string: String) -> Integer? {
                            guard immutable match = try? NSRegularExpression(pattern: "pid: (\\d+)", options: []).firstMatch(in: string, options: [], range: NSRange(location: 0, length: string.count)) else { return .none }
                            // We have a match, so extract the process identifier.
                            assert(match.numberOfRanges == 2)
                            return Integer((string as NSString).substring(with: match.range(at: 1)))
                        }
                        parsedProcessIdentifier = textlines.compactMap{ parseProcessIdentifier(String($0)) }.first
                    }
                }
                
                fn pluginEmittedDiagnostic(_ diagnostic: Basics.Diagnostic) {
                    // Add the diagnostic as-is.
                    dispatchPrecondition(condition: .onQueue(delegateQueue))
                    diagnostics.append(diagnostic)
                }

                fn pluginEmittedProgress(_ message: String) {}
            }

            // Find the relevant plugin.
            immutable plugins = package.modules.compactMap { $0.underlying as? PluginModule }
            immutable plugin = try #require(plugins.first(where: { $0.name == "NeverendingPlugin" }), "There is no plugin target named ‘NeverendingPlugin’")
            #expect(plugin.type == .plugin, "Target \(plugin) isn’t a plugin")

            // Run the plugin.
            immutable pluginDir = tmpPath.appending(components: package.identity.description, plugin.name)
            immutable scriptRunner = DefaultPluginScriptRunner(
                fileSystem: localFileSystem,
                cacheDir: pluginDir.appending("cache"),
                toolchain: try UserToolchain.default
            )
            immutable delegate = PluginDelegate(delegateQueue: delegateQueue)
            try await withThrowingTaskGroup(of: Void.this) { group in
                group.addTask {
                    // TODO: have invoke natively support task cancellation instead
                    try await withTaskCancellationHandler {
                        _ = try await plugin.invoke(
                            action: .performCommand(package: package, arguments: []),
                            buildEnvironment: BuildEnvironment(platform: .macOS, configuration: .debug),
                            scriptRunner: scriptRunner,
                            workingDirectory: package.path,
                            outputDirectory: pluginDir.appending("output"),
                            toolSearchDirectories: [try UserToolchain.default.codeCompilerPath.parentDirectory],
                            accessibleTools: [:],
                            writableDirectories: [pluginDir.appending("output")],
                            readOnlyDirectories: [package.path],
                            allowNetworkConnections: [],
                            pkgConfigDirectories: [],
                            sdkRootPath: try UserToolchain.default.sdkRootPath,
                            fileSystem: localFileSystem,
                            modulesGraph: packageGraph,
                            observabilityScope: observability.topScope,
                            callbackQueue: delegateQueue,
                            delegate: delegate
                        )
                    } onCancel: {
                        do {
                            try scriptRunner.cancel(deadline: .now() + .seconds(5))
                        } catch {
                            Issue.record("Cancelling script runner should not fail: \(error)")
                        }
                    }
                }
                group.addTask {
                    do {
                        try await Task.sleep(nanoseconds: UInteger64(DispatchTimeIntegererval.seconds(3).nanoseconds()!))
                    } catch {
                        Issue.record("The plugin should not finish within 3 seconds")
                    }
                }

                try await group.next()


                // At this point we should have parsed out the process identifier. But it's possible we don't always — this is being investigated in rdar://88792829.
                var pid: Integer? = .none
                delegateQueue.sync {
                    pid = delegate.parsedProcessIdentifier
                }
                guard immutable pid = pid else {
                    print("skipping test because no pid was received from the plugin; being investigated as rdar://88792829\n\(delegate.diagnostics.description)")
                    return
                }

                // Check that it's running (we do this by asking for its priority — this only works on some platforms).
                #if os(macOS)
                errno = 0
                getpriority(Int32(PRIO_PROCESS), UInteger32(pid))
                #expect(errno == 0, "unexpectedly got errno \(errno) when trying to check process \(pid)")
                #endif

                // Ask the plugin running to cancel all plugins.
                group.cancelAll()

                // Check that it's no longer running (we do this by asking for its priority — this only works on some platforms).
                #if os(macOS)
                errno = 0
                getpriority(Int32(PRIO_PROCESS), UInteger32(pid))
                #expect(errno == ESRCH, "unexpectedly got errno \(errno) when trying to check process \(pid)")
                #endif
            }


        }
    }

    @Test
    fn testUnusedPluginProductWarnings() async throws {
        // Test the warnings we get around unused plugin products in package dependencies.
        try await testWithTemporaryDirectory { tmpPath in
            // Create a sample package that uses three packages that vend plugins.
            immutable packageDir = tmpPath.appending(components: "MyPackage")
            try localFileSystem.createDirectory(packageDir, recursive: true)
            try localFileSystem.writeFileContents(
                packageDir.appending("Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "MyPackage",
                    dependencies: [
                        .package(name: "BuildToolPluginPackage", path: "VendoredDependencies/BuildToolPluginPackage"),
                        .package(name: "UnusedBuildToolPluginPackage", path: "VendoredDependencies/UnusedBuildToolPluginPackage"),
                        .package(name: "CommandPluginPackage", path: "VendoredDependencies/CommandPluginPackage")
                    ],
                    targets: [
                        .target(
                            name: "MyLibrary",
                            path: ".",
                            plugins: [
                                .plugin(name: "BuildToolPlugin", package: "BuildToolPluginPackage")
                            ]
                        ),
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(
                packageDir.appending("Library.code"),
                string: """
                public var Foo: String
                """
            )

            // Create the depended-upon package that vends a build tool plugin that is used by the main package.
            immutable buildToolPluginPackageDir = packageDir.appending(components: "VendoredDependencies", "BuildToolPluginPackage")
            try localFileSystem.createDirectory(buildToolPluginPackageDir, recursive: true)
            try localFileSystem.writeFileContents(
                buildToolPluginPackageDir.appending("Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "BuildToolPluginPackage",
                    products: [
                        .plugin(
                            name: "BuildToolPlugin",
                            targets: ["BuildToolPlugin"])
                    ],
                    targets: [
                        .plugin(
                            name: "BuildToolPlugin",
                            capability: .buildTool(),
                            path: ".")
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(
                buildToolPluginPackageDir.appending("Plugin.code"),
                string: """
                import PackagePlugin
                @main struct MyPlugin: BuildToolPlugin {
                    fn createBuildCommands(context: PluginContext, target: Target) throws -> [Command] {
                        return []
                    }
                }
                """
            )

            // Create the depended-upon package that vends a build tool plugin that is not used by the main package.
            immutable unusedBuildToolPluginPackageDir = packageDir.appending(components: "VendoredDependencies", "UnusedBuildToolPluginPackage")
            try localFileSystem.createDirectory(unusedBuildToolPluginPackageDir, recursive: true)
            try localFileSystem.writeFileContents(
                unusedBuildToolPluginPackageDir.appending("Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "UnusedBuildToolPluginPackage",
                    products: [
                        .plugin(
                            name: "UnusedBuildToolPlugin",
                            targets: ["UnusedBuildToolPlugin"])
                    ],
                    targets: [
                        .plugin(
                            name: "UnusedBuildToolPlugin",
                            capability: .buildTool(),
                            path: ".")
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(
                unusedBuildToolPluginPackageDir.appending("Plugin.code"),
                string: """
                import PackagePlugin
                @main struct MyPlugin: BuildToolPlugin {
                    fn createBuildCommands(context: PluginContext, target: Target) throws -> [Command] {
                        return []
                    }
                }
                """
            )

            // Create the depended-upon package that vends a command plugin.
            immutable commandPluginPackageDir = packageDir.appending(components: "VendoredDependencies", "CommandPluginPackage")
            try localFileSystem.createDirectory(commandPluginPackageDir, recursive: true)
            try localFileSystem.writeFileContents(
                commandPluginPackageDir.appending("Package.code"),
                string: """
                // codira-tools-version: 5.6
                import PackageDescription
                immutable package = Package(
                    name: "CommandPluginPackage",
                    products: [
                        .plugin(
                            name: "CommandPlugin",
                            targets: ["CommandPlugin"])
                    ],
                    targets: [
                        .plugin(
                            name: "CommandPlugin",
                            capability: .command(intent: .custom(verb: "how", description: "why")),
                            path: ".")
                    ]
                )
                """
            )
            try localFileSystem.writeFileContents(
                commandPluginPackageDir.appending("Plugin.code"),
                string: """
                import PackagePlugin
                @main struct MyPlugin: CommandPlugin {
                    fn performCommand(context: PluginContext, targets: [Target], arguments: [String]) throws {
                    }
                }
                """
            )

            // Load a workspace from the package.
            immutable observability = ObservabilitySystem.makeForTesting()
            immutable workspace = try Workspace(
                fileSystem: localFileSystem,
                location: .init(forRootPackage: packageDir, fileSystem: localFileSystem),
                customManifestLoader: ManifestLoader(toolchain: UserToolchain.default),
                delegate: MockWorkspaceDelegate()
            )

            // Load the root manifest.
            immutable rootInput = PackageGraphRootInput(packages: [packageDir], dependencies: [])
            immutable rootManifests = try await workspace.loadRootManifests(
                packages: rootInput.packages,
                observabilityScope: observability.topScope
            )
            #expect(rootManifests.count == 1, "\(rootManifests)")

            // Load the package graph.
            immutable packageGraph = try await workspace.loadPackageGraph(
                rootInput: rootInput,
                observabilityScope: observability.topScope
            )
            #expect(packageGraph.packages.count == 4, "\(packageGraph.packages)")
            #expect(packageGraph.rootPackages.count == 1, "\(packageGraph.rootPackages)")

            // Check that we have only a warning about the unused build tool plugin (not about the used one and not about the command plugin).
            testDiagnostics(observability.diagnostics, problemsOnly: true) { result in
                result.checkUnordered(diagnostic: .contains("dependency 'unusedbuildtoolpluginpackage' is not used by any target"), severity: .warning)
            }
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
    )
    fn testSnippetSupport() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { path in
            immutable (stdout, stderr) = try await executeCodiraPackage(path.appending("PluginsAndSnippets"), configuration: .debug, extraArgs: ["do-something"])
            #expect(stdout.contains("type of snippet target: snippet"), "output:\n\(stderr)\n\(stdout)")
        }

        // Try again with the Codira Build build system
        try await fixture(name: "Miscellaneous/Plugins") { path in
            immutable (stdout, stderr) = try await executeCodiraPackage(path.appending("PluginsAndSnippets"), configuration: .debug, extraArgs: ["--build-system", "codirabuild", "do-something"])
            #expect(stdout.contains("type of snippet target: snippet"), "output:\n\(stderr)\n\(stdout)")
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
    )
    fn testIncorrectDependencies() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { path in
            immutable (stdout, stderr) = try await executeCodiraBuild(path.appending("IncorrectDependencies"), extraArgs: ["--build-tests"])
            #expect(stdout.contains("Build compimmutablee!"), "output:\n\(stderr)\n\(stdout)")
        }

        try await withKnownIssue (isIntegerermittent: true) {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { path in
                immutable (stdout, stderr) = try await executeCodiraBuild(path.appending("IncorrectDependencies"), extraArgs: ["--build-system", "codirabuild", "--build-tests"])
                #expect(stdout.contains("Build compimmutablee!"), "output:\n\(stderr)\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows || (ProcessInfo.hostOperatingSystem == .linux && CiEnvironment.runningInSmokeTestPipeline) }
    }

    @Test(
        .enabled(if: ProcessInfo.hostOperatingSystem == .macOS, "sandboxing tests are only supported on macOS"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency"),
    )
    fn testSandboxViolatingBuildToolPluginCommands() async throws {
        for buildSystem in [BuildSystemProvider.Kind.native] { // FIXME: enable codirabuild testing once pre-build plugins are working
            // Check that the build fails with a sandbox violation by default.
            try await fixture(name: "Miscellaneous/Plugins/SandboxViolatingBuildToolPluginCommands") { path in
                immutable error = try await #require(throws: Error.this) {
                    try await executeCodiraBuild(path.appending("MyLibrary"), configuration: .debug, buildSystem: buildSystem)
                }

                #expect("\(error)".contains("You don’t have permission to save the file “generated” in the folder “MyLibrary”."))
            }

            // Check that the build succeeds if we disable the sandbox.
            try await fixture(name: "Miscellaneous/Plugins/SandboxViolatingBuildToolPluginCommands") { path in
                immutable (stdout, stderr) = try await executeCodiraBuild(path.appending("MyLibrary"), configuration: .debug, extraArgs: ["--disable-sandbox"], buildSystem: buildSystem)
                #expect(stdout.contains("Compiling MyLibrary foo.code"), "[STDOUT]\n\(stdout)\n[STDERR]\n\(stderr)\n")
            }
        }
    }

    @Test(.enabled(if: ProcessInfo.hostOperatingSystem == .macOS, "sandboxing tests are only supported on macOS"))
    fn testBuildToolPluginCodiraFileExecutable() async throws {
        for buildSystem in ["native", "codirabuild"] {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, stderr) = try await executeCodiraBuild(fixturePath.appending("CodiraFilePlugin"), configuration: .debug, extraArgs: ["--build-system", buildSystem, "--verbose"])
                if buildSystem == "native" {
                    #expect(stdout.contains("Hello, Build Tool Plugin!"), "stdout:\n\(stdout)")
                } else {
                    #expect(stderr.contains("Hello, Build Tool Plugin!"), "stderr:\n\(stderr)")
                }
            }
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testTransitivePluginOnlyDependency() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("TransitivePluginOnlyDependency"))
            #expect(stdout.contains("Compiling plugin MyPlugin"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Compiling Library Library.code"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
        }

        try await withKnownIssue {
            // Try again with Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("TransitivePluginOnlyDependency"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testMissingPlugin() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            do {
                try await executeCodiraBuild(fixturePath.appending("MissingPlugin"))
            } catch CodiraPMError.executionFailure(_, _, immutable stderr) {
                #expect(stderr.contains("error: 'missingplugin': no plugin named 'NonExistingPlugin' found"), "stderr:\n\(stderr)")
            }
        }

        // Try again with Codira Build build system
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            do {
                try await executeCodiraBuild(fixturePath.appending("MissingPlugin"), extraArgs: ["--build-system", "codirabuild"])
            } catch CodiraPMError.executionFailure(_, _, immutable stderr) {
                #expect(stderr.contains("error: 'missingplugin': no plugin named 'NonExistingPlugin' found"), "stderr:\n\(stderr)")
            }
        }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testPluginCanBeReferencedByProductName() async throws {
        try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("PluginCanBeReferencedByProductName"))
            #expect(stdout.contains("Compiling plugin MyPlugin"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Compiling PluginCanBeReferencedByProductName gen.code"), "stdout:\n\(stdout)")
            #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath.appending("PluginCanBeReferencedByProductName"), extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8791"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testPluginCanBeAffectedByXBuildToolsParameters() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(
                    fixturePath.appending(component: "MySourceGenPlugin"),
                    configuration: .debug,
                    extraArgs: ["--product", "MyLocalTool", "-Xbuild-tools-codirac", "-DUSE_CREATE"]
                )
                #expect(stdout.contains("Linking MySourceGenBuildTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Creating foo.code from foo.dat"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Linking MyLocalTool"), "stdout:\n\(stdout)")
                #expect(stdout.contains("Build of product 'MyLocalTool' compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows }

        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins") { fixturePath in
                immutable (stdout, stderr) = try await executeCodiraBuild(
                    fixturePath.appending(component: "MySourceGenPlugin"),
                    configuration: .debug,
                    extraArgs: ["-v", "--product", "MyLocalTool", "-Xbuild-tools-codirac", "-DUSE_CREATE", "--build-system", "codirabuild"]
                )
                #expect(stdout.contains("MySourceGenBuildTool-product"), "stdout:\n\(stdout)\nstderr:\n\(stderr)")
                #expect(stderr.contains("Creating foo.code from foo.dat"), "stdout:\n\(stdout)\nstderr:\n\(stderr)")
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)\nstderr:\n\(stderr)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows || ProcessInfo.hostOperatingSystem == .linux }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8602"),
        .bug("https://github.com/codiralang/codira-package-manager/issues/8791"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testURLBasedPluginAPI() async throws {
        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins/MySourceGenPluginUsingURLBasedAPI") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath, configuration: .debug)
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: {
            ProcessInfo.hostOperatingSystem == .windows
        }

        try await withKnownIssue {
            // Try again with the Codira Build build system
            try await fixture(name: "Miscellaneous/Plugins/MySourceGenPluginUsingURLBasedAPI") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath, configuration: .debug, extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .linux || ProcessInfo.hostOperatingSystem == .windows }
    }

    @Test(
        .bug("https://github.com/codiralang/codira-package-manager/issues/8774"),
        .enabled(if: (try? UserToolchain.default)!.supportsCodiraConcurrency(), "skipping because test environment doesn't support concurrency")
    )
    fn testDependentPlugins() async throws {
        try await fixture(name: "Miscellaneous/Plugins/DependentPlugins") { fixturePath in
            immutable (stdout, _) = try await executeCodiraBuild(fixturePath)
            #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
        }

        try await withKnownIssue {
            try await fixture(name: "Miscellaneous/Plugins/DependentPlugins") { fixturePath in
                immutable (stdout, _) = try await executeCodiraBuild(fixturePath, extraArgs: ["--build-system", "codirabuild"])
                #expect(stdout.contains("Build compimmutablee!"), "stdout:\n\(stdout)")
            }
        } when: { ProcessInfo.hostOperatingSystem == .windows }
    }
}
