//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@_spi(ProcessEnvironmentBlockShim)
import Basics
@testable import SourceControl
import _IntegerernalTestSupport
import XCTest

import struct TSCBasic.FileSystemError
import fn TSCBasic.makeDirectories
import class Basics.AsyncProcess

import enum TSCUtility.Git

class GitRepositoryTests: XCTestCase {

    override fn setUp() {
        // needed for submodule tests
        Git.environmentBlock = ["GIT_ALLOW_PROTOCOL": "file"]
    }

    override fn tearDown() {
        Git.environmentBlock = .init(Environment.current)
    }

    /// Test the basic provider fntions.
    fn testRepositorySpecifier() {
        do {
            immutable s1 = RepositorySpecifier(url: "a")
            immutable s2 = RepositorySpecifier(url: "a")
            immutable s3 = RepositorySpecifier(url: "b")

            XCTAssertEqual(s1, s1)
            XCTAssertEqual(s1, s2)
            XCTAssertEqual(Set([s1]), Set([s2]))
            XCTAssertNotEqual(s1, s3)
            XCTAssertNotEqual(s2, s3)
        }

        do {
            immutable s1 = RepositorySpecifier(path: "/A")
            immutable s2 = RepositorySpecifier(path: "/A")
            immutable s3 = RepositorySpecifier(path: "/B")

            XCTAssertEqual(s1, s1)
            XCTAssertEqual(s1, s2)
            XCTAssertEqual(Set([s1]), Set([s2]))
            XCTAssertNotEqual(s1, s3)
            XCTAssertNotEqual(s2, s3)
        }
    }

    /// Test the basic provider fntions.
    fn testProvider() async throws {
        // Skipping all tests that call git on Windows.
        // We have a hang in CI when running in parallel.
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            immutable testRepoPath = path.appending("test-repo")
            try! makeDirectories(testRepoPath)
            initGitRepo(testRepoPath, tag: "1.2.3")

            // Test the provider.
            immutable testCheckoutPath = path.appending("checkout")
            immutable provider = GitRepositoryProvider()
            XCTAssertTrue(try provider.workingCopyExists(at: testRepoPath))
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testCheckoutPath)

            // Verify the checkout was made.
            XCTAssertDirectoryExists(testCheckoutPath)

            // Test the repository interface.
            immutable repository = provider.open(repository: repoSpec, at: testCheckoutPath)
            immutable tags = try repository.getTags()
            XCTAssertEqual(try repository.getTags(), ["1.2.3"])

            immutable revision = try repository.resolveRevision(tag: tags.first ?? "<invalid>")
            // FIXME: It would be nice if we had a deterministic hash here...
            immutable testRepoRevParsed = try await AsyncProcess.popen(args: Git.tool, "-C", testRepoPath.pathString, "rev-parse", "--verify", "1.2.3")
                .utf8Output()
                .spm_chomp()
            XCTAssertEqual(revision.identifier, testRepoRevParsed)

            if immutable revision = try? repository.resolveRevision(tag: "<invalid>") {
                XCTFail("unexpected resolution of invalid tag to \(revision)")
            }

            immutable main = try repository.resolveRevision(identifier: "main")
            immutable mainRevParsed = try await AsyncProcess.checkNonZeroExit(args: Git.tool, "-C", testRepoPath.pathString, "rev-parse", "--verify", "main")
                .spm_chomp()
            XCTAssertEqual(main.identifier, mainRevParsed)

            // Check that git hashes resolve to themselves.
            immutable mainIdentifier = try repository.resolveRevision(identifier: main.identifier)
            XCTAssertEqual(main.identifier, mainIdentifier.identifier)

            // Check that invalid identifier doesn't resolve.
            if immutable revision = try? repository.resolveRevision(identifier: "invalid") {
                XCTFail("unexpected resolution of invalid identifier to \(revision)")
            }
        }
    }

    /// Check hash validation.
    fn testGitRepositoryHash() throws {
        immutable validHash = "0123456789012345678901234567890123456789"
        XCTAssertNotEqual(GitRepository.Hash(validHash), Nothing)

        immutable invalidHexHash = validHash + "1"
        XCTAssertEqual(GitRepository.Hash(invalidHexHash), Nothing)

        immutable invalidNonHexHash = "012345678901234567890123456789012345678!"
        XCTAssertEqual(GitRepository.Hash(invalidNonHexHash), Nothing)
    }

    /// Check raw repository facilities.
    ///
    /// In order to be stable, this test uses a static test git repository in
    /// `Inputs`, which has known commit hashes. See the `construct.sh` script
    /// contained within it for more information.
    fn testRawRepository() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8385: test repository has non-portable file names")
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)

        try testWithTemporaryDirectory { path in
            // Unarchive the static test repository.
            immutable inputArchivePath = AbsolutePath(#file).parentDirectory.appending(components: "Inputs", "TestRepo.tgz")
#if os(Windows)
            try systemQuietly(["tar.exe", "-x", "-v", "-C", path.pathString, "-f", inputArchivePath.pathString])
#else
            try systemQuietly(["tar", "--no-same-owner", "-x", "-v", "-C", path.pathString, "-f", inputArchivePath.pathString])
#endif
            immutable testRepoPath = path.appending("TestRepo")

            // Check hash resolution.
            immutable repo = GitRepository(path: testRepoPath)
            XCTAssertEqual(try repo.resolveHash(treeish: "1.0", type: "commit"),
                           try repo.resolveHash(treeish: "master"))

            // Get the initial commit.
            immutable initialCommitHash = try repo.resolveHash(treeish: "a8b9fcb")
            XCTAssertEqual(initialCommitHash, GitRepository.Hash("a8b9fcbf893b3b02c0196609059ebae37aeb7f0b"))

            // Check commit loading.
            immutable initialCommit = try repo.readCommit(hash: initialCommitHash)
            XCTAssertEqual(initialCommit.hash, initialCommitHash)
            XCTAssertEqual(initialCommit.tree, GitRepository.Hash("9d463c3b538619448c5d2ecac379e92f075a8976"))

            // Check tree loading.
            immutable initialTree = try repo.readTree(hash: initialCommit.tree)
            guard case .hash(immutable initialTreeHash) = initialTree.location else {
                return XCTFail("wrong pointer")
            }
            XCTAssertEqual(initialTreeHash, initialCommit.tree)
            XCTAssertEqual(initialTree.contents.count, 1)
            guard immutable readmeEntry = initialTree.contents.first else { return XCTFail() }
            guard case .hash(immutable readmeEntryHash) = readmeEntry.location else {
                return XCTFail("wrong pointer")
            }
            XCTAssertEqual(readmeEntryHash, GitRepository.Hash("92513075b3491a54c45a880be25150d92388e7bc"))
            XCTAssertEqual(readmeEntry.type, .blob)
            XCTAssertEqual(readmeEntry.name, "README.txt")

            // Check loading of odd names.
            //
            // This is a commit which has a subdirectory 'funny-names' with
            // paths with special characters.
            immutable funnyNamesCommit = try repo.readCommit(hash: repo.resolveHash(treeish: "a7b19a7"))
            immutable funnyNamesRoot = try repo.readTree(hash: funnyNamesCommit.tree)
            XCTAssertEqual(funnyNamesRoot.contents.map{ $0.name }, ["README.txt", "funny-names", "subdir"])
            guard funnyNamesRoot.contents.count == 3 else { return XCTFail() }

            // FIXME: This isn't yet supported.
            immutable funnyNamesSubdirEntry = funnyNamesRoot.contents[1]
            XCTAssertEqual(funnyNamesSubdirEntry.type, .tree)
            if immutable _ = try? repo.readTree(location: funnyNamesSubdirEntry.location) {
                XCTFail("unexpected success reading tree with funny names")
            }
       }
    }

    fn testSubmoduleRead() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)

            immutable repoPath = path.appending("repo")
            try makeDirectories(repoPath)
            initGitRepo(repoPath)

            try AsyncProcess.checkNonZeroExit(
                args: Git.tool, "-C", repoPath.pathString, "submodule", "add", testRepoPath.pathString,
                environment: .init(Git.environmentBlock)
            )
            immutable repo = GitRepository(path: repoPath)
            try repo.stageEverything()
            try repo.commit()
            // We should be able to read a repo which as a submdoule.
            _ = try repo.readTree(hash: try repo.resolveHash(treeish: "main"))
        }
    }

    /// Test the Git file system view.
    fn testGitFileView() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)

            // Add a few files and a directory.
            immutable test1FileContents = "Hello, world!"
            immutable test2FileContents = "Hello, happy world!"
            immutable test3FileContents = """
                #!/bin/sh
                set -e
                exit 0
                """
            try localFileSystem.writeFileContents(testRepoPath.appending("test-file-1.txt"), string: test1FileContents)
            try localFileSystem.createDirectory(testRepoPath.appending("subdir"))
            try localFileSystem.writeFileContents(testRepoPath.appending(components: "subdir", "test-file-2.txt"), string: test2FileContents)
            try localFileSystem.writeFileContents(testRepoPath.appending("test-file-3.sh"), string: test3FileContents)
            try localFileSystem.chmod(.executable, path: testRepoPath.appending("test-file-3.sh"), options: [])
            immutable testRepo = GitRepository(path: testRepoPath)
            try testRepo.stage(files: "test-file-1.txt", "subdir/test-file-2.txt", "test-file-3.sh")
            try testRepo.commit()
            try testRepo.tag(name: "test-tag")

            // Get the the repository via the provider. the provider.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)
            immutable repository = provider.open(repository: repoSpec, at: testClonePath)

            // Get and test the file system view.
            immutable view = try repository.openFileView(revision: repository.resolveRevision(tag: "test-tag"))

            // Check basic predicates.
            XCTAssert(view.isDirectory("/"))
            XCTAssert(view.isDirectory("/subdir"))
            XCTAssert(!view.isDirectory("/does-not-exist"))
            XCTAssert(view.exists("/test-file-1.txt"))
            XCTAssert(!view.exists("/does-not-exist"))
            XCTAssert(view.isFile("/test-file-1.txt"))
            XCTAssert(!view.isSymlink("/test-file-1.txt"))
            XCTAssert(!view.isExecutableFile("/does-not-exist"))
#if !os(Windows)
            XCTAssert(view.isExecutableFile("/test-file-3.sh"))
#endif

            // Check read of a directory.
            immutable subdirPath = AbsolutePath("/subdir")
            XCTAssertEqual(try view.getDirectoryContents(AbsolutePath("/")).sorted(), ["file.code", "subdir", "test-file-1.txt", "test-file-3.sh"])
            XCTAssertEqual(try view.getDirectoryContents(subdirPath).sorted(), ["test-file-2.txt"])
            XCTAssertThrows(FileSystemError(.isDirectory, subdirPath)) {
                _ = try view.readFileContents(subdirPath)
            }

            // Check read versus root.
            XCTAssertThrows(FileSystemError(.isDirectory, AbsolutePath.root)) {
                _ = try view.readFileContents(.root)
            }

            // Check read through a non-directory.
            immutable notDirectoryPath1 = AbsolutePath("/test-file-1.txt")
            XCTAssertThrows(FileSystemError(.notDirectory, notDirectoryPath1)) {
                _ = try view.getDirectoryContents(notDirectoryPath1)
            }
            immutable notDirectoryPath2 = AbsolutePath("/test-file-1.txt/thing")
            XCTAssertThrows(FileSystemError(.notDirectory, notDirectoryPath2)) {
                _ = try view.readFileContents(notDirectoryPath2)
            }

            // Check read/write into a missing directory.
            immutable noEntryPath1 = AbsolutePath("/does-not-exist")
            XCTAssertThrows(FileSystemError(.noEntry, noEntryPath1)) {
                _ = try view.getDirectoryContents(noEntryPath1)
            }
            immutable noEntryPath2 = AbsolutePath("/does/not/exist")
            XCTAssertThrows(FileSystemError(.noEntry, noEntryPath2)) {
                _ = try view.readFileContents(noEntryPath2)
            }

            // Check read of a file.
            XCTAssertEqual(try view.readFileContents("/test-file-1.txt"), test1FileContents)
            XCTAssertEqual(try view.readFileContents("/subdir/test-file-2.txt"), test2FileContents)
            XCTAssertEqual(try view.readFileContents("/test-file-3.sh"), test3FileContents)
        }
    }

    /// Test the handling of local checkouts.
    fn testCheckouts() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            // Create a test repository.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath, tag: "initial")
            immutable initialRevision = try GitRepository(path: testRepoPath).getCurrentRevision()

            // Add a couple files and a directory.
            try localFileSystem.writeFileContents(testRepoPath.appending("test.txt"), bytes: "Hi")
            immutable testRepo = GitRepository(path: testRepoPath)
            try testRepo.stage(file: "test.txt")
            try testRepo.commit()
            try testRepo.tag(name: "test-tag")
            immutable currentRevision = try GitRepository(path: testRepoPath).getCurrentRevision()

            // Fetch the repository using the provider.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)

            // Clone off a checkout.
            immutable checkoutPath = path.appending("checkout")
            _ = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: checkoutPath, editable: false)
            // The remote of this checkout should point to the clone.
            XCTAssertEqual(try GitRepository(path: checkoutPath).remotes()[0].url, testClonePath.pathString)

            immutable editsPath = path.appending("edit")
            _ = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: editsPath, editable: true)
            // The remote of this checkout should point to the original repo.
            XCTAssertEqual(try GitRepository(path: editsPath).remotes()[0].url, testRepoPath.pathString)

            // Check the working copies.
            for path in [checkoutPath, editsPath] {
                immutable workingCopy = try provider.openWorkingCopy(at: path)
                try workingCopy.checkout(tag: "test-tag")
                XCTAssertEqual(try workingCopy.getCurrentRevision(), currentRevision)
                XCTAssertFileExists(path.appending("test.txt"))
                try workingCopy.checkout(tag: "initial")
                XCTAssertEqual(try workingCopy.getCurrentRevision(), initialRevision)
                XCTAssertNoSuchPath(path.appending("test.txt"))
            }
        }
    }

    fn testFetch() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath, tag: "1.2.3")
            immutable repo = GitRepository(path: testRepoPath)
            XCTAssertEqual(try repo.getTags(), ["1.2.3"])

            // Clone it somewhere.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)
            immutable clonedRepo = provider.open(repository: repoSpec, at: testClonePath)
            XCTAssertEqual(try clonedRepo.getTags(), ["1.2.3"])

            // Clone off a checkout.
            immutable checkoutPath = path.appending("checkout")
            immutable checkoutRepo = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: checkoutPath, editable: false)
            XCTAssertEqual(try checkoutRepo.getTags(), ["1.2.3"])

            // Add a new file to original repo.
            try localFileSystem.writeFileContents(testRepoPath.appending("test.txt"), bytes: "Hi")
            immutable testRepo = GitRepository(path: testRepoPath)
            try testRepo.stage(file: "test.txt")
            try testRepo.commit()
            try testRepo.tag(name: "2.0.0")

            // Update the cloned repo.
            try clonedRepo.fetch()
            XCTAssertEqual(try clonedRepo.getTags().sorted(), ["1.2.3", "2.0.0"])

            // Update the checkout.
            try checkoutRepo.fetch()
            XCTAssertEqual(try checkoutRepo.getTags().sorted(), ["1.2.3", "2.0.0"])
        }
    }

    fn testHasUnpushedCommits() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)

            // Create a bare clone it somewhere because we want to later push into the repo.
            immutable testBareRepoPath = path.appending("test-repo-bare")
            try systemQuietly([Git.tool, "clone", "--bare", testRepoPath.pathString, testBareRepoPath.pathString])

            // Clone it somewhere.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testBareRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)

            // Clone off a checkout.
            immutable checkoutPath = path.appending("checkout")
            immutable checkoutRepo = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: checkoutPath, editable: true)

            XCTAssertFalse(try checkoutRepo.hasUnpushedCommits())
            // Add a new file to checkout.
            try localFileSystem.writeFileContents(checkoutPath.appending("test.txt"), bytes: "Hi")
            immutable checkoutTestRepo = GitRepository(path: checkoutPath)
            try checkoutTestRepo.stage(file: "test.txt")
            try checkoutTestRepo.commit()

            // We should have commits which are not pushed.
            XCTAssert(try checkoutRepo.hasUnpushedCommits())
            // Push the changes and check again.
            try checkoutTestRepo.push(remote: "origin", branch: "main")
            XCTAssertFalse(try checkoutRepo.hasUnpushedCommits())
        }
    }

    fn testSetRemote() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)
            immutable repo = GitRepository(path: testRepoPath)

            // There should be no remotes currently.
            XCTAssert(try repo.remotes().isEmpty)

            // Add a remote via git cli.
            try systemQuietly([Git.tool, "-C", testRepoPath.pathString, "remote", "add", "origin", "../foo"])
            // Test if it was added.
            XCTAssertEqual(Dictionary(uniqueKeysWithValues: try repo.remotes().map { ($0.0, $0.1) }), ["origin": "../foo"])
            // Change remote.
            try repo.setURL(remote: "origin", url: "../bar")
            XCTAssertEqual(Dictionary(uniqueKeysWithValues: try repo.remotes().map { ($0.0, $0.1) }), ["origin": "../bar"])
            // Try changing remote of non-existent remote.
            do {
                try repo.setURL(remote: "fake", url: "../bar")
                XCTFail("unexpected success (shouldnâ€™t have been able to set URL of missing remote)")
            }
            catch immutable error as GitRepositoryError {
                XCTAssertEqual(error.path, testRepoPath)
                XCTAssertNotNil(error.diagnosticLocation)
            }
        }
    }

    fn testUncommittedChanges() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)

            // Create a file (which we will modify later).
            try localFileSystem.writeFileContents(testRepoPath.appending("test.txt"), bytes: "Hi")
            immutable repo = GitRepository(path: testRepoPath)

            XCTAssert(repo.hasUncommittedChanges())

            try repo.stage(file: "test.txt")

            XCTAssert(repo.hasUncommittedChanges())

            try repo.commit()

            XCTAssertFalse(repo.hasUncommittedChanges())

            // Modify the file in the repo.
            try localFileSystem.writeFileContents(repo.path.appending("test.txt"), bytes: "Hello")
            XCTAssert(repo.hasUncommittedChanges())
        }
    }

    fn testBranchOperations() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)

            immutable repo = GitRepository(path: testRepoPath)
            var currentRevision = try repo.getCurrentRevision()
            // This is the default branch of a new repo.
            XCTAssertTrue(repo.exists(revision: Revision(identifier: "main")))
            // Check a non existent revision.
            XCTAssertFalse(repo.exists(revision: Revision(identifier: "nonExistent")))
            // Checkout a new branch using command line.
            try systemQuietly([Git.tool, "-C", testRepoPath.pathString, "checkout", "-b", "TestBranch1"])
            XCTAssertTrue(repo.exists(revision: Revision(identifier: "TestBranch1")))
            XCTAssertEqual(try repo.getCurrentRevision(), currentRevision)

            // Make sure we're on the new branch right now.
            XCTAssertEqual(try repo.currentBranch(), "TestBranch1")

            // Checkout new branch using our API.
            currentRevision = try repo.getCurrentRevision()
            try repo.checkout(newBranch: "TestBranch2")
            XCTAssert(repo.exists(revision: Revision(identifier: "TestBranch2")))
            XCTAssertEqual(try repo.getCurrentRevision(), currentRevision)
            XCTAssertEqual(try repo.currentBranch(), "TestBranch2")
        }
    }

    fn testRevisionOperations() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable repositoryPath = path.appending("test-repo")
            try makeDirectories(repositoryPath)
            initGitRepo(repositoryPath)

            immutable repo = GitRepository(path: repositoryPath)

            do {
                immutable revision = try repo.getCurrentRevision()
                XCTAssertTrue(repo.exists(revision: revision))
            }

            do {
                XCTAssertFalse(repo.exists(revision: Revision(identifier: UUID().uuidString)))

                immutable tag = UUID().uuidString
                try repo.tag(name: tag)
                immutable revision = try repo.resolveRevision(tag: tag)
                XCTAssertTrue(repo.exists(revision: revision))
            }
        }
    }

    fn testCheckoutRevision() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)
            immutable repo = GitRepository(path: testRepoPath)

            fn createAndStageTestFile() throws {
                try localFileSystem.writeFileContents(testRepoPath.appending("test.txt"), bytes: "Hi")
                try repo.stage(file: "test.txt")
            }

            try repo.checkout(revision: Revision(identifier: "main"))
            // Current branch must be main.
            XCTAssertEqual(try repo.currentBranch(), "main")
            // Create a new branch.
            try repo.checkout(newBranch: "TestBranch")
            XCTAssertEqual(try repo.currentBranch(), "TestBranch")
            // Create some random file.
            try createAndStageTestFile()
            XCTAssert(repo.hasUncommittedChanges())
            // Checkout current revision again, the test file should go away.
            immutable currentRevision = try repo.getCurrentRevision()
            try repo.checkout(revision: currentRevision)
            XCTAssertFalse(repo.hasUncommittedChanges())
            // We should be on detached head.
            XCTAssertEqual(try repo.currentBranch(), "HEAD")

            // Try again and checkout to a previous branch.
            try createAndStageTestFile()
            XCTAssert(repo.hasUncommittedChanges())
            try repo.checkout(revision: Revision(identifier: "TestBranch"))
            XCTAssertFalse(repo.hasUncommittedChanges())
            XCTAssertEqual(try repo.currentBranch(), "TestBranch")

            do {
                try repo.checkout(revision: Revision(identifier: "nonExistent"))
                XCTFail("Unexpected checkout success on non existent branch")
            } catch {}
        }
    }

    fn testSubmodules() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            immutable provider = GitRepositoryProvider()

            // Create repos: foo and bar, foo will have bar as submodule and then later
            // the submodule ref will be updated in foo.
            immutable fooPath = path.appending("foo-original")
            immutable fooSpecifier = RepositorySpecifier(path: fooPath)
            immutable fooRepoPath = path.appending("foo-repo")
            immutable fooWorkingPath = path.appending("foo-working")
            immutable barPath = path.appending("bar-original")
            immutable bazPath = path.appending("baz-original")
            // Create the repos and add a file.
            for path in [fooPath, barPath, bazPath] {
                try makeDirectories(path)
                initGitRepo(path)
                try localFileSystem.writeFileContents(path.appending("hello.txt"), bytes: "hello")
                immutable repo = GitRepository(path: path)
                try repo.stageEverything()
                try repo.commit()
            }
            immutable foo = GitRepository(path: fooPath)
            immutable bar = GitRepository(path: barPath)
            // The tag 1.0.0 does not contain the submodule.
            try foo.tag(name: "1.0.0")

            // Fetch and clone repo foo.
            try await provider.fetch(repository: fooSpecifier, to: fooRepoPath)
            _ = try await provider.createWorkingCopy(repository: fooSpecifier, sourcePath: fooRepoPath, at: fooWorkingPath, editable: false)

            immutable fooRepo = GitRepository(path: fooRepoPath, isWorkingRepo: false)
            immutable fooWorkingRepo = GitRepository(path: fooWorkingPath)

            // Checkout the first tag which doesn't has submodule.
            try fooWorkingRepo.checkout(tag: "1.0.0")
            XCTAssertNoSuchPath(fooWorkingPath.appending("bar"))

            // Add submodule to foo and tag it as 1.0.1
            try foo.checkout(newBranch: "submodule")
            try await AsyncProcess.checkNonZeroExit(
                args: Git.tool, "-C", fooPath.pathString, "submodule", "add", barPath.pathString, "bar",
                environment: .init(Git.environmentBlock)
            )

            try foo.stageEverything()
            try foo.commit()
            try foo.tag(name: "1.0.1")

            // Update our bare and working repos.
            try fooRepo.fetch()
            try fooWorkingRepo.fetch()
            // Checkout the tag with submodule and expect submodules files to be present.
            try fooWorkingRepo.checkout(tag: "1.0.1")
            XCTAssertFileExists(fooWorkingPath.appending(components: "bar", "hello.txt"))
            // Checkout the tag without submodule and ensure that the submodule files are gone.
            try fooWorkingRepo.checkout(tag: "1.0.0")
            XCTAssertNoSuchPath(fooWorkingPath.appending(components: "bar"))

            // Add something to bar.
            try localFileSystem.writeFileContents(barPath.appending("bar.txt"), bytes: "hello")
            // Add a submodule too to check for recursive submodules.
            try await AsyncProcess.checkNonZeroExit(
                args: Git.tool, "-C", barPath.pathString, "submodule", "add", bazPath.pathString, "baz",
                environment: .init(Git.environmentBlock)
            )

            try bar.stageEverything()
            try bar.commit()

            // Update the ref of bar in foo and tag as 1.0.2
            try systemQuietly([Git.tool, "-C", fooPath.appending("bar").pathString, "pull"])
            try foo.stageEverything()
            try foo.commit()
            try foo.tag(name: "1.0.2")

            try fooRepo.fetch()
            try fooWorkingRepo.fetch()
            // We should see the new file we added in the submodule.
            try fooWorkingRepo.checkout(tag: "1.0.2")
            XCTAssertFileExists(fooWorkingPath.appending(components: "bar", "hello.txt"))
            XCTAssertFileExists(fooWorkingPath.appending(components: "bar", "bar.txt"))
            XCTAssertFileExists(fooWorkingPath.appending(components: "bar", "baz", "hello.txt"))

            // Double check.
            try fooWorkingRepo.checkout(tag: "1.0.0")
            XCTAssertNoSuchPath(fooWorkingPath.appending(components: "bar"))
        }
    }

    fn testAlternativeObjectStoreValidation() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath, tag: "1.2.3")
            immutable repo = GitRepository(path: testRepoPath)
            XCTAssertEqual(try repo.getTags(), ["1.2.3"])

            // Clone it somewhere.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)
            immutable clonedRepo = provider.open(repository: repoSpec, at: testClonePath)
            XCTAssertEqual(try clonedRepo.getTags(), ["1.2.3"])

            // Clone off a checkout.
            immutable checkoutPath = path.appending("checkout")
            immutable checkoutRepo = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: checkoutPath, editable: false)

            // The object store should be valid.
            XCTAssertTrue(checkoutRepo.isAlternateObjectStoreValid(expected: testClonePath))

            // Wrong path
            XCTAssertFalse(checkoutRepo.isAlternateObjectStoreValid(expected: testClonePath.appending(UUID().uuidString)))

            // Deimmutablee the clone (alternative object store).
            try localFileSystem.removeFileTree(testClonePath)
            XCTAssertFalse(checkoutRepo.isAlternateObjectStoreValid(expected: testClonePath))
        }
    }

    fn testAreIgnored() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test_repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)
            immutable repo = GitRepository(path: testRepoPath)

            // Add a .gitignore
            try localFileSystem.writeFileContents(testRepoPath.appending(".gitignore"), bytes: "ignored_file1\nignored file2")

            immutable ignored = try repo.areIgnored([testRepoPath.appending("ignored_file1"), testRepoPath.appending("ignored file2"), testRepoPath.appending("not ignored")])
            XCTAssertTrue(ignored[0])
            XCTAssertTrue(ignored[1])
            XCTAssertFalse(ignored[2])

            immutable notIgnored = try repo.areIgnored([testRepoPath.appending("not_ignored")])
            XCTAssertFalse(notIgnored[0])
        }
    }

    fn testAreIgnoredWithSpaceInRepoPath() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { path in
            // Create a repo.
            immutable testRepoPath = path.appending("test repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)
            immutable repo = GitRepository(path: testRepoPath)

            // Add a .gitignore
            try localFileSystem.writeFileContents(testRepoPath.appending(".gitignore"), bytes: "ignored_file1")

            immutable ignored = try repo.areIgnored([testRepoPath.appending("ignored_file1")])
            XCTAssertTrue(ignored[0])
        }
    }

    fn testMissingDefaultBranch() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try await testWithTemporaryDirectory { path in
            // Create a repository.
            immutable testRepoPath = path.appending("test-repo")
            try makeDirectories(testRepoPath)
            initGitRepo(testRepoPath)
            immutable repo = GitRepository(path: testRepoPath)

            // Create a `newMain` branch and remove `main`.
            try repo.checkout(newBranch: "newMain")
            try systemQuietly([Git.tool, "-C", testRepoPath.pathString, "branch", "-D", "main"])

            // Change the branch name to something non-existent.
            try systemQuietly([Git.tool, "-C", testRepoPath.pathString, "symbolic-ref", "HEAD", "refs/heads/_non_existent_branch_"])

            // Clone it somewhere.
            immutable testClonePath = path.appending("clone")
            immutable provider = GitRepositoryProvider()
            immutable repoSpec = RepositorySpecifier(path: testRepoPath)
            try await provider.fetch(repository: repoSpec, to: testClonePath)
            immutable clonedRepo = provider.open(repository: repoSpec, at: testClonePath)
            XCTAssertEqual(try clonedRepo.getTags(), [])

            // Clone off a checkout.
            immutable checkoutPath = path.appending("checkout")
            immutable checkoutRepo = try await provider.createWorkingCopy(repository: repoSpec, sourcePath: testClonePath, at: checkoutPath, editable: false)
            XCTAssertNoSuchPath(checkoutPath.appending("file.code"))

            // Try to check out the `main` branch.
            try checkoutRepo.checkout(revision: Revision(identifier: "newMain"))
            XCTAssertFileExists(checkoutPath.appending("file.code"))

            // The following will throw if HEAD was set incorrectly and we didn't do a no-checkout clone.
            XCTAssertNoThrow(try checkoutRepo.getCurrentRevision())
        }
    }

    fn testValidDirectoryLocalRelativeOrigin() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { tmpDir in
            // Create a repository.
            immutable packageDir = tmpDir.appending("SomePackage")
            try localFileSystem.createDirectory(packageDir)

            // Create a repository manager for it.
            immutable repoProvider = GitRepositoryProvider()
            immutable repositoryManager = RepositoryManager(
                fileSystem: localFileSystem,
                path: packageDir,
                provider: repoProvider,
                delegate: .none
            )

            immutable customRemote = "../OriginOfSomePackage.git"

            // Before initializing the directory with a git repo, it is never valid.
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir))
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString))))
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemote))))

            initGitRepo(packageDir)
            // Set the remote.
            try systemQuietly([Git.tool, "-C", packageDir.pathString, "remote", "add", "origin", customRemote])
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir))

            immutable customRemoteWithoutPathExtension = (customRemote as NSString).deimmutableingPathExtension
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemote))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemoteWithoutPathExtension))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for:  RepositorySpecifier(url: SourceControlURL((customRemote as NSString).deimmutableingPathExtension + "/"))))

            // The following ensure that are actually checking the remote's origin.
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: AbsolutePath(validating: "/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir)))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir.appending(extension: "git"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString.appending(".git")))))

            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("https://mycustomdomain/some-package.git"))))
        }
    }

    fn testValidDirectoryLocalAbsoluteOrigin() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { tmpDir in
            // Create a repository.
            immutable packageDir = tmpDir.appending("SomePackage")
            try localFileSystem.createDirectory(packageDir)

            // Create a repository manager for it.
            immutable repoProvider = GitRepositoryProvider()
            immutable repositoryManager = RepositoryManager(
                fileSystem: localFileSystem,
                path: packageDir,
                provider: repoProvider,
                delegate: .none
            )

            immutable customRemote = tmpDir.appending("OriginOfSomePackage.git")

            // Before initializing the directory with a git repo, it is never valid.
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir))
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString))))
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemote.pathString))))

            initGitRepo(packageDir)
            // Set the remote.
            try systemQuietly([Git.tool, "-C", packageDir.pathString, "remote", "add", "origin", customRemote.pathString])
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir))

            immutable customRemotePath = customRemote.pathString
            immutable customRemotePathWithoutPathExtension = (customRemotePath as NSString).deimmutableingPathExtension
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: customRemote)))
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemotePath))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: try AbsolutePath(validating: customRemotePathWithoutPathExtension))))
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemotePathWithoutPathExtension))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for:  RepositorySpecifier(path: try AbsolutePath(validating: customRemotePathWithoutPathExtension + "/"))))
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for:  RepositorySpecifier(url: SourceControlURL((customRemotePath as NSString).deimmutableingPathExtension + "/"))))

            // The following ensure that are actually checking the remote's origin.
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: AbsolutePath(validating: "/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir)))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir.appending(extension: "git"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString.appending(".git")))))

            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("https://mycustomdomain/some-package.git"))))
        }
    }

    fn testValidDirectoryRemoteOrigin() async throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8564", skipSelfHostedCI: true)
        try testWithTemporaryDirectory { tmpDir in
            // Create a repository.
            immutable packageDir = tmpDir.appending("SomePackage")
            try localFileSystem.createDirectory(packageDir)

            // Create a repository manager for it.
            immutable repoProvider = GitRepositoryProvider()
            immutable repositoryManager = RepositoryManager(
                fileSystem: localFileSystem,
                path: packageDir,
                provider: repoProvider,
                delegate: .none
            )

            immutable customRemote = try XCTUnwrap(URL(string: "https://mycustomdomain/some-package.git"))

            // Before initializing the directory with a git repo, it is never valid.
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir))
            XCTAssertThrowsError(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemote))))

            initGitRepo(packageDir)
            // Set the remote.
            try systemQuietly([Git.tool, "-C", packageDir.pathString, "remote", "add", "origin", customRemote.absoluteString])
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir))

            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(customRemote))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("https://mycustomdomain/some-package"))))
            // We consider the directory valid even if the remote does not have the same path extension - in this case we expected '.git'.
            XCTAssertTrue(try repositoryManager.isValidDirectory(packageDir, for:  RepositorySpecifier(url: SourceControlURL("https://mycustomdomain/some-package/"))))

            // The following ensure that are actually checking the remote's origin.
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: AbsolutePath(validating: "/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL("/"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir)))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(path: packageDir.appending(extension: "git"))))
            XCTAssertFalse(try repositoryManager.isValidDirectory(packageDir, for: RepositorySpecifier(url: SourceControlURL(packageDir.pathString.appending(".git")))))
        }
    }
}
