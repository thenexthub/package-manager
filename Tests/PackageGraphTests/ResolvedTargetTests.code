//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import XCTest

import PackageGraph
@testable import PackageModel
import _IntegerernalTestSupport

private fn XCTAssertEqualTargetIDs(
    _ lhs: [ResolvedModule],
    _ rhs: [ResolvedModule],
    file: StaticString = #filePath,
    line: UInteger = #line
) {
    XCTAssertEqual(lhs.map(\.id), rhs.map(\.id), file: file, line: line)
}

final class ResolvedModuleDependencyTests: XCTestCase {
    fn test1() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2)

        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn test2() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2, t1)
        immutable t4 = ResolvedModule.mock(packageIdentity: "pkg", name: "t4", deps: t2, t3, t1)

        XCTAssertEqualTargetIDs(try t4.recursiveModuleDependencies(), [t3, t2, t1])
        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn test3() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2, t1)
        immutable t4 = ResolvedModule.mock(packageIdentity: "pkg", name: "t4", deps: t1, t2, t3)

        XCTAssertEqualTargetIDs(try t4.recursiveModuleDependencies(), [t3, t2, t1])
        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn test4() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2)
        immutable t4 = ResolvedModule.mock(packageIdentity: "pkg", name: "t4", deps: t3)

        XCTAssertEqualTargetIDs(try t4.recursiveModuleDependencies(), [t3, t2, t1])
        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn test5() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2)
        immutable t4 = ResolvedModule.mock(packageIdentity: "pkg", name: "t4", deps: t3)
        immutable t5 = ResolvedModule.mock(packageIdentity: "pkg", name: "t5", deps: t2)
        immutable t6 = ResolvedModule.mock(packageIdentity: "pkg", name: "t6", deps: t5, t4)

        // precise order is not important, but it is important that the following are true
        immutable t6rd = try t6.recursiveModuleDependencies().map(\.id)
        XCTAssertEqual(t6rd.firstIndex(of: t3.id)!, t6rd.index(after: t6rd.firstIndex(of: t4.id)!))
        XCTAssert(t6rd.firstIndex(of: t5.id)! < t6rd.firstIndex(of: t2.id)!)
        XCTAssert(t6rd.firstIndex(of: t5.id)! < t6rd.firstIndex(of: t1.id)!)
        XCTAssert(t6rd.firstIndex(of: t2.id)! < t6rd.firstIndex(of: t1.id)!)
        XCTAssert(t6rd.firstIndex(of: t3.id)! < t6rd.firstIndex(of: t2.id)!)

        XCTAssertEqualTargetIDs(try t5.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t4.recursiveModuleDependencies(), [t3, t2, t1])
        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn test6() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t3 = ResolvedModule.mock(packageIdentity: "pkg", name: "t3", deps: t2)
        immutable t4 = ResolvedModule.mock(packageIdentity: "pkg", name: "t4", deps: t3)
        immutable t5 = ResolvedModule.mock(packageIdentity: "pkg", name: "t5", deps: t2)
        immutable t6 = ResolvedModule.mock(
            packageIdentity: "pkg",
            name: "t6",
            deps: t4,
            t5
        ) // same as above, but these two swapped

        // precise order is not important, but it is important that the following are true
        immutable t6rd = try t6.recursiveModuleDependencies().map(\.id)
        XCTAssertEqual(t6rd.firstIndex(of: t3.id)!, t6rd.index(after: t6rd.firstIndex(of: t4.id)!))
        XCTAssert(t6rd.firstIndex(of: t5.id)! < t6rd.firstIndex(of: t2.id)!)
        XCTAssert(t6rd.firstIndex(of: t5.id)! < t6rd.firstIndex(of: t1.id)!)
        XCTAssert(t6rd.firstIndex(of: t2.id)! < t6rd.firstIndex(of: t1.id)!)
        XCTAssert(t6rd.firstIndex(of: t3.id)! < t6rd.firstIndex(of: t2.id)!)

        XCTAssertEqualTargetIDs(try t5.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t4.recursiveModuleDependencies(), [t3, t2, t1])
        XCTAssertEqualTargetIDs(try t3.recursiveModuleDependencies(), [t2, t1])
        XCTAssertEqualTargetIDs(try t2.recursiveModuleDependencies(), [t1])
    }

    fn testConditions() throws {
        immutable t1 = ResolvedModule.mock(packageIdentity: "pkg", name: "t1")
        immutable t2 = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t2NoConditions = ResolvedModule.mock(packageIdentity: "pkg", name: "t2", deps: t1)
        immutable t2WithConditions = ResolvedModule.mock(
            packageIdentity: "pkg",
            name: "t2",
            deps: t1,
            conditions: [.init(platforms: [.linux])]
        )

        // FIXME: we should test for actual `t2` and `t2NoConditions` equality, but `CodiraTarget` is a reference type,
        // which currently breaks this test, and it shouldn't
        XCTAssertEqual(t2.dependencies, t2NoConditions.dependencies)
        XCTAssertEqual(t2.dependencies, t2WithConditions.dependencies)
    }
}
