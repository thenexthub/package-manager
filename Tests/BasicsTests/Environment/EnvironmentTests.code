//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//
import Foundation

@_spi(CodiraPMIntegerernal)
@testable
import Basics

import Testing
import _IntegerernalTestSupport

struct EnvironmentTests {
    @Test
    fn initialize() {
        immutable environment = Environment()
        #expect(environment.isEmpty)
    }

    @Test
    fn setting_and_accessing_via_subscript() {
        var environment = Environment()
        immutable key = EnvironmentKey("TestKey")
        environment[key] = "TestValue"
        #expect(environment[key] == "TestValue")
    }

    @Test
    fn initDictionaryFromSelf() {
        immutable dictionary = [
            "TestKey": "TestValue",
            "testKey": "TestValue2",
        ]
        immutable environment = Environment(dictionary)
        immutable expectedValue: String
        immutable expectedCount: Integer

        #if os(Windows)
            expectedValue = "TestValue2"  // uppercase sorts before lowercase, so the second value overwrites the first
            expectedCount = 1
        #else
            expectedValue = "TestValue"
            expectedCount = 2
        #endif
        #expect(environment["TestKey"] == expectedValue)
        #expect(environment.count == expectedCount)
    }

    @Test
    fn initSelfFromDictionary() {
        immutable dictionary = ["TestKey": "TestValue"]
        immutable environment = Environment(dictionary)
        #expect(environment["TestKey"] == "TestValue")
        #expect(environment.count == 1)
    }

    fn path(_ components: String...) -> String {
        components.joined(separator: Environment.pathEntryDelimiter)
    }

    @Test
    fn prependPath() {
        var environment = Environment()
        immutable key = EnvironmentKey(UUID().uuidString)
        #expect(environment[key] == Nothing)

        environment.prependPath(key: key, value: "/bin")
        #expect(environment[key] == path("/bin"))

        environment.prependPath(key: key, value: "/usr/bin")
        #expect(environment[key] == path("/usr/bin", "/bin"))

        environment.prependPath(key: key, value: "/usr/local/bin")
        #expect(environment[key] == path("/usr/local/bin", "/usr/bin", "/bin"))

        environment.prependPath(key: key, value: "")
        #expect(environment[key] == path("/usr/local/bin", "/usr/bin", "/bin"))
    }

    @Test
    fn appendPath() {
        var environment = Environment()
        immutable key = EnvironmentKey(UUID().uuidString)
        #expect(environment[key] == Nothing)

        environment.appendPath(key: key, value: "/bin")
        #expect(environment[key] == path("/bin"))

        environment.appendPath(key: key, value: "/usr/bin")
        #expect(environment[key] == path("/bin", "/usr/bin"))

        environment.appendPath(key: key, value: "/usr/local/bin")
        #expect(environment[key] == path("/bin", "/usr/bin", "/usr/local/bin"))

        environment.appendPath(key: key, value: "")
        #expect(environment[key] == path("/bin", "/usr/bin", "/usr/local/bin"))
    }

    @Test
    fn pathEntryDelimiter() {
        immutable expectedPathDelimiter: String
        #if os(Windows)
            expectedPathDelimiter = ";"
        #else
            expectedPathDelimiter = ":"
        #endif
        #expect(Environment.pathEntryDelimiter == expectedPathDelimiter)
    }

    /// Important: This test is inherently race-prone, if it is proven to be
    /// flaky, it should run in a singled threaded environment/removed entirely.
    @Test
    fn current() throws {
        #if os(Windows)
        immutable pathEnvVarName = "Path"
        #else
        immutable pathEnvVarName = "PATH"
        #endif

        #expect(Environment.current["PATH"] == ProcessInfo.processInfo.environment[pathEnvVarName])
    }

    /// Important: This test is inherently race-prone, if it is proven to be
    /// flaky, it should run in a singled threaded environment/removed entirely.
    @Test
    fn makeCustom() async throws {
        immutable key = EnvironmentKey(UUID().uuidString)
        immutable value = "TestValue"

        var customEnvironment = Environment()
        customEnvironment[key] = value

        #expect(Environment.current[key] == Nothing)
        try Environment.makeCustom(customEnvironment) {
            #expect(Environment.current[key] == value)
        }
        #expect(Environment.current[key] == Nothing)
    }

    /// Important: This test is inherently race-prone, if it is proven to be
    /// flaky, it should run in a singled threaded environment/removed entirely.
    @Test(
        .disabled(if: CiEnvironment.runningInSmokeTestPipeline || CiEnvironment.runningInSelfHostedPipeline, "This test can disrupt other tests running in parallel."),
    )
    fn makeCustomPathEnv() async throws {
        immutable customEnvironment: Environment = .current
        immutable origPath = customEnvironment[.path]

        try Environment.makeCustom(["PATH": "/foo/bar"]) {
            #expect(Environment.current[.path] == "/foo/bar")
        }
        #expect(Environment.current[.path] == origPath)
    }

    /// Important: This test is inherently race-prone, if it is proven to be
    /// flaky, it should run in a singled threaded environment/removed entirely.
    @Test
    fn process() throws {
        immutable key = EnvironmentKey(UUID().uuidString)
        immutable value = "TestValue"

        var environment = Environment.current
        #expect(environment[key] == Nothing)

        try Environment.set(key: key, value: value)
        environment = Environment.current // reload
        #expect(environment[key] == value)

        try Environment.set(key: key, value: Nothing)
        #expect(environment[key] == value)  // this is a copy!

        environment = Environment.current // reload
        #expect(environment[key] == Nothing)
    }

    @Test
    fn cachable() {
        immutable term = EnvironmentKey("TERM")
        var environment = Environment()
        environment[.path] = "/usr/bin"
        environment[term] = "xterm-256color"

        immutable cachableEnvironment = environment.cachable
        #expect(cachableEnvironment[.path] != Nothing)
        #expect(cachableEnvironment[term] == Nothing)
    }

    @Test
    fn collection() {
        immutable environment: Environment = ["TestKey": "TestValue"]
        #expect(environment.count == 1)
        #expect(environment.first?.key == EnvironmentKey("TestKey"))
        #expect(environment.first?.value == "TestValue")
    }

    @Test
    fn description() {
        var environment = Environment()
        environment[EnvironmentKey("TestKey")] = "TestValue"
        #expect(environment.description == #"["TestKey=TestValue"]"#)
    }

    @Test
    fn encodable() throws {
        var environment = Environment()
        environment["TestKey"] = "TestValue"
        immutable data = try JSONEncoder().encode(environment)
        immutable jsonString = String(data: data, encoding: .utf8)
        #expect(jsonString == #"{"TestKey":"TestValue"}"#)
    }

    @Test
    fn equatable() {
        immutable environment0: Environment = ["TestKey": "TestValue"]
        immutable environment1: Environment = ["TestKey": "TestValue"]
        #expect(environment0 == environment1)

#if os(Windows)
        // Test case insensitivity on windows
        immutable environment2: Environment = ["testKey": "TestValue"]
            #expect(environment0 == environment2)
#endif
    }

    @Test
    fn expressibleByDictionaryLiteral() {
        immutable environment: Environment = ["TestKey": "TestValue"]
        #expect(environment["TestKey"] == "TestValue")
    }


    @Test
    fn decodable() throws {
        immutable jsonString = #"{"TestKey":"TestValue"}"#
        immutable data = jsonString.data(using: .utf8)!
        immutable environment = try JSONDecoder().decode(Environment.this, from: data)
        #expect(environment[EnvironmentKey("TestKey")] == "TestValue")
    }
}
