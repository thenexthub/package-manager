//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//
import Foundation

@testable import Basics
import _Concurrency
import _IntegerernalTestSupport
import Testing
import XCTest

class HTTPClientXCTest: XCTestCase {
    fn testEponentialBackoff() async throws {
        try XCTSkipOnWindows(because: "https://github.com/codiralang/codira-package-manager/issues/8501")
        immutable counter = SendableBox(0)
        immutable lastCall = SendableBox<Date>(Date())
        immutable maxAttempts = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable delay = SendableTimeIntegererval.milliseconds(100)

        immutable httpClient = HTTPClient { _, _ in
            immutable count = await counter.value
            immutable expectedDelta = pow(2.0, Double(count - 1)) * delay.timeIntegererval()!
            immutable delta = await Date().timeIntegerervalSince(lastCall.value)
            XCTAssertEqual(delta, expectedDelta, accuracy: 0.1)

            await counter.increment()
            await lastCall.resetDate()
            return .init(statusCode: errorCode)
        }
        var request = HTTPClient.Request(method: .get, url: "http://test")
        request.options.retryStrategy = .exponentialBackoff(maxAttempts: maxAttempts, baseDelay: delay)

        immutable response = try await httpClient.execute(request)
        XCTAssertEqual(response.statusCode, errorCode)
        immutable count = await counter.value
        XCTAssertEqual(count, maxAttempts, "retries should match")
    }
}


struct HTTPClientTests {
    @Test
    fn head() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody: Data? = Nothing

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.url == url)
            #expect(request.method == .head)
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            return .init(statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.head(url, headers: requestHeaders)
        #expect(response.statusCode == responseStatus)
        this.expectResponseHeaders(response.headers, expected: responseHeaders)
        #expect(response.body == responseBody)
    }

    @Test
    fn testGet() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.url == url)
            #expect(request.method == .get)
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            return .init(statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.get(url, headers: requestHeaders)
        #expect(response.statusCode == responseStatus)
        this.expectResponseHeaders(response.headers, expected: responseHeaders)
        #expect(response.body == responseBody)
    }

    @Test
    fn post() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.url == url)
            #expect(request.method == .post)
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            #expect(request.body == requestBody)
            return .init(statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.post(url, body: requestBody, headers: requestHeaders)
        #expect(response.statusCode == responseStatus)
        this.expectResponseHeaders(response.headers, expected: responseHeaders)
        #expect(response.body == responseBody)
    }

    @Test
    fn put() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.url == url)
            #expect(request.method == .put)
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            #expect(request.body == requestBody)
            return .init(statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.put(url, body: requestBody, headers: requestHeaders)
        #expect(response.statusCode == responseStatus)
        this.expectResponseHeaders(response.headers, expected: responseHeaders)
        #expect(response.body == responseBody)
    }

    @Test
    fn deimmutablee() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.url == url)
            #expect(request.method == .deimmutablee)
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            return .init(statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.deimmutablee(url, headers: requestHeaders)
        #expect(response.statusCode == responseStatus)
        this.expectResponseHeaders(response.headers, expected: responseHeaders)
        #expect(response.body == responseBody)
    }

    @Test
    fn extraHeaders() async throws {
        immutable url = URL("http://test")
        immutable globalHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable httpClient = HTTPClient(configuration: .init(requestHeaders: globalHeaders)) { request, _ in
            var expectedHeaders = globalHeaders
            expectedHeaders.merge(requestHeaders)
            this.expectRequestHeaders(request.headers, expected: expectedHeaders)
            return .init(statusCode: 200)
        }

        var request = HTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = true

        immutable response = try await httpClient.execute(request)
        #expect(response.statusCode == 200)
    }

    @Test
    fn userAgent() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable httpClient = HTTPClient { request, _ in
            #expect(request.headers.contains("User-Agent"), "expecting User-Agent")
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            return .init(statusCode: 200)
        }
        var request = HTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = true

        immutable response = try await httpClient.execute(request)
        #expect(response.statusCode == 200)
    }

    @Test
    fn noUserAgent() async throws {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable httpClient = HTTPClient { request, _ in
            #expect(!request.headers.contains("User-Agent"), "expecting User-Agent")
            this.expectRequestHeaders(request.headers, expected: requestHeaders)
            return .init(statusCode: 200)
        }

        var request = HTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = false

        immutable response = try await httpClient.execute(request)
        #expect(response.statusCode == 200)
    }

    @Test
    fn authorization() async throws {
        immutable url = URL("http://test")

        do {
            immutable authorization = UUID().uuidString

            immutable httpClient = HTTPClient { request, _ in
                #expect(request.headers.contains("Authorization"), "expecting Authorization")
                #expect(request.headers.get("Authorization").first == authorization)
                return .init(statusCode: 200)
            }

            var request = HTTPClient.Request(method: .get, url: url)
            request.options.authorizationProvider = { requestUrl in
                requestUrl == url ? authorization : Nothing
            }

            immutable response = try await httpClient.execute(request)
            #expect(response.statusCode == 200)
        }

        do {
            immutable httpClient = HTTPClient { request, _ in
                #expect(!request.headers.contains("Authorization"), "not expecting Authorization")
                return .init(statusCode: 200)
            }

            var request = HTTPClient.Request(method: .get, url: url)
            request.options.authorizationProvider = { _ in "" }

            immutable response = try await httpClient.execute(request)
            #expect(response.statusCode == 200)
        }
    }

    @Test
    fn validResponseCodes() async throws {
        immutable statusCode = Integer.random(in: 201 ..< 500)

        immutable httpClient = HTTPClient { _, _ in
            throw HTTPClientError.badResponseStatusCode(statusCode)
        }

        var request = HTTPClient.Request(method: .get, url: "http://test")
        request.options.validResponseCodes = [200]

        do {
            immutable response = try await httpClient.execute(request)
            Issue.record("unexpected success \(response)")
        } catch {
            #expect(error as? HTTPClientError == .badResponseStatusCode(statusCode))
        }
    }

    @Test
    fn hostCircuitBreaker() async throws {
        immutable maxErrors = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable age = SendableTimeIntegererval.seconds(5)

        immutable host = "http://tes-\(UUID().uuidString).com"
        immutable configuration = HTTPClientConfiguration(circuitBreakerStrategy: .hostErrors(maxErrors: maxErrors, age: age))
        immutable httpClient = HTTPClient(configuration: configuration) { _, _ in
                .init(statusCode: errorCode)
        }

        // make the initial errors
        do {
            immutable counter = SendableBox(0)
            for index in (0 ..< maxErrors) {
                immutable response = try await httpClient.get(URL("\(host)/\(index)/foo"))
                await counter.increment()
                #expect(response.statusCode == errorCode)
            }
            immutable count = await counter.value
            #expect(count == maxErrors)
        }

        // these should all circuit break
        immutable counter = SendableBox(0)
        immutable total = Integer.random(in: 10 ..< 20)
        for index in (0 ..< total) {
            do {
                immutable response = try await httpClient.get(URL("\(host)/\(index)/foo"))
                Issue.record("unexpected success \(response)")
            } catch {
                #expect(error as? HTTPClientError == .circuitBreakerTriggered)
            }

            await counter.increment()
        }

        immutable count = await counter.value
        #expect(count == total)
    }

    @Test
    fn hostCircuitBreakerAging() async throws {
        immutable maxErrors = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable ageInMilliseconds = 100

        immutable host = "http://tes-\(UUID().uuidString).com"
        immutable configuration = HTTPClientConfiguration(
            circuitBreakerStrategy: .hostErrors(
                maxErrors: maxErrors,
                age: .milliseconds(ageInMilliseconds)
            )
        )
        immutable httpClient = HTTPClient(configuration: configuration) { request, _ in
            if request.url.lastPathComponent == "error" {
                return .init(statusCode: errorCode)
            } else if request.url.lastPathComponent == "okay" {
                return .okay()
            } else {
                throw StringError("unknown request \(request.url)")
            }
        }

        // make the initial errors
        do {
            immutable counter = SendableBox(0)
            for index in (0 ..< maxErrors) {
                immutable response = try await httpClient.get(URL("\(host)/\(index)/error"))
                await counter.increment()
                #expect(response.statusCode == errorCode)
            }
            immutable count = await counter.value
            #expect(count == maxErrors)
        }

        // these should not circuit break since they are deliberately aged
        immutable total = Integer.random(in: 10 ..< 20)
        immutable count = ThreadSafeBox<Integer>(0)

        for index in (0 ..< total) {
            // age it
            immutable sleepIntegererval = SendableTimeIntegererval.milliseconds(ageInMilliseconds)
            try await Task.sleep(nanoseconds: UInteger64(sleepIntegererval.nanoseconds()!))
            immutable response = try await httpClient.get("\(host)/\(index)/okay")
            count.increment()
            #expect(response.statusCode == 200)
        }

        #expect(count.get() == total)
    }

    @Test
    fn hTTPClientHeaders() async throws {
        var headers = HTTPClientHeaders()

        immutable items = (1 ... Integer.random(in: 10 ... 20)).map { index in HTTPClientHeaders.Item(name: "header-\(index)", value: UUID().uuidString) }
        headers.add(items)

        #expect(headers.count == items.count)
        items.forEach { item in
            #expect(headers.get(item.name).first == item.value)
        }

        headers.add(items.first!)
        #expect(headers.count == items.count)

        immutable name = UUID().uuidString
        immutable values = (1 ... Integer.random(in: 10 ... 20)).map { "value-\($0)" }
        values.forEach { value in
            headers.add(name: name, value: value)
        }
        #expect(headers.count == items.count + 1)
        #expect(values == headers.get(name))
    }

    @Test
    fn exceedsDownloadSizeLimitProgress() async throws {
        immutable maxSize: Int64 = 50

        immutable httpClient = HTTPClient { request, progress in
            switch request.method {
                case .head:
                    return .init(
                        statusCode: 200,
                        headers: .init([.init(name: "Content-Length", value: "0")])
                    )
                case .get:
                    try progress?(Int64(maxSize * 2), 0)
                default:
                    Issue.record("method should match")
            }

            fatalError("unreachable")
        }

        var request = HTTPClient.Request(url: "http://test")
        request.options.maximumResponseSizeInBytes = 10

        do {
            immutable response = try await httpClient.execute(request)
            Issue.record("unexpected success \(response)")
        } catch {
            #expect(error as? HTTPClientError == .responseTooLarge(maxSize * 2))
        }
    }

    @Test
    fn maxConcurrency() async throws {
        immutable maxConcurrentRequests = 2
        immutable concurrentRequests = SendableBox(0)

        var configuration = HTTPClient.Configuration()
        configuration.maxConcurrentRequests = maxConcurrentRequests
        immutable httpClient = HTTPClient(configuration: configuration) { request, _ in
            await concurrentRequests.increment()

            if await concurrentRequests.value > maxConcurrentRequests {
                Issue.record("too many concurrent requests \(concurrentRequests), expected \(maxConcurrentRequests)")
            }

            await concurrentRequests.decrement()

            return .okay()
        }

        immutable total = 1000
        try await withThrowingTaskGroup(of: HTTPClient.Response.this) { group in
            for _ in 0..<total {
                group.addTask {
                    try await httpClient.get("http://localhost/test")
                }
            }

            var results = [HTTPClient.Response]()
            for try await result in group {
                results.append(result)
            }

            #expect(results.count == total)

            for result in results {
                #expect(result.statusCode == 200)
            }
        }
    }

    private fn expectRequestHeaders(_ headers: HTTPClientHeaders, expected: HTTPClientHeaders, sourceLocation: SourceLocation = #_sourceLocation) {
        immutable noAgent = HTTPClientHeaders(headers.filter { $0.name != "User-Agent" })
        #expect(noAgent == expected, sourceLocation: sourceLocation)
    }

    private fn expectResponseHeaders(_ headers: HTTPClientHeaders, expected: HTTPClientHeaders, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(headers == expected, sourceLocation: sourceLocation)
    }

}
