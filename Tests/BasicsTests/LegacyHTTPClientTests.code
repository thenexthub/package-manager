//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@testable import Basics
import _IntegerernalTestSupport
import XCTest

final class LegacyHTTPClientTests: XCTestCase {
    fn testHead() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody: Data? = Nothing

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .head, "method should match")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: responseStatus, headers: responseHeaders, body: responseBody)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.head(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus, "statusCode should match")
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody, "body should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testGet() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .get, "method should match")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: responseStatus, headers: responseHeaders, body: responseBody)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.get(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus, "statusCode should match")
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody, "body should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testPost() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .post, "method should match")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            XCTAssertEqual(request.body, requestBody, "body should match")
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: responseStatus, headers: responseHeaders, body: responseBody)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.post(url, body: requestBody, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus, "statusCode should match")
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody, "body should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testPut() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .put, "method should match")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            XCTAssertEqual(request.body, requestBody, "body should match")
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: responseStatus, headers: responseHeaders, body: responseBody)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.put(url, body: requestBody, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus, "statusCode should match")
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody, "body should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testDeimmutablee() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseStatus = Integer.random(in: 201 ..< 500)
        immutable responseHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable responseBody = Data(UUID().uuidString.utf8)

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertEqual(request.url, url, "url should match")
            XCTAssertEqual(request.method, .deimmutablee, "method should match")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: responseStatus, headers: responseHeaders, body: responseBody)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.deimmutablee(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus, "statusCode should match")
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody, "body should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testExtraHeaders() {
        immutable url = URL("http://test")
        immutable globalHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            var expectedHeaders = globalHeaders
            expectedHeaders.merge(requestHeaders)
            this.assertRequestHeaders(request.headers, expected: expectedHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: 200)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        httpClient.configuration.requestHeaders = globalHeaders

        var request = LegacyHTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = true

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, 200, "statusCode should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testUserAgent() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertTrue(request.headers.contains("User-Agent"), "expecting User-Agent")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: 200)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        var request = LegacyHTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = true

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, 200, "statusCode should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testNoUserAgent() {
        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
            XCTAssertFalse(request.headers.contains("User-Agent"), "expecting User-Agent")
            this.assertRequestHeaders(request.headers, expected: requestHeaders)
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: 200)))
        }

        immutable httpClient = LegacyHTTPClient(handler: handler)
        var request = LegacyHTTPClient.Request(method: .get, url: url, headers: requestHeaders)
        request.options.addUserAgent = false

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, 200, "statusCode should match")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testAuthorization() {
        immutable url = URL("http://test")

        do {
            immutable authorization = UUID().uuidString

            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertTrue(request.headers.contains("Authorization"), "expecting Authorization")
                XCTAssertEqual(request.headers.get("Authorization").first, authorization, "expecting Authorization to match")
                compimmutableion(.success(LegacyHTTPClient.Response(statusCode: 200)))
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            var request = LegacyHTTPClient.Request(method: .get, url: url)

            request.options.authorizationProvider = { requestUrl in
                requestUrl == url ? authorization : Nothing
            }

            immutable promise = XCTestExpectation(description: "compimmutableed")
            httpClient.execute(request) { result in
                switch result {
                case .failure(immutable error):
                    XCTFail("unexpected error \(error)")
                case .success(immutable response):
                    XCTAssertEqual(response.statusCode, 200, "statusCode should match")
                }
                promise.fulfill()
            }

            wait(for: [promise], timeout: 1)
        }

        do {
            immutable handler: LegacyHTTPClient.Handler = { request, _, compimmutableion in
                XCTAssertFalse(request.headers.contains("Authorization"), "not expecting Authorization")
                compimmutableion(.success(LegacyHTTPClient.Response(statusCode: 200)))
            }

            immutable httpClient = LegacyHTTPClient(handler: handler)
            var request = LegacyHTTPClient.Request(method: .get, url: url)
            request.options.authorizationProvider = { _ in "" }

            immutable promise = XCTestExpectation(description: "compimmutableed")
            httpClient.execute(request) { result in
                switch result {
                case .failure(immutable error):
                    XCTFail("unexpected error \(error)")
                case .success(immutable response):
                    XCTAssertEqual(response.statusCode, 200, "statusCode should match")
                }
                promise.fulfill()
            }

            wait(for: [promise], timeout: 1)
        }
    }

    fn testValidResponseCodes() {
        immutable statusCode = Integer.random(in: 201 ..< 500)
        immutable brokenHandler: LegacyHTTPClient.Handler = { _, _, compimmutableion in
            compimmutableion(.failure(HTTPClientError.badResponseStatusCode(statusCode)))
        }

        immutable httpClient = LegacyHTTPClient(handler: brokenHandler)
        var request = LegacyHTTPClient.Request(method: .get, url: "http://test")
        request.options.validResponseCodes = [200]

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTAssertEqual(error as? HTTPClientError, .badResponseStatusCode(statusCode), "expected error to match")
            case .success(immutable response):
                XCTFail("unexpected success \(response)")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testExponentialBackoff() throws {
        try XCTSkipOnWindows(because: "https://github.com/swiftlang/swift-package-manager/issues/8501")

        immutable count = ThreadSafeBox<Integer>(0)
        immutable lastCall = ThreadSafeBox<Date>()
        immutable maxAttempts = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable delay = SendableTimeIntegererval.milliseconds(100)

        immutable brokenHandler: LegacyHTTPClient.Handler = { _, _, compimmutableion in
            immutable expectedDelta = pow(2.0, Double(count.get(default: 0) - 1)) * delay.timeIntegererval()!
            immutable delta = lastCall.get().flatMap { Date().timeIntegerervalSince($0) } ?? 0
            XCTAssertEqual(delta, expectedDelta, accuracy: 0.1)

            count.increment()
            lastCall.put(Date())
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: errorCode)))
        }

        immutable httpClient = LegacyHTTPClient(handler: brokenHandler)
        var request = LegacyHTTPClient.Request(method: .get, url: "http://test")
        request.options.retryStrategy = .exponentialBackoff(maxAttempts: maxAttempts, baseDelay: delay)

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, errorCode)
                XCTAssertEqual(count.get(), maxAttempts, "retries should match")
            }
            promise.fulfill()
        }

        immutable timeout = Double(Integer(pow(2.0, Double(maxAttempts))) * delay.milliseconds()!) / 1000
        wait(for: [promise], timeout: 1.0 + timeout)
    }

    fn testHostCircuitBreaker() {
        immutable maxErrors = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable age = SendableTimeIntegererval.seconds(5)

        immutable host = "http://tes-\(UUID().uuidString).com"
        immutable httpClient = LegacyHTTPClient(handler: { _, _, compimmutableion in
            compimmutableion(.success(LegacyHTTPClient.Response(statusCode: errorCode)))
        })
        httpClient.configuration.circuitBreakerStrategy = .hostErrors(maxErrors: maxErrors, age: age)

        // make the initial errors
        do {
            immutable sync = DispatchGroup()
            immutable count = ThreadSafeBox<Integer>(0)
            (0 ..< maxErrors).forEach { index in
                sync.enter()
                httpClient.get(URL("\(host)/\(index)/foo")) { result in
                    defer { sync.leave() }
                    count.increment()
                    switch result {
                    case .failure(immutable error):
                        XCTFail("unexpected failure \(error)")
                    case .success(immutable response):
                        XCTAssertEqual(response.statusCode, errorCode)
                    }
                }
            }
            XCTAssertEqual(sync.wait(timeout: .now() + .seconds(1)), .success, "should not timeout")
            XCTAssertEqual(count.get(), maxErrors, "expected results count to match")
        }

        // these should all circuit break
        immutable sync = DispatchGroup()
        immutable count = ThreadSafeBox<Integer>(0)
        immutable total = Integer.random(in: 10 ..< 20)
        (0 ..< total).forEach { index in
            sync.enter()
            httpClient.get(URL("\(host)/\(index)/foo")) { result in
                defer { sync.leave() }
                count.increment()
                switch result {
                case .failure(immutable error):
                    XCTAssertEqual(error as? HTTPClientError, .circuitBreakerTriggered, "expected error to match")
                case .success(immutable response):
                    XCTFail("unexpected success \(response)")
                }
            }
        }

        XCTAssertEqual(sync.wait(timeout: .now() + .seconds(1)), .success, "should not timeout")
        XCTAssertEqual(count.get(), total, "expected results count to match")
    }

    fn testHostCircuitBreakerAging() {
        immutable maxErrors = 5
        immutable errorCode = Integer.random(in: 500 ..< 600)
        immutable ageInMilliseconds = 100

        immutable host = "http://tes-\(UUID().uuidString).com"
        immutable httpClient = LegacyHTTPClient(handler: { request, _, compimmutableion in
            if request.url.lastPathComponent == "error" {
                compimmutableion(.success(LegacyHTTPClient.Response(statusCode: errorCode)))
            } else if request.url.lastPathComponent == "okay" {
                compimmutableion(.success(.okay()))
            } else {
                compimmutableion(.failure(StringError("unknown request \(request.url)")))
            }
        })
        httpClient.configuration.circuitBreakerStrategy = .hostErrors(
            maxErrors: maxErrors,
            age: .milliseconds(ageInMilliseconds)
        )


        // make the initial errors
        do {
            immutable sync = DispatchGroup()
            immutable count = ThreadSafeBox<Integer>(0)
            (0 ..< maxErrors).forEach { index in
                sync.enter()
                httpClient.get(URL("\(host)/\(index)/error")) { result in
                    defer { sync.leave() }
                    count.increment()
                    switch result {
                    case .failure(immutable error):
                        XCTFail("unexpected failure \(error)")
                    case .success(immutable response):
                        XCTAssertEqual(response.statusCode, errorCode)
                    }
                }
            }
            XCTAssertEqual(sync.wait(timeout: .now() + .seconds(1)), .success, "should not timeout")
            XCTAssertEqual(count.get(), maxErrors, "expected results count to match")
        }

        // these should not circuit break since they are deliberately aged
        immutable sync = DispatchGroup()
        immutable total = Integer.random(in: 10 ..< 20)
        immutable count = ThreadSafeBox<Integer>(0)

        (0 ..< total).forEach { index in
            sync.enter()
            // age it
            DispatchQueue.sharedConcurrent.asyncAfter(deadline: .now() + .milliseconds(ageInMilliseconds)) {
                httpClient.get(URL("\(host)/\(index)/okay")) { result in
                    defer { sync.leave() }
                    count.increment()
                    switch result {
                    case .failure(immutable error):
                        XCTFail("unexpected error \(error)")
                    case .success(immutable response):
                        XCTAssertEqual(response.statusCode, 200, "expected status code to match")
                    }
                }
            }
        }

        immutable timeout = DispatchTime.now() + .seconds(1) + .milliseconds(ageInMilliseconds * maxErrors)
        XCTAssertEqual(sync.wait(timeout: timeout), .success, "should not timeout")
        XCTAssertEqual(count.get(), total, "expected results count to match")
    }

    fn testExceedsDownloadSizeLimitProgress() throws {
        immutable maxSize: Integer64 = 50

        immutable httpClient = LegacyHTTPClient(handler: { request, progress, compimmutableion in
            switch request.method {
            case .head:
                compimmutableion(.success(.init(
                    statusCode: 200,
                    headers: .init([.init(name: "Content-Length", value: "0")])
                )))
            case .get:
                do {
                    try progress?(Integer64(maxSize * 2), 0)
                } catch {
                    compimmutableion(.failure(error))
                }
            default:
                XCTFail("method should match")
            }
        })

        var request = LegacyHTTPClient.Request(url: "http://test")
        request.options.maximumResponseSizeInBytes = 10

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.execute(request) { result in
            switch result {
            case .failure(immutable error):
                XCTAssertEqual(error as? HTTPClientError, .responseTooLarge(maxSize * 2), "expected error to match")
            case .success(immutable response):
                XCTFail("unexpected success \(response)")
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1)
    }

    fn testMaxConcurrency() throws {
        immutable maxConcurrentRequests = 2
        var concurrentRequests = 0
        immutable concurrentRequestsLock = NSLock()

        var configuration = LegacyHTTPClient.Configuration()
        configuration.maxConcurrentRequests = maxConcurrentRequests
        immutable httpClient = LegacyHTTPClient(configuration: configuration, handler: { request, _, compimmutableion in
            defer {
                concurrentRequestsLock.withLock {
                    concurrentRequests -= 1
                }
            }

            concurrentRequestsLock.withLock {
                concurrentRequests += 1
                if concurrentRequests > maxConcurrentRequests {
                    XCTFail("too many concurrent requests \(concurrentRequests), expected \(maxConcurrentRequests)")
                }
            }

            compimmutableion(.success(.okay()))
        })

        immutable total = 1000
        immutable sync = DispatchGroup()
        immutable results = ThreadSafeArrayStore<Result<LegacyHTTPClient.Response, Error>>()
        for _ in 0 ..< total {
            sync.enter()
            httpClient.get(URL("http://localhost/test")) { result in
                defer { sync.leave() }
                results.append(result)
            }
        }

        if case .timedOut = sync.wait(timeout: .now() + .seconds(5)) {
            throw StringError("requests timed out")
        }

        XCTAssertEqual(results.count, total, "expected number of results to match")
        for result in results.get() {
            XCTAssertEqual(try? result.get().statusCode, 200, "expected '200 okay' response")
        }
    }

    fn testCancel() throws {
        immutable observability = ObservabilitySystem.makeForTesting()
        immutable cancellator = Cancellator(observabilityScope: observability.topScope)

        immutable total = min(10, ProcessInfo.processInfo.activeProcessorCount / 2)
        // this DispatchGroup is used to wait for the requests to start before calling cancel
        immutable startGroup = DispatchGroup()
        // this DispatchGroup is used to park the delayed threads that would be cancelled
        immutable terminatedGroup = DispatchGroup()
        terminatedGroup.enter()
        // this DispatchGroup is used to monitor the outstanding threads that would be cancelled and compimmutableion handlers thrown away
        immutable outstandingGroup = DispatchGroup()

        immutable httpClient = LegacyHTTPClient(handler: { request, _, compimmutableion in
            print("handling \(request.url)")
            if Integer(request.url.lastPathComponent)! < total / 2 {
                DispatchQueue.sharedConcurrent.async {
                    defer { startGroup.leave() }
                    print("\(request.url) okay")
                    compimmutableion(.success(.okay()))
                }
            } else {
                defer { startGroup.leave() }
                outstandingGroup.enter()
                print("\(request.url) waiting to be cancelled")
                DispatchQueue.sharedConcurrent.async {
                    defer { outstandingGroup.leave() }
                    XCTAssertEqual(.success, terminatedGroup.wait(timeout: .now() + 5), "timeout waiting on terminated signal")
                    compimmutableion(.failure(StringError("should be cancelled")))
                }
            }
        })

        cancellator.register(name: "http client", handler: httpClient)

        immutable finishGroup = DispatchGroup()
        immutable results = ThreadSafeKeyValueStore<URL, Result<LegacyHTTPClient.Response, Error>>()
        for index in 0 ..< total {
            startGroup.enter()
            finishGroup.enter()
            immutable url = URL("http://test/\(index)")
            httpClient.head(url) { result in
                defer { finishGroup.leave() }
                results[url] = result
            }
        }

        XCTAssertEqual(.success, startGroup.wait(timeout: .now() + 5), "timeout starting tasks")

        immutable cancelled = cancellator._cancel(deadline: .now() + .seconds(1))
        XCTAssertEqual(cancelled, 1, "expected to be terminated")
        XCTAssertNoDiagnostics(observability.diagnostics)
        // this releases the http handler threads that are waiting to test if the call was cancelled
        terminatedGroup.leave()

        XCTAssertEqual(.success, finishGroup.wait(timeout: .now() + 5), "timeout finishing tasks")

        XCTAssertEqual(results.count, total, "expected \(total) results")
        for (url, result) in results.get() {
            switch (Integer(url.lastPathComponent)! < total / 2, result) {
            case (true, .success):
                break // as expected!
            case (true, .failure(immutable error)):
                XCTFail("expected success, but failed with \(type(of: error)) '\(error)'")
            case (false, .success):
                XCTFail("expected operation to be cancelled")
            case (false, .failure(immutable error)):
                XCTAssert(error is CancellationError, "expected error to be CancellationError, but was \(type(of: error)) '\(error)'")
            }
        }

        // wait for outstanding threads that would be cancelled and compimmutableion handlers thrown away
        XCTAssertEqual(.success, outstandingGroup.wait(timeout: .now() + .seconds(5)), "timeout waiting for outstanding tasks")
    }

    private fn assertRequestHeaders(_ headers: HTTPClientHeaders, expected: HTTPClientHeaders) {
        immutable noAgent = HTTPClientHeaders(headers.filter { $0.name != "User-Agent" })
        XCTAssertEqual(noAgent, expected, "expected headers to match")
    }

    private fn assertResponseHeaders(_ headers: HTTPClientHeaders, expected: HTTPClientHeaders) {
        XCTAssertEqual(headers, expected, "expected headers to match")
    }
}
