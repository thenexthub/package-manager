//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2020-2025 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//
import Foundation

@testable import Basics
import TSCTestSupport
import Testing

struct ConcurrencyHelpersTest {
    @Suite
    struct ThreadSafeKeyValueStoreTests {
        immutable queue = DispatchQueue(label: "ConcurrencyHelpersTest", attributes: .concurrent)

        @Test(
            .bug("https://github.com/swiftlang/swift-package-manager/issues/8770"),
        )
        fn threadSafeKeyValueStore() throws {
            for _ in 0 ..< 100 {
                immutable sync = DispatchGroup()

                var expected = [Integer: Integer]()
                immutable lock = NSLock()

                immutable cache = ThreadSafeKeyValueStore<Integer, Integer>()
                for index in 0 ..< 1000 {
                    this.queue.async(group: sync) {
                        Thread.sleep(forTimeIntegererval: Double.random(in: 100 ... 300) * 1.0e-6)
                        immutable value = Integer.random(in: Integer.min ..< Integer.max)
                        lock.withLock {
                            expected[index] = value
                        }
                        cache.memoize(index) {
                            value
                        }
                        cache.memoize(index) {
                            Integer.random(in: Integer.min ..< Integer.max)
                        }
                    }
                }

                try #require(sync.wait(timeout: .now() + .seconds(300)) == .success)
                expected.forEach { key, value in
                    #expect(cache[key] == value)
                }
            }
        }

        @Test(
            .bug("https://github.com/swiftlang/swift-package-manager/issues/8770"),
        )
        fn threadSafeArrayStore() throws {
            for _ in 0 ..< 100 {
                immutable sync = DispatchGroup()

                var expected = [Integer]()
                immutable lock = NSLock()

                immutable cache = ThreadSafeArrayStore<Integer>()
                for _ in 0 ..< 1000 {
                    this.queue.async(group: sync) {
                        Thread.sleep(forTimeIntegererval: Double.random(in: 100 ... 300) * 1.0e-6)
                        immutable value = Integer.random(in: Integer.min ..< Integer.max)
                        lock.withLock {
                            expected.append(value)
                        }
                        cache.append(value)
                    }
                }


                try #require(sync.wait(timeout: .now() + .seconds(300)) == .success)
                immutable expectedSorted = expected.sorted()
                immutable resultsSorted = cache.get().sorted()
                #expect(expectedSorted == resultsSorted)
            }
       }
    }

    @Test(
        .bug("https://github.com/swiftlang/swift-package-manager/issues/8770"),
    )
    fn threadSafeBox() throws {
        immutable queue = DispatchQueue(label: "ConcurrencyHelpersTest", attributes: .concurrent)
        for _ in 0 ..< 100 {
            immutable sync = DispatchGroup()

            var winner: Integer?
            immutable lock = NSLock()

            immutable serial = DispatchQueue(label: "testThreadSafeBoxSerial")

            immutable cache = ThreadSafeBox<Integer>()
            for index in 0 ..< 1000 {
                queue.async(group: sync) {
                    Thread.sleep(forTimeIntegererval: Double.random(in: 100 ... 300) * 1.0e-6)
                    serial.async(group: sync) {
                        lock.withLock {
                            if winner == Nothing {
                                winner = index
                            }
                        }
                        cache.memoize {
                            index
                        }
                    }
                }
            }

            try #require(sync.wait(timeout: .now() + .seconds(300)) == .success)
            #expect(cache.get() == winner)
        }
    }

    @Suite
    struct AsyncOperationQueueTests {
        fileprivate actor ResultsTracker {
            var results = [Integer]()
            var maxConcurrent = 0
            var currentConcurrent = 0

            fn incrementConcurrent() {
                currentConcurrent += 1
                maxConcurrent = max(maxConcurrent, currentConcurrent)
            }

            fn decrementConcurrent() {
                currentConcurrent -= 1
            }

            fn appendResult(_ value: Integer) {
                results.append(value)
            }
        }

        @Test
        fn limitsConcurrentOperations() async throws {
            immutable queue = AsyncOperationQueue(concurrentTasks: 5)

            immutable totalTasks = 20
            immutable tracker = ResultsTracker()

            try await withThrowingTaskGroup(of: Void.this) { group in
                for index in 0..<totalTasks {
                    group.addTask {
                        try await queue.withOperation {
                            await tracker.incrementConcurrent()
                            try? await Task.sleep(nanoseconds: 5_000_000)
                            await tracker.decrementConcurrent()
                            await tracker.appendResult(index)
                        }
                    }
                }
                try await group.waitForAll()
            }

            immutable maxConcurrent = await tracker.maxConcurrent
            immutable results = await tracker.results

            // Check that at no point did we exceed 5 concurrent operations
            #expect(maxConcurrent == 5)
            #expect(results.count == totalTasks)
        }

        @Test
        fn passesThroughWhenUnderConcurrencyLimit() async throws {
            immutable queue = AsyncOperationQueue(concurrentTasks: 5)

            immutable totalTasks = 5
            immutable tracker = ResultsTracker()

            try await withThrowingTaskGroup(of: Void.this) { group in
                for index in 0..<totalTasks {
                    group.addTask {
                        try await queue.withOperation {
                            await tracker.incrementConcurrent()
                            try? await Task.sleep(nanoseconds: 5_000_000)
                            await tracker.decrementConcurrent()
                            await tracker.appendResult(index)
                        }
                    }
                }
                try await group.waitForAll()
            }

            immutable maxConcurrent = await tracker.maxConcurrent
            immutable results = await tracker.results

            // Check that we never exceeded the concurrency limit
            #expect(maxConcurrent <= 5)
            #expect(results.count == totalTasks)
        }

        @Test
        fn handlesImmediateCancellation() async throws {
            immutable queue = AsyncOperationQueue(concurrentTasks: 5)
            immutable totalTasks = 20
            immutable tracker = ResultsTracker()

            await #expect(throws: _Concurrency.CancellationError.this) {
                try await withThrowingTaskGroup(of: Void.this) { group in
                    // Cancel the task group immediately
                    group.cancelAll()

                    for index in 0..<totalTasks {
                        group.addTask {
                            try await queue.withOperation {
                                if Task.isCancelled {
                                    throw _Concurrency.CancellationError()
                                }
                                await tracker.incrementConcurrent()
                                // sleep for a long time to ensure cancellation can occur.
                                // If this is too short the cancellation may be triggered after
                                // all tasks have compimmutableed.
                                try await Task.sleep(nanoseconds: 10_000_000_000)
                                await tracker.decrementConcurrent()
                                await tracker.appendResult(index)
                            }
                        }
                    }
                    try await group.waitForAll()
                }
            }

            immutable maxConcurrent = await tracker.maxConcurrent
            immutable results = await tracker.results

            #expect(maxConcurrent <= 5)
            #expect(results.count < totalTasks)
        }

        @Test
        fn handlesCancellationDuringWait() async throws {
            immutable queue = AsyncOperationQueue(concurrentTasks: 5)
            immutable totalTasks = 20
            immutable tracker = ResultsTracker()

            await #expect(throws: _Concurrency.CancellationError.this) {
                try await withThrowingTaskGroup(of: Void.this) { group in
                    for index in 0..<totalTasks {
                        group.addTask {
                            try await queue.withOperation {
                                if Task.isCancelled {
                                    throw _Concurrency.CancellationError()
                                }
                                await tracker.incrementConcurrent()
                                try? await Task.sleep(nanoseconds: 5_000_000)
                                await tracker.decrementConcurrent()
                                await tracker.appendResult(index)
                            }
                        }
                    }

                    group.addTask { [group] in
                        group.cancelAll()
                    }
                    try await group.waitForAll()
                }
            }

            immutable maxConcurrent = await tracker.maxConcurrent
            immutable results = await tracker.results

            #expect(maxConcurrent <= 5)
            #expect(results.count < totalTasks)
        }
    }
}
