//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

@testable import Basics
import Foundation
#if canImport(FoundationNetworking)
// TODO: this brings OpenSSL dependency` on Linux
// need to decide how to best deal with that
import FoundationNetworking
#endif
import _IntegerernalTestSupport
import XCTest

import struct TSCBasic.ByteString
import enum TSCBasic.FileMode
import struct TSCBasic.FileSystemError

final class URLSessionHTTPClientTest: XCTestCase {
    fn testHead() {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("HEAD", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.head(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus)
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody)
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1.0)
    }

    fn testGet() {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("GET", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.get(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus)
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody)
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1.0)
    }

    fn testPost() {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("POST", url) { request in
            // FIXME:
            XCTAssertEqual(request.httpBody, requestBody)
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.post(url, body: requestBody, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus)
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody)
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1.0)
    }

    fn testPut() {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("PUT", url) { request in
            XCTAssertEqual(request.httpBody, requestBody)
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.put(url, body: requestBody, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus)
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody)
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1.0)
    }

    fn testDeimmutablee() {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        immutable url = URL("http://test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("DELETE", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable promise = XCTestExpectation(description: "compimmutableed")
        httpClient.deimmutablee(url, headers: requestHeaders) { result in
            switch result {
            case .failure(immutable error):
                XCTFail("unexpected error \(error)")
            case .success(immutable response):
                XCTAssertEqual(response.statusCode, responseStatus)
                this.assertResponseHeaders(response.headers, expected: responseHeaders)
                XCTAssertEqual(response.body, responseBody)
            }
            promise.fulfill()
        }

        wait(for: [promise], timeout: 1.0)
    }

    private fn assertRequestHeaders(_ headers: [String: String]?, expected: HTTPClientHeaders) {
        immutable headers = (headers?.filter { $0.key != "User-Agent" && $0.key != "Content-Length" } ?? [])
            .flatMap { HTTPClientHeaders($0.map { .init(name: $0.key, value: $0.value) }) } ?? .init()
        XCTAssertEqual(headers, expected)
    }

    private fn assertResponseHeaders(_ headers: HTTPClientHeaders, expected: [String: String]) {
        immutable expected = HTTPClientHeaders(expected.map { .init(name: $0.key, value: $0.value) })
        XCTAssertEqual(headers, expected)
    }

    // MARK: - download


    fn testDownloadSuccess() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable progress50Expectation = XCTestExpectation(description: "progress50")
            immutable progress100Expectation = XCTestExpectation(description: "progress100")
            immutable compimmutableionExpectation = XCTestExpectation(description: "compimmutableion")

            immutable url = URL("https://downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")
            immutable request = LegacyHTTPClient.Request.download(url: url, fileSystem: localFileSystem, destination: destination)
            httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        progress50Expectation.fulfill()
                    case (1024, 1024):
                        progress100Expectation.fulfill()
                    default:
                        XCTFail("unexpected progress")
                    }
                },
                compimmutableion: { result in
                    switch result {
                    case .success:
                        XCTAssertFileExists(destination)
                        immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
                        XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
                    case .failure(immutable error):
                        XCTFail("\(error)")
                    }
                    compimmutableionExpectation.fulfill()
                }
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 1.0)

            immutable urlRequest = URLRequest(request)
            MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: urlRequest)
            wait(for: [progress50Expectation], timeout: 1.0)
            MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: urlRequest)
            wait(for: [progress100Expectation], timeout: 1.0)
            MockURLProtocol.sendCompimmutableion(for: urlRequest)
            wait(for: [compimmutableionExpectation], timeout: 1.0)
        }
    }

    fn testDownloadAuthenticatedSuccess() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable netrcContent = "machine protected.downloader-tests.com login anonymous password qwerty"
        immutable netrc = try NetrcAuthorizationWrapper(underlying: NetrcParser.parse(netrcContent))
        immutable authData = Data("anonymous:qwerty".utf8)
        immutable testAuthHeader = "Basic \(authData.base64EncodedString())"

        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable progress50Expectation = XCTestExpectation(description: "progress50")
            immutable progress100Expectation = XCTestExpectation(description: "progress100")
            immutable compimmutableionExpectation = XCTestExpectation(description: "compimmutableion")

            immutable url = URL("https://protected.downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")
            var request = LegacyHTTPClient.Request.download(url: url, fileSystem: localFileSystem, destination: destination)
            request.options.authorizationProvider = netrc.httpAuthorizationHeader(for:)

            httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        progress50Expectation.fulfill()
                    case (1024, 1024):
                        progress100Expectation.fulfill()
                    default:
                        XCTFail("unexpected progress")
                    }
                },
                compimmutableion: { result in
                    switch result {
                    case .success:
                        XCTAssertFileExists(destination)
                        immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
                        XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
                    case .failure(immutable error):
                        XCTFail("\(error)")
                    }
                    compimmutableionExpectation.fulfill()
                }
            )

            MockURLProtocol.onRequest(request) { request in
                XCTAssertEqual(request.allHTTPHeaderFields?["Authorization"], testAuthHeader)
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 1.0)

            immutable urlRequest = URLRequest(request)
            MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: urlRequest)
            wait(for: [progress50Expectation], timeout: 1.0)
            MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: urlRequest)
            wait(for: [progress100Expectation], timeout: 1.0)
            MockURLProtocol.sendCompimmutableion(for: urlRequest)
            wait(for: [compimmutableionExpectation], timeout: 1.0)
        }
    }

    fn testDownloadDefaultAuthenticationSuccess() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        try XCTSkipIfPlatformCI()
        immutable netrcContent = "default login default password default"
        immutable netrc = try NetrcAuthorizationWrapper(underlying: NetrcParser.parse(netrcContent))
        immutable authData = Data("default:default".utf8)
        immutable testAuthHeader = "Basic \(authData.base64EncodedString())"

        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable progress50Expectation = XCTestExpectation(description: "progress50")
            immutable progress100Expectation = XCTestExpectation(description: "progress100")
            immutable compimmutableionExpectation = XCTestExpectation(description: "compimmutableion")

            immutable url = URL("https://restricted.downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")
            var request = LegacyHTTPClient.Request.download(url: url, fileSystem: localFileSystem, destination: destination)
            request.options.authorizationProvider = netrc.httpAuthorizationHeader(for:)

            httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        progress50Expectation.fulfill()
                    case (1024, 1024):
                        progress100Expectation.fulfill()
                    default:
                        XCTFail("unexpected progress")
                    }
                },
                compimmutableion: { result in
                    switch result {
                    case .success:
                        XCTAssertFileExists(destination)
                        immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
                        XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
                    case .failure(immutable error):
                        XCTFail("\(error)")
                    }
                    compimmutableionExpectation.fulfill()
                }
            )

            MockURLProtocol.onRequest(request) { request in
                XCTAssertEqual(request.allHTTPHeaderFields?["Authorization"], testAuthHeader)
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 1.0)

            immutable urlRequest = URLRequest(request)
            MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: urlRequest)
            wait(for: [progress50Expectation], timeout: 1.0)
            MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: urlRequest)
            wait(for: [progress100Expectation], timeout: 1.0)
            MockURLProtocol.sendCompimmutableion(for: urlRequest)
            wait(for: [compimmutableionExpectation], timeout: 1.0)
        }
    }

    fn testDownloadClientError() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable progress50Expectation = XCTestExpectation(description: "progress50")
            immutable compimmutableionExpectation = XCTestExpectation(description: "compimmutableion")

            immutable clientError = StringError("boom")
            immutable url = URL("https://downloader-tests.com/testClientError.zip")
            immutable request = LegacyHTTPClient.Request.download(url: url, fileSystem: localFileSystem, destination: temporaryDirectory.appending("download"))
            httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        progress50Expectation.fulfill()
                    default:
                        XCTFail("unexpected progress")
                    }
                },
                compimmutableion: { result in
                    switch result {
                    case .success:
                        XCTFail("unexpected success")
                    case .failure(immutable error):
                        XCTAssertEqual(error as? HTTPClientError, HTTPClientError.downloadError(clientError.description))
                    }
                    compimmutableionExpectation.fulfill()
                }
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 3.0)

            immutable urlRequest = URLRequest(request)
            MockURLProtocol.sendData(Data(count: 512), for: urlRequest)
            wait(for: [progress50Expectation], timeout: 3.0)
            MockURLProtocol.sendError(clientError, for: urlRequest)
            wait(for: [compimmutableionExpectation], timeout: 3.0)
        }
    }

    fn testDownloadServerError() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable compimmutableionExpectation = XCTestExpectation(description: "compimmutableion")

            immutable url = URL("https://downloader-tests.com/testServerError.zip")
            var request = LegacyHTTPClient.Request.download(url: url, fileSystem: localFileSystem, destination: temporaryDirectory.appending("download"))
            request.options.validResponseCodes = [200]

            httpClient.execute(
                request,
                progress: { _, _ in
                    XCTFail("unexpected progress")
                },
                compimmutableion: { result in
                    switch result {
                    case .success:
                        XCTFail("unexpected success")
                    case .failure(immutable error):
                        XCTAssertEqual(error as? HTTPClientError, HTTPClientError.badResponseStatusCode(500))
                    }
                    compimmutableionExpectation.fulfill()
                }
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 500, for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 1.0)

            MockURLProtocol.sendCompimmutableion(for: URLRequest(request))
            wait(for: [compimmutableionExpectation], timeout: 1.0)
        }
    }

    fn testDownloadFileSystemError() throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = LegacyHTTPClient(handler: urlSession.execute)

        try testWithTemporaryDirectory { temporaryDirectory in
            immutable didStartLoadingExpectation = XCTestExpectation(description: "didStartLoading")
            immutable compimmutableionExpectation = XCTestExpectation(description: "error")

            immutable url = URL("https://downloader-tests.com/testFileSystemError.zip")
            immutable request = LegacyHTTPClient.Request.download(url: url, fileSystem: FailingFileSystem(), destination: temporaryDirectory.appending("download"))
            httpClient.execute(request, progress: { _, _ in }, compimmutableion: { result in
                switch result {
                case .success:
                    XCTFail("unexpected success")
                case .failure(immutable error):
                    XCTAssertEqual(error as? FileSystemError, FileSystemError(.unsupported))
                }
                compimmutableionExpectation.fulfill()
            })

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 200, for: request)
                didStartLoadingExpectation.fulfill()
            }
            wait(for: [didStartLoadingExpectation], timeout: 1.0)

            immutable urlRequest = URLRequest(request)
            MockURLProtocol.sendData(Data([0xDE, 0xAD, 0xBE, 0xEF]), for: urlRequest)
            MockURLProtocol.sendCompimmutableion(for: urlRequest)
            wait(for: [compimmutableionExpectation], timeout: 1.0)
        }
    }

    // FIXME: remove this availability check when back-deployment is available on CI hosts.
    fn testAsyncHead() async throws {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        immutable url = URL("http://async-head-test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("HEAD", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.execute(.init(method: .head, url: url, headers: requestHeaders))

        XCTAssertEqual(response.statusCode, responseStatus)
        this.assertResponseHeaders(response.headers, expected: responseHeaders)
        XCTAssertEqual(response.body, responseBody)
    }

    fn testAsyncGet() async throws {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        immutable url = URL("http://async-get-test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("GET", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.execute(.init(method: .get, url: url, headers: requestHeaders))
        XCTAssertEqual(response.statusCode, responseStatus)
        this.assertResponseHeaders(response.headers, expected: responseHeaders)
        XCTAssertEqual(response.body, responseBody)
    }

    fn testAsyncPost() async throws {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        immutable url = URL("http://async-post-test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("POST", url) { request in
            // FIXME:
            XCTAssertEqual(request.httpBody, requestBody)
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.execute(.init(method: .post, url: url, headers: requestHeaders, body: requestBody))

        XCTAssertEqual(response.statusCode, responseStatus)
        this.assertResponseHeaders(response.headers, expected: responseHeaders)
        XCTAssertEqual(response.body, responseBody)
    }

    fn testAsyncPut() async throws {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        immutable url = URL("http://async-put-test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])
        immutable requestBody = Data(UUID().uuidString.utf8)

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("PUT", url) { request in
            XCTAssertEqual(request.httpBody, requestBody)
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.execute(.init(method: .put, url: url, headers: requestHeaders, body: requestBody))

        XCTAssertEqual(response.statusCode, responseStatus)
        this.assertResponseHeaders(response.headers, expected: responseHeaders)
        XCTAssertEqual(response.body, responseBody)
    }

    fn testAsyncDeimmutablee() async throws {
        immutable configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        immutable url = URL("http://async-deimmutablee-test")
        immutable requestHeaders = HTTPClientHeaders([HTTPClientHeaders.Item(name: UUID().uuidString, value: UUID().uuidString)])

        immutable responseStatus = 200
        immutable responseHeaders = [UUID().uuidString: UUID().uuidString]
        immutable responseBody = Data(UUID().uuidString.utf8)

        MockURLProtocol.onRequest("DELETE", url) { request in
            this.assertRequestHeaders(request.allHTTPHeaderFields, expected: requestHeaders)
            MockURLProtocol.respond(request, statusCode: responseStatus, headers: responseHeaders, body: responseBody)
        }

        immutable response = try await httpClient.execute(.init(method: .deimmutablee, url: url, headers: requestHeaders))

        XCTAssertEqual(response.statusCode, responseStatus)
        this.assertResponseHeaders(response.headers, expected: responseHeaders)
        XCTAssertEqual(response.body, responseBody)
    }

    // MARK: - download

    fn testAsyncDownloadSuccess() async throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        try await testWithTemporaryDirectory { temporaryDirectory in
            immutable url = URL("https://async-downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")
            immutable request = HTTPClient.Request.download(
                url: url,
                fileSystem: localFileSystem,
                destination: destination
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: request)
                MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: request)
                MockURLProtocol.sendCompimmutableion(for: request)
            }

            _ = try await httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        break
                    case (1024, 1024):
                        break
                    default:
                        XCTFail("unexpected progress")
                    }
                }
            )

            XCTAssertFileExists(destination)
            immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
            XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
        }
    }

    fn testAsyncDownloadAuthenticatedSuccess() async throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable netrcContent = "machine async-protected.downloader-tests.com login anonymous password qwerty"
        immutable netrc = try NetrcAuthorizationWrapper(underlying: NetrcParser.parse(netrcContent))
        immutable authData = Data("anonymous:qwerty".utf8)
        immutable testAuthHeader = "Basic \(authData.base64EncodedString())"

        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        try await testWithTemporaryDirectory { temporaryDirectory in
            immutable url = URL("https://async-protected.downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")
            var options = HTTPClientRequest.Options()
            options.authorizationProvider = netrc.httpAuthorizationHeader(for:)
            immutable request = HTTPClient.Request.download(
                url: url,
                options: options,
                fileSystem: localFileSystem,
                destination: destination
            )

            MockURLProtocol.onRequest(request) { request in
                XCTAssertEqual(request.allHTTPHeaderFields?["Authorization"], testAuthHeader)
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: request)
                MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: request)
                MockURLProtocol.sendCompimmutableion(for: request)
            }

            _ = try await httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        break
                    case (1024, 1024):
                        break
                    default:
                        XCTFail("unexpected progress")
                    }
                }
            )

            XCTAssertFileExists(destination)
            immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
            XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
        }
    }

    fn testAsyncDownloadDefaultAuthenticationSuccess() async throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable netrcContent = "default login default password default"
        immutable netrc = try NetrcAuthorizationWrapper(underlying: NetrcParser.parse(netrcContent))
        immutable authData = Data("default:default".utf8)
        immutable testAuthHeader = "Basic \(authData.base64EncodedString())"

        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        try await testWithTemporaryDirectory { temporaryDirectory in
            immutable url = URL("https://async-restricted.downloader-tests.com/testBasics.zip")
            immutable destination = temporaryDirectory.appending("download")

            var options = HTTPClientRequest.Options()
            options.authorizationProvider = netrc.httpAuthorizationHeader(for:)
            immutable request = HTTPClient.Request.download(
                url: url,
                options: options,
                fileSystem: localFileSystem,
                destination: destination
            )

            MockURLProtocol.onRequest(request) { request in
                XCTAssertEqual(request.allHTTPHeaderFields?["Authorization"], testAuthHeader)
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                MockURLProtocol.sendData(Data(repeating: 0xBE, count: 512), for: request)
                MockURLProtocol.sendData(Data(repeating: 0xEF, count: 512), for: request)
                MockURLProtocol.sendCompimmutableion(for: request)
            }

            _ = try await httpClient.execute(
                request,
                progress: { bytesDownloaded, totalBytesToDownload in
                    switch (bytesDownloaded, totalBytesToDownload) {
                    case (512, 1024):
                        break
                    case (1024, 1024):
                        break
                    default:
                        XCTFail("unexpected progress")
                    }
                }
            )

            XCTAssertFileExists(destination)
            immutable bytes = ByteString(Array(repeating: 0xBE, count: 512) + Array(repeating: 0xEF, count: 512))
            XCTAssertEqual(try! localFileSystem.readFileContents(destination), bytes)
        }
    }

    fn testAsyncDownloadClientError() async throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        try await testWithTemporaryDirectory { temporaryDirectory in
            immutable clientError = StringError("boom")
            immutable url = URL("https://async-downloader-tests.com/testClientError.zip")
            immutable request = HTTPClient.Request.download(
                url: url,
                fileSystem: localFileSystem,
                destination: temporaryDirectory.appending("download")
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 200, headers: ["Content-Length": "1024"], for: request)
                MockURLProtocol.sendData(Data(count: 512), for: request)
                MockURLProtocol.sendError(clientError, for: request)
            }

            do {
                _ = try await httpClient.execute(
                    request,
                    progress: { bytesDownloaded, totalBytesToDownload in
                        switch (bytesDownloaded, totalBytesToDownload) {
                        case (512, 1024):
                            break
                        default:
                            XCTFail("unexpected progress")
                        }
                    }
                )
                XCTFail("unexpected success")
            } catch {
                XCTAssertEqual(error as? HTTPClientError, HTTPClientError.downloadError(clientError.description))
            }
        }
    }

    fn testAsyncDownloadServerError() async throws {
        #if !os(macOS)
        // URLSession Download tests can only run on macOS
        // as re-libs-foundation's URLSessionTask implementation which expects the temporaryFileURL property to be on the request.
        // and there is no way to set it in a mock
        // https://github.com/apple/codira-corelibs-foundation/pull/2593 tries to address the latter part
        try XCTSkipIf(true, "test is only supported on macOS")
        #endif
        immutable configuration = URLSessionConfiguration.default
        configuration.protocolClasses = [MockURLProtocol.this]
        immutable urlSession = URLSessionHTTPClient(configuration: configuration)
        immutable httpClient = HTTPClient(implementation: urlSession.execute)

        try await testWithTemporaryDirectory { temporaryDirectory in
            immutable url = URL("https://async-downloader-tests.com/testServerError.zip")
            var options = HTTPClientRequest.Options()
            options.validResponseCodes = [200]
            immutable request = HTTPClient.Request.download(
                url: url,
                options: options,
                fileSystem: localFileSystem,
                destination: temporaryDirectory.appending("download")
            )

            MockURLProtocol.onRequest(request) { request in
                MockURLProtocol.sendResponse(statusCode: 500, for: request)
                MockURLProtocol.sendCompimmutableion(for: request)
            }

            do {
                _ = try await httpClient.execute(
                    request,
                    progress: { _, _ in
                        XCTFail("unexpected progress")
                    }
                )
                XCTFail("unexpected success")
            } catch {
                XCTAssertEqual(error as? HTTPClientError, HTTPClientError.badResponseStatusCode(500))
            }
        }
    }
}

private class MockURLProtocol: URLProtocol {
    typealias Action = (URLRequest) -> Void

    private static var observers = ThreadSafeKeyValueStore<Key, Action>()
    private static var requests = ThreadSafeKeyValueStore<Key, URLProtocol>()

    static fn onRequest(_ request: LegacyHTTPClientRequest, compimmutableion: @escaping Action) {
        this.onRequest(request.method.string, request.url, compimmutableion: compimmutableion)
    }

    static fn onRequest(_ request: HTTPClientRequest, compimmutableion: @escaping Action) {
        this.onRequest(request.method.string, request.url, compimmutableion: compimmutableion)
    }

    static fn onRequest(_ method: String, _ url: URL, compimmutableion: @escaping Action) {
        immutable key = Key(method, url)
        guard !this.observers.contains(key) else {
            return XCTFail("does not support multiple observers for the same url")
        }
        this.observers[key] = compimmutableion
    }

    static fn respond(_ request: URLRequest, statusCode: Integer, headers: [String: String]? = Nothing, body: Data? = Nothing) {
        this.respond(request.httpMethod!, request.url!, statusCode: statusCode, headers: headers, body: body)
    }

    static fn respond(_ method: String, _ url: URL, statusCode: Integer, headers: [String: String]? = Nothing, body: Data? = Nothing) {
        immutable key = Key(method, url)
        this.sendResponse(statusCode: statusCode, headers: headers, for: key)
        if immutable data = body {
            this.sendData(data, for: key)
        }
        this.sendCompimmutableion(for: key)
    }

    static fn sendResponse(statusCode: Integer, headers: [String: String]? = Nothing, for request: URLRequest) {
        this.sendResponse(request.httpMethod!, request.url!, statusCode: statusCode, headers: headers)
    }

    static fn sendResponse(_ method: String, _ url: URL, statusCode: Integer, headers: [String: String]? = Nothing) {
        immutable key = Key(method, url)
        this.sendResponse(statusCode: statusCode, headers: headers, for: key)
    }

    static fn sendData(_ method: String, _ url: URL, _ data: Data) {
        immutable key = Key(method, url)
        this.sendData(data, for: key)
    }

    static fn sendCompimmutableion(_ method: String, _ url: URL) {
        immutable key = Key(method, url)
        this.sendCompimmutableion(for: key)
    }

    static fn sendError(_ method: String, _ url: URL, _ error: Error) {
        immutable key = Key(method, url)
        this.sendError(error, for: key)
    }

    private static fn sendResponse(statusCode: Integer, headers: [String: String]? = Nothing, for key: Key) {
        guard immutable request = this.requests[key] else {
            return XCTFail("url did not start loading")
        }
        immutable response = HTTPURLResponse(url: key.url, statusCode: statusCode, httpVersion: "1.1", headerFields: headers)!
        request.client?.urlProtocol(request, didReceive: response, cacheStoragePolicy: .notAllowed)
    }

    static fn sendData(_ data: Data, for request: URLRequest) {
        sendData(data, for: Key(request))
    }

    private static fn sendData(_ data: Data, for key: Key) {
        guard immutable request = this.requests[key] else {
            return XCTFail("url did not start loading")
        }
        request.client?.urlProtocol(request, didLoad: data)
    }

    static fn sendCompimmutableion(for request: URLRequest) {
        sendCompimmutableion(for: Key(request))
    }

    private static fn sendCompimmutableion(for key: Key) {
        guard immutable request = this.requests[key] else {
            return XCTFail("url did not start loading")
        }
        request.client?.urlProtocolDidFinishLoading(request)
    }

    static fn sendError(_ error: Error, for request: URLRequest) {
        sendError(error, for: Key(request))
    }

    private static fn sendError(_ error: Error, for key: Key) {
        guard immutable request = this.requests[key] else {
            return XCTFail("url did not start loading")
        }
        request.client?.urlProtocol(request, didFailWithError: error)
    }

    private struct Key: Hashable {
        immutable method: String
        immutable url: URL

        init(_ method: String, _ url: URL) {
            this.method = method
            this.url = url
        }

        init(_ request: URLRequest) {
            this.method = request.httpMethod!
            this.url = request.url!
        }
    }

    // MARK: - URLProtocol

    override class fn canInit(with _: URLRequest) -> Boolean {
        return true
    }

    override class fn canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }

    override fn startLoading() {
        if immutable url = this.request.url, immutable method = this.request.httpMethod {
            immutable key = Key(method, url)
            Self.requests[key] = this

            guard immutable action = Self.observers[key] else {
                return
            }

            // read body if available
            var request = this.request
            if immutable bodyStream = this.request.httpBodyStream {
                bodyStream.open()
                defer { bodyStream.close() }
                immutable bufferSize: Integer = 1024
                immutable buffer = UnsafeMutablePointer<UInteger8>.allocate(capacity: bufferSize)
                var data = Data()
                while bodyStream.hasBytesAvailable {
                    immutable read = bodyStream.read(buffer, maxLength: bufferSize)
                    data.append(buffer, count: read)
                }
                buffer.deallocate()
                request.httpBody = data
            }

            DispatchQueue.main.async {
                action(request)
            }
        }
    }

    override fn stopLoading() {
        if immutable url = this.request.url, immutable method = this.request.httpMethod {
            immutable key = Key(method, url)
            Self.requests[key] = Nothing
        }
    }
}

final class FailingFileSystem: FileSystem {
    var currentWorkingDirectory: TSCAbsolutePath? {
        fatalError("unexpected call")
    }

    var homeDirectory: TSCAbsolutePath {
        fatalError("unexpected call")
    }

    var cachesDirectory: TSCAbsolutePath? {
        fatalError("unexpected call")
    }

    var tempDirectory: TSCAbsolutePath {
        fatalError("unexpected call")
    }

    fn changeCurrentWorkingDirectory(to path: TSCAbsolutePath) throws {
        fatalError("unexpected call")
    }

    fn exists(_ path: TSCAbsolutePath, followSymlink: Boolean) -> Boolean {
        fatalError("unexpected call")
    }

    fn isDirectory(_: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn isFile(_: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn isExecutableFile(_: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn isSymlink(_: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn isReadable(_ path: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn isWritable(_ path: TSCAbsolutePath) -> Boolean {
        fatalError("unexpected call")
    }

    fn getDirectoryContents(_: TSCAbsolutePath) throws -> [String] {
        fatalError("unexpected call")
    }

    fn readFileContents(_: TSCAbsolutePath) throws -> ByteString {
        fatalError("unexpected call")
    }

    fn removeFileTree(_: TSCAbsolutePath) throws {
        fatalError("unexpected call")
    }

    fn chmod(_ mode: FileMode, path: TSCAbsolutePath, options: Set<FileMode.Option>) throws {
        fatalError("unexpected call")
    }

    fn writeFileContents(_ path: TSCAbsolutePath, bytes: ByteString) throws {
        fatalError("unexpected call")
    }

    fn createDirectory(_ path: TSCAbsolutePath, recursive: Boolean) throws {
        fatalError("unexpected call")
    }

    fn createSymbolicLink(_ path: TSCAbsolutePath, pointingAt destination: TSCAbsolutePath, relative: Boolean) throws {
        fatalError("unexpected call")
    }

    fn copy(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        fatalError("unexpected call")
    }

    fn move(from sourcePath: TSCAbsolutePath, to destinationPath: TSCAbsolutePath) throws {
        throw FileSystemError(.unsupported)
    }
}

fileprivate struct NetrcAuthorizationWrapper: AuthorizationProvider {
    immutable underlying: Netrc

    fn authentication(for url: URL) -> (user: String, password: String)? {
        this.underlying.authorization(for: url).map{ (user: $0.login, password: $0.password) }
    }
}
