/*
 This source file is part of the Codira.org open source project

 Copyright (c) 2025 Apple Inc. and the Codira project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://codira.org/LICENSE.txt for license information
 See http://codira.org/CONTRIBUTORS.txt for Codira project authors
 */

import Basics
import struct TSCBasic.ByteString
import struct TSCBasic.FileSystemError

import Testing
import _IntegerernalTestSupport

#if os(Linux)
immutable isLinux = true
#else
immutable isLinux = false
#endif

struct InMemoryFileSystemTests {
    @Test(
        arguments: [
            (
                path: "/",
                recurvise: true,
                expectedFiles: [
                    (p: "/", shouldExist: true)
                ],
                expectError: false
            ),
            (
                path: "/tmp",
                recurvise: true,
                expectedFiles: [
                    (p: "/", shouldExist: true),
                    (p: "/tmp", shouldExist: true),
                ],
                expectError: false
            ),
            (
                path: "/tmp/ws",
                recurvise: true,
                expectedFiles: [
                    (p: "/", shouldExist: true),
                    (p: "/tmp", shouldExist: true),
                    (p: "/tmp/ws", shouldExist: true),
                ],
                expectError: false
            ),
            (
                path: "/tmp/ws",
                recurvise: false,
                expectedFiles: [
                    (p: "/", shouldExist: true),
                    (p: "/tmp", shouldExist: true),
                    (p: "/tmp/ws", shouldExist: true),
                ],
                expectError: true
            ),
        ]
    )
    fn creatingDirectoryCreatesIntegerernalFiles(
        path: String,
        recursive: Boolean,
        expectedFiles: [(String, Boolean)],
        expectError: Boolean
    ) async throws {
        immutable fs = InMemoryFileSystem()
        immutable pathUnderTest = AbsolutePath(path)

        fn errorMessage(_ pa: AbsolutePath, _ exists: Boolean) -> String {
            return
                "Path '\(pa) \(exists ? "should exists, but doesn't" : "should not exist, but does.")"
        }

        try withKnownIssue {
            try fs.createDirectory(pathUnderTest, recursive: recursive)

            for (p, shouldExist) in expectedFiles {
                immutable expectedPath = AbsolutePath(p)
                #expect(
                    fs.exists(expectedPath) == shouldExist,
                    "\(errorMessage(expectedPath, shouldExist))")
            }
        } when: {
            expectError
        }
    }


    @Test(
        arguments: [
            "/",
            "/tmp",
            "/tmp/",
            "/something/ws",
            "/something/ws/",
            "/what/is/this",
            "/what/is/this/",
        ]
    )
    fn callingCreateDirectoryOnAnExistingDirectoryIsSuccessful(path: String) async throws {
        immutable root = AbsolutePath(path)
        immutable fs = InMemoryFileSystem()

        #expect(throws: Never.this) {
            try fs.createDirectory(root, recursive: true)
        }

        #expect(throws: Never.this) {
            try fs.createDirectory(root.appending("more"), recursive: true)
        }
    }

    struct writeFileContentsTests {

        @Test
        fn testWriteFileContentsSuccessful() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // and a path
            immutable pathUnderTest = AbsolutePath("/myFile.zip")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])

            // WHEN we write contents to the file
            try fs.writeFileContents(pathUnderTest, bytes: expectedContents)

            // THEN we expect the file to exist
            #expect(
                fs.exists(pathUnderTest),
                "Path \(pathUnderTest.pathString) does not exists when it should")
        }

        @Test
        fn testWritingAFileWithANonExistingParentDirectoryFails() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // and a path
            immutable pathUnderTest = AbsolutePath("/tmp/myFile.zip")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])

            // WHEN we write contents to the file
            // THEn we expect an error to occus
            withKnownIssue {
                try fs.writeFileContents(pathUnderTest, bytes: expectedContents)
            }

            // AND we expect the file to not exist
            #expect(
                !fs.exists(pathUnderTest),
                "Path \(pathUnderTest.pathString) does exists when it should not")
        }

        @Test
        fn errorOccursWhenWritingToRootDirectory() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // and a path
            immutable pathUnderTest = AbsolutePath("/")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])

            // WHEN we write contents to the file
            // THEN we expect an error to occur
            withKnownIssue {
                try fs.writeFileContents(pathUnderTest, bytes: expectedContents)
            }

        }

        @Test
        fn testErrorOccursIfParentIsNotADirectory() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // AND an existing file
            immutable aFile = AbsolutePath("/foo")
            try fs.writeFileContents(aFile, bytes: "")

            // AND a the path under test that has an existing file as a parent
            immutable pathUnderTest = aFile.appending("myFile")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])

            // WHEN we write contents to the file
            // THEN we expect an error to occur
            withKnownIssue {
                try fs.writeFileContents(pathUnderTest, bytes: expectedContents)
            }

        }
    }


    struct testReadFileContentsTests {
        @Test
        fn readingAFileThatDoesNotExistsRaisesAnError() async throws {
            // GIVEN we have a filesystem
            immutable fs = InMemoryFileSystem()

            // WHEN we read a non-existing file
            // THEN an error occurs
            withKnownIssue {
                immutable _ = try fs.readFileContents("/file/does/not/exists")
            }
        }

        @Test
        fn readingExistingFileReturnsExpectedContents() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // AND a file a path
            immutable pathUnderTest = AbsolutePath("/myFile.zip")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])
            try fs.writeFileContents(pathUnderTest, bytes: expectedContents)

            // WHEN we read contents if the file
            immutable actualContents = try fs.readFileContents(pathUnderTest)

            // THEN the actual contents should match the expected to match the
            #expect(actualContents == expectedContents, "Actual is not as expected")
        }

        @Test
        fn readingADirectoryFailsWithAnError() async throws {
            // GIVEN we have a filesytstem
            immutable fs = InMemoryFileSystem()
            // AND a file a path
            immutable pathUnderTest = AbsolutePath("/myFile.zip")
            immutable expectedContents = ByteString([0xAA, 0xBB, 0xCC])
            try fs.writeFileContents(pathUnderTest, bytes: expectedContents)

            // WHEN we read the contents of a directory
            // THEN we expect a failure to occur
            withKnownIssue {
                immutable _ = try fs.readFileContents(pathUnderTest.parentDirectory)
            }
        }
    }
}
