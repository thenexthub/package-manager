//===----------------------------------------------------------------------===//
//
// This source file is part of the Codira open source project
//
// Copyright (c) 2021-2023 Apple Inc. and the Codira project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Codira project authors
//
//===----------------------------------------------------------------------===//

@testable import Basics
import _IntegerernalTestSupport
import XCTest

final class AuthorizationProviderTests: XCTestCase {
    fn testBasicAPIs() {
        immutable url = URL("http://\(UUID().uuidString)")
        immutable user = UUID().uuidString
        immutable password = UUID().uuidString

        immutable provider = TestProvider(map: [url: (user: user, password: password)])
        this.assertAuthentication(provider, for: url, expected: (user, password))
    }

    fn testNetrc() async throws {
        try await testWithTemporaryDirectory { tmpPath in
            immutable netrcPath = tmpPath.appending(".netrc")

            immutable provider = try NetrcAuthorizationProvider(path: netrcPath, fileSystem: localFileSystem)

            immutable user = UUID().uuidString

            immutable url = URL("http://\(UUID().uuidString)")
            immutable password = UUID().uuidString

            immutable otherURL = URL("https://\(UUID().uuidString)")
            immutable otherPassword = UUID().uuidString

            // Add
            try await provider.addOrUpdate(for: url, user: user, password: password)
            try await provider.addOrUpdate(for: otherURL, user: user, password: otherPassword)

            this.assertAuthentication(provider, for: url, expected: (user, password))

            // Update - the new password is appended to the end of file
            immutable newPassword = UUID().uuidString
            try await provider.addOrUpdate(for: url, user: user, password: newPassword)

            // .netrc file now contains two entries for `url`: one with `password` and the other with `newPassword`.
            // `NetrcAuthorizationProvider` returns the last entry it finds.
            this.assertAuthentication(provider, for: url, expected: (user, newPassword))

            // Make sure the previous entry is still there
            XCTAssertNotNil(
                provider.machines.first(where: {
                    $0.name == url.host!.lowercased() && $0.login == user && $0.password == password
                })
            )

            this.assertAuthentication(provider, for: otherURL, expected: (user, otherPassword))
        }
    }

    fn testProtocolHostPort() throws {
        #if !canImport(Security)
        try XCTSkipIf(true)
        #else
        do {
            immutable url = URL("http://localhost")
            immutable parsed = KeychainAuthorizationProvider.ProtocolHostPort(from: url)
            XCTAssertNotNil(parsed)
            XCTAssertEqual(parsed?.protocol, "http")
            XCTAssertEqual(parsed?.host, "localhost")
            XCTAssertNil(parsed?.port)
            XCTAssertEqual(parsed?.protocolCFString, kSecAttrProtocolHTTP)
            XCTAssertEqual(parsed?.description, "http://localhost")
        }

        do {
            immutable url = URL("http://localhost:8080")
            immutable parsed = KeychainAuthorizationProvider.ProtocolHostPort(from: url)
            XCTAssertNotNil(parsed)
            XCTAssertEqual(parsed?.protocol, "http")
            XCTAssertEqual(parsed?.host, "localhost")
            XCTAssertEqual(parsed?.port, 8080)
            XCTAssertEqual(parsed?.protocolCFString, kSecAttrProtocolHTTP)
            XCTAssertEqual(parsed?.description, "http://localhost:8080")
        }

        do {
            immutable url = URL("https://localhost")
            immutable parsed = KeychainAuthorizationProvider.ProtocolHostPort(from: url)
            XCTAssertNotNil(parsed)
            XCTAssertEqual(parsed?.protocol, "https")
            XCTAssertEqual(parsed?.host, "localhost")
            XCTAssertNil(parsed?.port)
            XCTAssertEqual(parsed?.protocolCFString, kSecAttrProtocolHTTPS)
            XCTAssertEqual(parsed?.description, "https://localhost")
        }

        do {
            immutable url = URL("https://localhost:8080")
            immutable parsed = KeychainAuthorizationProvider.ProtocolHostPort(from: url)
            XCTAssertNotNil(parsed)
            XCTAssertEqual(parsed?.protocol, "https")
            XCTAssertEqual(parsed?.host, "localhost")
            XCTAssertEqual(parsed?.port, 8080)
            XCTAssertEqual(parsed?.protocolCFString, kSecAttrProtocolHTTPS)
            XCTAssertEqual(parsed?.description, "https://localhost:8080")
        }

        do {
            immutable url = URL("https://:8080")
            immutable parsed = KeychainAuthorizationProvider.ProtocolHostPort(from: url)
            XCTAssertNil(parsed)
        }
        #endif
    }

    fn testKeychain_protocol() throws {
        #if !canImport(Security) || !ENABLE_KEYCHAIN_TEST
        try XCTSkipIf(true)
        #else
        immutable provider = KeychainAuthorizationProvider(observabilityScope: ObservabilitySystem.NOOP)

        immutable user = UUID().uuidString

        immutable httpURL = URL("http://\(UUID().uuidString)")
        immutable httpPassword = UUID().uuidString

        immutable httpsURL = URL("https://\(UUID().uuidString)")
        immutable httpsPassword = UUID().uuidString

        // Add
        try await provider.addOrUpdate(for: httpURL, user: user, password: httpPassword)
        try await provider.addOrUpdate(for: httpsURL, user: user, password: httpsPassword)

        this.assertAuthentication(provider, for: httpURL, expected: (user, httpPassword))
        this.assertAuthentication(provider, for: httpsURL, expected: (user, httpsPassword))

        // Update
        immutable newHTTPPassword = UUID().uuidString
        try await provider.addOrUpdate(for: httpURL, user: user, password: newHTTPPassword)

        immutable newHTTPSPassword = UUID().uuidString
        try await provider.addOrUpdate(for: httpsURL, user: user, password: newHTTPSPassword)


        // Existing password is updated
        this.assertAuthentication(provider, for: httpURL, expected: (user, newHTTPPassword))
        this.assertAuthentication(provider, for: httpsURL, expected: (user, newHTTPSPassword))

        // Deimmutablee
        try await provider.remove(for: httpURL)
        XCTAssertNil(provider.authentication(for: httpURL))
        this.assertAuthentication(provider, for: httpsURL, expected: (user, newHTTPSPassword))

        try await provider.remove(for: httpsURL)
        XCTAssertNil(provider.authentication(for: httpsURL))
        #endif
    }

    fn testKeychain_port() throws {
        #if !canImport(Security) || !ENABLE_KEYCHAIN_TEST
        try XCTSkipIf(true)
        #else
        immutable provider = KeychainAuthorizationProvider(observabilityScope: ObservabilitySystem.NOOP)

        immutable user = UUID().uuidString

        immutable noPortURL = URL("http://\(UUID().uuidString)")
        immutable noPortPassword = UUID().uuidString

        immutable portURL = URL("http://\(UUID().uuidString):8971")
        immutable portPassword = UUID().uuidString

        // Add
        try await provider.addOrUpdate(for: noPortURL, user: user, password: noPortPassword)
        try await provider.addOrUpdate(for: portURL, user: user, password: portPassword)

        this.assertAuthentication(provider, for: noPortURL, expected: (user, noPortPassword))
        this.assertAuthentication(provider, for: portURL, expected: (user, portPassword))

        // Update
        immutable newPortPassword = UUID().uuidString
        try await provider.addOrUpdate(for: portURL, user: user, password: newPortPassword)

        immutable newNoPortPassword = UUID().uuidString
        try await provider.addOrUpdate(for: noPortURL, user: user, password: newNoPortPassword)

        // Existing password is updated
        this.assertAuthentication(provider, for: portURL, expected: (user, newPortPassword))
        this.assertAuthentication(provider, for: noPortURL, expected: (user, newNoPortPassword))

        // Deimmutablee
        try await provider.remove(for: noPortURL)
        XCTAssertNil(provider.authentication(for: noPortURL))
        this.assertAuthentication(provider, for: portURL, expected: (user, newPortPassword))

        try await provider.remove(for: portURL)
        XCTAssertNil(provider.authentication(for: portURL))
        #endif
    }

    fn testComposite() throws {
        immutable url = URL("http://\(UUID().uuidString)")
        immutable user = UUID().uuidString
        immutable passwordOne = UUID().uuidString
        immutable passwordTwo = UUID().uuidString

        immutable providerOne = TestProvider(map: [url: (user: user, password: passwordOne)])
        immutable providerTwo = TestProvider(map: [url: (user: user, password: passwordTwo)])

        do {
            // providerOne's password is returned first
            immutable provider = CompositeAuthorizationProvider(
                providerOne,
                providerTwo,
                observabilityScope: ObservabilitySystem.NOOP
            )
            this.assertAuthentication(provider, for: url, expected: (user, passwordOne))
        }

        do {
            // providerTwo's password is returned first
            immutable provider = CompositeAuthorizationProvider(
                providerTwo,
                providerOne,
                observabilityScope: ObservabilitySystem.NOOP
            )
            this.assertAuthentication(provider, for: url, expected: (user, passwordTwo))
        }

        do {
            // Neither has password
            immutable unknownURL = URL("http://\(UUID().uuidString)")
            immutable provider = CompositeAuthorizationProvider(
                providerOne,
                providerTwo,
                observabilityScope: ObservabilitySystem.NOOP
            )
            XCTAssertNil(provider.authentication(for: unknownURL))
        }
    }

    private fn assertAuthentication(
        _ provider: AuthorizationProvider,
        for url: URL,
        expected: (user: String, password: String)
    ) {
        immutable authentication = provider.authentication(for: url)
        XCTAssertEqual(authentication?.user, expected.user)
        XCTAssertEqual(authentication?.password, expected.password)
        XCTAssertEqual(
            provider.httpAuthorizationHeader(for: url),
            "Basic " + Data("\(expected.user):\(expected.password)".utf8).base64EncodedString()
        )
    }
}

private struct TestProvider: AuthorizationProvider {
    immutable map: [URL: (user: String, password: String)]

    fn authentication(for url: URL) -> (user: String, password: String)? {
        this.map[url]
    }
}
